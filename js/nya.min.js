"use strict";
NYA.REBUILD = {};

Game_Actor.prototype.expForLevel = function() {
	return 0;
};

Game_Actor.prototype.initSkills = function() {
    this._skills = [];
};

Game_BattlerBase.prototype.refresh = function () {
};

Game_BattlerBase.prototype.recoverAll = function () {
};

Game_CharacterBase.prototype.shiftY = function() {
    return 0;
};

SceneManager.isGameActive = function() {
	return true;
};

Scene_Map.prototype.isFastForward = function() {
	return false;
};

Graphics._defaultStretchMode = function() {
	return true;
};

Graphics._stretchHeight = function() {
    if (Utils.isMobileDevice()) {
        return document.documentElement.clientHeight;
    } else {
        return window.innerHeight;
    }
};

Sprite_Character.prototype.initMembers = function() {
	this._lowerSprite = new Sprite();
	this.addChild(this._lowerSprite);
	this._contentSprite = new Sprite();
	this.addChild(this._contentSprite);
	this._contentSprite.scale.x = Graphics.scaleX;
	this._contentSprite.scale.y = Graphics.scaleY;
	this._contentSprite.anchor.x = 0.5;
    this._contentSprite.anchor.y = 1;
    this._character = null;
    this._balloonDuration = 0;
    this._tilesetId = 0;
    this._upperBody = null;
    this._lowerBody = null;
	this._framePos = 0;
};

Sprite_Character.prototype.setTileBitmap = function() {
    this._contentSprite.bitmap = this.tilesetBitmap(this._tileId);
};

Sprite_Character.prototype.setCharacterBitmap = function() {
    this._contentSprite.bitmap = ImageManager.loadCharacter(this._characterName);
};

Sprite_Character.prototype.updateTileFrame = function() {
    const tileId = this._tileId;
    const pw = this.patternWidth();
    const ph = this.patternHeight();
    const sx = ((Math.floor(tileId / 128) % 2) * 8 + (tileId % 8)) * pw;
    const sy = (Math.floor((tileId % 256) / 8) % 16) * ph;
    this._contentSprite.setFrame(sx, sy, pw, ph);
};

Sprite_Character.prototype.updateCharacterFrame = function() {
    const pw = this.patternWidth();
    const ph = this.patternHeight();
    const sx = (this.characterBlockX() + this.characterPatternX()) * pw;
    const sy = (this.characterBlockY() + this.characterPatternY()) * ph;
    this.updateHalfBodySprites();
    if (this._bushDepth > 0) {
        const d = this._bushDepth;
        this._upperBody.setFrame(sx, sy, pw, ph - d);
        this._lowerBody.setFrame(sx, sy + ph - d, pw, d);
        this._contentSprite.setFrame(sx, sy, 0, ph);
    } else {
        this._contentSprite.setFrame(sx, sy, pw, ph);
    }
};

Sprite_Character.prototype.patternWidth = function() {
    if (this._tileId > 0) {
        return $gameMap.tileWidth();
    } else if (this._isBigCharacter) {
        return this._contentSprite.bitmap.width / 3;
    } else {
        return this._contentSprite.bitmap.width / 12;
    }
};

Sprite_Character.prototype.patternHeight = function() {
    if (this._tileId > 0) {
        return $gameMap.tileHeight();
    } else if (this._isBigCharacter) {
        return this._contentSprite.bitmap.height / 4;
    } else {
        return this._contentSprite.bitmap.height / 8;
    }
};

Sprite_Character.prototype.createHalfBodySprites = function() {
    if (!this._upperBody) {
        this._upperBody = new Sprite();
        this._upperBody.anchor.x = 0.5;
        this._upperBody.anchor.y = 1;
        this._contentSprite.addChild(this._upperBody);
    }
    if (!this._lowerBody) {
        this._lowerBody = new Sprite();
        this._lowerBody.anchor.x = 0.5;
        this._lowerBody.anchor.y = 1;
        this._lowerBody.opacity = 128;
        this._contentSprite.addChild(this._lowerBody);
    }
};

Sprite_Balloon.prototype.updatePosition = function() {
    this.x = this._target.x;
    this.y = this._target.y - this._target._contentSprite.height;
};

Game_Map.prototype.createVehicles = function() {
	this._vehicles = [];
};

Game_Followers.prototype.setup = function() {
	this._data = [];
};

Spriteset_Map.prototype.updateShadow = function() {
};

Graphics._createPixiApp = function() {
    this._setupPixi();
	this._app = new PIXI.Application({
		view: this._canvas,
		autoStart: false
	});
	this._app.ticker.remove(this._app.render, this._app);
	this._app.ticker.add(this._onTick, this);
};

Spriteset_Base.prototype.initialize = function() {
    Sprite.prototype.initialize.call(this);
    this.setFrame(0, 0, Graphics.width, Graphics.height);
    this.loadSystemImages();
    this.createLowerLayer();
    this.createUpperLayer();
};

Spriteset_Map.prototype.createParallax = function() {
};

Spriteset_Map.prototype.updateParallax = function() {
};

WebAudio.prototype._createEndTimer = function() {
};

Game_CharacterBase.prototype.update = function() {
	this.updateStop();
	this.updateAnimation();
};

Game_CharacterBase.prototype.updateStop = function() {
};

Game_Event.prototype.updateStop = function() {
	Game_Character.prototype.updateStop.call(this);
};

Game_Player.prototype.update = function(sceneActive) {
    if (sceneActive) {
        this.moveByInput();
    }
    Game_Character.prototype.update.call(this);
};

Spriteset_Map.prototype.createDestination = function() {
};

Scene_Map.prototype.processMapTouch = function() {
};

Scene_Base.prototype.createWindowLayer = function() {
    this._windowLayer = new WindowLayer();
    this.addChild(this._windowLayer);
};

Window_ChoiceList.prototype.windowX = function() {
    const positionType = $gameMessage.choicePositionType();
    if (positionType === 1) {
        return (Graphics.width - this.windowWidth()) / 2;
    } else if (positionType === 2) {
        return Graphics.width - this.windowWidth();
    } else {
        return 0;
    }
};

Utils._isMobileDevice = Utils.isMobileDevice();
Utils.isMobileDevice = function() {
	return this._isMobileDevice;
};

ImageManager.isObjectCharacter = function() {
	return false;
};

ImageManager.isBigCharacter = function() {
	return false;
};

Spriteset_Map.prototype.createTilemap = function() {
    const tilemap = new Tilemap();
    this._baseSprite.addChild(tilemap);
    this._effectsContainer = tilemap;
    this._tilemap = tilemap;
};

Spriteset_Map.prototype.updateTileset = function() {
};
NYA.METHOD = {};
NYA.BASE = {};

NYA.BASE_SCREEN_WIDTH = 1280;
NYA.BASE_SCREEN_HEIGHT = 720;
NYA.SCREEN_WIDTH_MAX = 1760;
NYA.SCREEN_WIDTH_MIN = 1152;

/* Utils.isMobileDevice = function() {
	return true;
}; */

Utils.launchScreenWidth = function() {
	if(typeof AndroidJsObject === "object") {
		const ratio = AndroidJsObject.getScreenRatio();
		return Math.round(NYA.BASE_SCREEN_HEIGHT * ratio).clamp(NYA.SCREEN_WIDTH_MIN, NYA.SCREEN_WIDTH_MAX);
	} else {
		return NYA.BASE_SCREEN_WIDTH;
	}
};

(() => {
	NYA.SCREEN_WIDTH = Utils.launchScreenWidth();
	NYA.SCREEN_HEIGHT = NYA.BASE_SCREEN_HEIGHT;
})();

NYA.BASE.Game_CharacterBase_initMembers = Game_CharacterBase.prototype.initMembers;
Game_CharacterBase.prototype.initMembers = function() {
	NYA.BASE.Game_CharacterBase_initMembers.apply(this, arguments);
	this._framePos = 0;
	this._frameAnimationCounter = 0;
	this._frameStartPos = 0;
	this._frameEndPos = 0;
	this._mirrorLR = false;
	this._pauseFrameAnimation = false;
};

Game_CharacterBase.prototype.setMirrorLR = function(val) {
	this._mirrorLR = val;
};

Game_CharacterBase.prototype.setFramePos = function(pos) {
	this._framePos = pos;
};

Game_CharacterBase.prototype.screenX = function() {
	const leftX = this.px - this.phAnchorX();
	const width = this.patternWidth();
    return leftX + width / 2 - $gameMap.displayX() * $gameMap.tileWidth();
};

Game_CharacterBase.prototype.screenY = function() {
    const upY = this.py - this.phAnchorY();
	const height = this.patternHeight();
	return upY + height - $gameMap.displayY() * $gameMap.tileHeight();
};

Game_CharacterBase.prototype.isBigCharacter = function() {
	return ImageManager.isBigCharacter(this._characterName);
};

Game_CharacterBase.prototype.bitmapName = function() {
	const name = this.characterName();
	const info = ImageFrame.info(name);
	if(info.res) {
		return info.res;
	}
	return name;
};

Object.defineProperties(Game_CharacterBase.prototype, {
	width: {
        get: function() {
            if(this.characterName()) {
				return ImageManager.loadCharacter(this.bitmapName()).width * Graphics.scaleX;
			}
			return 0;
        },
        configurable: false
    },
    height: {
        get: function() {
            if(this.characterName()) {
				return ImageManager.loadCharacter(this.bitmapName()).height * Graphics.scaleY;
			}
			return 0;
        },
        configurable: false
    }
});

Game_CharacterBase.prototype.patternWidth = function() {
    return this.oneFrameWidth();
};

Game_CharacterBase.prototype.oneFrameWidth = function() {
	const info = ImageFrame.info(this.characterName());
	return this.width / info.width;
};

Game_CharacterBase.prototype.oneFrameHeight = function() {
	const info = ImageFrame.info(this.characterName());
	return this.height / info.height;
};

Game_CharacterBase.prototype.patternHeight = function() {
    return this.oneFrameHeight();
};

Game_CharacterBase.prototype.pauseFrameAnimation = function() {
	this._pauseFrameAnimation = true;
};

Game_CharacterBase.prototype.resumeFrameAnimation = function() {
	this._pauseFrameAnimation = false;
};

Game_CharacterBase.prototype.isFrameAnimationPause = function() {
	return this._pauseFrameAnimation;
};

Game_CharacterBase.prototype.updateFrameAnimation = function(info) {
	if(this.isFrameAnimationPause()) {
		return;
	}
	const speed = this.getFrameSpeed(info);
	if(speed) {
		this._frameAnimationCounter++;
		if(this._frameAnimationCounter >= speed) {
			this._frameAnimationCounter = 0;
			this._framePos++;
			if(this._framePos > this.getEndFramePos(info)) {
 				if(!info.noCycle) {
					this._framePos = this._frameStartPos;
				} else {
					this._framePos--;
				}
			}
		}
	}
};

Game_CharacterBase.prototype.getEndFramePos = function(info) {
	if(this._frameEndPos) {
		return this._frameEndPos;
	} else {
		return info.width * info.height - 1;
	}
};

Game_CharacterBase.prototype.getFrameSpeed = function(info) {
	if(info.frameSpeedDetail) {
		return info.frameSpeedDetail[this._framePos];
	} else {
		return info.frameSpeed;
	}
};

Game_CharacterBase.prototype.getAllFrameTime = function(info) {
	if(info.frameSpeedDetail) {
		let total = 0;
		for(const i of info.frameSpeedDetail) {
			total += i;
		}
		return total;
	} else {
		return info.width * info.height * info.frameSpeed;
	}
};

Game_CharacterBase.prototype.setFrameSection = function(start, end) {
	this._frameStartPos = start;
	this._frameEndPos = end;
	this._framePos = this._framePos.clamp(start, end);
};

NYA.BASE.Game_CharacterBase_updateAnimation = Game_CharacterBase.prototype.updateAnimation;
Game_CharacterBase.prototype.updateAnimation = function() {
	const info = ImageFrame.info(this.characterName());
	this.updateFrameAnimation(info);
};

Game_CharacterBase.prototype.resetFrameAnimation = function() {
	this._frameAnimationCounter = 0;
	this._framePos = 0;
	this._frameStartPos = 0;
	this._frameEndPos = 0;
	this._pauseFrameAnimation = false;
};

Game_CharacterBase.prototype.framePos = function() {
	return this._framePos;
};

NYA.BASE.Sprite_Character_updateFrame = Sprite_Character.prototype.updateFrame;
Sprite_Character.prototype.updateFrame = function() {
	if(this._framePos !== this._character.framePos())
	{
		const pos = this._character.framePos();
		this._framePos = pos;
		const info = ImageFrame.info(this._character.characterName());
		const width = this._character.patternWidth() / Graphics.scaleX;
		const height = this._character.patternHeight() / Graphics.scaleY;
		if(!info.rtl) {
			this._contentSprite.setFrame((pos % info.width) * width, Math.trunc(pos / info.width) * height, width, height);
		} else {
			this._contentSprite.setFrame(((info.width - pos - 1) % info.width) * width, Math.trunc(pos / info.width) * height, width, height);
		}
	}
};

SceneManager.suspendScene = function(sceneClass) {
    if (sceneClass && this._scene && this._suspendScene == null) {
        this._suspendScene = this._scene;
        this._scene = null;
        this.goto(sceneClass);
    }
};

SceneManager.clearSuspend = function() {
    this._suspendScene = null;
};

SceneManager.resumeScene = function() {
    this._scene.stop();
    this._scene.terminate();
	this._scene.destroy();
    this._scene = this._suspendScene;
	Graphics.setStage(this._scene);
    this.clearSuspend();
};

Utils.safeDivide = function(a, b) {
	if(b === 0) { return 0;}
	return a / b;
};

NYA.BASE.DataManager_extractMetadata = DataManager.extractMetadata;
DataManager.extractMetadata = function(data) {
	NYA.BASE.DataManager_extractMetadata.apply(this, arguments);
	const regExp = /<([^<> ]+)( ?)([^>]*)>/g;
	data.richMeta = {};
	for (;;) {
		const match = regExp.exec(data.note);
		if (match) {
			if(!data.richMeta[match[1]]) {
				data.richMeta[match[1]] = [];
			}
			if (match[2] === " ") {
				data.richMeta[match[1]].push(DataManager.extractPropertyMetadata(match[3]));
			} 
		} else {
			break;
		}
	}
};

DataManager.extractPropertyMetadata = function(str) {
	let res = {};
	let kvs = str.split(',');
	kvs.forEach((kv) => {
		let kv_split = kv.split(':');
		if(kv_split.length > 1) {
			res[kv_split[0]] = kv_split[1];
		}
		else {
			res[kv_split[0]] = true;
		}
	});
	return res;
};

Utils.tryParseNumber = function(str, def) {
	if(!str) { return def; }
	let parse = Number.parseFloat(str);
	if(Number.isNaN(parse)) {
		return 0;
	}
	return parse;
};

Utils.tryParseInt = function(str, def = 0) {
	return Math.round(this.tryParseNumber(str, def));
};

Utils.tryParseIntEx = function(str, def = 0) {
	if(!str) { return def;}
	if(str.indexOf("~") !== -1) {
		const arr = str.split("~");
		return this.randomInt(parseInt(arr[0]), parseInt(arr[1]));
	} else {
		return this.tryParseInt(str, def);
	}
};

Utils.tryParseBoolean = function(str, def = false) {
	if(!str) {return def; }
	if(str === 'true' || str === 'TRUE' || str === '1') {return true;}
	return false;
};

Utils.tryParseSheet = function(obj, def = "") {
	if(obj) {
		return obj.w;
	} else {
		return def;
	}
};

Utils.tryParseIntArray = function(str) {
	if(!str) {
		return [];
	}
	return JSON.parse(str);
};

Input.keyMapper = {
    //9: "tab", // tab
    //16: "shift", // shift
    //17: "control", // control
    //18: "control", // alt
    27: "menu", // escape
    33: "pageup", // pageup
    34: "pagedown", // pagedown
    37: "left", // left arrow
    38: "up", // up arrow
    39: "right", // right arrow
    40: "down", // down arrow
	65: "zxc", // A
	67: "bullet", // C
	68: "item", // D
	83: "cfish", // S
    86: "subattack", // V
    88: "cancel", // X
    90: "ok", // Z
    120: "debug", // F9
};

Input.gamepadMapper = {
    0: "ok", // A
    1: "cancel", // B
    2: "bullet", // X
    3: "subattack", // Y
    4: "menu", // LB
    5: "item", // RB
	6: "zxc", // LT
    7: "cfish", // RT
    12: "up", // D-pad up
    13: "down", // D-pad down
    14: "left", // D-pad left
    15: "right", // D-pad right
	96: "s-up",	 // S-UP
	97: "s-down", // S-DOWN
	98: "s-left", // S-LEFT
	99: "s-right" // S-RIGHT
};

Input.defaultKeyMapper = Object.assign({}, Input.keyMapper);
Input.defaultGamepadMapper = Object.assign({}, Input.gamepadMapper);

Input.isUITriggered = function(keyName, idx) {
	switch(keyName) {
		case 'ok': {
			const translate = ConfigManager.attackBindingCancel ? 'ok' : 'cancel';
			return Input.isTriggered(translate, idx) || (!this.checkButtonConflict(13, translate) && this.latestButtonCodeTriggered(13) === 13);
		}
		case 'cancel': {
			const translate = ConfigManager.attackBindingCancel ? 'cancel' : 'ok';
			return Input.isTriggered(translate, idx) || Input.isTriggered("menu", idx);
		}
		default: return Input.isTriggered(keyName, idx) || Input.isRepeated(keyName, idx);
	}
};

Input.isUIRepeated = function(keyName, idx) {
	switch(keyName) {
		case 'ok': return Input.isRepeated('ok', idx) || this.latestButtonCode() === 13;
		case 'cancel': return Input.isRepeated('cancel', idx) || this.latestButtonCode() === 27;
		default: return Input.isRepeated(keyName, idx);
	}
};

Input.checkButtonConflict = function(code, keyName) {
	return this.keyMapper[code] !== keyName && this.keyMapper[code] !== undefined;
};

NYA.BASE.Input_clear = Input.clear;
Input.clear = function() {
	NYA.BASE.Input_clear.apply(this, arguments);
	this._latestButtonArr = [[],[],[],[]];
	this._latestButtonCode = null;
	this._latestButtonCodeTriggered = 0;
	this._latestGamepadCodeTriggered = 0;
	this._currentState = [{},{},{},{}];
    this._previousState = [{},{},{},{}];
	this._latestButton = [null,null,null,null];
	this._pressedTime = [0,0,0,0];
	this._joystickPressX = 0;
	this._joystickPressY = 0;
};

Input.update = function() {
    this._pollGamepads();
	for(let i = 0; i < this._currentState.length && i < 4; i++) {
		const state = this._currentState[i];
		const pstate = this._previousState[i];
		if (state[this._latestButton[i]]) {
			this._pressedTime[i]++;
		} else {
			this._latestButton[i] = null;
		}
		this._latestButtonArr[i] = this._latestButtonArr[i].filter((key) => {
			if(state[key.button]) {
				key.time++;
				return true;
			}
			else {
				return false;
			}
		});
		for (const name in state) {
			if (state[name] && !pstate[name]) {
				this._latestButton[i] = name;
				this._pressedTime[i] = 0;
				this._date = Date.now();
				this._latestButtonArr[i].push({button:name,time:0});
			}
			pstate[name] = state[name];
		}
	}
	if (this._virtualButton) {
		this._latestButton[0] = this._virtualButton;
		this._pressedTime[0] = 0;
		this._virtualButton = null;
	}
	this._updateDirection();
};

Input.isPressed = function(keyName, idx = 0) {
    return !!this._currentState[idx][keyName];
};

Input.isTriggered = function(keyName, idx = 0) {
    const triggered = this._latestButton[idx] === keyName && this._pressedTime[idx] === 0;
	if(triggered) {
		this._pressedTime[idx]++;
	}
	return triggered;
};

Input.isStrictTriggered = function(keyName, idx = 0) {
	 return this._latestButtonArr[idx].some((key) => {
		return key.time === 0 && key.button === keyName; 
	});
};

Input.isRepeated = function(keyName, idx = 0) {
    return (
		this._latestButton[idx] === keyName &&
		(this._pressedTime[idx] === 0 ||
			(this._pressedTime[idx] >= this.keyRepeatWait &&
				this._pressedTime[idx] % this.keyRepeatInterval === 0))
	);
};

Input.isLongPressed = function(keyName, idx = 0) {
    return (
        this._latestButton[idx] === keyName &&
        this._pressedTime[idx] >= this.keyRepeatWait
    );
};

Input._onKeyDown = function(event) {
    if (this._shouldPreventDefault(event.keyCode)) {
        event.preventDefault();
    }
    const buttonName = this.keyMapper[event.keyCode];
    if (buttonName) {
        this._currentState[0][buttonName] = true;
    }
};

Input._onKeyUp = function(event) {
    const buttonName = this.keyMapper[event.keyCode];
    if (buttonName) {
        this._currentState[0][buttonName] = false;
    }
};

Input.latestButtonCode = function() {
	return this._latestButtonCode;
};

Input.latestButtonCodeTriggered = function(expectCode) {
	if(this._latestButtonCode !== null && (expectCode === undefined || this._latestButtonCode === expectCode) && !this._latestButtonCodeTriggered) {
		this._latestButtonCodeTriggered = 1;
		return this._latestButtonCode;
	}
	return null;
};

Input.latestGamepadCodeTriggered = function() {
	const code = this.latestGamepadCode();
	if(this._latestGamepadCodeTriggered && code !== null) {
		return null;
	} else if(!this._latestGamepadCodeTriggered && code !== null) {
		this._latestGamepadCodeTriggered = 1;
		return code;
	} else if(this._latestGamepadCodeTriggered && code === null) {
		this._latestGamepadCodeTriggered = 0;
		return null;
	}
	return null;
};

Input.setLatestGamepadCodeTriggered = function() {
	this._latestGamepadCodeTriggered = 1;
};

Input.setLatestButtonCodeTriggered = function() {
	this._latestButtonCodeTriggered = 1;
};

Input.latestGamepadCode = function() {
	for(const state of this._gamepadStates) {
		if(state) {
			for(let code = 0; code < state.length; code++) {
				if(state[code]) {
					return code;
				}
			}
		}
	}
	return null;
};

Input.isAnyTriggered = function() {
	return this.latestButtonCode() !== null || this.latestGamepadCode() !== null || TouchInput.isTriggered();
};

NYA.BASE.Input__onKeyDown = Input._onKeyDown;
Input._onKeyDown = function(event) {
	NYA.BASE.Input__onKeyDown.apply(this, arguments);
	this._latestButtonCode = event.keyCode;
	this._latestButtonCodeTriggered = 0;
	this._mode = 'button';
};

NYA.BASE.Input__onKeyUp = Input._onKeyUp;
Input._onKeyUp = function(event) {
	NYA.BASE.Input__onKeyUp.apply(this, arguments);
	if(this._latestButtonCode === event.keyCode) {
		this._latestButtonCode = null;
	}
};

Input._pollGamepads = function() {
	let connected = false;
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        if (gamepads) {
			let idx = 0;
            for (const gamepad of gamepads) {
                if (gamepad && gamepad.connected) {
                    this._updateGamepadState(gamepad, idx);
					connected = true;
					idx++;
                }
            }
        }
    }
	this._updateGamePadConnectedEvent(connected);
};

Input._updateGamepadState = function(gamepad, idx) {
    const lastState = this._gamepadStates[gamepad.index] || [];
    const newState = [];
    const buttons = gamepad.buttons;
    const axes = gamepad.axes;
    const thresholdX = ConfigManager.xAxesThreshold;
	const thresholdY = ConfigManager.yAxesThreshold;
    newState[12] = false;
    newState[13] = false;
    newState[14] = false;
    newState[15] = false;
    for (let i = 0; i < buttons.length; i++) {
        newState[i] = buttons[i].pressed;
    }
    if (axes[1] < -thresholdY) {
        newState[12] = true; // up
    } else if (axes[1] > thresholdY) {
        newState[13] = true; // down
    }
    if (axes[0] < -thresholdX) {
        newState[14] = true; // left
    } else if (axes[0] > thresholdX) {
        newState[15] = true; // right
    }
	newState[96] = false;
    newState[97] = false;
    newState[98] = false;
    newState[99] = false;
	if (axes[3] < -thresholdY) {
        newState[96] = true;
    } else if (axes[3] > thresholdY) {
        newState[97] = true;
    }
    if (axes[2] < -thresholdX) {
        newState[98] = true;
    } else if (axes[2] > thresholdX) {
        newState[99] = true;
    }
    for (let j = 0; j < newState.length; j++) {
        if (newState[j] !== lastState[j]) {
            const buttonName = this.gamepadMapper[j];
            if (buttonName) {
                this._currentState[idx][buttonName] = newState[j];
            }
        }
		if (newState[j]) {
			this._mode = 'gamepad';
		}
    }
    this._gamepadStates[gamepad.index] = newState;
};

Input._updateGamePadConnectedEvent = function(connected) {
	if(this._gamepadConnected === undefined) {
		this._gamepadConnected = connected;
		return;
	}
	if(!this._gamepadConnected && connected) {
		this.onGamepadConnected();
		document.body.style.cursor = "none";
	} else if(this._gamepadConnected && !connected) {
		document.body.style.cursor = "auto";
	}
	this._gamepadConnected = connected;
};

Input.getMode = function() {
	return this._mode ? this._mode : "button";
};

Input.mode = function() {
	return this._mode;
};

Input.onGamepadConnected = function() {
	if(this._gamepadConnectedHandler) {
		this._gamepadConnectedHandler();
	}
};

Input.setGamepadConnectedHandler = function(handler) {
	this._gamepadConnectedHandler = handler;
};

Input.unsetGamepadConnectedHandler = function() {
	this._gamepadConnectedHandler = undefined;
};

TouchInput._setupEventHandlers = function() {
    const pf = { passive: false };
	if(!Utils.isMobileDevice()) {
		document.addEventListener("mousedown", this._onMouseDown.bind(this));
		document.addEventListener("mousemove", this._onMouseMove.bind(this));
		document.addEventListener("mouseup", this._onMouseUp.bind(this));
	}
	document.addEventListener("wheel", this._onWheel.bind(this), pf);
    document.addEventListener("touchstart", this._onTouchStart.bind(this), pf);
    document.addEventListener("touchmove", this._onTouchMove.bind(this), pf);
    document.addEventListener("touchend", this._onTouchEnd.bind(this));
    document.addEventListener("touchcancel", this._onTouchCancel.bind(this));
    window.addEventListener("blur", this._onLostFocus.bind(this));
};

NYA.BASE.TouchInput_clear = TouchInput.clear;
TouchInput.clear = function() {
	NYA.BASE.TouchInput_clear.apply(this, arguments);
	this._touching = [];
};

// UI界面上的触屏操作仍然保留RM原本的方式（除了双指返回）
// 但是地图界面上的摇杆和技能按钮操作走另一个逻辑，RM自身的触屏操作设计貌似不支持这种ACT触屏，必须额外写代码
TouchInput._onTouchStart = function(event) {
    for (const touch of event.changedTouches) {
        const x = Graphics.pageToCanvasX(touch.pageX);
        const y = Graphics.pageToCanvasY(touch.pageY);
        if (Graphics.isInsideCanvas(x, y)) {
            this._screenPressed = true;
            this._pressedTime = 0;
            if (event.touches.length < 2) {
                this._onTrigger(x, y);
            }
			this.add(touch.identifier, x, y);
        }
    }
	if(Utils.isMobileDevice() && Input.mode() !== undefined) {
		Input._mode = undefined;
	}
    if (window.cordova || window.navigator.standalone) {
        event.preventDefault();
    }
};

TouchInput._onTouchMove = function(event) {
    for (const touch of event.changedTouches) {
        const x = Graphics.pageToCanvasX(touch.pageX);
        const y = Graphics.pageToCanvasY(touch.pageY);
        this._onMove(x, y);
		this.move(touch.identifier, x, y);
    }
};

TouchInput._onTouchEnd = function(event) {
    for (const touch of event.changedTouches) {
        const x = Graphics.pageToCanvasX(touch.pageX);
        const y = Graphics.pageToCanvasY(touch.pageY);
        this._screenPressed = false;
        this._onRelease(x, y);
		this.del(touch.identifier);
    }
};

TouchInput.add = function(id, x, y) {
	if(!this._touching.some((touch) => {
		return touch.id === id;
	})) {
		const name = this.calcTouchButton(x, y);
		if(!this.checkScreenButtonMutex(id, name)) {
			this._touching.push({id:id, name:name, triggered:0, x:x, y:y});
		} else {
			this._touching.push({id:id, name:"", triggered:0, x:x, y:y});
		}
	}
};

TouchInput.del = function(id) {
	this._touching = this._touching.filter((touch) => {
		return touch.id !== id;
	});
};

TouchInput.move = function(id, x, y) {
	for(const touch of this._touching) {
		if(touch.id === id) {
			const name = this.calcTouchButton(x, y, true, touch.name);
			if(!this.checkScreenButtonMutex(id, name)) {
				if(touch.name !== name) {
					touch.name = name;
					touch.triggered = 0;
				}
			} else {
				touch.name = "";
			}
			touch.x = x;
			touch.y = y;
		}
	}
};

TouchInput.isInteract = function() {
	return TouchInput.isReleased() || TouchInput.isMoved() || TouchInput.isTriggered();
};

TouchInput.isDraged = function() {
    return this.isPressed() && (this._pressedTime >= 12 || this._moved);
};

Object.defineProperty(TouchInput, "moveDeltaX", {
    get: function() {
        return this._x - this._triggerX;
    },
    configurable: true
});

Object.defineProperty(TouchInput, "moveDeltaY", {
    get: function() {
        return this._y - this._triggerY;
    },
    configurable: true
});

Object.defineProperty(TouchInput, "moved", {
	get: function() {
		return this._moved;
	},
	configurable: true
});

// 滑动操作相比按下操作，是不会取消摇杆的按下状态的，相比其他按钮滑动时离开范围则按下状态就取消了。
// 如果某按钮已经按下，则不会再计算出其他手指按下按钮的结果，同时，left right up down也互相排斥，已有一个不会计算出其他结果
// 一般情况下，操作者是不希望一根手指头同时按下两个键的，所以这个函数只会返回一个结果，而不是数组
// 所以设置里务必阻止多个按钮重叠摆放的情况，这种情况下只会判断出一个按钮按下
TouchInput.calcTouchButton = function(tx, ty, isMove = false, previousName = "") {
	for(const buttonInfo of ConfigManager.screenButtons) {
		const sx = buttonInfo.x;
		const sy = buttonInfo.y;
		const sr = buttonInfo.rad;
		const name = buttonInfo.name;
		const deadzone = 16;
		if(previousName === "" && name !== "joystick") {
			if(this.checkInCircle(tx, ty, sx, sy, sr)) {
				return name;
			}
		} else if(!isMove && name === "joystick") {
			if(this.checkInCircle(tx, ty, sx, sy, sr)) {
				if(ConfigManager.isFixedJoystick) {
					if(Math.abs(sx - tx) + Math.abs(sy - ty) >= deadzone) {
						return this.classifyScreenButton(name, tx, ty, sx, sy);
					} else {
						return "joystick";
					}
				} else {
					this._joystickPressX = tx;
					this._joystickPressY = ty;
					return "joystick";
				}
			}
		} else if(name === "joystick" && this.isJoystickButton(previousName)) {
			if(ConfigManager.isFixedJoystick) {
				if(Math.abs(sx - tx) + Math.abs(sy - ty) >= deadzone) {
					return this.classifyScreenButton(name, tx, ty, sx, sy);
				} else {
					return "joystick";
				}
			} else {
				return this.classifyScreenButton(name, tx, ty, this._joystickPressX, this._joystickPressY);
			}
		} else if(!this.isJoystickButton(previousName)) {
			if(this.checkInCircle(tx, ty, sx, sy, sr)) {
				return name;
			}
		}
	}
	return "";
};

TouchInput.isJoystickButton = function(name) {
	return name === "left" || name === "right" || name === "up" || name === "down" || name === "left_up" || name === "right_up" || name === "left_down" || name === "right_down"|| name === "joystick";
};

TouchInput.getJoystickButtonPressed = function() {
	for(const touch of this._touching) {
		if(this.isJoystickButton(touch.name)) {
			return touch;
		}
	}
	return null;
};

TouchInput.classifyScreenButton = function(name, tx, ty, sx, sy) {
	let rotation = 0;
	if(sy === ty) {		//12点方向为0角度，顺时针旋转半圈为Math.PI角度，计算摇杆摆动方向
		rotation = tx > sx ? Math.PI / 2 : 1.5 * Math.PI;
	} else if(sx === tx) {
		rotation = sy > ty ? 0 : Math.PI;
	} else if(sy > ty && tx > sx) {		// 判定圆的右上部分
		rotation = Math.atan((tx - sx) / (sy - ty));
	} else if(sy > ty && tx < sx) {			// 判定圆的左上部分
		rotation = 2 * Math.PI + Math.atan((tx - sx) / (sy - ty));
	} else if(sy < ty && tx > sx) {		// 判定圆的右下部分
		rotation = Math.PI + Math.atan((tx - sx) / (sy - ty));
	} else {								// 判定圆的左下部分
		rotation = Math.PI + Math.atan((tx - sx) / (sy - ty));
	}
	const dir = Math.trunc(rotation / (Math.PI / 4) + 0.5);
	switch(dir) {
		case 0: case 8: {
			return "up";
		}
		case 1: {
			return "right_up";
		}
		case 2: {
			return "right"
		}
		case 3: {
			return "right_down"
		}
		case 4: {
			return "down";
		}
		case 5: {
			return "left_down";
		}
		case 6: {
			return "left";
		}
		case 7: {
			return "left_up";
		}
	}
};

TouchInput.checkInCircle = function(tx, ty, sx, sy, sr) {
	return Math.sqrt(Math.pow(Math.abs(sx - tx), 2) + Math.pow(Math.abs(sy - ty), 2)) <= sr;
};

TouchInput.checkScreenButtonMutex = function(id, name) {
	for(const touch of this._touching) {
		if(touch.id !== id && (touch.name === name || (this.isJoystickButton(touch.name) && this.isJoystickButton(name)))) {
			return true;
		}
	}
	return false;
};

TouchInput.isScreenButtonTriggered = function(name) {
	for(const touch of this._touching) {
		if(this.isDirectionButtonEqual(name, touch.name) && touch.triggered === 1) {
			return true;
		}
	}
	return false;
};

TouchInput.isScreenButtonPressed = function(name) {
	for(const touch of this._touching) {
		if(this.isDirectionButtonEqual(name, touch.name)) {
			return true;
		}
	}
	return false;
};

TouchInput.isDirectionButtonEqual = function(name, touchName) {
	switch(name) {
		case "left": {
			return touchName === "left" || touchName === "left_down" || touchName === "left_up";
		}
		case "right": {
			return touchName === "right" || touchName === "right_down" || touchName === "right_up";
		}
		case "up": {
			return touchName === "up" || touchName === "left_up" || touchName === "right_up";
		}
		case "down": {
			return touchName === "down" || touchName === "right_down" || touchName === "left_down";
		}
		default: {
			return name === touchName;
		}
	}
};

TouchInput.isDoublePressed = function() {
	return this._touching.length > 1;
};

TouchInput.doublePressedDistance = function() {
	const touch1 = this._touching[0];
	const touch2 = this._touching[1];
	return Math.round(Math.sqrt(Math.pow(touch1.x - touch2.x, 2) + Math.pow(touch1.y - touch2.y, 2)));
};

TouchInput.isFirstPressedInCirCle = function(x, y, radius) {
	const touch1 = this._touching[0];
	return this.checkInCircle(touch1.x, touch1.y, x, y, radius);
};

NYA.BASE.TouchInput_update = TouchInput.update;
TouchInput.update = function() {
	NYA.BASE.TouchInput_update.apply(this, arguments);
	for(const touch of this._touching) {
		touch.triggered++;
	}
};

Utils.xhrGetArrayBuffer = function(url, callback, progress) {
	let xhr = new XMLHttpRequest();
	xhr.open('GET', url);
	xhr.responseType = "arraybuffer";
	xhr.onload = callback;
	if(progress != null) {
		xhr.addEventListener('progress', progress);
	}
	xhr.send();
};

Utils.xhrGetJson = function(url, callback, progress) {
	let xhr = new XMLHttpRequest();
	xhr.open('GET', url);
	xhr.responseType = "json";
	xhr.onload = callback;
	if(progress != null) {
		xhr.addEventListener('progress', progress);
	}
	xhr.send();
};

function Sprite_KeyFrameAnimation() {
	this.initialize(...arguments);
}

Sprite_KeyFrameAnimation.prototype = Object.create(Sprite.prototype);
Sprite_KeyFrameAnimation.prototype.constructor = Sprite_KeyFrameAnimation;

Sprite_KeyFrameAnimation.prototype.initialize = function(prefix, frameCount, folder = 'img/keyframe_animation/', frameSpeed = 8) {
	Sprite.prototype.initialize.call(this);
	this._baseSprite = new Sprite();
	this._prefix = prefix;
	this._frameCount = frameCount;
	this._frameSpeed = frameSpeed;
	this._started = false;
	this._frameIdx = 0;
	this._frameCounter = 0;
	this._folder = folder;
	this.addChild(this._baseSprite);
	this.build();
	this.start();
};

Sprite_KeyFrameAnimation.prototype.start = function(frameIdx) {
	this._started = true;
	if(frameIdx != null) {
		this._frameIdx = frameIdx;
		this.flushIdx();
	}
};

Sprite_KeyFrameAnimation.prototype.stop = function(frameIdx) {
	this._started = false;
	if(frameIdx != null) {
		this._frameIdx = frameIdx;
		this.flushIdx();
	}
};

Sprite_KeyFrameAnimation.prototype.update = function() {
	Sprite.prototype.update.apply(this, arguments);
	if(this._started) {
		this._frameCounter++;
		if(this._frameCounter > this._frameSpeed) {
			this._frameCounter = 0;
			this._frameIdx++;
			this.onFrameIdxChange();
			if(this._frameIdx >= this._baseSprite.children.length) {
				this._frameIdx = 0;
			}
			this.flushIdx();
		}
	}
};

Sprite_KeyFrameAnimation.prototype.onFrameIdxChange = function() {
};

Sprite_KeyFrameAnimation.prototype.flushIdx = function() {
	let idx = 0;
	for(const child of this._baseSprite.children) {
		if(idx === this._frameIdx) {
			child.visible = true;
		}
		else {
			child.visible = false;
		}
		idx++;
	}
};

Sprite_KeyFrameAnimation.prototype.build = function() {
	this._baseSprite.removeChildren();
	for(let i = 1; i <= this._frameCount; i++) {
		let bitmap = ImageManager.loadBitmap(this._folder, this._prefix + i);
		let child = new Sprite(bitmap);
		this._baseSprite.addChild(child);
	}
	this.flushIdx();
};

Sprite_KeyFrameAnimation.prototype.adjustAnchor = function() {
	for(const child of this._baseSprite.children) {
		child.anchor.x = this.anchor.x;
		child.anchor.y = this.anchor.y;
	}
};

NYA.BASE.LIVE2D_FOLDER = 'img/live2d/';
window.LIVE2DCUBISMCORE = Live2DCubismCore;
function Sprite_Live2D() {
	this.initialize(...arguments);
}

Sprite_Live2D.prototype = Object.create(PIXI.Sprite.prototype);
Sprite_Live2D.prototype.constructor = Sprite_Live2D;

Sprite_Live2D.prototype.initialize = function(name) {
	PIXI.Sprite.call(this);
	if(name === undefined) { return; }
	this._name = name;
	this._prevProgress = 0;
	this.buildL2D();
};

Sprite_Live2D.prototype.setModel = function(model) {
	this._model = model;
	this.removeChildren();
	this.addChild(this._model);
/* 	this._ticker = new PIXI.Ticker();
	this._ticker.stop();
	this._ticker.start();
	this._ticker.add(this.updateModel.bind(this)); */
};

Sprite_Live2D.prototype.buildL2D = function() {
	const name = this._name;
	const headerExt = '.model3.json';
	const rootFolder = NYA.BASE.LIVE2D_FOLDER + name + '/';
	const setModel = function(model) {this.setModel(model);}.bind(this);
	const headerUrl = rootFolder + name + headerExt;
	PIXILoaderManager.load([{key:headerUrl, type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON}], function(resources) {
		const json = resources[headerUrl].data;
		const res = [];
		for(const motionFile of json.Motions) {
			const motionFileUrl = rootFolder + motionFile + '.motion3.json';
			res.push({key:motionFileUrl, type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON });
		}
		
		PIXILoaderManager.load(res, (resources) => {
			var builder = new LIVE2DCUBISMPIXI.ModelBuilder();
			builder.addAnimatorLayer("base", LIVE2DCUBISMFRAMEWORK.BuiltinAnimationBlenders.OVERRIDE, 1);
			builder.setTimeScale(1);
			builder.addGroups(json.Groups);
			builder.buildFromModel3Json({url:rootFolder + name + headerExt, data:json}, setModel);
		});
	});
	
};

Sprite_Live2D.prototype.motionUrl = function(motionName) {
	const rootFolder = NYA.BASE.LIVE2D_FOLDER + this._name + '/';
	return rootFolder + motionName + '.motion3.json';
};

Sprite_Live2D.prototype.playMotion = function(motionName) {
	this._motionName = motionName;
	this._prevProgress = 0;
	this.checkMotionTransition();
};

Sprite_Live2D.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._motionName) {
		this.checkMotionTransition();
	}
	this.updateModel(1);
};

Sprite_Live2D.prototype.checkMotionTransition = function() {
	if(this._model) {
		const animator = this._model.animator.getLayer("base");
		if(animator.currentAnimation) {
			const animation = animator.currentAnimation;
			const duration = animation.duration;
			const progress = animator.currentTime / duration;
			if(this._prevProgress > 0 && Math.trunc(this._prevProgress) !== Math.trunc(progress)) {
				this.executeMotion();
			}
			this._prevProgress = progress;
		} else {
			this.executeMotion();
		}
	}
};

Sprite_Live2D.prototype.executeMotion = function() {
	const motionName = this._motionName;
	const url = this.motionUrl(motionName);
	const resources = PIXILoaderManager.resources();
	const live2d_motion = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(resources[url].data);
	this._model.animator.getLayer("base").play(live2d_motion);
	this._motionName = undefined;
};

Sprite_Live2D.prototype.updateModel = function(time) {
	if(this._model) {
		this._model.update(time);
		this.updateTransform();
		this._model.masks.update(Graphics.app.renderer);
	}
};

function PIXILoaderManager() {
	throw new Error("This is a static class");
}

PIXILoaderManager.loader = PIXI.Loader.shared;
PIXILoaderManager.working = [];

PIXILoaderManager.resources = function() {
	return this.loader.resources;
};

PIXILoaderManager.load = function(resArr, callback) {
	if(this.loader.loading) {
		this.working.push({resArr:resArr, callback:callback});
		return;
	}
	
	this.realAdd(resArr, callback);
};

PIXILoaderManager.isIdle = function() {
	return !this.loader.loading && this.working.length === 0;
};

PIXILoaderManager.realAdd = function(resArr, callback) {
	let needLoad = false;
	resArr.forEach((res) => { 
		if(!this.loader.resources[res.key]) {
			this.loader.add(res.key, res.key, {xhrType:res.type}); 
			needLoad = true;
		}
		
	});
	if(needLoad) {
		this.realLoad(resArr, callback);
	}
	else if(callback) {
		callback(this.loader.resources);
	}
};

PIXILoaderManager.realLoad = function(resArr, callback) {
	this.loader.load((loader, resources) => {
		this.checkWorking();
		if(callback) {
			callback(resources);
		}
	});
};

PIXILoaderManager.checkWorking = function() {
	if(this.working.length > 0) {
		let info = this.working.pop();
		let resArr = info.resArr;
		let callback = info.callback;
		this.realAdd(resArr, callback);
	}
};

PIXILoaderManager.loader.onError = {
	dispatch: function(error, loader, resource) {
		console.error(error);
	}
};

LIVE2DCUBISMPIXI.ModelBuilder.prototype.buildFromModel3Json = function (model3Obj, callbackFunc) {
	var _this = this;
	var model3URL = model3Obj.url;
	var modelDir = model3URL.substring(0, model3URL.lastIndexOf("/") + 1);
	var textureURLArr = [];
	let res = [];
	let modelUrl = '';
	if (typeof (model3Obj.data['FileReferences']['Moc']) !== "undefined") {
		modelUrl = modelDir + model3Obj.data['FileReferences']['Moc'];
		res.push({key:modelUrl,type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER});
	}
	if (typeof (model3Obj.data['FileReferences']['Textures']) !== "undefined") {
		model3Obj.data['FileReferences']['Textures'].forEach(function (element) {
			let textureUrl = modelDir + element;
			res.push({key:textureUrl,type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER});
			textureURLArr.push(textureUrl);
		});
	}
	let physicsUrl = '';
	if (typeof (model3Obj.data['FileReferences']['Physics']) !== "undefined") {
		physicsUrl = modelDir + model3Obj.data['FileReferences']['Physics'];
		res.push({key:physicsUrl, type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON});
	}
	let userDataUrl = '';
	if (typeof (model3Obj.data['FileReferences']['UserData']) !== "undefined") {
		userDataUrl = modelDir + model3Obj.data['FileReferences']['UserData'];
		res.push({key:userDataUrl, type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON});
	}
	if (typeof (model3Obj.data['Groups'] !== "undefined"))
		this._groups = LIVE2DCUBISMFRAMEWORK.Groups.fromModel3Json(model3Obj.data);
	PIXILoaderManager.load(res, function (resources) {
		if (typeof (resources[modelUrl]) !== "undefined")
			_this.setMoc(LIVE2DCUBISMCORE.Moc.fromArrayBuffer(resources[modelUrl].data));
		for (var i = 0; i < textureURLArr.length; i++) {
			_this.addTexture(i, resources[textureURLArr[i]].texture);
		}
		if (typeof (resources[physicsUrl]) !== "undefined")
			_this.setPhysics3Json(resources[physicsUrl].data);
		if (typeof (resources[userDataUrl]) !== "undefined")
			_this.setUserData3Json(resources[physicsUrl].data);
		var model = _this.build();
		callbackFunc(model);
	});
};

NYA.BASE.Game_Event_initialize = Game_Event.prototype.initialize;
Game_Event.prototype.initialize = function() {
	NYA.BASE.Game_Event_initialize.apply(this, arguments);
	if(this.event().note)
	{
		this.readEventNote(this.event().note);
	}
};

Game_Event.prototype.readEventNote = function(note) {
	// overwrite
};

Graphics.scaleX = 2;
Graphics.scaleY = 2;

Game_Map.prototype.tileWidth = function() {
	return 96;
};

Game_Map.prototype.tileHeight = function() {
	return 96;
};

ImageManager.rebuildScaleBitmap = function(id, bitmapOriginal, powerOf2) {
	bitmapOriginal.smooth = false;
	const bitmap = new Bitmap(bitmapOriginal.width * Graphics.scaleX, bitmapOriginal.height * Graphics.scaleY);
	bitmap.context.imageSmoothingEnabled = false;
	bitmap.blt(bitmapOriginal, 0, 0, bitmapOriginal.width, bitmapOriginal.height, 0, 0, bitmap.width, bitmap.height);
	bitmapOriginal.destroy();
	bitmap.smooth = false;
	this._imageCache[id] = bitmap;
};

Utils.truncWith = function(truncNum, val) {
	return Math.trunc(val * truncNum) / truncNum;
};

Utils.roundWith = function(roundNum, val) {
	return Math.round(val * roundNum) / roundNum;
};

Game_Player.prototype.setupForNewGame = function() {
    const mapId = $dataSystem.startMapId;
    const x = $dataSystem.startX;
    const y = $dataSystem.startY;
    this.reserveTransfer(mapId, x, y, 4, 0);
};

Utils.saveImg = function(bitmap, fileName) {
	if(Utils.isNwjs())
	{
		var fs = require('fs');
        var regex = (/^data:image\/png;base64,/);
		var urlData = bitmap.canvas.toDataURL('image/png', 1);
            var base64Data = urlData.replace(regex, "");

            fs.writeFile(fileName, base64Data, 'base64', function(e) {});
	}

};

Utils.saveSprite = function(sprite, fileName) {
	if(Utils.isNwjs())
	{
		var fs = require('fs');
        var regex = (/^data:image\/png;base64,/);
		var urlData = Graphics.app.renderer.extract.base64(sprite, 'image/png');
            var base64Data = urlData.replace(regex, "");

            fs.writeFile(fileName, base64Data, 'base64', function(e) {});
	}

};

Utils.bitmapFrameOutput = function(name, frameWidth, frames) {
	const bitmap = ImageManager.loadBitmap("", name);
	bitmap.addLoadListener(() => {
		const oneWidth = bitmap.width / frameWidth;
		const out = new Bitmap(oneWidth * frames.length, bitmap.height);
		let idx = 0;
		for(const i of frames) {
			out.blt(bitmap, i * oneWidth, 0, oneWidth, bitmap.height, idx * oneWidth, 0, oneWidth, bitmap.height);
			idx++;
		}
		this.saveImg(out, name + ".png");
		out.destroy();
	});
};
Utils.bitmapFrameFlatten = async function(name, start, end, desWidth = 0, desHeight = 0) {
	let out = null;
	let idx = 0;
	for(let i = start; i <= end; i++) {
		const bitmap = await this.syncLoadBitmap(name + i);
		const width = bitmap.width;
		const height = bitmap.height;
		desWidth = desWidth || width;
		desHeight = desHeight || height;
		if(!out) {
			out = new Bitmap(desWidth * (end - start + 1), desHeight);
		}
		out.blt(bitmap, 0, 0, width, height, idx * desWidth, 0, width, height);
		idx++;
	}
	this.saveImg(out, name + ".png");
	out.destroy();
};
Utils.syncLoadBitmap = function(name) {
	const promise = new Promise((resolve, reject) => {
		const bitmap1 = ImageManager.loadBitmap("", name);
		bitmap1.addLoadListener(() => {
			resolve(bitmap1);
		});
	});
	return promise;
};
Utils.baseName = function(str) {
	const start = str.lastIndexOf("/") + 1;
	const len = str.lastIndexOf(".") - start;
	return str.substr(start, len);
};
Utils.makeTileA5 = function(folder, offset = 0) {
	const fs = require('fs');
	const arr = fs.readdirSync(folder);
	const w = 8; const h = 16;
	const cw = 48; const ch = 48;
	const out = new Bitmap(w * cw, h * ch);
	let i = offset;
	let j = 0;
	arr.forEach((name) => {
		const bitmap = ImageManager.loadBitmap(folder, name.substr(0, name.lastIndexOf(".")));
		const dx = i % w;
		const dy = Math.trunc(i / w);
		bitmap.addLoadListener(() => {
			out.blt(bitmap, 0, 0, cw, ch, dx * cw, dy * ch, cw, ch);
			j++;
			if(j === arr.length) {
				Utils.saveImg(out, "output.png");
				out.destroy();
			}
		});
		i++;
	});
};

Utils.randomInt = function(min, max) {
	return min + Math.randomInt(max + 1 - min);
};

Utils.randomFloat = function(min, max) {
	return min + (max - min) * Math.random();
};

Utils.cloneArrayBufferFromUint8Array = function(u8) {
	return u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
};

PIXI.Graphics.prototype.drawSector = function(cx, cy, radius, angle) {
	if(angle > Math.PI) {
		this.arc(cx, cy, radius, 0, Math.PI);
		this.drawPolygon([
			new PIXI.Point(cx, cy)
			, new PIXI.Point(cx - radius, cy)
			, new PIXI.Point(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle))
		]);
		this.arc(cx, cy, radius, Math.PI, angle);
	} else {
		this.drawPolygon([
			new PIXI.Point(cx, cy)
			, new PIXI.Point(cx + radius, cy)
			, new PIXI.Point(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle))
		]);
		this.arc(cx, cy, radius, 0, angle);
	}
};

Array.prototype.randomElement = function() {
	return this[Utils.randomInt(0, this.length - 1)];
};

Utils.makeRegularPolygon = function(r, n, expandX = 1, expandY = 1) {
	const result = [];
	const offset = Math.PI / n;
	for(let i = 0; i < n; i++) {
		result.push({x:Math.round(r * Math.sin(2 * Math.PI * i / n + offset) * expandX), y:Math.round(-r * Math.cos(2 * Math.PI * i / n + offset) * expandY)});
	}
	return result;
};

Utils.uceil = function(number) {
	return this.sign(number) * Math.ceil(Math.abs(number));
};

Sprite_Character.prototype.updateBitmap = function() {
    if (this.isImageChanged()) {
        this._tilesetId = $gameMap.tilesetId();
        this._tileId = this._character.tileId();
        this._characterName = this._character.bitmapName();
        this._characterIndex = this._character.characterIndex();
		this._contentSprite.blendMode = this._character.blendMode();
        this.setCharacterBitmap();
		this._framePos = -1;
    }
};

Sprite_Character.prototype.isImageChanged = function() {
    return (
        this._characterName !== this._character.bitmapName() ||
        this._characterIndex !== this._character.characterIndex()
    );
};

Utils.attackVerticeGenerateEx = function(vertices, x, y) {
	vertices.forEach((p) => {
		p.x = (p.x - x) * 2;
		p.y = (p.y - y) * 2;
	});
};

Utils.boolSign = function(val) {
	if(val) {
		return 1;
	} else {
		return -1;
	}
};

Game_CharacterBase.prototype.blendMode = function() {
	const name = this._characterName;
	const info = ImageFrame.info(name);
	return info.blendMode || 0;
};

Utils.isSpacingNewLineLanguage = function() {
	return !!$dataLanguageSystem.WAIT_SPACE_NEW_LINE;
};

Utils.nearestPowerOf2 = function(val1, val2) {
	const w = Math.pow(2, Math.ceil(Math.log2(val1)));
	const h = Math.pow(2, Math.ceil(Math.log2(val2)));
	return Math.max(w, h);
};

Utils.colorMatrixHSL = function(h, s, l) {
	const colorMatrix = new PIXI.filters.ColorMatrixFilter();
	colorMatrix.hue(h);
	colorMatrix.saturate(s / 100);
	colorMatrix.brightness(l / 100 + 1.0);
	return colorMatrix;
};

Utils.colorMatrixHSLEx = function(colorMatrix, h, s, l) {
	colorMatrix.hue(h);
	colorMatrix.saturate(s / 100);
	colorMatrix.brightness(l / 100 + 1.0);
};

Utils.createBezierContext = function(px1, py1, ltx, lty, rdx, rdy) {
	const r1 = Math.random();
	const r2 = Math.random();
	const r3 = Math.random();
	const r4 = Math.random();
	const px2 = Math.trunc(r1 * (rdx - ltx) + ltx);
	const py2 = Math.trunc(r2 * (rdy - lty) + lty);
	const px3 = Math.trunc(r3 * (rdx - ltx) + ltx);
	const py3 = Math.trunc(r4 * (rdy - lty) + lty);
	return {bezierList:[[px1, py1],[px2, py2],[px3, py3]], bezierInterpolation:0};
};

// 目前，闪烁屏幕的事件指令无效，色调调整中的灰度无效，因为为了爪机上的性能优化而屏蔽了
Spriteset_Base.prototype.createBaseFilters = function() {
    this._baseColorAdd = new PIXI.Graphics();
	this._baseColorMultiply = new PIXI.Graphics();
	this._baseColorAdd.blendMode = PIXI.BLEND_MODES.ADD;
	this._baseColorMultiply.blendMode = PIXI.BLEND_MODES.MULTIPLY;
	this._baseColorCacheR = 0;
	this._baseColorCacheG = 0;
	this._baseColorCacheB = 0;
	this._baseColorFilter = new PIXI.Container();
    this._baseColorFilter.addChild(this._baseColorAdd, this._baseColorMultiply);
	this.addChild(this._baseColorFilter);
};

Spriteset_Base.prototype.createOverallFilters = function() {
};

Spriteset_Base.prototype.updateBaseFilters = function() {
	this.ensureBaseColorGraphics();
	const c = $gameScreen.tone();
	const c2 = $gameScreen.flashColor();
	const r = c[0] || Math.round(c2[0] * (c2[3]/255)); const g = c[1] || Math.round(c2[1] * (c2[3]/255)); const b = c[2] || Math.round(c2[2] * (c2[3]/255));
	if(this._baseColorCacheR !== r || this._baseColorCacheG !== g || this._baseColorCacheB !== b) {
		this._baseColorCacheR = r;
		this._baseColorCacheG = g;
		this._baseColorCacheB = b;
		this.updateBaseColorAdd(r > 0 ? r : 0, g > 0 ? g : 0, b > 0 ? b : 0);
		this.updateBaseColorMultiply(r < 0 ? -r : 0, g < 0 ? -g : 0, b < 0 ? -b : 0);
	}
};

Spriteset_Base.prototype.updateBaseColorAdd = function(r, g, b) {
	this._baseColorAdd.clear();
	this._baseColorAdd.beginFill(r << 16 | g << 8 | b);
	this._baseColorAdd.drawRect(0, 0, Graphics.width, Graphics.height);
	this._baseColorAdd.endFill();
};

Spriteset_Base.prototype.updateBaseColorMultiply = function(r, g, b) {
	this._baseColorMultiply.clear();
	this._baseColorMultiply.beginFill((255 - r) << 16 | (255 - g) << 8 | (255 - b));
	this._baseColorMultiply.drawRect(0, 0, Graphics.width, Graphics.height);
	this._baseColorMultiply.endFill();
};

Spriteset_Base.prototype.ensureBaseColorGraphics = function() {
	if(this.children[this.children.length - 1] !== this._baseColorFilter) {
		this.removeChild(this._baseColorFilter);
		this.addChild(this._baseColorFilter);
	}
};

Spriteset_Base.prototype.updateOverallFilters = function() {
};

Scene_Base.prototype.createColorFilter = function() {
	this._colorFilter = new PIXI.Graphics();
	this._cacheFadeColor = -1;
};

Scene_Base.prototype.updateColorFilterColor = function() {
	if(this._cacheFadeColor !== this._fadeWhite) {
		this._cacheFadeColor = this._fadeWhite;
		const c = this._fadeWhite ? 255 : 0;
		this._colorFilter.clear();
		this._colorFilter.beginFill(c << 16 | c << 8 | c);
		this._colorFilter.drawRect(0, 0, Graphics.width, Graphics.height);
		this._colorFilter.endFill();
	}
};

Scene_Base.prototype.ensureColorFilter = function() {
	if(this.children[this.children.length - 1] !== this._colorFilter) {
		this.removeChild(this._colorFilter);
		this.addChild(this._colorFilter);
	}
};

Scene_Base.prototype.updateColorFilter = function() {
	this.ensureColorFilter();
	this.updateColorFilterColor();
    this._colorFilter.alpha = this._fadeOpacity / 255;
};

NYA.BASE.Scene_Base_initialize = Scene_Base.prototype.initialize;
Scene_Base.prototype.initialize = function() {
	NYA.BASE.Scene_Base_initialize.call(this);
	this.filters = [new PIXI.Filter()];				// 把所有filter都移除之后，Effekseer粒子动画似乎会反过来，只好加一句这个就正常了
};

NYA.BASE.Scene_Base_terminate = Scene_Base.prototype.terminate;
Scene_Base.prototype.terminate = function() {
	NYA.BASE.Scene_Base_terminate.apply(this, arguments);
	//Graphics.fillAllScreen();
};

Scene_Map.prototype.updateColorFilter = function() {
	this.ensureColorFilter();
	if($gameScreen.brightness() < 255) {
		this._fadeWhite = 0;
		this.updateColorFilterColor();
		this._colorFilter.alpha = (255 - $gameScreen.brightness()) / 255;
	} else {
		this.updateColorFilterColor();
		this._colorFilter.alpha = this._fadeOpacity / 255;
	}
};

NYA.BASE.SceneManager_onSceneCreate = SceneManager.onSceneCreate;
SceneManager.onSceneCreate = function() {
	this._scene.ensureColorFilter();
    NYA.BASE.SceneManager_onSceneCreate.apply(this, arguments);
};

Utils.baseHalfWidth = function() {
	return (Graphics.width - NYA.BASE_SCREEN_WIDTH) / 2;
};

Utils.touchUISmooth = function() {
	return 24;
};

Utils.touchUIDragPageThreshold = function() {
	return 360;
};

NYA.BASE.SceneManager_terminate = SceneManager.terminate;
SceneManager.terminate = function() {
	if(typeof AndroidJsObject === "object") {
		AndroidJsObject.exitApp();
	} else {
		NYA.BASE.SceneManager_terminate.apply(this, arguments);
	}
};

PIXI.RenderTexture.prototype.destroy = function() {
	PIXI.Texture.prototype.destroy.call(this, true);
};

Graphics._requestFullScreen = function() {
    const element = document.body;
	if(element.requestFullscreen) {
		return element.requestFullscreen();
	} else if(element.webkitRequestFullscreen) {
		return element.webkitRequestFullscreen();
	} else if(element.mozRequestFullScreen) {
		return element.mozRequestFullScreen();
	} else {
		return element.msRequestFullscreen();
	}
};

Graphics._cancelFullScreen = function() {
	if (document.exitFullscreen) {
        return document.exitFullscreen();
    } else if (document.webkitExitFullscreen){
        return document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
        return document.mozCancelFullScreen();
    } else {
        return document.msExitFullscreen();
    }
};

Graphics._isFullScreen = function() {
	return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
};

Graphics.adjustScreen = function(clientWidth, clientHeight) {
	clientWidth = clientWidth ? clientWidth : document.documentElement.clientWidth;
	clientHeight = clientHeight ? clientHeight : document.documentElement.clientHeight;
	if(NYA.SCREEN_WIDTH === clientWidth && NYA.SCREEN_HEIGHT === clientHeight) {
		return 2;
	}
	let ratio = clientWidth / clientHeight;
	const min = 16 / 10;
	const max = 22 / 9;
	ratio = ratio.clamp(min, max);
	const pw = NYA.SCREEN_WIDTH;
	const ph = NYA.SCREEN_HEIGHT;
	NYA.SCREEN_HEIGHT = NYA.BASE_SCREEN_HEIGHT;
	NYA.SCREEN_WIDTH = Math.round(NYA.BASE_SCREEN_HEIGHT * ratio);
	Graphics.resize(NYA.SCREEN_WIDTH, NYA.SCREEN_HEIGHT);
};

// 是否是移动端并且没有使用键盘或鼠标外设
Utils.isMobileDeviceTouchMode = function() {
	return this.isMobileDevice() && Input.mode() === undefined;
};

Utils.rotationDXDY = function(x, y) {
	if(x === 0 && y === 0) {
		return 0;
	} else if(x !== 0 && y === 0) {
		return x > 0 ? 0.5 * Math.PI : 1.5 * Math.PI;
	} else if(x === 0 && y !== 0) {
		return y > 0 ? Math.PI : 0;
	} else if(y < 0) {
		return Math.atan(-x / y);
	} else {
		return Math.PI + Math.atan(-x / y);
	}
};

Utils.randomRectHalfIntersectPoint = function(ltx1, lty1, rdx1, rdy1, ltx2, lty2, rdx2, rdy2) {
	const ltx = Math.max(ltx1, ltx2);
	const rdx = Math.min(rdx1, rdx2);
	const lty = Math.max(lty1, lty2);
	const rdy = Math.min(rdy1, rdy2);
	const qx = Math.trunc((rdx - ltx) / 4);
	const qy = Math.trunc((rdy - lty) / 4);
	return new Game_RangeRandPoint(ltx + qx, rdx - qx, lty + qy, rdy - qy);
};

function Game_RangeRandPoint() {
	this.initialize(...arguments);
}

Game_RangeRandPoint.prototype.initialize = function(ltx, rdx, lty, rdy) {
	this._ltx = ltx;
	this._rdx = rdx;
	this._lty = lty;
	this._rdy = rdy;
};

Object.defineProperty(Game_RangeRandPoint.prototype, "x", {
	get: function() {
        return Utils.randomInt(this._ltx, this._rdx);
    },
    configurable: true
});

Object.defineProperty(Game_RangeRandPoint.prototype, "y", {
	get: function() {
        return Utils.randomInt(this._lty, this._rdy);
    },
    configurable: true
});

Utils.isLegalMode = function() {
	return NYA.LEGAL;
};

function Tilemap() {
	this.initialize(...arguments);
}

Tilemap.prototype = Object.create(PIXI.Container.prototype);
Tilemap.prototype.constructor = Tilemap;

Tilemap.prototype.initialize = function() {
	PIXI.Container.call(this);
	this.origin = new Point();
};

Tilemap.prototype.destroy = function() {
    const options = { children: true, texture: true };
    PIXI.Container.prototype.destroy.call(this, options);
};

Tilemap.prototype.updateTransform = function() {
    this._sortChildren();
    PIXI.Container.prototype.updateTransform.call(this);
};

Tilemap.prototype._sortChildren = function() {
    this.children.sort(this._compareChildOrder.bind(this));
};

Tilemap.prototype._compareChildOrder = function(a, b) {
	const az = a.z;
	const bz = b.z;
    if (az !== bz) {
        return az - bz;
    } else if(az === 3) {
		const azx = a.zx;
		const azy = a.zy;
		const azk = a.zk;
		const bzx = b.zx;
		const bzy = b.zy;
		const bzk = b.zk;
		return (azx + bzx) * azk + azy - ((bzx + azx) * bzk + bzy);
	} else {
        return a.spriteId - b.spriteId;
    }
};

Tilemap.prototype.update = function() {
    for (const child of this.children) {
        if (child.update) {
            child.update();
        }
    }
};

Tilemap.prototype.addChild = function() {
	PIXI.Container.prototype.addChild.apply(this, arguments);
	for(const child of arguments) {
		this.ensureSpriteId(child);
	}
};

Tilemap.prototype.addChildAt = function(child) {
	PIXI.Container.prototype.addChildAt.apply(this, arguments);
	this.ensureSpriteId(child);
};

Tilemap.prototype.ensureSpriteId = function(sprite) {
	if(!sprite.spriteId) {
		sprite.spriteId = Sprite._counter++;
	}
	if(!sprite.z) {
		sprite.z = 0;
	}
	if(!sprite.zx) {
		sprite.zx = 0;
	}
	if(!sprite.zy) {
		sprite.zy = 0;
	}
	if(!sprite.zk) {
		sprite.zk = 0;
	}
};

Tilemap.Renderer = function() {
	PIXI.ObjectRenderer.call(this);
}

Tilemap.Renderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);
Tilemap.Renderer.prototype.constructor = Tilemap.Renderer;

PIXI.Renderer.registerPlugin("rpgtilemap", Tilemap.Renderer);

NYA.BASE.Graphics_FPSCounter_initialize = Graphics.FPSCounter.prototype.initialize;
Graphics.FPSCounter.prototype.initialize = function() {
	NYA.BASE.Graphics_FPSCounter_initialize.apply(this, arguments);
	this._shouldUpdateDuration = false;
	this._durationBuffer = 0;				// 屏幕高于60HZ刷新率时，我会把不造成逻辑计算的deltaTime先叠加到此值
};

Graphics.FPSCounter.prototype._update = function() {
    const count = this._showFps ? this.fps : this.duration;
    this._labelDiv.textContent = this._showFps ? "FPS" : "CPU";
    this._numberDiv.textContent = this._showFps ? "" + Math.round(count): Math.min(100, Math.round(count / (1000 / 60) * 100)) + "%";
};

Graphics.FPSCounter.prototype.setDisable = function() {
	this._showFps = false;
	this._boxDiv.style.display = "none";
};

Graphics.FPSCounter.prototype.setFPSEnable = function() {
	this._boxDiv.style.display = "block";
	this._showFps = true;
	this._update();
};

Graphics.FPSCounter.prototype.setCPUEnable = function() {
	this._boxDiv.style.display = "block";
	this._showFps = false;
	this._update();
};

Graphics.FPSCounter.prototype.endTick = function() {
    const time = performance.now();
    const thisFrameTime = time - this._lastLoop;
    this._frameTime += (thisFrameTime - this._frameTime) / 12;
    this.fps = 1000 / this._frameTime;
	if(this._shouldUpdateDuration) {
		this.duration *= 0.98;
		this.duration += (Math.max(0, time - this._frameStart) + this._durationBuffer) * 0.02;
		this._durationBuffer = 0;
	} else {
		this._durationBuffer += Math.max(0, time - this._frameStart);
	}
    this._lastLoop = time;
    if (this._tickCount++ % 15 === 0) {
        this._update();
    }
};

Graphics.setShouldUpdateDuration = function(val) {
	this._fpsCounter._shouldUpdateDuration = val;
};

SceneManager.update = function(deltaTime) {
    try {
        const n = this.determineRepeatNumber(deltaTime);
        for (let i = 0; i < n; i++) {
            this.updateMain();
        }
		Graphics.setShouldUpdateDuration(n > 0);
    } catch (e) {
        this.catchException(e);
    }
};
NYA.PHYSICS = {};

NYA.PHYSICS.Game_CharacterBase_initMembers = Game_CharacterBase.prototype.initMembers;
Game_CharacterBase.prototype.initMembers = function() {
	NYA.PHYSICS.Game_CharacterBase_initMembers.apply(this, arguments);
	this.type = 0;			// 地形的特殊标识 1代表该地形是空心的，2代表该地形碰到了会掉血/复位
	this.px = this.rx = this.vx = 0;
	this.py = this.ry = this.vy = 0;
	this.dotX = 0.0;		// 上一帧速度的小数值，会在后面几帧累积并且发挥左右
	this.dotY = 0.0;
	this._rvx = 0;
	this._rvy = 0;
	this.physics = false;
	this.fix = false;
	this.fitX = [];
	this.fitY = [];
	this.m = 1;
	this.elastic = 0;
	this._isGrounding = false;
	this._hitOffsetL = this._hitOffsetT = this._hitOffsetR = this._hitOffsetB = 0;
	this._phAnchorX = 0;
	this._phAnchorY = 0;
	this._suspendFriction = false;
	this._suspendGravity = false;
	this._preventAutoPhAnchor = false;
	this._groundGradient = 0;
	this._groundGradientObj = null;
	this._groundHitObj = null;
	this._mirrorLR = false;
	this._physicsFlag = 0;
	this._g = 0;
	this.vertices = null;
	this._antiVground = false;			// 开启后所有vground地形全部变成普通地形，且只有vground地形有碰撞
	this._immueVground = false;			// 开启后所有vground地形全部变成空气
	this._groundingX = 0;				// 浮空前的位置X
	this._groundingY = 0;				// 浮空前的位置X
	this._terrainGroundingX = 0;		// 最后一次踩在静态地形上的位置X
	this._terrainGroundingY = 0;		// 最后一次踩在静态地形上的位置Y
	this._immuePhysicsObject = []		// 免疫碰撞的物体对象
	this._shouldUseMiniumFriction = false;	// 计算摩擦力时是否使用两物体之间较小的摩擦力
	this._nextFrameImmueElasticCollision = false;			// 被技能击中后下一帧免疫弹性碰撞，打击感问题
	this.terrain = false;
	this._mg = 0;
	this._extGravity = 0;
	this._extMGravity = 0;
	this.initTempValues();
};

Game_CharacterBase.prototype.initTempValues = function() {
	this._tpy = undefined;
	this._testV = false;
	this._tvx = 0;
	this._tvy = 0;
	this._impact = undefined;
	this._impactvx = 0;
	this._impactvy = 0;
	this.__impactvx = 0;
	this.__impactvy = 0;
};

Game_CharacterBase.prototype.battleTeam = function() {
	return this.battleObject().team;
};

Game_CharacterBase.prototype.physicsFlag = function() {
	return ((this.fix || this.terrain) && this._physicsFlag === 0) ? 6 : this._physicsFlag;
};

Game_CharacterBase.prototype.isAntiVground = function() {
	return this._antiVground;
};

Game_CharacterBase.prototype.setAntiVground = function(value) {
	this._antiVground = value;
};

Game_CharacterBase.prototype.isImmueVground = function() {
	return this._immueVground;
};

Game_CharacterBase.prototype.setImmueVground = function(value) {
	this._immueVground = value;
};

Game_CharacterBase.prototype.phAnchorX = function() {
	if(!this._mirrorLR) {
		return this._phAnchorX;
	} else {
		return this.patternWidth() - this._phAnchorX;
	}
};

Game_CharacterBase.prototype.phAnchorY = function() {
	return this._phAnchorY;
};

Game_CharacterBase.prototype.g = function() {
	return this._g + this._extGravity;
};

Game_CharacterBase.prototype.mg = function() {
	return this._mg + this._extMGravity;
};

Game_CharacterBase.prototype.setTempGravity = function(v) {
	this._extGravity = v;
};

Game_CharacterBase.prototype.setTempMGravity = function(v) {
	this._extMGravity = v;
};

Game_CharacterBase.prototype.doGravity = function() {
	if(!this.isSuspendGravity())
	{
		const g = $gameMap.g() + this.g();
		const mg = $gameMap.mg() + this.mg();
		if(mg > 0) {
			if(!this.isGrounding() && this._vy < mg)
			{
				this.vy = this._vy + g;
				if(this._vy > mg) {
					this.vy = mg;
				}
			}
		} else {
			if(this._vy > mg)
			{
				this.vy = this._vy + g;
				if(this._vy < mg) {
					this.vy = mg;
				}
			}
		}
	}
	this.setTempGravity(0);
	this.setTempMGravity(0);
};

Game_CharacterBase.prototype.isSuspendGravity = function() {
	return this._suspendGravity || (this._staggerTime && this._isFixStagger);
};

Game_Map.prototype.mg = function() {
	return this._inWater ? 6 : 12;
};

Game_CharacterBase.prototype.suspendGravity = function() {
	this._suspendGravity = true;
};

Game_CharacterBase.prototype.resumeGravity = function() {
	this._suspendGravity = false;
};

Game_CharacterBase.prototype.suspendFriction = function() {
	this._suspendFriction = true;
};

Game_CharacterBase.prototype.resumeFriction = function() {
	this._suspendFriction = false;
};

Game_CharacterBase.prototype.physicsUpdate = function() {
	this.elasticCollision();
	this.doGravity();
	this.doFriction();
};

Game_CharacterBase.prototype.elasticCollision = function() {
	if(this._impact) {
		const obj = this._impact;
		const ela = Math.max(this.elastic, obj.elastic);
		const vx1 = this._impactvx;
		const vy1 = this._impactvy;
		const vx2 = this.__impactvx;
		const vy2 = this.__impactvy;
		const dir = this._impactDirection;
		this.dotX = this.dotY = 0;
		if(!this._nextFrameImmueElasticCollision) {
			this.executeElasticCollision(obj, ela, vx1, vy1, vx2, vy2, dir);
		}
		if(!this._impact.fix && !this._impact._nextFrameImmueElasticCollision) {
			this._impact.executeElasticCollision(this, ela, vx2, vy2, vx1, vy1, dir);
		}
	}
	this._nextFrameImmueElasticCollision = false;
};

Game_CharacterBase.prototype.executeElasticCollision = function(obj, ela, vx1, vy1, vx2, vy2, dir) {
	if(obj.fix) {
		switch(dir) {
			case 0: this._vx = vx2 + Utils.passVal(-vx1, 0, ela); break;
			case 1: this._vy = vy2 + Utils.passVal(-vy1, 0, ela); break;
			case 2: this._vx = vx2 + Utils.passVal(-vx1, 0, ela); this._vy = vy2 + Utils.passVal(-vy1, 0, ela); break;
			default: break;
		}
	}
	else {
		const elavx = ((this.m - obj.m) * vx1 + 2 * obj.m * vx2) / (this.m + obj.m);
		const noelavx = (this.m * vx1 + obj.m * vx2) / (this.m + obj.m);
		const elavy = ((this.m - obj.m) * vy1 + 2 * obj.m * vy2) / (this.m + obj.m);
		const noelavy = (this.m * vy1 + obj.m * vy2) / (this.m + obj.m);
		switch(dir) {
			case 0: this._vx = Utils.passVal(elavx, noelavx, ela); break;
			case 1: this._vy = Utils.passVal(elavy, noelavy, ela); break;
			case 2: this._vx = Utils.passVal(elavx, noelavx, ela); this._vy = Utils.passVal(elavy, noelavy, ela); break;
			default: break;
		}
	}
	if(this.isGrounding() && dir === 1 && Math.abs(this._vy) < 1) {
		this._vy = 0;
	}
};

Game_CharacterBase.prototype.impu = function(x, y) {
	this.vx = this._vx + x / this.m;
	this.vy = this._vy + y / this.m;
};

Game_CharacterBase.prototype.impux = function(x) {
	this.impu(x, 0);
};

Game_CharacterBase.prototype.impuy = function(y) {
	this.impu(0, y);
};

Game_CharacterBase.prototype.shouldUseMiniumFriction = function() {
	return this._shouldUseMiniumFriction;
};

Game_CharacterBase.prototype.useMiniumFriction = function(val) {
	this._shouldUseMiniumFriction = val;
};

Game_CharacterBase.prototype.doFriction = function() {
	if(this.isSuspendFriction()) {
		return;
	}
	if(this.pollMoveSuspendFriction()) {
		return;
	}
	if(this._groundHitObj)
	{
		const ch = this._groundHitObj;
		if(ch._vx != this._vx)
		{
			const fr = this.shouldUseMiniumFriction() || ch.shouldUseMiniumFriction() ? Math.min(this.friction(), ch.friction()) : Math.max(this.friction(), ch.friction());
			this.executeFriction(fr, ch._vx);
		}
		
	}
	else if(this._vx != 0) {
		const fr = this.airFriction();
		this.executeFriction(fr, 0);
	}
};

Game_CharacterBase.prototype.isSuspendFriction = function() {
	return this._suspendFriction || this._noControlTimeEx || this._noControlTimeEx2 || (this._staggerTime && this._isFixStagger);
};

Game_CharacterBase.prototype.fixFriction = function(dx, rel) {
	this._vx = dx > 0 && this._vx < rel || dx <= 0 && this._vx > rel ? rel : this._vx;
};

Game_CharacterBase.prototype.executeFriction = function(fr, rel) {
	const dx = this._vx - rel;
	const fx = dx > 0 ? -fr : fr;
	this._vx += fx;
	this.fixFriction(dx, rel);
};

NYA.PHYSICS.Game_Player_initMembers = Game_Player.prototype.initMembers;
Game_Player.prototype.initMembers = function() {
	NYA.PHYSICS.Game_Player_initMembers.apply(this, arguments);
	this.fix = false;
	this.physics = true;
	this.setFriction(6);
	this.setAirFriction(6);
};

Game_Player.prototype.refresh = function() {
};

Game_CharacterBase.prototype.resetHitOffset = function() {
	if(this.vertices) {
		return;
	}
	this._hitOffsetL = this._hitOffsetR = this.patternWidth() / 2;
	this._hitOffsetB = 0;
	this._hitOffsetT = this.patternHeight();
};

Game_CharacterBase.prototype.setHitRect = function(rect) {
	this.setHitOffsetL(rect.l);
	this.setHitOffsetT(rect.t);
	this.setHitOffsetR(rect.r);
	this.setHitOffsetB(rect.b);
};

NYA.PHYSICS.Game_Map_update = Game_Map.prototype.update;
Game_Map.prototype.update = function(sceneActive) {
	NYA.PHYSICS.Game_Map_update.apply(this, arguments);
	if(this._pausePhysics) {
		this._pausePhysics--;
		return;
	}
	
	this.makePhysicsObject();
	
	const physicsObject = this._physicsObject;
	const physicsDynamicObject = this._physicsDynamicObject;
	const physicsFixObject = this._physicsFixObject;
	
	this.updatePhysicsOther();
	
	physicsDynamicObject.forEach((ev) => { ev.physicsUpdate(); });  					// 外力：重力，摩擦力，阻力，弹性碰撞
	
	physicsObject.forEach((ev) => {ev.updateStatem();});								// 内力：有限状态机
	
	physicsObject.forEach((ev) => { ev.makeMomentum(); });								// 生成物理动量					
	
	this.generateImmuePhysicsObject(physicsDynamicObject, physicsObject);				// 某些物体在物理引擎运行前就已经“卡住”了，为各个对象排除已卡住的物体
	
	this.executeHitTest(physicsDynamicObject, physicsFixObject, physicsObject);			// 碰撞检测
	
	this.generatePhysicsInfo(physicsObject, physicsDynamicObject);						// 生成辅助参数
	
	physicsObject.forEach((ev) => { ev.flush(); });										// 应用结果
	
	this.updateBullets();
		
	this.processCamera();																// 镜头处理
};

Game_Map.prototype.updatePhysicsOther = function() {
	// overwrite
};

Game_Map.prototype.makePhysicsObject = function() {
	this._physicsObject = [];
	this._physicsFixObject = [];
	this._physicsDynamicObject = [];
	const po = this._physicsObject;
	const pfo = this._physicsFixObject;
	const pdo = this._physicsDynamicObject;
	pdo.push($gamePlayer);
	po.push($gamePlayer);
	this.events().forEach((ev) => {
		this.classifyEvents(ev, po, pdo, pfo);
	});
	
	this.dynamicCharacters().forEach((ev) => {
		this.classifyEvents(ev, po, pdo, pfo);
	});
	
	pdo.sort((ch1, ch2) => {
		return ch2.py - ch1.py;
	});
	this._physicsDynamicGrid.reset(pdo);
	this._physicsFixGrid.reset(pfo);
	this._physicsGrid.reset(po);
};

Game_Map.prototype.clearPhysicsObject = function() {
	this._physicsObject = [];
	this._physicsFixObject = [];
	this._physicsDynamicObject = [];
	this._physicsDynamicGrid.reset([]);
	this._physicsFixGrid.reset([]);
	this._physicsGrid.reset([]);
};

Game_Map.prototype.classifyEvents = function(ev, po, pdo, pfo) {
	if(ev.physics) {
		if(!ev.isDeath() || !ev.isDeathAnimationComplete()) {
			if(!ev.fix) {
				pdo.push(ev);
			}
			else {
				pfo.push(ev);
			}
			po.push(ev);
		}
	}
};

Game_Map.prototype.generatePhysicsInfo = function(po, pdo) {
	const grid = new PhysicsGrid(this._physicsObject);
	pdo.forEach((ev) => {
		this.generateObjectPhysicsInfo(ev, grid);
	});
};

Game_Map.prototype.generateObjectPhysicsInfo = function(ev, es) {
	ev.startTestV();
	ev.testVY(ev._vy + 1);
	const hitObjs = this.hitTest(ev, es);
	const tres = [];
	if(hitObjs) {
		if(hitObjs[0].type !== 2) { 
			ev._isGrounding = true;
			ev._groundHitObj = hitObjs[0];
		} else {
			ev._isGrounding = false;
			ev._groundHitObj = null;
		}
		if(!ev.vertices) {
			for(const hitObj of hitObjs) {
				if(hitObj.vertices) {
					const offset = ev.staticBound();
					const p1x1 = physicsASMHeap64[4];
					const p1y1 = physicsASMHeap64[5];
					const p1x2 = physicsASMHeap64[6];
					const p1y2 = physicsASMHeap64[7];
					const offset2 = hitObj.staticBound(offset);
					let p2x1 = physicsASMHeap64[offset2 - 2];
					let p2y1 = physicsASMHeap64[offset2 - 1];
					
					for(let i = offset; i < offset2; i+=2) {
						const p2x2 = physicsASMHeap64[i];
						const p2y2 = physicsASMHeap64[i+1];
						if(p2x1 !== p2x2 && p2y1 !== p2y2 && Math.abs((p2y1 - p2y2) / (p2x1 - p2x2)) < 2) {		// 太斜的坡不给爬
							if(physicsASM.isSegmentIntersect(p1x1, p1y1, p1x2, p1y2, p2x1, p2y1, p2x2, p2y2)) {
								const gradient = (p2y1 - p2y2) / (p2x1 - p2x2);
								tres.push(gradient);
								ev._groundGradientObj = hitObj;
							}
						}
						p2x1 = p2x2;
						p2y1 = p2y2;
					}
				}
			}
		}
	}
	else {
		if(ev._isGrounding) {
			ev._groundingX = ev.px;
			ev._groundingY = ev.py;
			if(ev._groundHitObj && ev._groundHitObj.constructor === Game_Terrain && !ev._groundHitObj.triggerDamage && ev.py <= $gameMap.height() * $gameMap.tileHeight()) {
				ev._terrainGroundingX = ev._groundingX;
				ev._terrainGroundingY = ev._groundingY;
			}
		}
		ev._isGrounding = false;
		ev._groundHitObj = null;
	}
	if(tres.length === 1) {
		// 下坡路 gradient > 0 上坡 gradient < 0
		ev._groundGradient = tres[0];
		ev._groundHitObj = ev._groundGradientObj;
	}
	else {
		ev._groundGradient = 0;
		ev._groundGradientObj = null;
	}
	ev.endTestV();
};

Game_Map.prototype.hitTest = function(obj, es, terrain = true) {
	const hit = [];
	es.getObjGrid(obj, hit);
	if(terrain) {
		const terrains = this._terrain;
		terrains.getObjGrid(obj, hit);
	}
	if(hit.length === 0) {
		return null;
	}
	return hit;
};

// FLAG = 1 只和 FLAG = 2以及地形，fix=true发生碰撞，FLAG = 1一般是掉落的钱币，或者是暂时无视碰撞箱的战斗单位，FLAG = 2是蘑菇，会和钱发生碰撞
// FLAG = 3 只和 FLAG = 4发生碰撞，FLAG = 4是技能判定
// FLAG = 5 只和 FLAG = 4以及地形，fix=true发生碰撞，FLAG = 5是莉莉亚的炸弹
Game_CharacterBase.prototype.hitTest = function(obj) {
	const flag1 = this.physicsFlag();
	const flag2 = obj.physicsFlag();
	if(!PhysicsGrid._flagMatrix[flag1].includes(flag2)) {
		return false;
	}
	if(this._immuePhysicsObject && this._immuePhysicsObject.includes(obj)) {
		return false;
	}
	if(this.immueFixObject() && obj.fix && !obj.terrain || obj.immueFixObject() && this.fix && !this.terrain) {
		return false;
	}
	if(this.baseHitTest(obj)) {
		if(obj.type === 1) {
			if(this.isVGroundTerrain(obj)) { return false; }
		} else if(this.type === 1) {
			if(obj.isVGroundTerrain(this)) { return false; }
		}
		return true;
	}
	return false;
};

Game_CharacterBase.prototype.baseHitTest = function(obj) {
	if(!physicsASM.isRectOutBound(this.rx, this.ry, this.hitOffsetL(), this.hitOffsetT(), this.hitOffsetR(), this.hitOffsetB()
		, obj.rx, obj.ry, obj.hitOffsetL(), obj.hitOffsetT(), obj.hitOffsetR(), obj.hitOffsetB())) {
		const offset = this.staticBound();
		const offset2 = obj.staticBound(offset);
		if(physicsASM.isConvexPolygonIntersect(0, offset, offset, offset2)) {
			return true;
		}
	}
	return false;
};

Game_CharacterBase.prototype.isPointIn = function(x, y) {
	const offset = this.staticBound();
	return !!physicsASM.isPointInConvexPolygon(x, y, 0, offset);
};

Game_CharacterBase.prototype.isXIn = function(x) {
	const minX = this.px - this.hitOffsetL();
	const maxX = this.px + this.hitOffsetR() - 1;
	return x >= minX && x <= maxX;
};

Game_CharacterBase.prototype.isVGroundTerrain = function(terrain) {
	if(this.isImmueVground()) {
		return true;
	} else if(this.isAntiVground()) {
		return false;
	}
	const pvx = this._vx;
	const pvy = this._vy;
	const tvx = this._vx - terrain._vx;
	const tvy = this._vy - terrain._vy;		// 相对速度
	if(this._groundGradient !== 0) { return false; }
	if(tvy < 0) { return true; }
	this.testV({x:tvx, y:terrain._vy});
	if(this.baseHitTest(terrain)) {
		this.testV({x:pvx, y:pvy});
		return true;
	}
	this.testV({x:terrain._vx, y:terrain._vy});
	if(this.baseHitTest(terrain)) {
		this.testV({x:pvx, y:pvy});
		return true;
	}
	this.testV({x:pvx, y:pvy});
	return false;
};

Game_CharacterBase.prototype.vxInterpolation = function(n) {
	const vx = this._tvx;
	const ivx = Utils.vInterpolation(vx, n);
	return ivx;
};

Game_CharacterBase.prototype.vyInterpolation = function(n) {
	const vy = this._tvy;
	const ivy = Utils.vInterpolation(vy, n);
	return ivy;
};

Utils.vInterpolation = function(v, n) {
	const sign = Utils.sign(n % 2);
	const count = Math.trunc(n / 2) + 1;
	const iv = v + count * sign;
	return iv;
};

Game_Map.prototype.executeHitTest = function(pdo, pfo, po) {
	this.doExecuteHitTest(pdo, pdo);
	this.executeHitTestPFO(pdo.clone(), pfo);
};

if(Utils.isMobileDevice()) {
Game_CharacterBase.prototype.shouldUseImmuePhysicsObject = function() {
	return false;
};
} else {
Game_CharacterBase.prototype.shouldUseImmuePhysicsObject = function() {
	return true;
};
}

Game_CharacterBase.prototype.immueFixObject = function() {
	return false;
};

Game_Event.prototype.shouldUseImmuePhysicsObject = function() {
	return true;
};

Game_Player.prototype.shouldUseImmuePhysicsObject = function() {
	return true;
};

Game_Map.prototype.generateImmuePhysicsObject = function(pdo, po) {
	po.forEach((obj) => {
		obj.startTestV();
		obj.testV({x:0, y:0});
	});
	pdo.forEach((obj) => {
		if(obj.shouldUseImmuePhysicsObject()) {
			obj._immuePhysicsObject = null;
			const hitObjs = this.hitTest(obj, this._physicsGrid);
			obj._immuePhysicsObject = hitObjs;
		}
	});
	po.forEach((obj) => {
		obj.endTestV();
	});
};

Game_Map.prototype.executeHitTestPFO = function(pdo, pfo, dvx, dvy) {
	pfo.forEach((ev) => {
		const vx = dvx === undefined ? ev.vx : dvx;
		const vy = dvy === undefined ? ev.vy : dvy;
		const gridDynamic = new PhysicsGrid(pdo);
		const hit = this.hitTest(ev, gridDynamic, false);
		if(hit) {
			hit.forEach((dev) => {
				const ppx = dev.px;
				const ppy = dev.py;
				let signx = 0;
				const vsx = vx * dev._vx;
				if(vsx < 0) {		// 动态物体与静态物体速度方向相反
					dev.px += vx;
					dev._vx -= vx;
					signx = 0;
				} else {			// 动态物体与静态物体速度方向相同
					if(Math.abs(vx) > Math.abs(dev._vx)) {
						signx = 1;
					} else {
						signx = 0;
					}
					dev._vx += vx;
				}
				let signy = 0;
				const tvx = dev._vx;
				dev._vx = 0;
				dev.makeMomentum();
				const grid = new PhysicsGrid([ev]);
				let imDirection = 0;
				if(this.hitTest(dev, grid, false)) {
					imDirection = 1;
					dev._vx = tvx;
					const vsy = vy * dev._vy;
					if(vsy < 0) {
						dev.py += vy;
						dev._vy -= vy;
						signy = 0;
					} else {
						if(Math.abs(vy) > Math.abs(dev._vy)) {
							signy = 1;
						} else {
							signy = 0;
						}
						dev._vy += vy;
					}
				}
				const imtvx = dev._tvx;
				const imtvy = dev._tvy;
				dev.makeMomentum();
				dev.startTestV();
				
				const gridnew = new PhysicsGrid([ev]);
				this.internalHitTest(dev, gridnew, signx, signy, false);
				dev.makeImpactEx(ev, imtvx, imtvy, imDirection);
				dev.flushTestV();
				dev._vx += (dev.px - ppx);
				dev.px = ppx;
				dev._vy += (dev.py - ppy);
				dev.py = ppy;
				dev.makeMomentum();
				this.executeHitTestPFO(pdo.remove(dev), [dev]);
			});
		}
	});
};

Game_Map.prototype.doExecuteHitTest = function(pdo, po) {
	pdo.forEach((ev) => {
		ev.startTestV();
		ev.testV({x:0,y:0});
	});
	const grid = new PhysicsGrid(po);
	pdo.forEach((ev) => {
		grid.gridOpDel(ev);
		const currentHit = this.checkShouldUseInternalTest(ev, grid);
		if(currentHit) {
			ev.smoothCorner(grid, currentHit);
			this.internalHitTest(ev, grid);
		} else {
			ev.clearImpact();
/* 			if(ev.smoothVGround(grid)) {
				this.internalHitTest(ev, grid);
			} */
		}
		ev.flushTestV();
		grid.gridOpAdd(ev);
	});
};

Game_Map.prototype.checkShouldUseInternalTest = function(ev, grid) {
	ev.testV({x:ev._tvx,y:ev._tvy});
	if(ev._groundGradientObj) {
		return [];
	} else {
		return this.hitTest(ev, grid, true);
	}
};

// 0代表从0往最终速度值上逐像素检测，一旦发现有碰撞则退回前一状态
// 1则代表从最终速度值往0上逐像素检测
Game_Map.prototype.internalHitTest = function(ev, po, signx = 0, signy = 0, terrain = true) {
	let ht = true;
	let vt = true;
	const tvx = ev._tvx;
	const tvy = ev._tvy;
	const mv = Math.ceil(Math.max(1, Math.max(Math.abs(tvx), Math.abs(tvy))));
	let d = 1;
	const startX = signx === 0 ? 0 : tvx;
	const startY = signy === 0 ? 0 : tvy;
	ev.testV({x:startX,y:startY});
	while(d <= mv && (ht || vt)) {
		if(ht) {
			const tx = this.signRound(tvx, d, mv, signx);
			const pvx = ev._vx;
			ev.testVX(tx);
			const hit = this.hitTest(ev, po, terrain);
			if(hit) {
				ev.makeImpact(hit[0]);
				ev._impactDirection = 0;
				ht = false;
				ev.testVX(pvx);
				if(hit.length === 1 && hit[0] === ev._groundGradientObj && ev._groundGradient * tvx < 0) {		// 异号，爬坡状态
					if(!this.gradientGroundWalk(ev, po)) {
						ht = true;
						ev.clearImpact();
						continue;
					}
				}
			}
			else {
				if(ev._groundHitObj === ev._groundGradientObj && ev._groundGradient * tvx > 0) {		 // 同号，下坡状态
					this.gradientGroundWalk(ev, po);
				}
			}
		}
		if(vt) {
			const ty = this.signRound(tvy, d, mv, signy);
			const pvy = ev._vy;
			ev.testVY(ty);
			const hit = this.hitTest(ev, po, terrain);
			if(hit) {
				ev.makeImpact(hit[0]);
				ev._impactDirection = 1;
				vt = false;
				ev.testVY(pvy);
			}
		}
		d++;
	}
	if(ht && vt) {
		ev.clearImpact();
	}
};

Game_Map.prototype.signRound = function(v, d, mv, sign) {
	if(!sign) {
		return v * d / mv;
	} else {
		return v * (mv - d) / mv;
	}
};

Game_Map.prototype.gradientGroundWalk = function(ev, pdo) {
	const tvx = ev._tvx;
	const tvy = ev._tvy;
	if(ev._groundGradient !== 0 && Math.round(tvy) === 0 && Math.round(tvx) !== 0) {
		const impactEvs = [];
		this.findUpImapct(impactEvs, ev, pdo);
		impactEvs.push(ev);
		
		const pdo2 = new PhysicsGrid();
		pdo.forEach((dynamicObj) => {
			if(!impactEvs.includes(dynamicObj)) {
				pdo2.push(dynamicObj);
			}
		});
		pdo2.rebuild();
		
		const gradientHit = impactEvs.some((iev) => {
			iev._tpy = iev.py;
			iev.py = iev.ry = iev._tpy + Utils.sign(ev._groundGradient * tvx);
			return !!this.hitTest(iev, pdo2);
		});
		impactEvs.forEach((iev) => {
			if(gradientHit && iev._tpy !== undefined) {
				iev.py = iev.ry = iev._tpy;
			}
			iev._tpy = undefined;
		});
		return gradientHit;
	}
	return true;
};

Game_Map.prototype.findUpImapct = function(impact, ev, pdo) {
	ev.testVY(-1);
	const hitObjs = this.hitTest(ev, pdo, false);
	if(hitObjs) {
		for(const hitObj of hitObjs) {
			impact.push(hitObj);
			this.findUpImapct(impact, hitObj, pdo);
		}
	}
	ev.testVY(0);
};

Game_CharacterBase.prototype.makeImpact = function(impact) {
	this._impactvx = this._tvx;
	this._impactvy = this._tvy;
	this._impact = impact;
	this.__impactvx = impact._vx;
	this.__impactvy = impact._vy;
};

Game_CharacterBase.prototype.makeImpactEx = function(impact, tvx, tvy, direction) {
	this._impactDirection = direction;
	this._impactvx = tvx;
	this._impactvy = tvy;
	this._impact = impact;
	this.__impactvx = impact._vx;
	this.__impactvy = impact._vy;
};

Game_CharacterBase.prototype.impactObject = function() {
	return this._impact;
};

Game_CharacterBase.prototype.clearImpact = function() {
	this._impact = null;
};

Game_CharacterBase.prototype.friction = function() {
	return this._friction ? this._friction : 0.6;
};

Game_CharacterBase.prototype.setFriction = function(val) {
	this._friction = val;
};

Game_CharacterBase.prototype.airFriction = function() {
	return this._airfriction ? this._airfriction : 0.6;
};

Game_CharacterBase.prototype.setAirFriction = function(val) {
	this._airfriction = val;
};

Game_Map.prototype.buildTerrain = function() {
	this._terrain = new PhysicsGrid();
	this.tilemapTerrain();
	const terrainBoundL = new Game_Terrain(0, 0, 3);
	terrainBoundL.makeMapBoundL();
	const terrainBoundR = new Game_Terrain(0, 0, 4);
	terrainBoundR.makeMapBoundR();
	const terrainBoundB = new Game_Terrain(0, 0, 2);
	terrainBoundB.makeMapBoundB();
	this._terrain.push(terrainBoundL, terrainBoundR, terrainBoundB);
	this._terrain.rebuild();
};

Game_Map.prototype.hasTileA = function(x, y, z) {
	var mapData = this.tileId(x, y, z);
	if(mapData == 0 || mapData == null)
	{
		return false;
	}
	if(mapData >= Tilemap.TILE_ID_A5)
	{
		return true;
	}
	return false;
};

NYA.PHYSICS.Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
	NYA.PHYSICS.Game_Map_initialize.apply(this, arguments);
	this._bullets = [];
	this._displayPosController = {};
	this._pausePhysics = 0;
	this._tmxExternalVertices = {};		// 一个外部多边形集合，事件里可以引用它作为自己的判定
	this._inWater = false;
	this._sightMoveX = new Game_SightMove();
	this._sightMoveY = new Game_SightMove();
	this.setupPhysicsGrid();
};

Game_Map.prototype.setupPhysicsGrid = function() {
	this._physicsDynamicGrid = new PhysicsGrid([]);
	this._physicsFixGrid = new PhysicsGrid([]);
	this._physicsGrid = new PhysicsGrid([]);
};

NYA.PHYSICS.Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function() {
	this._tmxExternalVertices = {};		// 一个外部多边形集合，事件里可以引用它作为自己的判定
	NYA.PHYSICS.Game_Map_setup.apply(this, arguments);
	this._bullets = [];
	this._displayPosController = {};
	this._pausePhysics = 0;
	this.initInWater();
	this._sightMoveX.clear();
	this._sightMoveY.clear();
};

Game_Map.prototype.getExternalVertices = function(id) {
	return this._tmxExternalVertices[id];
};

Game_Map.prototype.pausePhysics = function(time = 2147483647) {
	this._pausePhysics = time;
};

Game_Map.prototype.resumePhysics = function() {
	this._pausePhysics = 0;
};

Game_Map.prototype.isPhysicPause = function() {
	return !!this._pausePhysics;
};

NYA.PHYSICS.Game_CharacterBase_isFrameAnimationPause = Game_CharacterBase.prototype.isFrameAnimationPause;
Game_CharacterBase.prototype.isFrameAnimationPause = function() {
	return NYA.PHYSICS.Game_CharacterBase_isFrameAnimationPause.call(this) || $gameMap.isPhysicPause();
};

NYA.PHYSICS.Game_Map_setupEvents = Game_Map.prototype.setupEvents;
Game_Map.prototype.setupEvents = function() {
	this.clearPhysicsObject();
	this.buildTerrain();
	NYA.PHYSICS.Game_Map_setupEvents.apply(this, arguments);
	this.makePhysicsObject();
};

Game_Map.prototype.bullets = function() {
	return this._bullets;
};

Game_Map.prototype.setDisplayControlPos = function(tx, ty, time, easingFunc) {
	this._displayPosController.tx = tx;
	this._displayPosController.ty = ty;
	this._displayPosController.sx = this._displayX;
	this._displayPosController.sy = this._displayY;
	this._displayPosController.time = 0;
	this._displayPosController.maxTime = time;
	this._displayPosController.easingFunc = easingFunc;
};

Game_Map.prototype.revertDisplayControlPos = function(maxTime) {
	this._displayPosController.time = 0;
	const sx = this._displayPosController.sx;
	const sy = this._displayPosController.sy;
	const tx = this._displayPosController.tx;
	const ty = this._displayPosController.ty;
	this._displayPosController.sx = tx;
	this._displayPosController.sy = ty;
	this._displayPosController.tx = sx;
	this._displayPosController.ty = sy
	this._displayPosController.maxTime = maxTime || this._displayPosController.maxTime;
};

Game_Map.prototype.processCamera = function() {
	if(this.updateDisplayControlPos()) {
		return;
	}
	const displayCenterX = this.displayCenterX();
	const displayCenterY = this.displayCenterY();
	const sightMoveX = this._sightMoveX.update(displayCenterX, 0, Math.max(0, this.width() - Graphics.width / this.tileWidth()), "s-left", "s-right");
	const sightMoveY = this._sightMoveY.update(displayCenterY, 0, Math.max(0, this.height() - Graphics.height / this.tileHeight()), "s-up", "s-down");
	const cameraMoveRate = 0.15;				     // 镜头移动速度比率
	const displayX = this._displayX;
	const displayY = this._displayY;
	const deltaX = (displayCenterX - displayX + sightMoveX) * cameraMoveRate;
	const deltaY = (displayCenterY - displayY + sightMoveY) * cameraMoveRate;
	const realDisplayX = Utils.roundWith(this.tileWidth(), displayX + deltaX);
	const realDisplayY = Utils.roundWith(this.tileHeight(), displayY + deltaY);
	this.setDisplayPos(realDisplayX, realDisplayY);
};

Game_Map.prototype.syncCamera = function() {
	const displayCenterX = this.displayCenterX();
	const displayCenterY = this.displayCenterY();
	const realDisplayX = Utils.roundWith(this.tileWidth(), displayCenterX);
	const realDisplayY = Utils.roundWith(this.tileHeight(), displayCenterY);
	this.setDisplayPos(realDisplayX, realDisplayY);
};

Game_Map.prototype.resetCamera = function() {
	this.syncCamera();
	this._sightMoveX.clear();
	this._sightMoveY.clear();
};

Game_Map.prototype.updateDisplayControlPos = function() {
	if(this._displayPosController.maxTime) {
		const maxTime = this._displayPosController.maxTime;
		const time = this._displayPosController.time;
		if(time < maxTime) {
			this._displayPosController.time++;
			this.executeDisplayControlPos();
		}
		return true;
	}
	return false;
};

Game_Map.prototype.executeDisplayControlPos = function() {
	const maxTime = this._displayPosController.maxTime;
	const time = this._displayPosController.time;
	const progress = time / maxTime;
	const easingFunc = AnimationController[this._displayPosController.easingFunc];
	const val = easingFunc(progress);
	const sx = this._displayPosController.sx;
	const sy = this._displayPosController.sy;
	const tx = this._displayPosController.tx;
	const ty = this._displayPosController.ty;
	const x = Utils.roundWith(this.tileWidth(), sx + (tx - sx) * val);
	const y = Utils.roundWith(this.tileHeight(), sy + (ty - sy) * val);
	this.setDisplayPos(x, y);
};

Game_Map.prototype.clearDisplayControllPos = function() {
	this._displayPosController = {};
};

Game_Map.prototype.screenTileX = function() {
    return Graphics.width / this.tileWidth();
};

Game_Map.prototype.screenTileY = function() {
    return Graphics.height / this.tileHeight();
};

Game_Map.prototype.displayCenterX = function() {
	return ($gamePlayer.rx - Graphics.width / 2) / this.tileWidth();
};

Game_Map.prototype.displayCenterY = function() {
	return ($gamePlayer.ry - ($gamePlayer.hitOffsetT() + $gamePlayer.hitOffsetB()) / 2 - Graphics.height / 2) / this.tileHeight();
};

//-------------------------rebuild--------------------------------

Game_Map.prototype.g = function() {
	return this._inWater ? 0.2 : 0.4;
};

NYA.PHYSICS.Game_CharacterBase_locate = Game_CharacterBase.prototype.locate;
Game_CharacterBase.prototype.locate = function(x, y) {
	NYA.PHYSICS.Game_CharacterBase_locate.apply(this, arguments);
    this.unflush();
};

Game_CharacterBase.prototype.unflush = function() {
	this.px = this.rx = this.tileXToCenterX(this.x);
	this.py = this.ry = this.tileYToCenterY(this.y);
};

Game_CharacterBase.prototype.flush = function() {
	this.px = this.rx;
	this.py = this.ry;
	const dotX = this.dotX + this._vx - this.vx;
	const dotY = this.dotY + this._vy - this.vy;
	const shiftX = Math.trunc(dotX);
	const shiftY = Math.trunc(dotY);
	this.dotX = dotX - shiftX;
	this.dotY = dotY - shiftY;
};

Game_CharacterBase.prototype.makeMomentum = function() {
	const vx = this.vx;
	const vy = this.vy;
	const dotX = this.dotX + this._vx - vx;
	const dotY = this.dotY + this._vy - vy;
	const shiftX = Math.trunc(dotX);
	const shiftY = Math.trunc(dotY);
	this.rx = this.px + vx + shiftX;
	this.ry = this.py + vy + shiftY;
};

Game_CharacterBase.prototype.startTestV = function() {
	if(!this._testV) {
		this._testV = true;
		this._tvx = this._vx;
		this._tvy = this._vy;
	}
};

Game_CharacterBase.prototype.testV = function(v) {
	this.vx = v.x;
	this.vy = v.y;
	this.makeMomentum();
};

Game_CharacterBase.prototype.testVX = function(vx) {
	this.vx = vx;
	this.makeMomentum();
};

Game_CharacterBase.prototype.testVY = function(vy) {
	this.vy = vy;
	this.makeMomentum();
};

Game_CharacterBase.prototype.endTestV = function() {
	if(this._testV) {
		this.vx = this._tvx;
		this.vy = this._tvy;
		this._testV = false;
		this.makeMomentum();
	}
};

Game_CharacterBase.prototype.flushTestV = function() {
	this._testV = false;
};

Game_CharacterBase.prototype.tileXToCenterX = function(x) {
	const width = this.hitOffsetL() + this.hitOffsetR();
	return x * $gameMap.tileWidth() + Math.trunc(($gameMap.tileWidth() - width) / 2) + this.hitOffsetL();
};

Game_CharacterBase.prototype.tileYToCenterY = function(y) {
	return (y + 1) * $gameMap.tileHeight() - this.hitOffsetB();
};

Game_CharacterBase.prototype.centerXToTileX = function(x) {
	const leftX = x - this.phAnchorX();
	const width = this.patternWidth();
	const realX = leftX + width / 2 - $gameMap.tileWidth() / 2;
	return {x: Math.trunc(realX / $gameMap.tileWidth()), ox: realX % $gameMap.tileWidth()};
};

Game_CharacterBase.prototype.centerYToTileY = function(y) {
	const upY = y - this.phAnchorY();
	const height = this.patternHeight();
	const realY = upY + height;
	return {y: Math.trunc(realY / $gameMap.tileHeight()) - 1, oy: realY % $gameMap.tileHeight()};
};

Game_CharacterBase.physicsProperty = {
	px: {
        get: function() {
			return this._px;
        },
		set: function(val) {
			this._px = val;
		},
        configurable: true
    },
    py: {
        get: function() {
            return this._py;
        },
		set: function(val) {
			this._py = val;
		},
        configurable: true
    },
	rx: {
        get: function() {
			return this._rx;
        },
		set: function(val) {
			this._rx = val;
		},
        configurable: true
    },
    ry: {
        get: function() {
            return this._ry;
        },
		set: function(val) {
			this._ry = val;
		},
        configurable: true
    },
	vx: {
        get: function() {
			return Math.round(this._vx);
        },
		set: function(val) {
			this._vx = val;
		},
        configurable: true
    },
    vy: {
        get: function() {
            return Math.round(this._vy);
        },
		set: function(val) {
			this._vy = val;
		},
        configurable: true
    },
	fix: {
		get: function() {
			return this._fix;
		},
		set: function(val) {
			this._fix = val;
		},
		configurable: true
	},
	physics: {
		get: function() {
			return this._physics;
		},
		set: function(val) {
			this._physics = val;
		},
		configurable: true
	},
	elastic: {
		get: function() {
			return this._elastic;
		},
		set: function(val) {
			this._elastic = val;
		},
		configurable: true
	}
};

Game_CharacterBase.prototype.hitOffsetL = function() {
	return this._mirrorLR ? this._hitOffsetR : this._hitOffsetL;
};

Game_CharacterBase.prototype.hitOffsetT = function() {
	return this._hitOffsetT;
};

Game_CharacterBase.prototype.hitOffsetR = function() {
	return this._mirrorLR ? this._hitOffsetL : this._hitOffsetR;
};

Game_CharacterBase.prototype.hitOffsetB = function() {
	return this._hitOffsetB;
};

Game_CharacterBase.prototype.setHitOffsetL = function(val) {
	this._hitOffsetL = val;
};

Game_CharacterBase.prototype.setHitOffsetT = function(val) {
	this._hitOffsetT = val;
};

Game_CharacterBase.prototype.setHitOffsetR = function(val) {
	this._hitOffsetR = val;
};

Game_CharacterBase.prototype.setHitOffsetB = function(val) {
	this._hitOffsetB = val;
};

Object.defineProperties(Game_CharacterBase.prototype, Game_CharacterBase.physicsProperty);

Game_CharacterBase.prototype.staticBound = function(offset = 0) {
	if(this.vertices) {
		let i = 0;
		for(i = 0; i < this.vertices.length; i++) {
			const p = this.vertices[i];
			physicsASMHeap64[offset + i * 2] = p.x + this.rx;
			physicsASMHeap64[offset + i * 2 + 1] = p.y + this.ry;
		}
		return i * 2 + offset;
	}
	const rx = this.rx;
	const ry = this.ry;
	const minX = rx - this.hitOffsetL();
	const maxX = rx + this.hitOffsetR() - 1;
	const minY = ry - this.hitOffsetT();
	const maxY = ry + this.hitOffsetB() - 1;
	physicsASMHeap64[offset] = minX;
	physicsASMHeap64[offset+1] = minY;
	physicsASMHeap64[offset+2] = maxX;
	physicsASMHeap64[offset+3] = minY;
	physicsASMHeap64[offset+4] = maxX;
	physicsASMHeap64[offset+5] = maxY;
	physicsASMHeap64[offset+6] = minX;
	physicsASMHeap64[offset+7] = maxY;
	return offset+8;
};

Game_CharacterBase.prototype.staticBoundOverview = function() {
	const rx = this.rx;
	const ry = this.ry;
	const minX = rx - this.hitOffsetL();
	const maxX = rx + this.hitOffsetR() - 1;
	const minY = ry - this.hitOffsetT();
	const maxY = ry + this.hitOffsetB() - 1;
	return {l:minX,t:minY,r:maxX,b:maxY};
};

Utils.sign = function(d) {
	return d > 0 ? 1 : -1;
};

Utils.uceil = function(val) {
	if(val > 0) {
		return Math.ceil(val);
	}
	return Math.floor(val);
};

// 由系数r决定返回值靠近b还是靠近a，r=0时最靠近b，r=1时最靠近a
Utils.passVal = function(a, b, r) {
	return (a - b) * r + b;
};

Game_Map.prototype.verticesBound = function(vertices) {
	let minX = null, maxX = null, minY = null, maxY = null;
	vertices.forEach((p) => {
		if(minX === null || p.x < minX) {
			minX = p.x;
		}
		if(maxX === null || p.x > maxX) {
			maxX = p.x;
		}
		if(minY === null || p.y < minY) {
			minY = p.y;
		}
		if(maxY === null || p.y > maxY) {
			maxY = p.y;
		}
	});
	return {minX:minX, maxX:maxX, minY:minY, maxY:maxY};
};

Game_CharacterBase.prototype.setVertices = function(vertices) {
	this.vertices = vertices;
	this.cacheVerticesRect();
};

Game_CharacterBase.prototype.cacheVerticesRect = function() {
	if(this.vertices) {
		const bound = $gameMap.verticesBound(this.vertices);
		this._hitOffsetL = -bound.minX;
		this._hitOffsetR = bound.maxX + 1;
		this._hitOffsetT = -bound.minY;
		this._hitOffsetB = bound.maxY + 1;
	}
};

function Game_Terrain() {
	this.initialize(...arguments);
}

Game_Terrain.prototype = Object.create(Game_CharacterBase.prototype);
Game_Terrain.prototype.constructor = Game_Terrain;

Game_Terrain.prototype.initialize = function(px, py, type = 0, vertices) {
	Game_CharacterBase.prototype.initialize.call(this);
	this.type = type;
	this.px = this.rx = px;
	this.py = this.ry = py;
	this.footstepId = 0;
	this.setVertices(vertices);
	this.upElastic = 0;
};

Game_Terrain.prototype.initMembers = function() {
	Game_CharacterBase.prototype.initMembers.call(this);
	this.fix = true;
	this.terrain = true;
	this._hitOffsetL = this._hitOffsetR = $gameMap.tileWidth() / 2;
	this._hitOffsetT = this._hitOffsetB = $gameMap.tileHeight() / 2;
};

Game_Terrain.prototype.makeMapBoundL = function() {
	this.px = this.rx = (-0.3) * $gameMap.tileWidth();
	this.py = this.ry = 0;
	this.vertices = [{x:-$gameMap.tileWidth(), y:-9999},{x:0, y:-9999},{x:0, y:9999},{x:-$gameMap.tileWidth(), y:9999}];
	this.cacheVerticesRect();
};

Game_Terrain.prototype.makeMapBoundR = function() {
	this.px = this.rx = ($gameMap.width() + 1.3) * $gameMap.tileWidth();
	this.py = this.ry = 0;
	this.vertices = [{x:-$gameMap.tileWidth(), y:-9999},{x:0, y:-9999},{x:0, y:9999},{x:-$gameMap.tileWidth(), y:9999}];
	this.cacheVerticesRect();
};

Game_Terrain.prototype.makeMapBoundB = function() {
	this.px = this.rx = $gameMap.width() / 2 * $gameMap.tileWidth();
	this.py = this.ry = ($gameMap.height() + 2) * $gameMap.tileHeight();
	const height = $gameMap.tileHeight();
	this.vertices = [{x:-9999, y:height},{x:9999, y:height},{x:9999, y:height},{x:-9999, y:height}];
	this.cacheVerticesRect();
};

Game_Terrain.prototype.battleTeam = function() {
	return -1;
};

Object.defineProperties(Game_Terrain.prototype, {
	vx: {
        get: function() {
			return 0;
        },
		set: function(val) {
			this._vx = 0;
		},
        configurable: true
    },
    vy: {
        get: function() {
            return 0;
        },
		set: function(val) {
			this._vy = 0;
		},
        configurable: true
}});

Game_Map.prototype.updateBullets = function() {
	const bullets = this.bullets();
	this._bullets = bullets.filter((bullet) => {
		bullet.update();
		if(!bullet.physics) {
			return false;
		} 
		return true;
	});
};

Game_Map.prototype.addBullet = function(bullet) {
	this._bullets.push(bullet);
};

Game_CharacterBase.prototype.isGrounding = function() {
	return this._isGrounding;
};

NYA.PHYSICS.Game_CharacterBase_setImage = Game_CharacterBase.prototype.setImage;
Game_CharacterBase.prototype.setImage = function() {
	NYA.PHYSICS.Game_CharacterBase_setImage.apply(this, arguments);
	if(this.characterName() && !this._preventAutoPhAnchor) {
		const squash = this.isSquash();
		const info = ImageFrame.info(this.characterName());
		this._phAnchorX = Math.round(info.anchorX * this.patternWidth());
		this._phAnchorY = Math.round((squash ? (info.anchorY + (1 - info.anchorY) / 2) : info.anchorY) * this.patternHeight());
		if(!squash) {
			this.resetHitOffset();
		}
	}
};

Game_CharacterBase.prototype.hitPreview = function(x, y, grid) {
	const rx = this.rx;
	const ry = this.ry;
	const vx = this._vx;
	const vy = this._vy;
	this.rx = this.px + x;
	this.ry = this.py + y;
	this._vx = x;
	this._vy = y;
	const hit = $gameMap.hitTest(this, grid || $gameMap._physicsGrid);
	this.rx = rx;
	this.ry = ry;
	this._vx = vx;
	this._vy = vy;
	return hit;
};

Game_CharacterBase.prototype.hitPreviewDynamicObject = function(x = 0, y = 0) {
	return this.hitPreview(x, y, $gameMap._physicsDynamicGrid);
};

Game_CharacterBase.prototype.hitPreviewFixObject = function(x, y) {
	return this.hitPreview(x, y, $gameMap._physicsFixGrid);
};

Game_CharacterBase.prototype.hitPreviewNoVGround = function(x = 0, y = 0) {
	this.setImmueVground(true);
	
	const rx = this.rx;
	const ry = this.ry;
	const vx = this._vx;
	const vy = this._vy;
	this.rx += x;
	this.ry += y;
	this._vx += x;
	this._vy += y;
	const hit = $gameMap.hitTest(this, $gameMap._physicsGrid);
	this.rx = rx;
	this.ry = ry;
	this._vx = vx;
	this._vy = vy;
	
	this.setImmueVground(false);
	return hit;
};

Game_CharacterBase.prototype.hitPreviewAntiVGround = function(x = 0, y = 0) {
	this.setAntiVground(true);
	
	const rx = this.rx;
	const ry = this.ry;
	const vx = this._vx;
	const vy = this._vy;
	this.rx += x;
	this.ry += y;
	this._vx += x;
	this._vy += y;
	const hit = $gameMap.hitTest(this, $gameMap._physicsGrid);
	this.rx = rx;
	this.ry = ry;
	this._vx = vx;
	this._vy = vy;
	
	this.setAntiVground(false);
	return hit;
};

NYA.PHYSICS.GRID_WIDTH = 192;
NYA.PHYSICS.GRID_HEIGHT = 192;

Array.prototype.upush = function(element) {
	if(!this.includes(element)) {
		this.push(element);
	}
};

Game_CharacterBase.prototype.rectIndex = function(width, height) {
	const rect = this.staticBoundOverview();
	rect.l = Math.trunc(rect.l / width);
	rect.t = Math.trunc(rect.t / height);
	rect.r = Math.trunc(rect.r / width);
	rect.b = Math.trunc(rect.b / height);
	return rect;
};

function PhysicsGrid() {
	this.initialize(...arguments);
}

// 不同携带physicsFlag对象的碰撞规则，见Game_CharacterBase.prototype.hitTest
// fix=true和terrain=true覆盖对象的physicsFlag，相当于physicsFlag固定为6
PhysicsGrid._flagMatrix = [
	[0,2,4,6,8]		// 普通单位
	,[2,6]			// 猫币||无视碰撞且无敌单位
	,[0,1,2,4,6,8]	// 蘑菇
	,[4]			// 莉莉亚的气波
	,[0,2,3,5,6,8]	// 普通技能
	,[4,6]			// 莉莉亚的炸弹||无视碰撞但不无敌单位
	,[0,1,2,4,5,6,7,8]	// terrain=true||fix=true
	,[6]			// 仅和地形发生碰撞的单位
	,[0,2,4,6]		// 与普通单位一样，但不与同flag发生碰撞
];

PhysicsGrid.prototype.initialize = function(members = []) {
	this._members = [new Map(), new Map(), new Map(), new Map(), new Map(), new Map(), new Map(), new Map(), new Map()];
	this._allMembers = members;
	this.rebuild();
};

PhysicsGrid.prototype.resetMembers = function() {
	for(const map of this._members) {
		map.clear();
	}
};

PhysicsGrid.prototype.rebuild = function() {
	this.resetMembers();
	this._allMembers.forEach((obj) => {
		this.gridOpAdd(obj);
	});
};

PhysicsGrid.prototype.reset = function(members) {
	this._allMembers = members;
	this.rebuild();
};

PhysicsGrid.prototype.gridOpAdd = function(obj) {
	const rect = obj.rectIndex(NYA.PHYSICS.GRID_WIDTH, NYA.PHYSICS.GRID_HEIGHT);
	for(let x = rect.l; x <= rect.r; x++) {
		for(let y = rect.t; y <= rect.b; y++) {
			this.membersOp(this.idx(x, y), obj);
		}
	}
};

PhysicsGrid.prototype.gridOpDel = function(obj) {
	const rect = obj.rectIndex(NYA.PHYSICS.GRID_WIDTH, NYA.PHYSICS.GRID_HEIGHT);
	for(let x = rect.l; x <= rect.r; x++) {
		for(let y = rect.t; y <= rect.b; y++) {
			this.membersOpDel(this.idx(x, y), obj);
		}
	}
};

PhysicsGrid.prototype.membersOp = function(k, obj) {
	const flag = obj.physicsFlag();
	const map = this._members[flag];
	if(!map.has(k)) {
		map.set(k, []);
	}
	const arr = map.get(k);
	arr.upush(obj);
};

PhysicsGrid.prototype.membersOpDel = function(k, obj) {
	const flag = obj.physicsFlag();
	const map = this._members[flag];
	const arr = map.get(k);
	if(arr) {
		arr.remove(obj);
	}
};
// x和y的范围大致是-55~55
// 经过转换后，每个flag大致为65535
PhysicsGrid.prototype.idx = function(x, y) {
	return ((x + 128) << 8) + (y + 128);
};

PhysicsGrid.prototype.getGrid = function(flag, x, y) {
	return this._members[flag].get(this.idx(x, y));
};

PhysicsGrid.prototype.getObjGrid = function(obj, hit) {
	const rect = obj.rectIndex(NYA.PHYSICS.GRID_WIDTH, NYA.PHYSICS.GRID_HEIGHT);
	const flag = obj.physicsFlag();
	const collidables = PhysicsGrid._flagMatrix[flag];
	for(let x = rect.l; x <= rect.r; x++) {
		for(let y = rect.t; y <= rect.b; y++) {
			for(const collidableFlag of collidables) {
				const grid = this.getGrid(collidableFlag, x, y);
				if(grid) {
					grid.forEach((tobj) => {
						if(tobj !== obj && !hit.includes(tobj) && obj.hitTest(tobj)) {
							hit.push(tobj);
						}
					});
				}
			}
		}
	}
};

PhysicsGrid.prototype.push = function() {
	this._allMembers.push(...arguments);
};

PhysicsGrid.prototype.forEach = function(callback) {
	this._allMembers.forEach(callback);
};

PhysicsGrid.prototype.sort = function(sortf) {
	this._allMembers.sort(sortf);
};

Game_Map.prototype.startClassifyGrid = function(obj) {
	if(obj._gridFlag === 2) {
		this._physicsDynamicObject.gridOpDel(obj);
	} else if(obj._gridFlag === 1) {
		this._physicsFixObject.gridOpDel(obj);
	}
};

Game_Map.prototype.endClassifyGrid = function(obj) {
	if(obj._gridFlag === 2) {
		this._physicsDynamicObject.gridOpAdd(obj);
	} else if(obj._gridFlag === 1) {
		this._physicsFixObject.gridOpAdd(obj);
	}
};

Game_CharacterBase.prototype.clearPhysicsObject = function() {
	this._groundHitObj = null;
	this._groundGradientObj = null;
	this.clearImpact();
	this._immuePhysicsObject = null;
};

// 存档读档导致的对象引用问题：某个character被多处引用，序列化后再反序列化会导致多处引用的不再是同一个对象。
// 关于读档后还原对象引用，仍然有问题没有解决，但剩下的问题似乎是可以容忍的，如果后续发现有大问题再想办法解决吧。
// 已知存在有多处引用character的地方，含有攻击判定的飞行道具（Game_LilyBomb以及子类，Game_LilyProp以及子类，Game_Bullet，Game_LilyPan，以及他们创建的Game_BodyOnHit对象）
Game_Map.prototype.readyForSave = function() {
	const info = {};
	
	this._physicsObject.forEach((ev) => {
		ev.clearPhysicsObject();
	});
	$gameLily.clearPhysicsObject();
	$gamePlayer.clearPhysicsObject();
	
	info.pdo = this._physicsDynamicObject;
	info.pfo = this._physicsFixObject;
	info.po = this._physicsObject;
	
	info.gpdo = this._physicsDynamicGrid;
	info.gpfo = this._physicsFixGrid;
	info.gpo = this._physicsGrid;
	info.terrain = this._terrain;
	info.pathFinder = $gameLily._statemMembers.pathFinder;
	this._terrain = null;
	this._physicsDynamicObject = [];
	this._physicsFixObject = [];
	this._physicsObject = [];
	this._physicsDynamicGrid = null;
	this._physicsFixGrid = null;
	this._physicsGrid = null;
	$gameLily._statemMembers.pathFinder = null;
	return info;
};

Game_Map.prototype.completeSave = function(info) {
	this._physicsDynamicObject = info.pdo;
	this._physicsFixObject = info.pfo;
	this._physicsObject = info.po;
	
	this._physicsDynamicGrid = info.gpdo;
	this._physicsFixGrid = info.gpfo;
	this._physicsGrid = info.gpo;
	this._terrain = info.terrain;
	this._physicsObject.forEach((obj) => {
		this.generateObjectPhysicsInfo(obj, this._physicsGrid);
	});
	this.generateObjectPhysicsInfo($gameLily, this._physicsGrid);
	this.generateObjectPhysicsInfo($gamePlayer, this._physicsGrid);
	$gameLily._statemMembers.pathFinder = info.pathFinder;
};

Game_Map.prototype.clearNullEvent = function() {
	for(let i = 0; i < this._events.length; i++) {
		if(this._events[i] && !this._events[i].event()) {
			this._events[i] = null;
		}
	}
};

Game_Map.prototype.completeLoad = function() {
	const old = $dataMap;
	$dataMap = DataManager.getCachedData(this.mapId());
	const data = $dataMap;
	this.removeDynamicCharacter($gameLily.eventId());
	this._reserveCharacters = this._reserveCharacters.filter((ch) => { return ch.eventId() !== $gameLily.eventId(); });
	this.setupStaticCharacters();
	this.clearReserveCharacter();
	this.setupPhysicsGrid();
	this.makePhysicsObject();
	this.buildTerrain();
	this.clearNullEvent();
	this.events().forEach((ev) => {
		const id = ev.eventId();
		if(data.events[id]) {
			if(data.events[id].meta.load_refresh) {
				ev._erased = false;
				ev.refresh();
			}
		}
	});
	this.allCharacters().forEach((ev) => {
		ev.endBalloon();
	});
	this._physicsObject.forEach((obj) => {
		this.generateObjectPhysicsInfo(obj, this._physicsGrid);
	});
	$dataMap = old;
	$gameLily._statemMembers.pathFinder = new Game_ProperPathFindContext();
	$gameLily.clearCurrentFollowFinding();
	EffectManager.destroyPreverveAnimation();
};

JsonEx._encode = function(value, depth, key = "") {
    // [Note] The handling code for circular references in certain versions of
    //   MV has been removed because it was too complicated and expensive.
    if (depth >= this.maxDepth) {
		const errDataType = value.constructor.name;
		console.log(value);
		debugger;
        throw new Error("Object too deep : " + errDataType + " key : " + key);
    }
    const type = Object.prototype.toString.call(value);
    if (type === "[object Object]" || type === "[object Array]") {
        const constructorName = value.constructor.name;
        if (constructorName !== "Object" && constructorName !== "Array") {
            value["@"] = constructorName;
        }
        for (const key of Object.keys(value)) {
            value[key] = this._encode(value[key], depth + 1, key);
        }
    }
    return value;
};

JsonEx._decode = function(value) {
    const type = Object.prototype.toString.call(value);
    if (type === "[object Object]") {			
		let obj = {};
        if (value["@"]) {
            const constructor = window[value["@"]];
            if (constructor) {
				obj = Object.create(constructor.prototype);		// optimization
            }
        }
        for (const key of Object.keys(value)) {
            obj[key] = this._decode(value[key]);
        }
		return obj;
    } else if(type === "[object Array]") {
		if (value["@"]) {
            const constructor = window[value["@"]];
            if (constructor) {
                Object.setPrototypeOf(value, constructor.prototype);
            }
        }
		for (const key of Object.keys(value)) {
            value[key] = this._decode(value[key]);
        }
	}
    return value;
};

/* var _map_start = Scene_Map.prototype.start;
Scene_Map.prototype.start = function() {
	_map_start.call(this);
	const graphics = new PIXI.Graphics();
	this.addChild(graphics);
	this._testNodeGraphics = graphics;
};
Scene_Map.prototype.printTestPoints = function(nodeArr) {
	const sx = -$gameMap.displayX() * $gameMap.tileWidth();
	const sy = -$gameMap.displayY() * $gameMap.tileHeight();
	this._testNodeGraphics.x = sx;
	this._testNodeGraphics.y = sy;
	this._testNodeGraphics.clear();
	let i = 255;
	for(const node of nodeArr) {
		if(node.grounding) {
			this._testNodeGraphics.beginFill(0x00ff00 + i);
		} else {
			this._testNodeGraphics.beginFill(0xff0000 + i);
		}
		i -= 16;
		this._testNodeGraphics.drawCircle(node.x, node.y, 12);
	}
	this._testNodeGraphics.endFill();
}; */

Game_CharacterBase.prototype.posId = function() {
	return $gameMap.pos2id(this.rx, this.ry);
};

Game_CharacterBase.prototype.checkInProperGridPathGoal = function(tx, ty, smoothX, smoothY) {
	return this.rx >= tx - smoothX && this.rx <= tx + smoothX && this.ry >= ty - smoothY && this.ry <= ty;
};

Game_CharacterBase.prototype.checkCurrentIsGrounding = function(gh) {
	const before = this.hitPreviewAntiVGround(0, 0) || [];
	const after = this.hitPreviewAntiVGround(0, gh) || [];
	// 向下移动位置后，存在一个物体在移动后有碰撞，但移动前没有碰撞，就认为该物体踩地
	for(const obj of after) {
		if(!before.includes(obj)) {
			if(obj.triggerDamage) {
				return 0;
			}
			return 1;
		}
	}
	return -1;
};

Game_CharacterBase.prototype.calculateGridPathJumpParameters = function(ev, ms, jumpStrength) {
	const g = $gameMap.g() + ev.g();
	const mg = $gameMap.mg() + ev.mg();
	const maxYInT = Math.abs(jumpStrength) / g;
	
	const maxY = jumpStrength * maxYInT / 2;
	const halfMaxX = maxYInT * ms;
	
	// 应考虑到跳跃轨迹不是纯抛物线，下落速度达到13后不在有重力加速度
	const toLineMaxT = maxYInT + mg / g;
	const toLineMaxX = toLineMaxT * ms;
	
	/* 	因抛物线过点0,0，所以方程初步简化为y = ax^2 + bx
		抛物线又过点halfMaxX,maxY和点2*halfMaxX,0。带入求解a，b
		点2*halfMaxX,0：带入如下步骤：
		0 = 4 * a * halfMaxX * halfMaxX + 2 * b * halfMaxX
		0 = 4 * a * halfMaxX + 2 * b;
		得b = -2 * a * halfMaxX;
		
		点halfMaxX,maxY代入如下
		maxY = a * halfMaxX * halfMaxX + b * halfMaxX
		
		将b = -2 * a * halfMaxX得结果带入
		maxY = a * halfMaxX * halfMaxX + -2 * a * halfMaxX * halfMaxX;
		化简：
		maxY = -a * halfMaxX * halfMaxX;
		
		a = -maxY / (halfMaxX * halfMaxX);
		b = 2 * maxY / halfMaxX 
		
		不过，有可能需要判定往相反方向走的抛物线，即抛物线过点-halfMaxX,maxY和点-2*halfMaxX,0
		实际上就是halfMaxX = -halfMaxX
		代入式子，参数a依然不变，参数b有可能要加负号
	*/
	const a = -maxY / (halfMaxX * halfMaxX);
	const b = 2 * maxY / halfMaxX;
	/*
		直线过-toLineMaxX, a*toLineMaxX^2 + b*toLineMaxX点或toLineMaxX, a*toLineMaxX^2 + b*toLineMaxX点
		且斜率c是$gameMap.mg()/ms或者-$gameMap.mg()/ms，注解：最大下落速度越大，Y随着X的增加显得越陡
		y = cx + d或y = -cx + d，比较容易判断无论toLineMaxX正负，d都是确定的数
		点toLineMaxX, a*toLineMaxX^2 + b*toLineMaxX带入y = cx + d
		a*toLineMaxX^2 + b*toLineMaxX = c * toLineMaxX + d;
		求解d = a*toLineMaxX^2 + b*toLineMaxX - c * toLineMaxX;
	*/
	const c = $gameMap.mg() / ms;
	const d = a * toLineMaxX * toLineMaxX + b * toLineMaxX - c * toLineMaxX;
	return {a:a,b:b,c:c,d:d,maxJumpHeight:maxY, toLineMaxX:toLineMaxX, halfMaxX:halfMaxX};
};

Game_CharacterBase.prototype.checkCurrentGridPathJumpCanReach = function(nodeStart, parameters) {
	let node = nodeStart;
	let sx = 0;
	let sy = 0;
	// 最近一个踩地节点的坐标作为计算起点
	// PS：从开始节点往前推算，如果出现下降趋势之后出现上升趋势，则直接返回false，AI不会空中二段跳
	let sign = 1;
	let py = 2100000000;
	while(true) {
		if(node === null) {
			sx = this._groundingX;
			sy = this._groundingY;
			break;
		}
		
		if(node.y < py) {
			if(sign === -1) {
				return false;
			}
			sign = 1;				// 往上跳
		} else if(node.y > py) {
			sign = -1;				// 往下坠
		}
		py = node.y;
		
		if(node.grounding) {
			sx = node.x;
			sy = node.y;
			break;
		}
		node = node.parent;
	}
	const tx = this.rx;
	const ty = this.ry;
	const x = tx - sx;
	const y = ty - sy;
	
	const a = parameters.a;
	const b = parameters.b;
	const c = parameters.c;
	const d = parameters.d;
	const toLineMaxX = parameters.toLineMaxX;
	const halfMaxX = parameters.halfMaxX;
	const maxJumpHeight = parameters.maxJumpHeight;
	if(Math.abs(x) > toLineMaxX) {
		if(x > 0) {
			return y > x * c + d;
		} else {
			return y > -x * c + d;
		}
	} else if(Math.abs(x) < halfMaxX) {
		return y > maxJumpHeight;
	} else {
		if(x > 0) {
			return y > a * x * x + b * x;
		} else {
			return y > a * x * x - b * x;
		}
	}
};

Game_Map.prototype.pos2id = function(x, y) {
	return this.width() * this.tileWidth() * y + x;
};

Game_Map.prototype.allObjectStartTestV = function() {
	this._physicsObject.forEach((obj) => {
		obj.startTestV();
	});
};

Game_Map.prototype.allObjectEndTestV = function() {
	this._physicsObject.forEach((obj) => {
		obj.endTestV();
	});
};

Game_CharacterBase.prototype.forecastPosition = function(deltaTime) {
	const vx = this._tvx * (deltaTime + 1);
	const vy = this._tvy * (deltaTime + 1);
	this.testV({x:vx, y:vy});
};

Game_Map.prototype.allObjectForecastPosition = function(deltaTime) {
	for(const obj of this._physicsObject) {
		obj.forecastPosition(deltaTime);
	}
};

Game_Map.prototype.pixelDistance = function(x1, y1, x2, y2) {
	return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};

Game_CharacterBase.prototype.findPathTo = function(x, y, smoothX, smoothY, members, gw, gh, initOffsetX = 0, initOffsetY = 0) {
	const info = members.pathFinder.findProperGridPath(this, x, y, smoothX, smoothY, gw, gh, initOffsetX, initOffsetY);
	if(!info) {
		return 0;
	}
	let node = info.node;
	const arr = [];
	while(node) {
		arr.push(node);
		node = node.parent;
	}
	const seq = arr.reverse();
	const groundingFirst = this.isGrounding();
	if(seq.length <= 1) {
		return 0;
	}
	const followIndex = this.findPathCurrentFollowIndex(seq);
	const followNode = seq[followIndex];
	if(groundingFirst) {
		if(this.py > followNode.y || !followNode.grounding) {
			members.jumpSimulate = false;
			return 3;
		} else {
			return followNode.x === this.px ? 0 : (followNode.x > this.px ? 1: 2);
		}
	} else {
		if(this.py < followNode.y - gh && Math.abs(this.px - followNode.x) < 4 && !members.jumpSimulate) {
			this.vy = 0;
			members.jumpSimulate = true;
		} 
		return followNode.x === this.px ? 0 : (followNode.x > this.px ? 1: 2);
	}
};

Game_Player.prototype.findPathTo = function(x, y, smoothX, smoothY, members, gw, gh, initOffsetX = 0, initOffsetY = 0) {
	const info = members.pathFinder.findProperGridPath(this, x, y, smoothX, smoothY, gw, gh, initOffsetX, initOffsetY);
	if(!info) {
		return 0;
	}
	let node = info.node;
	const arr = [];
	while(node) {
		arr.push(node);
		node = node.parent;
	}
	const seq = arr.reverse();
	const groundingFirst = this.isFlexibleGrounding();
	if(seq.length <= 1) {
		return 0;
	}
	const followIndex = this.findPathCurrentFollowIndex(seq);
	const followNode = seq[followIndex];
	const water = this.isInWater();
	if(groundingFirst) {
		if(this.py > followNode.y || !followNode.grounding) {
			members.jumpSimulate = false;
			return 3;
		} else {
			return followNode.x === this.px ? 0 : (followNode.x > this.px ? 1: 2);
		}
	} else {
		if(this.py < followNode.y - gh && Math.abs(this.px - followNode.x) < 4 && !members.jumpSimulate && this.vy < 0) {
			this.vy = 0;
			if(!water) {
				members.jumpSimulate = true;
			}
		} else if(water && this.py > followNode.y + gh) {
			return 3;
		}
		return followNode.x === this.px ? 0 : (followNode.x > this.px ? 1: 2);
	}
};

Game_CharacterBase.prototype.findPathCurrentFollowIndex = function(seq) {
	const endPos = this.findPathCurrentEndIndex(seq);
	const d = Utils.sign(this.px - seq[endPos].x);
	let followIndex = -1;
	let minDistance = 9999;
	for(let i = 0; i <= endPos; i++) {
		const distance = (this.px - seq[i].x) * d;
		if(distance <= 0) {
			continue;
		}
		if(distance <= minDistance) {
			followIndex = i;
			minDistance = distance;
		}
	}
	if(followIndex === -1) {
		return endPos;
	}
	return followIndex;
};

Game_CharacterBase.prototype.findPathCurrentEndIndex = function(seq) {
	let directionChange = 0;
	for(let i = 0; i < seq.length - 1; i++) {
		if(seq[i].x !== seq[i + 1].x) {
			const newDirectionChange = seq[i].x > seq[i + 1].x ? 1 : -1;
			if(directionChange !== 0 && directionChange !== newDirectionChange) {
				return i;
			} 
			directionChange = newDirectionChange;
		}
	}
	return seq.length - 1;
};

Game_CharacterBase.prototype.followCharacter = function(character, members) {
	const smoothX = 32;
	const x = this.px - character.px > 0 ? character.px + character.hitOffsetR() + smoothX : character.px - character.hitOffsetL() - smoothX;
	const dx = character.px - this.px;
	const dy = character.py - this.py;
	const initOffsetX = dx >= 0 ? ((dx % 48) - 48) : (dx % 48);
	const initOffsetY = dy >= 0 ? (dy % 48) : -(dy % 48);
	const result = this.findPathTo(x, character.py, this.hitOffsetL() + this.hitOffsetR(), this.hitOffsetT() + this.hitOffsetB(), members, 48, 48, initOffsetX, initOffsetY);
	if(!character.isGrounding() && this.isGrounding() && !this.isInWater()) {
		return 0;
	}
	return result;
};

Game_CharacterBase.prototype.processFinderResult = function(resultCode) {
	switch(resultCode) {
		case 1: {
			const moveStrength = this.battleObject().moveStrength;
			const maxMoveSpeed = this.battleObject().maxMoveSpeed;
			this.performMove(moveStrength, maxMoveSpeed, false, true);
			break;
		}
		case 2: {
			const moveStrength = this.battleObject().moveStrength;
			const maxMoveSpeed = this.battleObject().maxMoveSpeed;
			this.performMove(moveStrength, maxMoveSpeed, true, false);
			break;
		}
		case 3: {
			this._vy = this.battleObject().jumpStrength;
			break;
		}
		default: break;
	}
};

Game_CharacterBase.prototype.followPlayer = function(members) {
	return this.followCharacter($gamePlayer, members);
};

// 2D横板地图上的寻路非常耗性能，因此拆到多帧来分散运算量
function Game_ProperPathFindContext() {
	this.initialize(...arguments);
}

Game_ProperPathFindContext.prototype.initialize = function() {
	this.createNodeObjectPool();
	this.clear();
};

Game_ProperPathFindContext.prototype.createNodeObjectPool = function() {
	this._nodeObjectPool = [];
	this._currentNodePoolPosition = 0;
	for(let i = 0; i <= 136; i++) {
		this._nodeObjectPool.push({x:0, y:0, parent:null, g:0, f:0, grounding:false, closedList:[]});
	}
};

Game_ProperPathFindContext.prototype.allocNodeObject = function() {
	if(this._currentNodePoolPosition >= this._nodeObjectPool.length) {
		const result = this._nodeObjectPool[this._currentNodePoolPosition];
		result.closedList.length = 0;
		this._currentNodePoolPosition++;
		return result;
	}
	return {x:0, y:0, parent:null, g:0, f:0, grounding:false, closedList:[]};
};

Game_ProperPathFindContext.prototype.resetNodeObject = function() {
	this._currentNodePoolPosition = 0;
};

Game_ProperPathFindContext.prototype.clear = function() {
	this._nodeBuffer = null;
	this._nodeList = [];
	this._openList = [];
	this.tx = 0;
	this.ty = 0;
	this.smoothX = 0;
	this.smoothY = 0;
	this._gw = 0;
	this._gh = 0;
	this._ms = 0;
	this._jumpStrength = 0;
	this._best = null;
	this._jumpParameters = null;
	this._completed = true;
	this._mapId = 0;
	this._runningFrame = 0;
};

Game_ProperPathFindContext.prototype.createNewContext = function(ev, tx, ty, smoothX, smoothY, gw, gh, initOffsetX, initOffsetY) {
	this.resetNodeObject();
	this._completed = false;
	this._mapId = $gameMap.mapId();
	this._runningFrame = 0;
	this._nodeList.length = 0;
	this._openList.length = 1;
	this._openList[0] = ev.posId();
	this.tx = tx;
	this.ty = ty;
	this.smoothX = smoothX;
	this.smoothY = smoothY;
	this._gw = gw || 48;
	this._gh = gh || 48;
	const sx = ev.rx + initOffsetX;
	const sy = ev.ry + initOffsetY;
	this._ms = ev.battleObject().maxMoveSpeed;
	this._jumpStrength = ev.battleObject().jumpStrength;
	const node = this.allocNodeObject();
	node.x = sx;
	node.y = sy;
	node.parent = null;
	node.g = 0;			// 实际消耗
	node.f = $gameMap.pixelDistance(sx, sy, tx, ty); // 启发函数求出的启发值
	node.grounding = ev.isGrounding();
	//node.closedList = []; // 找到一个踩地的节点之后，原本去不了的地方现在又能去了
	this._best = node;
	this._nodeList.push(this._best);
	this._jumpParameters = ev.calculateGridPathJumpParameters(ev, this._ms, this._jumpStrength);
};

Game_ProperPathFindContext.prototype.currentRunningFrame = function() {
	return this._runningFrame;
};

Game_ProperPathFindContext.prototype.timePerCell = function() {
	return Math.trunc(this._gw / this._ms);
};

Game_ProperPathFindContext.prototype.isCompleted = function() {
	return this._completed;
};

Game_ProperPathFindContext.prototype.findProperGridPath = function(ev, txInput, tyInput, smoothXInput, smoothYInput, gwInput, ghInput, initOffsetX, initOffsetY) {
	if(this._completed || $gameMap.mapId() !== this._mapId) {
		this.createNewContext(ev, txInput, tyInput, smoothXInput, smoothYInput, gwInput, ghInput, initOffsetX, initOffsetY);
	}
	let success = false;
	const openList = this._openList;
	const nodeList = this._nodeList;
	const gw = this._gw;
	const gh = this._gh;
	const ms = this._ms;
	const jumpParameters = this._jumpParameters;
	
	const tx = this.tx;
	const ty = this.ty;
	const smoothX = this.smoothX;
	const smoothY = this.smoothY;
	
	const searchLimit = 1280;
	let frameLimit = 32;
	
	ev.startTestV();
	
	while(nodeList.length > 0) {
		if(frameLimit <= 0) {
			break;
		}
		frameLimit--;
		let bestIndex = 0;
		for (let i = 0; i < nodeList.length; i++) {
            if (nodeList[i].f < nodeList[bestIndex].f) {
                bestIndex = i;
            }
        }
		const current = nodeList[bestIndex];
        const x1 = current.x;
        const y1 = current.y;
        const pos1 = $gameMap.pos2id(x1, y1);
        const g1 = current.g;
		const vy1 = current.vy;
		
		const groundingCurrent = this.findLatestGrounding(current);
		
		ev.testV({x: x1 - ev.px, y: y1 - ev.py});
		if(ev.checkInProperGridPathGoal(tx, ty, smoothX, smoothY)) {
			success = true;
			this._completed = true;
			this._best = current;
			break;
		}
		
		nodeList.splice(bestIndex, 1);
        openList.splice(openList.indexOf(pos1), 1);
		groundingCurrent.closedList.push(pos1);
		
		
		if (g1 >= searchLimit) {
            continue;
        }
		
		const time = this.calculateGridPathNodeTime(current);
		
		const dirSearch = [{x:1,y:1},{x:-1,y:1},{x:1,y:-1},{x:-1,y:-1},{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}];
		
		for (const dir of dirSearch) {
			const x2 = current.x + dir.x * gw;
			const y2 = current.y + dir.y * gh;
			
            let pos2 = $gameMap.pos2id(x2, y2);
			
			if (current.grounding && dir.y === 1) {
				continue;
			}
            if (groundingCurrent.closedList.includes(pos2)) {
                continue;
            }
			
			const t = this.timePerCell();	
			//$gameMap.allObjectForecastPosition(time + t - this._runningFrame);
			ev.testV({x: x2 - ev.px, y: y2 - ev.py});
			
			if (ev.hitPreviewNoVGround() || !ev.checkCurrentGridPathJumpCanReach(current, jumpParameters)) {		// 碰墙 || 浮空高度达到极限
				continue;
            }
			
            const g2 = g1 + $gameMap.pixelDistance(x2, y2, x1, y1);
            const index2 = openList.indexOf(pos2);
			
			

            if (index2 < 0 || g2 < nodeList[index2].g) {
                let neighbor = null;
                if (index2 >= 0) {
                    neighbor = nodeList[index2];
                } else {
					const groundingResult = ev.checkCurrentIsGrounding(gh);
					switch(groundingResult) {
						case 1: case -1: {
							const currentIsGrounding = groundingResult === 1;
							neighbor = this.allocNodeObject();
							neighbor.x = x2;
							neighbor.y = y2;
							neighbor.parent = current;
							neighbor.g = g2;
							neighbor.f = g2 + $gameMap.pixelDistance(x2, y2, tx, ty);
							neighbor.grounding = currentIsGrounding;
							nodeList.push(neighbor);
							openList.push(pos2);
						}
						default: continue;
					}
                }
                
                if (neighbor.f - neighbor.g < this._best.f - this._best.g) {
                    this._best = neighbor;
                }
            }
        }
	}
	
	ev.endTestV();
	if(nodeList.length === 0) {
		this._completed = true;
	}
	if(this._completed) {
		this._nodeBuffer = {node:this._best, success:success};
	}
	
	this._runningFrame++;
	return this.bufferResult();
};

Game_ProperPathFindContext.prototype.bufferResult = function() {
	return this._nodeBuffer;
};

Game_ProperPathFindContext.prototype.findLatestGrounding = function(current) {
	let node = current;
	while(node.parent) {
		if(node.grounding) {
			break;
		}
		node = node.parent;
	}
	return node;
};

Game_ProperPathFindContext.prototype.calculateGridPathNodeTime = function(node) {
	let total = 0;
	const per = this.timePerCell();
	let nodeParent = node.parent;
	while(nodeParent !== null) {
		total += per;
		nodeParent = nodeParent.parent;
	}
	return total;
};

// 计算当前物体从0,0坐标移动到dx, dy坐标所需要的时间
// vy是物体的当前的Y方向上的速度，由于X方向速度可控，Y方向速度不可控，所以这里只需要Y方向上初速度来计算随重力演化的情况
Game_ProperPathFindContext.prototype.calculateGridPathTimeX = function(dx, moveSpeed) {
	return Math.ceil(Math.abs(dx / moveSpeed));
};

Game_ProperPathFindContext.prototype.calculateGridPathTimeY = function(dy, vy) {
	const g = $gameMap.g();
	const mg = $gameMap.mg();
	let current = 0;
	let t = 0;
	while(!(dy > 0 && current > dy || dy < 0 && current < dy) && t < 40 && dy !== 0 && vy !== 0) {
		vy += g;
		vy = Math.min(mg, vy);
		current += vy;
		t++;
	}
	return {t:t, vy:vy};
};

Game_CharacterBase.prototype.revertToLastGroundingPos = function() {
};

Game_Player.prototype.revertToLastGroundingPos = function() {
	this.px = this.rx = this._terrainGroundingX;
	this.py = this.ry = this._terrainGroundingY;
	this.vx = this.vy = 0;
	let y = 0;
	let maxTry = 8;
	this.setImmueVground(true);
	while(this.hitPreview(0, y) && maxTry > 0) {
		y -= ($gameMap.tileHeight() / 2);
		maxTry--;
	}
	y = maxTry === 0 ? 0 : y;
	this.py = this.ry = this.ry + y;
	this.setImmueVground(false);
};

Game_CharacterBase.prototype.isInWater = function() {
	return $gameMap.isInWater();
};

Game_Map.prototype.initInWater = function() {
	this._inWater = !!$dataMap.meta.water;
};

Game_Map.prototype.isInWater = function() {
	return this._inWater;
};

Game_CharacterBase.prototype.smoothCorner = function(grid, currentHit) {
	// 只对玩家有效
};

// 类似celeste搓墙角平滑处理
// 只会把玩家往上推，左右推，暂时不处理往下推的情况
// 先处理往上推的情况，这种情况下首先需要X轴方向具有速度
// 然后再处理左右推
// 但游戏里的斜坡是一个特殊的东西，玩家踩在斜坡上的时候不适用该处理
Game_Player.prototype.smoothCorner = function(grid, currentHit) {
	if(this._groundGradientObj || !currentHit.every((obj) => {return obj.constructor === Game_Terrain;})) {		// 斜坡和与怪物or动态物体之间的碰撞不适用于该系统
		return;
	}
	const px = this.px;
	const py = this.py;
	const vx = this._tvx;
	const vy = this._tvy;
	this.testV({x:0, y:vy});
	if(!$gameMap.hitTest(this, grid, true)) {		// 如果去掉X方向上的速度仍然有碰撞说明该往左右抬
		if(vy > -4 && vx !== 0) {
			const threshold = this.smoothCornerThreshold();
			this.py -= threshold;
			this.testV({x:vx, y:vy});
			let d = 0;
			while(!$gameMap.hitTest(this, grid, true) && d < threshold) {
				d++;
				this.py++;
				this.makeMomentum();
			}
			if(d === 0) {			// 往上抬没成功或者不需要往上抬
				this.py = py;
			} else {
				this.py--;
			}
		}
	} else if(vy < 0) {		// 试着往左右抬
		const threshold = this.smoothCornerThreshold();
		this.px -= threshold;
		this.testV({x:vx, y:vy});
		let d = 0;
		while(!$gameMap.hitTest(this, grid, true) && d < threshold) {
			d++;
			this.px++;
			this.makeMomentum();
		}
		if(d === 0) {		// 往左抬失败，尝试往右抬
			this.px = px + threshold;
			this.makeMomentum();
			d = 0;
			while(!$gameMap.hitTest(this, grid, true) && d < threshold) {
				d++;
				this.px--;
				this.makeMomentum();
			}
			if(d === 0) {	// 往右抬也失败
				this.px = px;
			} else {
				this.px++;
			}
		} else {
			this.px--;
		}
	}
};

Game_Player.prototype.smoothCornerThreshold = function() {
	return 24;
};

Game_CharacterBase.prototype.smoothVGround = function(grid) {
	return false;
};

Game_Player.prototype.smoothVGround = function(grid) {
	const py = this.py;
	const vy = this._tvy;
	if(Math.abs(vy) < 2) {
		this.setAntiVground(true);
		const hit1 = $gameMap.hitTest(this, grid, true);
		if(hit1) {				// 一点一点往上抬，直到hit中有一个对象消失
			this.py -= this.smoothCornerThreshold();
			this.makeMomentum();
			const hit2 = $gameMap.hitTest(this, grid, true);
			this.setAntiVground(false);
			if(!this.isVGroundTerrainAllInArr(hit1, hit2)) {
				this._tvy += this.smoothCornerThreshold();
				return true;
			} else {
				this.py = py;
				return false;
			}
		}
		this.setAntiVground(false);
	}
	return false;
};

Game_Player.prototype.isVGroundTerrainAllInArr = function(src, des) {
	if(!des) {
		return false;
	} else {
		return src.every((obj) => { return des.includes(obj); });
	}
};

const emptyPhysicsGrid = new PhysicsGrid();

Game_Map.prototype.centerX = function() {
	return this.width() * this.tileWidth() / 2;
};

Game_Map.prototype.centerY = function() {
	return this.height() * this.tileHeight() / 2;
};

function Game_SightMove() {
	this.initialize(...arguments);
}

Game_SightMove.prototype.initialize = function() {
	this.clear();
};

Game_SightMove.prototype.clear = function() {
	this._state = 0;
	this._current = 0;
	this._start = 0;
	this._timeline = 0;
};

Game_SightMove.prototype.update = function(display, min, max, n, p) {
	const maxTime = this.maxTime();
	if(Input.isPressed(n)) {
		this.checkNewState(-1);
	} else if(Input.isPressed(p)) {
		this.checkNewState(1);
	} else {
		this.checkNewState(0);
	}
	if(this._timeline < maxTime) {
		this._timeline++;
		this.calc(maxTime);
	}
	if(display < min) {
		return this._current - display + min;
	} else if(display > max) {
		return this._current - display + max;
	} else {
		return this._current;
	}
};

Game_SightMove.prototype.checkNewState = function(state) {
	if(this._state !== state) {
		this._state = state;
		this._start = this._current;
		this._timeline = 0;
	}
};

Game_SightMove.prototype.calc = function(maxTime) {
	this._current = AnimationController.easeOutCubic(this._timeline / maxTime) * (this.maxDistance() * this._state - this._start) + this._start;
};

Game_SightMove.prototype.maxTime = function() {
	return 60;
};

Game_SightMove.prototype.maxDistance = function() {
	return 4;
};




NYA.STATEM = {};

Game_CharacterBase.prototype.pstate = function() {
	return this._pBufferState;
};

Game_CharacterBase.prototype.setPstate = function(state) {
	this._pBufferState = state;
};

Game_CharacterBase.prototype.flushPState = function() {
	var realState = this._pRealState;
	var bufferState = this.pstate();
	if(realState !== bufferState) {
		this.doPStateChange(realState, bufferState);
	}
	this.doPState(bufferState);
	this._pRealState = bufferState;
};

Game_CharacterBase.prototype.doPState = function(state) {
	const dir = this.direction();
	if(dir === 6) {
		this.setMirrorLR(false);
	} else if(dir === 4) {
		this.setMirrorLR(true);
	}
};

Game_Player.prototype.doPState = function(state) {
	Game_CharacterBase.prototype.doPState.call(this, state);
	this.updateFootStepSe(state);
};

Game_CharacterBase.prototype.doPStateChange = function(oldState, newState) {
	switch(newState) {
		case 10: {
			const scale = this.standardScale();
			this.performDeath(scale);
			break;
		}
	}
};

Game_CharacterBase.prototype.isStagger = function() {
	return this._staggerTime > 0 || this.isDeath();
};

Game_CharacterBase.prototype.isDeath = function() {
	if(this.battleObject()) {
		return this.battleObject().hp <= 0;
	}
	return false;
};

Game_CharacterBase.prototype.battleObject = function() {
	return null;
};

Game_Player.prototype.isOutControl = function() {
	return Game_CharacterBase.prototype.isOutControl.call(this) || $gameMap.isEventCurrentRunning();
};

Game_CharacterBase.prototype.isOutControl = function() {
	return this.isStagger() || this._invincibleLock;
};

Game_CharacterBase.prototype.isAttackOutControl = function() {
	return this.isOutControl() || $gameMap.isEventCurrentRunning();
};

Game_Player.prototype.playerControl = function() {
	const state = this.pstate();
	const actor = this.actor();
	this.controlWeaponChange(actor);
	if(this.isOutControl()) {
		return;
	}
	const shouldPreventJump = this.controlAttack(actor, state);  // 部分需要按跳触发的技能在触发成功后，阻止跳跃键的默认作用（跳跃）
	if(!shouldPreventJump && this.canAttackWithJump()) {
		this.controlJump(actor, state);
		this.controlDoubleJump(actor, state);
	}
	this.controlBreakJump(actor, state);
	this.controlGetDown(actor, state);
	this.controlFastMove();
	this.controlMove(actor, state);
};

Game_Player.prototype.jumpFlexibleFrame = function() {
	return 6;
};

Game_Player.prototype.controlJump = function(actor, state) {
	const jump = actor.jumpStrength();
	const dy = this.standstilly();
	if(this.isFlexibleGrounding())
	{
		if(this.isTriggeredJump()) {
			const max = jump + dy;
			if(this._vy > max)
			{
				this.vy = max;
			}
			AudioManager.playNormalSe("mtv_jump1");
			this.frameJump = true;
			this._nextFrameImmueElasticCollision = true;
			this._impact = null;
			if(this._jumpGroundingLR) {
				this.setNoControlTimeEx2(7);
				this.vx = this.currentMaxMoveSpeed(actor) * this._jumpGroundingD;
				this.setDirection(this._jumpGroundingD > 0 ? 6 : 4);
			}
		}
		else if(this.isGrounding()) {
			this.frameJump = false;
			if(this._groundHitObj.upElasticWithJumpStrength() === 0) {
				this.setFastMoveEffect(false);
			}
		} 
	}
	return true;
};

Game_Player.prototype.controlBreakJump = function(actor) {
	if(!this.isRepeatJump() && this.frameJump && this._vy < -0.5) {
		const mg = $gameMap.mg() + this.mg();
		if(mg > 0) {
			this.vy = this._vy / 2;
		}
	}
	return true;
};

Game_Player.prototype.controlFastMove = function() {
	if(this._fastMoveTriggerTime > 0 && this.isTriggeredJump()) {
		this.setFastMoveEffect(true);
	}
};

Game_Player.prototype.updateFastMoveTriggerTime = function() {
	if(this._fastMoveTriggerTime > 0) {
		this._fastMoveTriggerTime--;
	}
};

Game_CharacterBase.prototype.applyMoveDirection = function(isLeft, isRight) {
	if(isLeft) {
		this.setDirection(4);
	}
	if(isRight) {
		this.setDirection(6);
	}
};

// 是否锁定朝向，来自技能
Game_CharacterBase.prototype.attackDirectionLock = function() {
	if(!this.isBodyAttacking()) {
		return false;
	}
	const info = AttackFrame.info(this._bodyAttacking);
	return !info.noDirectionLock;
};

// noDirectionSet决定非攻击时是否可以变更角色朝向
Game_CharacterBase.prototype.performMove = function(moveStrength, maxMoveSpeed, isLeft, isRight, noDirectionSet = false) {
	if(isLeft && isRight) {
		return true;
	}
	const attackDirectionLock = this.attackDirectionLock();
	if(this.noControlTime() || !this.canAttackWithMove()) {
		if(!attackDirectionLock && !noDirectionSet && !this._noControlTimeEx2) {
			this.applyMoveDirection(isLeft, isRight);
		}
		return true;
	}
	this._isTriggeredLeft = isLeft;
	this._isTriggeredRight = isRight;
	const dx = this.standstillx();
	if(isLeft)
	{
		const dragFx = this.attackDragFx();
		this.impux(-moveStrength);
		const min = -maxMoveSpeed + dx + dragFx;
		if(this._vx < min)
		{
			this.vx = min;
		}
		if(!attackDirectionLock && !noDirectionSet) {
			this.setDirection(4);
		}
		this.setMoveSuspendFriction(true);
		return true;
	}
	if(isRight)
	{
		const dragFx = this.attackDragFx();
		this.impux(moveStrength);
		const max = maxMoveSpeed + dx + dragFx;
		if(this._vx > max)
		{
			this.vx = max;
		}
		if(!attackDirectionLock && !noDirectionSet) {
			this.setDirection(6);
		}
		this.setMoveSuspendFriction(true);
		return true;
	}
	return true;
};

Game_Player.prototype.controlMove = function(actor) {
	if(this.isBodyAttacking()) {
		const name = this._bodyAttacking;
		const info = AttackFrame.info(name);
		if(info.softBreak === 1 || info.softBreak === 3) {			// 处理按上/下/左/右/ 跳/ 攻击直接打断该技能的情况，但之前按住的键不会打断该技能
			return false;
		}
	}
	const moveStrength = actor.moveStrength();
	const maxMoveSpeed = this.currentMaxMoveSpeed(actor);
	const left = this.isTriggerLeft();
	const right = this.isTriggerRight();
	return this.performMove(moveStrength, maxMoveSpeed, !!left, !!right);
};

Game_Player.prototype.isTriggerLeft = function() {
	return Input.isPressed('left') || TouchInput.isScreenButtonPressed('left');
};

Game_Player.prototype.isTriggerRight = function() {
	return Input.isPressed('right') || TouchInput.isScreenButtonPressed('right');
};

Game_CharacterBase.prototype.syncDirectionFromInput = function() {
};

Game_Player.prototype.syncDirectionFromInput = function() {
	const left = this.isTriggerLeft();
	const right = this.isTriggerRight();
	if(left && !right) {
		this.setDirection(4);
	} else if(!left && right) {
		this.setDirection(6);
	}
};

Game_Player.prototype.currentMaxMoveSpeed = function(actor) {
	return actor.maxMoveSpeed() + (this.isFastMoveEffect() ? this.battleObject().dashJumpAddSpeed : 0) + (actor.isOrnamentEquip(12) ? 1 : 0);
};

Game_Player.prototype.controlDoubleJump = function(actor) {
	if(actor.doubleJump()) {
		if(this.isFlexibleGrounding()) {
			this.useDoubleJump = false;
		}
		else if(!this.useDoubleJump) {
			if(this.isTriggeredJump()) {
				this.vy = actor.doubleJumpStrength();
				this.useDoubleJump = true;
				this.frameJump = true;
				this._nextFrameImmueElasticCollision = true;
				AudioManager.playNormalSe("mtv_jump2");
			}
		}
	}
	return true;
};

Game_Player.prototype.controlAttack = function(actor, state) {
	const item = Input.isStrictTriggered('item') || TouchInput.isScreenButtonPressed('consumable');
	item && this.actor().findConsumableUsing("use_consumable");
	if(actor.isConsumableUsing()) {
		this.requestBodyAttack("use_consumable");
	}
	const up = Input.isPressed('up') || TouchInput.isScreenButtonPressed('up');
	const down = Input.isPressed('down') || TouchInput.isScreenButtonPressed('down');
	const left = Input.isPressed('left') || TouchInput.isScreenButtonPressed('left');
	const right = Input.isPressed('right') || TouchInput.isScreenButtonPressed('right');
	const fish = Input.isStrictTriggered('cancel') || TouchInput.isScreenButtonTriggered("attack");
	const jump = Input.isStrictTriggered('ok') || TouchInput.isScreenButtonTriggered("jump");
	const bullet = Input.isStrictTriggered('bullet') || TouchInput.isScreenButtonTriggered("bullet");
	const zxc = Input.isStrictTriggered('zxc') || TouchInput.isScreenButtonTriggered("zxc");
	const subattack = Input.isStrictTriggered('subattack') || TouchInput.isScreenButtonTriggered("subattack");
	if(zxc) {
		const zxcName = actor._weapons.currentZXCName();
		if(this.requestBodyAttack(zxcName)) {
			return false;
		}
	}
	const dashName = "dash";
	const reverseDashName = "reverse_dash";
	const downDashName = "toru_down_dash_attack";
	//const attackDashName = "toru_dash_attack_p";
	//const attackReverseDashName = "toru_reverse_dash_attack_p";
	const dashThrough = actor.isOrnamentEquip(15);
	const throughExtensions = dashThrough ? ((ext) => { 
		ext.changePhysicsFlag = 1;
		ext.staticAnimationId = 41;
	}) : undefined;
	if(up && fish && this.requestBodyAttack("up_normal")) {
		return false;
	} 
	if(down && fish && this.requestBodyAttack("down_normal")) {
		return false;
	}
	const isDashAttackUnlock = actor.isStoneUnlock(0);
	if(fish) {
		if(isDashAttackUnlock && this._bodyAttacking === dashName && this.requestBodyAttack("toru_dash_attack")) {
			return false;
		}
		if(isDashAttackUnlock && this._bodyAttacking === reverseDashName && this.requestBodyAttack("toru_reverse_dash_attack")) {
			return false;
		}
		if(this._isGetDown && actor.isStoneUnlock(4) && this.requestBodyAttack("toru_get_down_normal")) {
			return false;
		}
		if(this.requestBodyAttack("normal")) {
			return false;
		}
	}
	if(up && subattack && actor.isStoneUnlock(2) && this.requestBodyAttack("toru_dash_down_attack")) {
		return false;
	}
	if(down && subattack && !this.isGrounding() && actor.isStoneUnlock(1) && (this._bodyAttacking === downDashName || this.requestBodyAttack(downDashName, throughExtensions))) {
		this.setFastMoveEffect(true);
		return false;
	}
	const isBackDash = (left && right);
	const isFrontDash = !isBackDash;
	
	if(bullet && isBackDash) {
		this.requestBodyAttack(reverseDashName, throughExtensions);
		return false;
	}
	if(bullet && isFrontDash) {
		this.requestBodyAttack(dashName, throughExtensions);
		return false;
	}
	// 手感上的特殊处理，反向冲刺容差时间
	const isDashing = this._bodyAttacking === dashName || this._bodyAttacking === reverseDashName;
	if(isDashing) {
		this.smoothDashDirection(dashName, reverseDashName, left, right);
	}
	return false;
};

Game_Player.prototype.smoothDashDirection = function(dashName, reverseDashName, left, right) {
	if(((this.direction() === 4 ^ this._bodyAttacking === reverseDashName && right) || (this.direction() === 4 ^ this._bodyAttacking === dashName && left)) && (!right || !left) && this.attackLaunchFrame(AttackFrame.info(this._bodyAttacking)) <= 8) {
		if(left && right) {
			return;
		}
		if(this.direction() === 4) {
			this.setDirection(6);
			this._bodyAttackFirstDirection = 6;
		} else if(this.direction() === 6) {
			this.setDirection(4);
			this._bodyAttackFirstDirection = 4;
		}
		this._vx = -this._vx;
	}
};

Game_Player.prototype.jumpingFrame = function() {
	return this._groundingFlexibleFrame;
};

Game_Player.prototype.updateJumpingFrame = function() {
	if(this.isGrounding()) {
		this._groundingFlexibleFrame = 0;
		this._jumpGroundingLR = false;
	} else if(this.py >= 0 && this._impact && this._impactDirection === 0 && this._impact.terrain && this._impact.type === 0 && !this._impact.triggerDamage && !this.isBodyAttacking() && this.actor().isStoneUnlock(3)) {
		this._groundingFlexibleFrame = 0;
		this._jumpGroundingLR = true;
		this._airAttack.length = 0;
		this._jumpGroundingD = -Utils.sign(this._impactvx);
		const mg = $gameMap.mg() + this.mg();
		if(this.vy > mg) {
			this.vy = mg;
		}
		if(this._jumpGroundAnimationInterval === 0) {
			this.requestAnimation(42, {staticPosition:true, x:this.physicsCenterX(), y:this.py + this.hitOffsetB()});
			this._jumpGroundAnimationInterval++;
		} else if(this._jumpGroundAnimationInterval >= 4) {
			this._jumpGroundAnimationInterval = 0;
		} else {
			this._jumpGroundAnimationInterval++;
		}
	} else {
		this._groundingFlexibleFrame++;
	}
};

Game_Player.prototype.isFlexibleGrounding = function() {
	return this.jumpingFrame() < this.jumpFlexibleFrame();
};

Game_Player.prototype.mg = function() {
	if(this.isWallDown()) {
		return -$gameMap.mg() / 2;
	} else {
		return Game_CharacterBase.prototype.mg.call(this);
	}
};

Game_Player.prototype.isWallDown = function() {
	return this._jumpGroundingLR && this._groundingFlexibleFrame <= 1;
};

NYA.STATEM.Game_Player_initMembers = Game_Player.prototype.initMembers;
Game_Player.prototype.initMembers = function() {
	NYA.STATEM.Game_Player_initMembers.apply(this, arguments);
	this._groundingFlexibleFrame = 0;			// 用来做跳跃容差，离地jumpFlexibleFrame()帧内仍可做跳跃
	this.frameJump = false;
	this.useDoubleJump = false;
	this._shieldEffectCounter = 0;				// 60秒生成防御力场的护石
	this._jumpGroundingLR = false;				// 是否是爬墙跳状态
	this._jumpGroundingD = 0;					// 爬墙跳的方向（-1往左跳，1往右跳）
	this._bossScoreUseConsumables = false;		// boss评分用，击败boss的时间段内是否使用过消耗品
	this._bossScoreUseOrnaments = false;		// boss评分用，击败boss的时间段内是否使用过护符
	this._bossScoreUseOrnaments = false;		// boss评分用，击败boss的时间段内是否受伤害
	this._bossScoreRecording = false;			// 当前boss评分记录是否开始
	this._jumpGroundAnimationInterval = 0;		// 扒墙特效动画播放间隔
	this._weaponChangeRequest = false;			// 指示贴图显示当前武器切换效果
	this._noGroundingInteract = false;			// 空中是否可触发interact操作，因为天空图一直不能落地所以天空图空中也会显示interact
	this._fastMoveTriggerTime = 0;				// 按跳跃可触发加速模式的剩余时间
};

NYA.STATEM.Game_CharacterBase_initMembers = Game_CharacterBase.prototype.initMembers;
Game_CharacterBase.prototype.initMembers = function() {
	NYA.STATEM.Game_CharacterBase_initMembers.apply(this, arguments);
	this._pRealState = 0;
	this._pBufferState = -1;
	this._bodyAttacking = "";
	this._nextAttackName = "";
	this._nextAttackRootName = "";
	this._prepareNextAttackInput = false;
	this._attackingCounter = 0;    // 技能本体计数
	this._attackcd = [];			// 技能CD计数
	this._nextAttackDelay = 0;		// 连击发动容错时间计数
	this._staggerTime = 0;			// 硬直时间
	this._bodyHit = [];				// 技能判定
	this._bulletCreate = [];		// 技能产生飞行道具
	this._staggerFx = 0;			// 硬直后受到的力
	this._staggerFy = 0;			// 硬直后受到的力
	this._deathAnimationCompleted = false;
	this._deathFadeoutCounter = 0;
	this._invincibleTime = 0;		// 无敌状态时间
	this._invincibleLock = false;	// 锁定无敌状态（一般为剧情或者演出需要）
	this._beHitNum = 0;
	this._airAttack = [];			// 用来记录一些在可以在空中免消耗释放一次，落地恢复次数的技能
	this.searchSmoothFloorOutside = true;// RM里事件位置都是格子坐标，为了让事件一出生就站在地面上，而不是从空中落地，采用的平滑模式，false则为从墙体里向上下搜索可用位置，true则是从空中向上下搜索着陆点
	this._skillInvincibleLock = false; // 技能锁定无敌状态（来自于无敌技能）
	this.triggerDamage = null;
	this.terrainDamageCD = 0;		// 地形伤害CD 用来对付一些受击后没有无敌的物体
	this._squashTime = 0;			// 压扁状态
	this._defenceShieldEffect = false; // 防御力场
	this._noControlTime = 0;			// 移动不受控制的时间，用来表现击退力
	this._tempAirFriction = 0;			// 用来做弹簧效果，暂时减少玩家的摩擦力
	this._tempFriction = 0;
	this._tempFrictionTime = 0;
	this._attackCdReduce = 0;			// 下一次的攻击CD减少
	this._isNoHpSmallBar = false;		// 没有小血条显示
	this._moveSuspendFriction = false;  // 本帧暂时停止摩擦力计算，用于移动时屏蔽摩擦力
	this._changeAttackInfo = null;		// 下一帧立刻应用该技能并且指定额外效果
	this._skillRequestPhysicsFlag1 = false;// 技能请求当前暂时无视战斗单位碰撞
	this._requestPhysicsFlag1 = false;		// 其他逻辑请求当前暂时无视战斗单位碰撞
	this._originalPhysicsFlag = 0;			// 无视战斗对象碰撞之前的physicsFlag
	this._temporaryChangePhysicsFlag1 = false; // 无视战斗对象碰撞关闭后，如果当前正卡在某战斗单位里面，这个值会持续为true，直到不卡位置了才会真正恢复
	this._isTriggeredLeft = false;		// 决定是否播行走动画的一个标志，代表对象的行走意愿
	this._isTriggeredRight = false;		// 决定是否播行走动画的一个标志，代表对象的行走意愿
	this._noControlTimeEx = 0			// 移动不受控制，非计时，采用另一种机制取消，见setNoControlTimeEx函数
	this._shoundUseSpeedCompareForMovingState = false;		// 采用对象是否在移动来判断播不播行走动画，否则采用this._isTriggeredLeft和this._isTriggeredRight来判断
	this._skipFloorSearch = false;						// 跳过着陆搜索floorSearch
	this._specProgress = 0;								// boss头顶的机制条
	this._specProgressVisible = false;					// boss头顶的机制条-可见性
	this._bodyAttackFirstDirection = 0;					// 发动技能时的朝向，某些技能逻辑用到
	this._noControlTimeEx2 = 0							// 移动不受控制，非计时，采用另一种机制取消，见setNoControlTimeEx函数
	this._linkId = 0;									// 当这个对象不是一个事件时，这个ID能够帮助$gameMap.event来找到自身
	this.elasticSe = 0;									// 碰撞触发音效
	this.elasticSeCd = 0;								// 碰撞音效触发CD
	this._isFixStagger = false;							// 当前硬直是否是定身型硬直，定身型硬直会暂时屏蔽重力，锁定当前速度为0，击退力保留至硬直结束后发动
	this._delayRevertToLastGroundingPosTime = 0;	    // 某些刺碰到后会延迟一段时间让玩家传送到安全地带 
	this._bodyAttackExtensions = new Game_BodyAttackExtensions();	// 技能发动参数
	this._latestBodyAttackingLaunchFrame = 0;				// 上一次技能的发动计时器，某些技能需要用到，例如根据上一个技能的发动计时来决定伤害的技能
	this._bodyAttackParameterA = 0;
	this._bodyAttackParameterB = 0;						// 技能发动过程中的参数，意义不确定
	this._latestHitObjectsConstructor = [];						// 当前帧攻击此对象的prototype.constructor.name数组
};

Game_CharacterBase.prototype.canAttackWithJump = function() {
	if(!this.isBodyAttacking()) {
		return true;
	}
	const info = AttackFrame.info(this._bodyAttacking);
	return !info.heavyLock && (info.noJumpTime === 0 || this.attackLaunchFrame(info) >= info.noJumpTime);
};

Game_Player.prototype.isInLockVXVYAction = function() {
};

Game_CharacterBase.prototype.canAttackWithMove = function() {
	if(!this.isBodyAttacking()) {
		return true;
	}
	const info = AttackFrame.info(this._bodyAttacking);
	return (!!info.moveimage || this.pstate() === 9) && !info.heavyLock;
};

Game_CharacterBase.prototype.isInvincible = function() {
	return this.isVisibleInvincible() || this._invincibleLock || this._skillInvincibleLock || (this.battleObject() && this.battleObject().getBuffVal("unvisible_invincible"));
};

Game_CharacterBase.prototype.isVisibleInvincible = function() {
	if(this.battleObject() && this.battleObject().getBuffVal("invincible")) {
		return true;
	}
	return this._invincibleTime > 0;
};

Game_CharacterBase.prototype.makeInvincible = function(time) {
	this._invincibleTime = time;
};

Game_CharacterBase.prototype.lockInvincible = function() {
	this._invincibleLock = true;
};

Game_CharacterBase.prototype.unlockInvincible = function() {
	this._invincibleLock = false;
};

Game_CharacterBase.prototype.lockSkillInvincible = function() {
	this._skillInvincibleLock = true;
};

Game_CharacterBase.prototype.unlockSkillInvincible = function() {
	this._skillInvincibleLock = false;
};

Game_CharacterBase.prototype.updateInvincible = function() {
	if(this.isInvincible()) {
		this._invincibleTime--;
	}
};

Game_CharacterBase.prototype.setDeathAnimationComplete = function() {
	this._deathAnimationCompleted = true;
};

Game_CharacterBase.prototype.isDeathAnimationComplete = function() {
	return this._deathAnimationCompleted;
};

Game_CharacterBase.prototype.initToDeath = function() {
	this.setDeathAnimationComplete();
	this.setPstate(10);
	this._deathFadeoutCounter = this.deathFadeoutDuration() + 1;
	this.setOpacity(0);
	if(this.battleObject()) {
		this.battleObject().hp = 0;
	}
};

Game_CharacterBase.prototype.performDeath = function(scale) {
	this.requestDeathAnimation(scale * 0.7);
	this.setDeathAnimationComplete();
};

Game_Player.prototype.performDeath = function(scale) {
	AudioManager.fadeOutBgm((this.deathFadeoutDuration() + 40)/60);
};

Game_Event.prototype.performDeath = function(scale) {
	Game_CharacterBase.prototype.performDeath.apply(this, arguments);
	this.performDeathCoin(scale);
	this.performDeathDropRecover();
	this.triggerDeathTask();
};

Game_Event.prototype.performDeathDropRecover = function() {
	if(this.battleObject() && this.battleObject().mapRecoverCreate) {
		const recover = new Game_MapRecover();
		recover.px = this.physicsCenterX();
		recover.py = this.physicsCenterY();
		$gameMap.createCharacter(recover);
	}
};

Game_CharacterBase.prototype.hitFragmentCreate = function(obj, fx, fy) {
	if(obj.hitCreateFragment) {
		obj.hitCreateFragment.forEach((fragment) => {
			const duplicate = fragment.duplicate || 1;
			for(let i = 0; i < duplicate; i++) {
				const character = new Game_AttackFragment(fragment.name);
				if(fx !== 0) {
					character.vx = Utils.randomFloat(fragment.minX / 2 + fx, fragment.maxX / 2 + fx);
				} else {
					character.vx = Utils.randomFloat(fragment.minX, fragment.maxX);
				}
				if(fy < 0) {
					character.vy = Utils.randomFloat(fragment.minY + fy / 2, fragment.maxY + fy / 2);
				} else {
					character.vy = Utils.randomFloat(fragment.minY, fragment.maxY);
				}
				character.rx = character.px = Utils.randomInt(this.px - this.hitOffsetL(), this.px + this.hitOffsetR());
				character.ry = character.py = Utils.randomInt(this.py - this.hitOffsetT(), this.py + this.hitOffsetB());
				$gameMap.createCharacter(character);
			}
		});
	}
};

Game_CharacterBase.prototype.physicsCenterX = function() {
	return (this.px + (this.hitOffsetR() - this.hitOffsetL()) / 2) | 0;
};

Game_CharacterBase.prototype.physicsCenterY = function() {
	return (this.py + (this.hitOffsetB() - this.hitOffsetT()) / 2) | 0;
};

Game_Event.prototype.performDeathCoin = function(scale) {
	if(this.battleObject()) {
		const coin = this.battleObject().coin;
		if(coin) {
			const centerX = this.physicsCenterX();
			const centerY = this.physicsCenterY();
			const dir = this.vx === 0 ? 0 : (this.vx > 0 ? 1 : -1);
			const addDropOrnaments = $gamePlayer.actor().isOrnamentEquip(11);
			coin.forEach((item) => {
				const count = (item.num === 1 && addDropOrnaments) ? (item.count + 1) : item.count;
				for(let i = 0; i < count; i++) {
					$gameMap.dropCoin(centerX, centerY, item.num, scale, dir);
				}
			});
		}
	}
};

Game_Event.prototype.triggerDeathTask = function() {
	if(this.battleObject()) {
		const templateId = this.battleObject().templateId();
		$gamePlayer.actor().triggerTask("event_death", templateId);
	}
};

Game_CharacterBase.prototype.updateDeathAnimation = function() {
	if(this.isDeath()) {
		if(this._deathFadeoutCounter <= this.deathFadeoutDuration()) {
			this.setOpacity(255 * (1 - this._deathFadeoutCounter / this.deathFadeoutDuration()));
			this._deathFadeoutCounter++;
		}
	}
};

Game_Event.prototype.deathFadeoutDuration = function() {
	if(this.battleObject() && this.battleObject().deathFadeoutDuration) {
		return this.battleObject().deathFadeoutDuration;
	}
	return Game_CharacterBase.prototype.deathFadeoutDuration.call(this);
};

Game_Player.prototype.updateDeathAnimation = function() {
	if(this.isDeath()) {
		if(this._deathFadeoutCounter === this.deathFadeoutDuration()) {
			SceneManager.goto(Scene_Gameover);
			this._deathFadeoutCounter++;
		} else if(this._deathFadeoutCounter < this.deathFadeoutDuration()) {
			this._deathFadeoutCounter++;
		}
	}
};

Game_CharacterBase.prototype.deathFadeoutDuration = function() {
	return 23;
};

Game_CharacterBase.prototype.isAttackCD = function(name) {
	return this._attackcd.some((item) => {
		return item.name === name;
	});
};

Game_CharacterBase.prototype.reduceAttackCD = function(time) {
	this._attackCdReduce = time;
};

Game_CharacterBase.prototype.updateAttack = function() {
	this.updateAttackCD();
	this.updateAttackGroundingRecover();
};

Game_Player.prototype.updateAttack = function() {
	Game_CharacterBase.prototype.updateAttack.call(this);
	this.updateNextAttack();
};

Game_Player.prototype.updateNextAttack = function() {
	if(this._nextAttackDelay > 0 && !this.isBodyAttacking()) {
		this._nextAttackDelay--;
		if(this._nextAttackDelay === 0) {
			this.clearNextAttack();
		}
	}
}

// 对目标产生硬直
Game_CharacterBase.prototype.requestStagger = function(time, fx = 0, fy = 0, fix = true) {
	const realTime = this.staggerRealTime(time);
	if(realTime > 0) {
		this._staggerTime = realTime;
		this._isFixStagger = fix;
		if(fix) {
			this._staggerFx = fx;
			this._staggerFy = fy;
		} else {
			if(fy < 0 && this.vy > 0) {
				this.vy = 0;
			}
			this.impu(fx, fy);
		}
	}
};

Game_Player.prototype.requestStagger = function(time, fx = 0, fy = 0, fix = true) {
	Game_CharacterBase.prototype.requestStagger.apply(this, arguments);
	if(!fix) {
		this.frameJump = false;
	}
};

Game_CharacterBase.prototype.staggerRealTime = function(time) {
	const antiVal = this.battleObject().getBuffVal("anti_stagger");
	return Math.round(time * (1 - antiVal));
};

Game_CharacterBase.prototype.updateStagger = function() {
	if(this._staggerTime) {
		this._staggerTime--;
		if(this._isFixStagger) {
			if(this._staggerTime === 0) {
				this.impu(this._staggerFx, this._staggerFy);
			} else {
				this.vx = this.vy = 0;
			}
		} 
	}
};

Game_CharacterBase.prototype.clearStagger = function() {
	if(this._staggerTime) {
		this.resumeGravity();
		this._staggerTime = 0;
	}
};

// 连招处理
Game_CharacterBase.prototype.replaceContinueAttack = function(name) {
	if(this._nextAttackDelay > 0 && this._nextAttackRootName === name) {
		return this._nextAttackName;
	}
	return name;
};

// 没有体术动作，瞬间产生弹幕的攻击，因此不需要打断当前技能，也不需要检查各种施放状态
Game_CharacterBase.prototype.isBulletAttack = function(info) {
	return !info.image && !info.moveimage && !info.jumpimage;
};

// 体术攻击
Game_CharacterBase.prototype.requestBodyAttack = function(rootname, extensionsIniter, shouldSyncDirection = true) {
	const name = this.replaceContinueAttack(rootname);
	const info = AttackFrame.info(name);
	const isBulletAttack = this.isBulletAttack(info);
	if(!this.isAttackCD(rootname) && this.canBodyAttack(name, info, isBulletAttack) && this.checkBreakCurrentAttack(info, name, isBulletAttack)) {
		if(shouldSyncDirection) {
			this.syncDirectionFromInput();
		}
		const isNextAttack = this._prepareNextAttackInput;
		if(extensionsIniter) {
			extensionsIniter(this._bodyAttackExtensions);
		} else if(!isNextAttack) {		// 连续技的技能扩展会一直保存
			this._bodyAttackExtensions.clear();
		}
		if(!isBulletAttack) {
			this.clearNextAttack();
			this._nextAttackRootName = rootname;
			if(info.next) {
				this._nextAttackName = info.next;
			}
			this._bodyAttacking = name;
			this._attackingCounter = this.getAttackingCounter(info);
			this._bodyHit = info.hit.map((hit) => {
				return new Game_BodyHit(hit);
			});
			this._bulletCreate = info.bullet ? info.bullet.map((bulletCreate) => {
				return new Game_BulletCreate(bulletCreate);
			}) : [];
			this.resetFrameAnimation();
		} else {
			info.bullet.map((bulletCreate) => {
				this.createBullet(new Game_BulletCreate(bulletCreate));
			});
			info.action.forEach((action) => {
				this.attackAction(action);
			});
			this.enterCD(info, name);
		}
		this.onBodyAttack(name, info, isNextAttack);
		return true;
	} else if(this._nextAttackName && this._nextAttackRootName === name && !isBulletAttack) {
		this._prepareNextAttackInput = true;
	}
	return false;
};

Game_CharacterBase.prototype.getAttackingCounter = function(info) {
	if(info.time) {
		return info.time;
	}
	const image = info.image || info.moveimage || info.jumpimage;
	const infoImage = ImageFrame.info(image);
	return this.getAllFrameTime(infoImage) - 1;
};

Game_CharacterBase.prototype.onBodyAttack = function(name, info, isNextAttack) {
	this._bodyAttackFirstDirection = this.direction();
	if(info.lockInvincible) {
		this.lockSkillInvincible();
	}
	if(info.changePhysicsFlag || this._bodyAttackExtensions.changePhysicsFlag) {
		this.requestSkillTemporaryPhysicsFlag1();
	}
	if(info.temporaryScreenZ) {
		this.setTemporaryScreenZ(info.temporaryScreenZ);
	}
	if(info.noControlTimeExBreak) {
		this._noControlTimeEx = 0;
		this._noControlTimeEx2 = 0;
		this._noControlTime = 0;
	}
	if(info.zxc && this.checkZXCOnceMap()) {
		$gameMap.pausePhysics(80);
		const mirror = this.zxcArtworkMirror();
		const animationId = mirror ? 7 : 6;
		this.requestAnimation(animationId);
		$gameTemp.requestZXCArtwork(info.zxc, mirror);
		AudioManager.playNormalSe("zxc");
		return;
	}
	if(info.se && (!isNextAttack || !info.nextAttackNoSe)) {
		AudioManager.playPlayerRoundSe(this, info.randSelectSe());
	}
};

Game_CharacterBase.prototype.zxcArtworkMirror = function() {
	return true;
};

Game_Player.prototype.zxcArtworkMirror = function() {
	return false;
};

Game_CharacterBase.prototype.checkZXCOnceMap = function() {
	return true;
};

// 大招必杀技演出一个地图只出现一次
Game_Player.prototype.checkZXCOnceMap = function() {
	return !$gameMap.playerZXCOnce() && ConfigManager.zxcCutsceneEnabled;
};

Game_Event.prototype.checkZXCOnceMap = function() {
	return !this._zxcOnce && ConfigManager.zxcCutsceneEnabled;
};

Game_CharacterBase.prototype.checkBreakCurrentAttack = function(info, name, isBulletAttack) {
	if(this.isBodyAttacking() && !isBulletAttack) {
		if(this._bodyAttacking === name) {
			return false;
		}
		const currInfo = AttackFrame.info(this._bodyAttacking);
		const curr = currInfo.breakPriority | 0;
		const softBreak = currInfo.softBreak;
		const now = info.breakPriority | 0;
		if(now > curr || softBreak) {
			this.endBodyAttack(false);
			return true;
		}
		return false;
	}
	return true;
};

Game_CharacterBase.prototype.canBodyAttack = function(name, info, isBulletAttack) {
	const pstate = this.pstate();
	const battleObject = this.battleObject();
	if(isBulletAttack) {
		return true;
	}
	if((this.isJumping(pstate) || this.isAttackJumping(pstate)) && info.jumpimage) {
		return true;
	} else if((this.isStanding(pstate) || this.isMoving(pstate) || this.isAttackStanding(pstate) || this.isAttackMoving(pstate)) && info.image) {
		return true;
	} else if((this.isMoving(pstate) || this.isAttackMoving(pstate)) && info.moveimage) {
		return true;
	}
	return false;
};

Game_Player.prototype.onBodyAttack = function(name, info, isNextAttack) {
	Game_CharacterBase.prototype.onBodyAttack.apply(this, arguments);
	if(!this.isAirAttackFreeSp(info)) {
		this.battleObject().sp -= info.sp;
	} else {
		this._airAttack.push(info.airFreeSp);
	}
	if(info.softBreak === 1) {
		this._fastMoveTriggerTime = 22;
	}
	this.battleObject().zp -= info.zp;
};

Game_Player.prototype.canBodyAttack = function(name, info, isBulletAttack) {
	const baseCan = Game_CharacterBase.prototype.canBodyAttack.apply(this, arguments);
	const spCan = this.checkAttackSpEnough(name, info);
	const zpCan = this.battleObject().zp >= info.zp;
	if(!spCan) {
		this.requestSpLackEffect();
	}
	return baseCan && spCan && zpCan;
};

Game_Player.prototype.checkAttackSpEnough = function(name, info) {
	if(this.isAirAttackFreeSp(info)) {
		return true;
	}
	return this.battleObject().sp >= info.sp;
};

Game_Player.prototype.isAirAttackFreeSp = function(info) {
	return info.airFreeSp && !this._airAttack.includes(info.airFreeSp);
};

Game_CharacterBase.prototype.clearAfterAttackStanding = function() {
	this._afterAttackStanding = false;
};

Game_CharacterBase.prototype.updateBodyAttack = function(info) {
	if(this._attackingCounter > 0) {
		if(this.checkBodyAttackBreak(info)) {
			this.endBodyAttack(false, true);
			return;
		}
		if(this._attackPauseTime > 0) {
			this._attackPauseTime--;
			if(this._attackPauseTime === 0) {
				this.resumeAttackPause();
			}
			return;
		}
		this._attackingCounter--;
		const special = this.checkSpecialEndCondition(info);
		if(this._attackingCounter === 0 && special) {
			this.endBodyAttack();
		} else {
			if(!special && this._attackingCounter === 0) {
				this._attackingCounter = 1;
			}
			this.updateBodyAttackHit();
			this.updateBulletCreate();
			const launchFrame = this.attackLaunchFrame(info) - 1;
			this.updateAttackAction(info, launchFrame);
			this.updateSectionAttackAction(info, launchFrame);
			this.updateSpecialAction(info);
			this.updateZXCPlayDelayPlaySe(info);
		}
	}
};

Game_CharacterBase.prototype.updateAttackGroundingRecover = function() {
	if(this.isGrounding()) {
		this._airAttack = [];
	}
};

Game_CharacterBase.prototype.attackLaunchFrame = function(info) {
	const time = this.getAttackingCounter(info);
	return time - this._attackingCounter;
};

// 技能时间轴上的某个特定帧上才触发的特殊逻辑
Game_CharacterBase.prototype.updateAttackAction = function(info, launchFrame) {
	info.action.forEach((action) => {
		if(action.delay === launchFrame) {
			this.attackAction(action);
		}
	});
	const ftime = info.ftime || 0;
	if(ftime === launchFrame) {
		if(info.enableFx) {
			this._impact = null;
			this.vx = this._mirrorLR ? -info.fx : info.fx;
		}
		if(info.enableFy || info.enableFx) {
			this._impact = null;
			this.vy = info.fy;
		}
		if(info.suspendFriction) {
			this.suspendFriction();
		}
		if(info.suspendGravity) {
			this.suspendGravity();
		}
		if(info.animationId) {
			this.requestAnimation(info.animationId, {physicsPosition:true});
		}
		const staticAnimationId = info.staticAnimationId || this._bodyAttackExtensions.staticAnimationId;
		if(staticAnimationId) {
			this.requestAnimation(staticAnimationId, {staticPosition:true, x:this.physicsCenterX(), y:this.physicsCenterY(), z:this.screenZ()});
		}
	}
};

// 在技能某一段时间持续生效的逻辑
Game_CharacterBase.prototype.updateSectionAttackAction = function(info, launchFrame) {
	info.sectionAction.forEach((action) => {
		if(action.delay <= launchFrame && (action.delay + action.time > launchFrame || action.time === -1)) {
			this.attackAction(action);
		}
	});
};

// 技能生效时持续触发的特殊逻辑
Game_CharacterBase.prototype.updateSpecialAction = function(info) {
	switch(info.specialAction) {
		case "lily_zxc_next": {
			let threshold = -40;
			if($gameSystem.difficulty() === 0) {
				threshold = -100;
			} else if($gameSystem.difficulty() === -1){
				threshold = -160;
			}
			if(this.py < -40) {
				this.updateMoveSimple(this.px - $gamePlayer.px > 0, 2);
			} else if(this.vy > 0 && this.py < 0) {
				this._changeAttackInfo = {name:"lily_zxc_next"}
			}
			break;
		}
		case "lily_zxc_next_partner": {
			if(this.vy >= 0 && this._frameEndPos) {
				this._changeAttackInfo = {name:"lily_zxc_next"}
			}
			break;
		}
		case "lily_zxc_next_end_shake": {
			if(this.hitPreview(0, this.vy) && !this.hitPreview(0, 0)) {
				$gameScreen.startShake(4, 20, 30);
				AudioManager.playPlayerRoundSe(this, "lily_zxc_shake");
				this._nextFrameImmueElasticCollision = true;
			}
			break;
		}
		case "lily_fan_dash": {
			if(this.hitPreview(Utils.sign(this._bodyAttackFirstDirection === 6), 0) && this.attackLaunchFrame(info) > 1) {
				$gameScreen.startShake(4, 20, 30);
				AudioManager.playPlayerRoundSe(this, "lily_zxc_shake");
				this._changeAttackInfo = {name:""};
			}
			break;
		}
		case "cat6_jumpdown_shake": {		// 落地速度>= $gameMap.mg()则踩地单位全部被硬直+震飞
			if(this.hitPreview(0, this.vy) && !this.hitPreview(0, 0) && this.vy >= $gameMap.mg()) {
				$gameScreen.startShake(4, 20, 30);
				AudioManager.playPlayerRoundSe(this, "Explosion1");
				for(const ev of $gameMap._physicsDynamicObject) {
					if(ev !== this && ev.isGrounding()) {
						ev.requestStagger(60, 0, 0, false);
						ev.vy = -12;
					}
				}
			}
			break;
		}
		// drag_fx updateAttackDragFx函数实现
	}
};

// 因为技能第一帧出动画，所以大招的se推迟播放
Game_CharacterBase.prototype.updateZXCPlayDelayPlaySe = function(info) {
	if(this.isZXCNextLaunchFrame(info) && info.se) {
		AudioManager.playNormalSe(info.randSelectSe());
	}
};

Game_CharacterBase.prototype.isZXCFirstLaunchFrame = function(info) {
	return this.isZXCLaunchFrame(info, 0);
};

Game_CharacterBase.prototype.isZXCNextLaunchFrame = function(info) {
	return this.isZXCLaunchFrame(info, 2);
};

Game_CharacterBase.prototype.isZXCLaunchFrame = function(info, time) {
	return info.zxc && this.attackLaunchFrame(info) === time;
};

Game_Player.prototype.isZXCLaunchFrame = function() {
	return Game_CharacterBase.prototype.isZXCLaunchFrame.apply(this, arguments) && this.checkZXCOnceMap();
};

Game_CharacterBase.prototype.attackAction = function(action) {
	switch(action.type) {
		case "skill_image_section": this.setFrameSection(action.para[0], action.para[1]); break;
		case "lily_bomb": {
			const bomb = new Game_LilyBomb();
			bomb.initBomb(this);
			$gameMap.createCharacter(bomb);
			break;
		}
		case "lily_sea_bomb": {
			const bomb = new Game_LilySeaBomb();
			bomb.initBomb(this);
			$gameMap.createCharacter(bomb);
			break;
		}
		case "lily_bomb_partner": {
			const bomb = new Game_LilyBombPartner();
			bomb.initBomb(this);
			$gameMap.createCharacter(bomb);
			break;
		}
		case "lily_sea_bomb_partner": {
			const bomb = new Game_LilySeaBombPartner();
			bomb.initBomb(this);
			$gameMap.createCharacter(bomb);
			break;
		}
		case "lily_bomb_partner_wall": {
			const bomb = new Game_LilyBombPartner();
			bomb.initBombWall(this);
			$gameMap.createCharacter(bomb);
			break;
		}
		case "lily_prop": {
			const prop = new Game_LilyProp();
			prop.setupOwner(this);
			$gameMap.createCharacter(prop);
			break;
		}
		case "lily_prop_partner": {
			const prop = new Game_LilyPropPartner();
			prop.setupOwner(this);
			$gameMap.createCharacter(prop);
			break;
		}
		case "orange_cat_summon": {
			for(const evid of action.para) {
				const event = $gameMap.event(evid);
				event.resetStatem();
				event.locate(event.event().x, event.event().y);
				event.setupPageSettings();
				event.setOpacity(255);
			}
			break;
		}
		case "lily_pan_summon": {
			const pan = new Game_LilyPan();
			pan.setupOwner(this);
			$gameMap.createCharacter(pan);
			break;
		}
		case "orange_cat_absorb": {
			const power = action.para[0];
			const absorb = new Game_OrangeCatObsorb();
			absorb.setupPosition(this.physicsCenterX(), this.physicsCenterY() - 300, power, this);
			$gameMap.createCharacter(absorb);
			break;
		}
		case "lock_vxvy_face_player": {
			this.vx = action.para[0];
			this.vy = action.para[1];
			this.faceToPlayer();
			this._bodyAttackFirstDirection = this.direction();
			break;
		}
		case "lock_vxvy": {
			const dir = this._bodyAttackFirstDirection;
			this.vx = action.para[0] * Utils.sign(dir === 6);
			this.vy = action.para[1];
			break;
		}
		case "lock_vy": {
			this.vy = action.para[0];
			break;
		}
		case "lion_throw_pie": {
			const pie = new Game_IronPieThrow();
			pie.px = this.px + action.para[0] * Utils.sign(this.direction() === 6);
			pie.py = this.py + action.para[1];
			pie.vy = action.para[2];
			pie.setDirection(this.direction());
			$gameMap.createCharacter(pie);
			AudioManager.playPlayerRoundSe(this, "throw_pie");
			break;
		}
		case "small_bomb": {
			const bomb = new Game_SmallBomb();
			bomb.px = this.px;
			bomb.py = this.py;
			$gameMap.createCharacter(bomb);
			break;
		}
		case "toru_dash_attack_p_next": {
			this._changeAttackInfo = {name:"toru_dash_attack"};
			break;
		}
		case "toru_reverse_dash_attack_p_next": {
			this._changeAttackInfo = {name:"toru_reverse_dash_attack"};
			break;
		}
		case "toru_down_dash_attack_p1": {
			if(this._vy < 0 || this.pstate() !== 9) {
				this._changeAttackInfo = {name:""};
			}
			break;
		}
		case "toru_down_dash_attack_p2": {
			if(this._vy < 0 || this.pstate() !== 9 || this.isGrounding()) {
				if(this.isGrounding()) {
					this._changeAttackInfo = {name:"toru_down_dash_attack_boom", screenShake:[3,20,25]};
				} else {
					this._changeAttackInfo = {name:""};
				}
			}
			break;
		}
		case "animation": {
			if(action.para.length > 3) {
				this.requestAnimation(action.para[0], {physicsPosition:true, x:action.para[1] * Utils.sign(this.direction() === 6), y:action.para[2], z:action.para[3]});
			} else {
				this.requestAnimation(action.para[0], {physicsPosition:true, x:action.para[1] * Utils.sign(this.direction() === 6), y:action.para[2]});
			}
			break;
		}
		case "line_lockon_effect": {
			this._bodyAttackParameterA = $gamePlayer.px - this.px;
			this._bodyAttackParameterB = action.para.length > 0 ? 0 : $gamePlayer.py - this.py;
			this.requestAnimation(61, {physicsPosition:true, rotation:Utils.rotationDXDY(this._bodyAttackParameterA, this._bodyAttackParameterB), x:18 * Utils.sign(this.direction() === 6), y:0});
			break;
		}
		case "line_bullet_cell": {
			this.createBulletDirectly(this.physicsCenterX() + action.para[0] * Utils.sign(this.direction() === 6), this.physicsCenterY() + action.para[1], "berries_line");
			break;
		}
		case "berries_stage2": {
			this.battleObject().mhp += 70;
			this.battleObject().hp = this.battleObject().mhp;
			this.battleObject().delBuff("hp_lock");
			break;
		}
		case "line_lockon_effect_clear" : {
			$gameTemp.requestRemoveAnimation([this], 61);
			AudioManager.playNormalSe("Ice5");
			break;
		}
		case "evil_wall_purple_bullet": {
			const bullet = new Game_WallDivisionBullet();
			bullet.px = this.px - 24;
			bullet.py = this.py;
			$gameMap.createCharacter(bullet);
			break;
		}
		case "evil_wall_laser_bullet": {
			this.createBulletDirectly(this.px - 980, this.py, "evil_wall_laser_bullet");
			break;
		}
		default: break;
	}
};

Game_Player.prototype.attackAction = function(action) {
	Game_CharacterBase.prototype.attackAction.apply(this, arguments);
	switch(action.type) {
		case "use_consumable": {
			this.actor().performUseConsumable();
			this.triggerBossScoreUseConsumables();
			break;
		}
		default: break;
	}
};

Game_CharacterBase.prototype.checkBodyAttackBreak = function(info) {
	const pstate = this.pstate();
	return !this.isAttacking(pstate) || this.checkBodyAttackSoftBreak(info);
};

Game_CharacterBase.prototype.checkBodyAttackSoftBreak = function(info) {
	if(info.softBreak) {
		switch(info.softBreak) {
			case 1: {
				const launchFrame = this.attackLaunchFrame(info);
				const hasBreak = (this.vx > 0 && (Input.isStrictTriggered('left') || TouchInput.isScreenButtonTriggered('left')) && launchFrame >= 8) || (this.vx < 0 && (Input.isStrictTriggered('right') || TouchInput.isScreenButtonTriggered('right')) && launchFrame >= 8)
					|| Input.isStrictTriggered('ok') || Input.isStrictTriggered('cancel') || TouchInput.isScreenButtonTriggered('attack') || TouchInput.isScreenButtonTriggered('jump');
				return hasBreak;
			}
			case 2: {
				return Input.isStrictTriggered('up') || Input.isStrictTriggered('ok') || Input.isStrictTriggered('cancel')
				|| TouchInput.isScreenButtonTriggered('up') || TouchInput.isScreenButtonTriggered('attack') || TouchInput.isScreenButtonTriggered('jump');
			}
			case 3: {
				return Input.isStrictTriggered('up') || Input.isStrictTriggered('down') || Input.isStrictTriggered('left') || Input.isStrictTriggered('right') || Input.isStrictTriggered('ok') || Input.isStrictTriggered('cancel')
				|| TouchInput.isScreenButtonTriggered('up') || TouchInput.isScreenButtonTriggered('down') || TouchInput.isScreenButtonTriggered('left')|| TouchInput.isScreenButtonTriggered('right') || TouchInput.isScreenButtonTriggered('attack') || TouchInput.isScreenButtonTriggered('jump');
			}
			case 4: {
				return this.attackLaunchFrame(info) > 0 && (Input.isStrictTriggered('left') || Input.isStrictTriggered('right') || Input.isStrictTriggered('ok') || TouchInput.isScreenButtonTriggered('left') || TouchInput.isScreenButtonTriggered('right') || TouchInput.isScreenButtonTriggered('jump'));
			}
		}
	}
	return false;
};

// 返回false会阻止技能按正常的逻辑进行结束处理
Game_CharacterBase.prototype.checkSpecialEndCondition = function(info) {
	const flags = info.endFlags;
	if(flags.length === 0) {
		return true;
	} else {
		return flags.some((flag) => {
			switch(flag) {
				case 1: {
					return this.checkJumpNoEnd();
				}
				case 2: {
					return this.checkDownNoEnd();
				}
				case 3: {
					return this.checkUpNoEnd();
				}
				case 4: {
					return this.checkImpactNoEnd();
				}
				default: {
					return true;
				}
			}
		});
	}
};

Game_CharacterBase.prototype.checkJumpNoEnd = function() {
	return this.pstate() !== 9;
};

Game_CharacterBase.prototype.checkDownNoEnd = function() {
	return this.vy <= 0;
};

Game_CharacterBase.prototype.checkUpNoEnd = function() {
	return this.vy >= 0;
};

Game_CharacterBase.prototype.checkImpactNoEnd = function() {
	return this.impactObject() !== null;
};

Game_CharacterBase.prototype.enterCD = function(info, rootname) {
	if(info && info.cd) {
		this._attackcd.push({name:rootname,cd:info.cd-this._attackCdReduce});
	}
};

Game_CharacterBase.prototype.setCD = function(name, cd) {
	for(const item of this._attackcd) {
		if(item.name === name) {
			item.cd = cd;
			return;
		}
	}
	this._attackcd.push({name:name,cd:cd});
};

Game_CharacterBase.prototype.getCd = function(name) {
	for(const item of this._attackcd) {
		if(item.name === name) {
			return item.cd;
		}
	}
	return 0;
};

Game_CharacterBase.prototype.endBodyAttack = function(hasNextAttack = true, holdFastMove = false) {
	const name = this._bodyAttacking;
	const rootname = this._nextAttackRootName;
	const info = AttackFrame.info(name);
	this.enterCD(info, rootname);
	this._bodyAttacking = "";
	this._bodyHit = [];
	this._bulletCreate = [];
	this._attackPauseTime = 0;
	this._latestBodyAttackingLaunchFrame = this.attackLaunchFrame(info);
	this._attackingCounter = 0;
	
	if(info.suspendFriction) {
		this.resumeFriction();
	}
	if(info.suspendGravity) {
		this.resumeGravity();
	}
	if(info.lockInvincible) {
		this.unlockSkillInvincible();
	}
	if(info.zxc) {
		this.setPlayerZXCOnce();
	}
	if(info.temporaryScreenZ) {
		this.clearTemporaryScreenZ();
	}
	if(info.changePhysicsFlag || this._bodyAttackExtensions.changePhysicsFlag) {
		this.cancelSkillTemporaryPhysicsFlag1();
	}
	if(info.animationId) {
		$gameTemp.requestRemoveAnimation([this], info.animationId);
	}
	this.resumeAttackPause();
	this.clearUsingConsumable(info);
	this.detectState();
	this.flushPState();
	this.endBodyAttackSoftBreak(info, !hasNextAttack && !holdFastMove);
	
	if(info.nextDelay && hasNextAttack) {
		this._nextAttackDelay = info.nextDelay + 1;
		this.checkNextBodyAttack(false);
	} else {
		this.clearNextAttack();
	}
};

Game_CharacterBase.prototype.endBodyAttackSoftBreak = function(info, breakFastMove) {
};

Game_Player.prototype.endBodyAttackSoftBreak = function(info, breakFastMove) {
	if(info.softBreak === 1 && breakFastMove) {
		this.controlFastMove();
		this._fastMoveTriggerTime = 0;
	}
};

Game_CharacterBase.prototype.setPlayerZXCOnce = function() {
};

Game_Player.prototype.setPlayerZXCOnce = function() {
	$gameMap.setPlayerZXCOnce();
};

Game_Event.prototype.setPlayerZXCOnce = function() {
	this._zxcOnce = true;
};

Game_CharacterBase.prototype.clearUsingConsumable = function() {
};

Game_Player.prototype.clearUsingConsumable = function(info) {
	const result = info.action && info.action.some((action) => {
		return action.type === "use_consumable";
	});
	if(result) {
		this.actor().clearConsumableUsing();
	}
};

Game_CharacterBase.prototype.updateBodyAttackHit = function() {
	if(this._bodyHit) {
		for(const hit of this._bodyHit) {
			if(hit.delay) {
				hit.delay--;
				if(!hit.delay) {
					hit.metaData.se && AudioManager.playPlayerRoundSe(this, hit.metaData.randSelectSe());
				}
			} else if(hit.time > 0) {
				hit.time--;
				this.bodyAttackHit(hit);
			} else if(hit.time === -1) {
				this.bodyAttackHit(hit);
			}
		}
	}
};

Game_CharacterBase.prototype.bodyAttackHit = function(hit) {
	const vertices = hit.metaData.vertices.map((p) => {
		const x = this._mirrorLR ? -p.x : p.x;
		return {x:this.px + x, y:this.py + p.y};
	});
	$gameMap.isAttackHit(hit.onHit, vertices, this.onAttackHit.bind(this), this);
};

Game_CharacterBase.prototype.updateBulletCreate = function() {
	if(this._bulletCreate) {
		for(const create of this._bulletCreate) {
			if(create.delay) {
				create.delay--;
			} else if(!create.created) {
				create.created = true;
				this.createBullet(create);
			}
		}
	}
};

Game_CharacterBase.prototype.createBullet = function(create) {
	const data = create.metaData;
	const x = this._mirrorLR ? -data.x : data.x;
	const duplicate = data.duplicate || 1;
	const bulletx = this.px + x;
	const bullety = this.py + data.y;
	const dir = (this._mirrorLR && !data.dirLock) ? -1 : 1;
	for(let i = 0; i < duplicate; i++) {
		const bullet = new Game_Bullet(data.name, bulletx, bullety, this);
		bullet.setDirection(dir);
		bullet.setCreationOrder(i, duplicate);
		bullet.setLatestAttackingLaunchFrame(this._latestBodyAttackingLaunchFrame);
		$gameMap.addBullet(bullet);
	}
};

NYA.STATEM.Game_Temp_initialize = Game_Temp.prototype.initialize;
Game_Temp.prototype.initialize = function() {
	NYA.STATEM.Game_Temp_initialize.apply(this, arguments);
	this._tempCharacter = new Game_CharacterBase();			//	专门做碰撞检测用，减少垃圾回收消耗
};

Game_Temp.prototype.tempCharacter = function() {
	this._tempCharacter.px = this._tempCharacter.py = this._tempCharacter.rx = this._tempCharacter.ry = 0;
	return this._tempCharacter;
};

Game_Map.prototype.isAttackHit = function(info, vertices, callback, obj) {
	const attack = $gameTemp.tempCharacter();
	attack._physicsFlag = 4;
	if(obj.isSquash()) {
		attack.setVertices(obj.modifyVerticesForSquash(vertices));
	} else {
		attack.setVertices(vertices);
	}
	const hit = this.hitTest(attack, this._physicsGrid, false);
	if(!hit) {
		return;
	}
	for(const event of hit) {
		if(event === obj || !event.battleObject() || this.checkSameTeam(obj, event) || event.isInvincible() || event.isDeath() || (event.fix && event.battleObject().unlimitHp)) {
			continue;
		}
		const effectPos = event.randAttackPos(attack.vertices);
		if(info.metaData.noHitOnce) {
			if(info.isObjectInHitCD(event)) {
				continue;
			}
			callback(info, event, effectPos);
			info.enterObjectHitCD(event);
		} else {
			if(info.hitObjs.includes(event.eventId())) {
				continue;
			}
			callback(info, event, effectPos);
			info.hitObjs.push(event.eventId());
		}
	}
	info.updateHitObjCD();
};

Game_CharacterBase.prototype.beHitNum = function() {
	return this._beHitNum;
};

Game_CharacterBase.prototype.beHit = function(playSe = true, damage, src, fx = 0, fy = 0, noDamage = false) {
	this._beHitNum++;
	if(src) {
		this._latestHitObjectsConstructor.push(src.constructor.name);
	}
	const obj = this.battleObject();
	const se = obj.onHitSe;
	if(se.length > 0 && !obj.specailHitFlag && playSe && !noDamage) {
		AudioManager.playPlayerRoundSe(this, se.randomElement(), 0.9);
	}
	this.hitFragmentCreate(obj, fx, fy);
};

Game_CharacterBase.prototype.requestNormalDamage = function(damage, staggerTime = 0, fx = 0, fy = 0) {
	if(this.isInvincible()) {
		return;
	}
	if(this.checkShieldImmue()) {
		this.requestDamage(0, false);
	} else {
		this.requestStagger(staggerTime, fx, fy);
		this.requestDamage(damage);
	}
};

Game_CharacterBase.prototype.requestRealDamage = function(damage, staggerTime = 0, fx = 0, fy = 0) {
	this.requestStagger(staggerTime, fx, fy);
	this.requestDamage(damage, true, true);
};

Game_CharacterBase.prototype.requestDamage = function(damage, playSe = true, real = false, noTriggerBeHit = false) {
	const tobj = this.battleObject();
	const damage2 = Math.round(damage * (1 - tobj.getBuffVal("def_up") + tobj.getBuffVal("def_down")));
	const hpBefore = tobj.hp;
	if(!tobj.unlimitHp) {
		if(real) {
			tobj._hp = Math.max(0, tobj._hp - damage2);
		} else {
			tobj.hp -= damage2;
		}
		
	}
	if(!tobj.unlimitHp || tobj.alwaysShowDamageDigit) {
		$gameMap.addDamageDigit(this, damage2);
	}
	const hpAfter = tobj.hp;
	const realDamage = real ? 0 : hpBefore - hpAfter;
	if(!noTriggerBeHit) {
		this.beHit(playSe, realDamage);
	}
};

Game_Player.prototype.checkShieldImmue = function() {
	if(Game_CharacterBase.prototype.checkShieldImmue.call(this)) {
		this._shieldEffectCounter = 3600;
		return true;
	}
	return false;
};

Game_CharacterBase.prototype.checkShieldImmue = function() {
	if(this.isShieldEffect()) {
		this.setDefenceShieldEffect(false);
		return true;
	}
	return false;
};

Game_Event.prototype.beHit = function(playSe, damage, src, fx = 0, fy = 0) {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	const obj = this.battleObject();
	if(obj.specailHitFlag && this.isDeath()) {
		$gameMap.addSpecialCircleHit(this.eventId(), obj.specailHitFlag);
	}
};

Game_Player.prototype.beHit = function(playSe, damage, src, fx = 0, fy = 0, noDamage = false) {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	const actor = this.actor();
	if(!this.isDeath()) {
		if(!noDamage) {
			this.makeInvincible(actor.beHitInvincibleTime());
		}
	} else if(!actor.checkRaiseHpLockOrnaments(damage)) {
		this.lockSkillInvincible();
	} else {
		this.makeInvincible(actor.beHitInvincibleTime());
	}
	actor.checkRaiseDamageReflectionOrnaments(src, damage);
	this.triggerBossScoreOnHit();
};

Game_CharacterBase.prototype.onBulletHit = function() {
	this.onAttackHit(...arguments);
};

Game_CharacterBase.prototype.onAttackHit = function(onHit, character, effectPos) {
	const tobj = character.battleObject();
	const obj = this.battleObject();
	const hitFlag = tobj.specailHitFlag;
	const info = onHit.metaData;
	if(info.specailHitFlag === hitFlag || (hitFlag === 0 && !info.attackForSpecialFlag)) {
		const isBulletAttack = !!onHit.bulletOwner;
		const reference = onHit.bulletOwner ? onHit.bulletOwner : this;
		let fx = 0, fy = 0;
		if(!isBulletAttack) {
			fx = this._groundHitObj === character ? 0 : (reference._mirrorLR ? -info.fx * character.m : info.fx * character.m);
			fy = this._groundHitObj === character ? 0 : info.fy * character.m;
		} else {
			fx = reference.px > character.px ? -info.fx * character.m : info.fx * character.m;
			fy = reference.py > character.py ? -info.fy * character.m : info.fy * character.m;
		}
		const sfx = reference._mirrorLR ? -info.sfx * this.m : info.sfx * this.m;
		const sfy = info.sfy * this.m;
		const unlimitHp = tobj.unlimitHp;
		const hpBefore = tobj.hp;
		const defenceShield = character.checkShieldImmue();
		const noHotEvent = tobj.noHotEvent;
		const damage = (defenceShield || (tobj.immueStaggerAttack && info.staggerTime > 0)) ? 0 : 
			Math.round(info.damage * (1 + obj.getBuffVal("atk_up") - obj.getBuffVal("atk_down")) * (1 - tobj.getBuffVal("def_up") + tobj.getBuffVal("def_down")) * (1 + this._bodyAttackExtensions.atkUp));
		if(!unlimitHp) {
			tobj.hp -= damage;
		}
		const hpAfter = tobj.hp;
		const immueForce = tobj.getBuffVal("skill_force_immue") !== 0;
		if(info.staggerTime && !defenceShield) {
			character.requestStagger(info.staggerTime, fx, fy, info.fix);
			character.startShake(1, 25, info.staggerTime);
		} else if(!immueForce) {
			if(fy < 0 && character.vy > 0) {
				character.vy = 0;
			}
			character.impu(fx, fy);
			character._nextFrameImmueElasticCollision = true;
			if(this._impact === character) {
				this._nextFrameImmueElasticCollision = true;
			}
		}
		if(!immueForce && info.noControlTime) {
			character.setNoControlTime(info.noControlTime);
		}
		if(sfy < 0) {
			this.endFrameJump();
		}
		if(!isBulletAttack && !info.noHitF) {
			const add = tobj.sfadd || 1;
			this.vx = sfx * add;
			this.vy = sfy * add;
		}
		if(info.shake) {
			$gameScreen.startShake(info.shake, 20, info.pauseTime);
		} else {
			this.startShake(1, 25, info.pauseTime);
		}
		const realDamage = hpBefore - hpAfter;
		const shouldHideDamage = info.damage === 0;		// 是否应该隐藏伤害数字，并且不导致受击无敌，应用：毒雾攻击
		if(!shouldHideDamage && !hitFlag && !noHotEvent && (!unlimitHp || tobj.alwaysShowDamageDigit)) {
			$gameMap.addDamageDigit(character, damage, effectPos);
		}
		if(info.attackChange && info.attackChange.name) {
			this._changeAttackInfo = info.attackChange;
		}
		if(info.se) {
			AudioManager.playPlayerRoundSe(this, info.se);
		}
		if(info.buff) {
			for(const buffInfo of info.buff) {
				if(buffInfo.length > 3) {
					character.battleObject().addBuff(buffInfo[0], buffInfo[1], buffInfo[2], true, "", buffInfo[3]);
				} else {
					character.battleObject().addBuff(buffInfo[0], buffInfo[1], buffInfo[2], true);
				}
			}
		}
		character.beHit(!defenceShield && !info.se, realDamage, this, fx, fy, shouldHideDamage);
		return true;
	}
	return false;
};

Game_CharacterBase.prototype.endFrameJump = function() {
};

Game_Player.prototype.endFrameJump = function() {
	this.frameJump = false;
};

Game_Player.prototype.attackToDeathShakeTime = function() {
	return 12;
};

Game_Player.prototype.shouldSetHotEvent = function() {
	return true;
};

Game_Player.prototype.onBulletHit = function() {
	Game_CharacterBase.prototype.onBulletHit.apply(this, arguments);
};

Game_Player.prototype.onAttackHit = function(onHit, character, effectPos) {
	const info = onHit.metaData;
	const isBullet = !!onHit.bulletOwner;
	const result = Game_CharacterBase.prototype.onAttackHit.apply(this, arguments);
	if(!result) {
		return false;
	}
	const unlimitHp = character.battleObject().unlimitHp;
	const hp = character.battleObject().hp;
	const noHotEvent = character.battleObject().noHotEvent;
	if(!unlimitHp && !noHotEvent) {
		if(character.battleObject().isBoss) {
			$gameMap.setBossEvent(character.eventId());
		} else if(this.shouldSetHotEvent()) {
			$gameMap.setHotEvent(character.eventId(), {initHp:hp+info.damage});
		}
	}
	if(character.battleObject().hp <= 0) {
		if(!character.battleObject().noDeathShake) {
			const time = this.attackToDeathShakeTime();
			!isBullet && this.requestAttackPause(time);
			$gameScreen.startShake(2, 20, time);
		}
		if(!character.battleObject().deathNoZp) {
			this.battleObject().addZp(15 + character.battleObject().deathAddZp);
		}
	}
	else if(!onHit.firstHitObj && !isBullet) {
		this.requestAttackPause(info.pauseTime);
	}
	onHit.firstHitObj = character;
	const actor = this.actor();
	const effectX = effectPos.x - character.physicsCenterX();
	const effectY = effectPos.y - character.physicsCenterY(); 
	// 优先级：技能的命中特效>被击物体的命中特效>角色默认命中特效
	if(!info.animationId) {
		const beHitAnimations = character.battleObject().beAttackSlashAnimations;
		if(beHitAnimations && beHitAnimations.length > 0) {
			for(const animationId of beHitAnimations) {
				character.requestAnimation(animationId, {physicsPosition:true, x:effectX, y:effectY});
			}
		} else {
			for(const animationId of actor.attackSlashAnimations()) {
				character.requestAnimation(animationId, {physicsPosition:true, x:effectX, y:effectY});
			}
		}
	} else {
		character.requestAnimation(info.animationId, {physicsPosition:true, x:effectX, y:effectY});
	}
	if(info.refresh_air) {
		this.refreshAir();
	}
	return result;
};

Game_Player.prototype.refreshAir = function() {
	this._airAttack = [];
	this.useDoubleJump = false;
};

Game_CharacterBase.prototype.requestAttackPause = function(time) {
	if(time > 0) {
		this._attackPauseTime = time;
		this.pauseFrameAnimation();
	}
};

Game_CharacterBase.prototype.isAttackPause = function() {
	return this._attackPauseTime > 0;
};

Game_CharacterBase.prototype.resumeAttackPause = function() {
	this.resumeFrameAnimation();
};

Game_CharacterBase.prototype.clearNextAttack = function() {
	this._nextAttackName = "";
	this._nextAttackDelay = 0;
	this._prepareNextAttackInput = false;
};

Game_CharacterBase.prototype.checkNextBodyAttack = function(shouldSyncDirection = true) {
	if(this._prepareNextAttackInput && this._nextAttackName) {
		if(this.requestBodyAttack(this._nextAttackRootName, undefined, shouldSyncDirection)) {
			this._prepareNextAttackInput = false;
		}
	}
};

Game_CharacterBase.prototype.updateAttackCD = function() {
	this._attackcd = this._attackcd.filter((item) => {
		item.cd--;
		if(item.cd <= 0) {
			return false;
		}
		return true;
	});
};

Game_CharacterBase.prototype.isBodyAttacking = function() {
	return this._bodyAttacking !== "";
};

Game_CharacterBase.prototype.bodyAttackImage = function() {
	return AttackFrame.info(this._bodyAttacking).image;
};

Game_CharacterBase.prototype.bodyAttackImageMoving = function() {
	return AttackFrame.info(this._bodyAttacking).moveimage;
};

Game_CharacterBase.prototype.bodyAttackImageStanding = function() {
	return AttackFrame.info(this._bodyAttacking).standimage;
};

Game_CharacterBase.prototype.bodyAttackImageJumping = function() {
	return AttackFrame.info(this._bodyAttacking).jumpimage;
};

Game_CharacterBase.prototype.preferAttackImage = function(state) {
	switch(state) {
		case 7: {
			const prefer = this.bodyAttackImageStanding();
			if(prefer) {
				return prefer;
			}
			break;
		}
		case 8: {
			const prefer = this.bodyAttackImageMoving();
			if(prefer) {
				return prefer;
			}
			break;
		}
		case 9: {
			const prefer = this.bodyAttackImageJumping();
			if(prefer) {
				return prefer;
			}
			break;
		}
	}
	return this.bodyAttackImage();
};

Game_CharacterBase.prototype.updateStatem = function() {
	this.updateTerrainDamage();
	this.detectState();
	this.updateAttackChange();
	this.updateAttack();
	this.updateStagger();
	this.updateInvincible();
	this.updateSquash();
	this.updateNoControlTime();
	this.updateTempFriction();
	this.updateTemporaryPhysicsFlag1();
	this.updateSpecialGrounding();
	this.flushPState();
	this.updateAttackDragFx();
	this.updateBattleObject();
	this.clearLatestHitObjectsConstructor();
};

Game_CharacterBase.prototype.updateAttackChange = function() {
	if(this._changeAttackInfo) {
		const attackChange = this._changeAttackInfo;
		const newAttackName = attackChange.name;
		if(newAttackName !== "") {
			const initPauseTime = attackChange.pauseTime || 0;
			if(this.requestBodyAttack(newAttackName)) {
				this.requestAttackPause(initPauseTime);
				this.startShake(1, 25, initPauseTime);
				if(attackChange.screenShake) {
					$gameScreen.startShake(attackChange.screenShake[0], attackChange.screenShake[1], attackChange.screenShake[2]);
				}
			} else {
				this.endBodyAttack(false);
			}
		} else {
			this.endBodyAttack(false);
		}
		this._changeAttackInfo = null;
	}
};

Game_CharacterBase.prototype.updateNoControlTime = function() {
	if(this._noControlTime > 0) {
		this._noControlTime--;
	}
	if(this._noControlTimeEx) {
		if(this.isGrounding() || this._impact || Math.abs(this.vx) < 1) {
			this._noControlTimeEx = 0;
		}
	}
	if(this._noControlTimeEx2) {
		this._noControlTimeEx2--;
		if(this.isGrounding() || this._impact || Math.abs(this.vx) < 1) {
			this._noControlTimeEx2 = 0;
		}
	}
};

Game_CharacterBase.prototype.noControlTime = function() {
	return this._noControlTime || this._noControlTimeEx || this._noControlTimeEx2;
};

// 另外一种机制的锁左右键控制
// 可被技能打断，发生碰撞时打断，落地时直接打断
Game_CharacterBase.prototype.setNoControlTimeEx = function(val) {
	this._noControlTimeEx = val;
};

// 另外一种机制的锁左右键控制
// 可被技能打断，发生碰撞时打断，落地时直接打断，但也会在时限内自己消除
Game_CharacterBase.prototype.setNoControlTimeEx2 = function(val) {
	this._noControlTimeEx2 = val;
};

NYA.STATEM.Game_CharacterBase_update = Game_CharacterBase.prototype.update;
Game_CharacterBase.prototype.update = function() {
	NYA.STATEM.Game_CharacterBase_update.apply(this, arguments);
	this.updateDeathAnimation();
	this.updateFallDown();
};

Game_CharacterBase.prototype.updateBattleObject = function() {
	if(this.battleObject()) {
		this.battleObject().update();
		for(const buff of this.battleObject().allBuff()) {
			if(buff.effectId && (Graphics.frameCount % buff.effectInterval) === 0) {
				this.requestAnimation(buff.effectId, {physicsPosition:true});
			}
		}
	}
};


Game_Player.prototype.updateStatem = function() {
	this.updateJumpingFrame();
	this.updateInWater();
	this.checkNextBodyAttack();
	this.playerControl();
	this.updateFastMoveTriggerTime();
	this.updateGetDown();
	Game_CharacterBase.prototype.updateStatem.call(this);
	this.updateDefenceShieldOrnaments();
	this.updateBowOrnaments();
	this.updateBossScoreRecording();
};

Game_Event.prototype.updateStatem = function() {
	this.eventControl();
	Game_CharacterBase.prototype.updateStatem.call(this);
};

Game_CharacterBase.prototype.standstillx = function() {
	return this._groundHitObj ? this._groundHitObj._vx : 0;
};

Game_CharacterBase.prototype.standstilly = function() {
	return this._groundHitObj ? this._groundHitObj._vy : 0;
};

Game_Player.prototype.isTriggeredJump = function() {
	return Input.isStrictTriggered('ok') || TouchInput.isScreenButtonTriggered('jump');
};

Game_Player.prototype.isRepeatJump = function() {
	return Input.isPressed('ok') || TouchInput.isScreenButtonPressed('jump');
};

Game_CharacterBase.prototype.detectState = function() {
	const ground = this.isGrounding() && this._groundHitObj.upElasticWithJumpStrength() === 0;
	let pstate = 0;
	if(this.isDeath()) {
		pstate = 10;
	}
	else if(this.isStagger()) {
		pstate = 6;		// 硬直状态
	}
	else if(Math.abs(this.vy) <= 1 && !ground) {
		pstate = 4;			// 浮空状态
	}
	else if(this.vy > 0 && !ground) {
		pstate = 3;	// 浮空（下降）状态
	}
	else if(this.vy < 0 && !ground) {
		if(this.useDoubleJump) {
			pstate = 5;	// 浮空（上升）（二段跳）状态
		}
		else {
			pstate = 2;	// 浮空（下降）（二段跳）状态
		}
	}
	else if(this._shoundUseSpeedCompareForMovingState && this.standstillx() != this._vx) {
		pstate = 1;
	}
	else if(!this._shoundUseSpeedCompareForMovingState && (this.isTriggeredLeft() || this.isTriggeredRight())) {
		pstate = 1;
	}
	else if(this.isGrounding()) {
		pstate = 0;
	}
	if(this.isBodyAttacking()) {
		const info = AttackFrame.info(this._bodyAttacking);
		const prev = pstate;
		if(this.isStanding(pstate) && this.preferAttackImage(7)) {
			pstate = 7;
		} else if(this.isMoving(pstate) && this.preferAttackImage(8)) {
			pstate = 8;
		} else if(this.isJumping(pstate) && this.preferAttackImage(9)) {
			pstate = 9;
		}
		this.setPstate(pstate);
		this.updateBodyAttack(info);
		if(!this.isBodyAttacking()) {
			pstate = prev;
		}
	}
	this.setPstate(pstate);
	this._isTriggeredLeft = false;
	this._isTriggeredRight = false;
};

Game_Player.prototype.detectState = function() {
	Game_CharacterBase.prototype.detectState.call(this);
	const pstate = this.pstate();
	if(this.isWallDown() && pstate === 3) {
		this.setPstate(11);
	}
	if(this._isGetDown) {
		if(pstate === 0 || pstate === 2 || pstate === 3 || pstate === 4 || pstate === 5) {
			this.setPstate(12);
		}
		if(pstate === 1) {
			this.setPstate(13);
		}
	}
};

// 对于玩家来说是控制方向的输入指示
// 但对于其他对象，这个函数返回的只是决定人物是否该不该播走路动画，参考detectState函数
Game_CharacterBase.prototype.isTriggeredLeft = function() {
	return this._isTriggeredLeft;
};

Game_CharacterBase.prototype.isTriggeredRight = function() {
	return this._isTriggeredRight;
};

Game_CharacterBase.prototype.isStanding = function(state) {
	return state === 0 || state === 12;
};

Game_CharacterBase.prototype.isMoving = function(state) {
	return state === 1 || state === 13;
};

Game_CharacterBase.prototype.isJumping = function(state) {
	return state === 2 || state === 3 || state === 4 || state === 5 || state === 11;
};

Game_CharacterBase.prototype.isAttacking = function(state) {
	return this.isAttackMoving(state) || this.isAttackStanding(state) || this.isAttackJumping(state);
};

Game_CharacterBase.prototype.isAttackJumping = function(state) {
	return state === 9;
};

Game_CharacterBase.prototype.isAttackMoving = function(state) {
	return state === 8;
};

Game_CharacterBase.prototype.isAttackStanding = function(state) {
	return state === 7;
	
};

Game_Player.prototype.actor = function() {
	return $gameParty.leader();
};

// 转换为该状态时，如果上一状态在以下列表中则不重置当前动作序列位置
Game_CharacterBase.prototype.normalAttackCompatibleStateGroup = function() {
	return [7, 8, 9];
};

Game_Player.prototype.doPStateChange = function(oldState, newState) {
	Game_CharacterBase.prototype.doPStateChange.apply(this, arguments);
	const actor = this.actor();
	switch(newState) {
		case 0: this.resetImage(actor.standingImage()); break;
		case 1: this.resetImage(actor.movingImage()); break;
		case 3: this.resetImage(actor.jumpDownImage()); break;
		case 4: this.resetImage(actor.jumpMiddleImage()); break;
		case 2: this.resetImage(actor.jumpUpImage()); break;
		case 5: this.resetImage(actor.doubleJumpUpImage()); break;
		case 6: case 10: this.resetImage(actor.staggerImage()); break;
		case 7: case 8: case 9: { 
			if(!this.normalAttackCompatibleStateGroup().includes(oldState)) {
				this.resetFrameAnimation(); 
			}
			this.setImage(this.preferAttackImage(newState));
			break;
		}
		case 11: this.resetImage(actor.wallDownImage()); break;
		case 12: this.resetImage(actor.getDownImage()); break;
		case 13: this.resetImage(actor.getDownMoveImage()); break;
		default: this.resetImage(actor.standingImage()); break;
	}
};

Game_Player.prototype.moveByInput = function() {
};

Game_CharacterBase.prototype.resetImage = function(name) {
	this.resetFrameAnimation();
	Game_CharacterBase.prototype.setImage.call(this, name);
};

function Game_Bullet() {
	this.initialize(...arguments);
}

Game_Bullet.prototype = Object.create(Game_CharacterBase.prototype);
Game_Bullet.prototype.constructor = Game_Bullet;

Game_Bullet.prototype.initialize = function(name, x, y, character) {
	Game_CharacterBase.prototype.initialize.call(this);
	this._isHitTerrain = false;
	this.physics = true;
	this._name = name;
	this._direction = 1;
	this._physicsFlag = 4;
	this._creationOrder = 0;
	this._parentBulletDuplicateNum = 0;
	this._pathActiveDatas = {};
	this.setupOwner(character);
	this.setupPos(x, y);
	this.initBound();
	this.cacheVerticesRect();
	this.playStartSe();
};

Game_Bullet.prototype.playStartSe = function() {
	const data = this.data();
	if(data.start_se && data.start_se.length > 0) {
		AudioManager.playPlayerRoundSe(this, data.start_se.randomElement());
	}
};

Game_Bullet.prototype.playEndSe = function() {
	const data = this.data();
	if(data.end_se) {
		AudioManager.playPlayerRoundSe(this, data.end_se);
	}
};

Game_Bullet.prototype.setDirection = function(d) {
	if(this._direction !== d) {
		this.vertices = this.vertices.map((p) => {
			return {x:-p.x, y:p.y};
		});
		this.cacheVerticesRect();
		this._direction = d;
	}
	this._mirrorLR = (this._direction === -1);
};

Game_Bullet.prototype.setCreationOrder = function(order, duplicate) {
	this._creationOrder = order;
	this._parentBulletDuplicateNum = duplicate;
};

Game_Bullet.prototype.initBound = function() {
	const data = this.data();
	const vertices = data.vertices;
	this.vertices = vertices;
};

Game_Bullet.prototype.setupOwner = function(character) {
	this._character = character;
};

Game_Bullet.prototype.setupPos = function(x, y) {
	this.px = this.rx = x;
	this.py = this.ry = y;
};

Game_Bullet.prototype.initMembers = function() {
	Game_CharacterBase.prototype.initMembers.call(this);
	this._name = "";
	this._time = 0;
	this._hitObjCd = [];
};

Game_Bullet.prototype.data = function() {
	return BulletFrame.info(this._name);
};

Game_Bullet.prototype.update = function() {
	const data = this.data();
	const maxTime = data.liveTime + data.endimage.time;
	this._time++;
	this.updateAttackInterval();
	this.updatePath(data);
	const hitTime = this.getAttackTime(data);
	if(hitTime) {
		this.updateHit(hitTime);
	}
	if(!this._isHitTerrain && !data.canThroughTerrain) {
		this.checkHitTerrain(data);
	}
	if(this._time >= maxTime) {
		this.destroy();
	}
};

Game_Bullet.prototype.image = function() {
	const data = this.data();
	if(this._time === data.liveTime) {
		this.playEndSe();
	}
	if(this._time > data.liveTime) {
		if(this.endType(data) === "fadeout") {
			return data.image[data.image.length - 1].name;
		} else {
			return data.endimage.name;
		}
	} else {
		for(const item of data.image) {
			if(this._time >= item.start && this._time <= item.end) {
				return item.name;
			}
		}
		return "";
	}
};

Game_Bullet.prototype.endType = function(data) {
	return data.endimage.type;
};

Game_Bullet.prototype.fadeAlpha = function() {
	const data = this.data();
	if(this._time > data.liveTime && this.endType(data) === "fadeout") {
		const maxTime = data.liveTime + data.endimage.time;
		return 1 - (this._time - data.liveTime) / maxTime;
	}
	return 1;
};

Game_Bullet.prototype.checkHitTerrain = function(data) {
	if(this.isHitTerrain()) {
		this._isHitTerrain = true;
		this._time = Math.max(this._time, data.liveTime);
	}
};

Game_Bullet.prototype.isHitTerrain = function() {
	this.setImmueVground(true);
	const hit = $gameMap.hitTest(this, $gameMap._physicsFixGrid);
	this.setImmueVground(false);
	return !!hit && !hit.includes(this._character);
};

Game_Bullet.prototype.isDestroy = function() {
	return !this.physics;
};

Game_Bullet.prototype.battleTeam = function() {
	return this._character.battleTeam();
};

Game_Bullet.prototype.destroy = function() {
	this.physics = false;
};

Game_Bullet.prototype.updatePath = function(data) {
	const path = this.getPath(data);
	if(path) {
		switch(this.getPathType(data, path)) {
			case 0: {
				this.px = this.rx = this.rx + path.a * this._direction;
				this.py = this.ry = this.ry + path.b;
				break;
			}
			case 1: {
				this.getPathActiveData(data, path);
				if(path.a !== 0) {
					this._vy += path.a;
					this._vy = path.a > 0 ? Math.min(path.c, this._vy) : Math.max(path.c, this._vy);
				}
				if(path.f !== 0) {
					let f = path.f;
					if(path.h) {
						f *= this._direction;
					}
					this._vx += f;
					this._vx = f > 0 ? Math.min(0, this._vx) : Math.max(0, this._vx);
				}
				this.makeMomentum();
				this.px = this.rx;
				this.py = this.ry;
				break;
			}
			case 2: case 3: {
				const activeData = this.getPathActiveData(data, path);
				this._vx = activeData.a;
				this._vy = activeData.b;
				this.makeMomentum();
				this.px = this.rx;
				this.py = this.ry;
				break;
			}
			case 4: {
				const activeData = this.getPathActiveData(data, path);
				this.px = this.rx = this.rx + activeData.a;
				this.py = this.ry = this.ry + activeData.b;
				break;
			}
			case 5: {
				this.px = this.rx = this._character.px + path.a;
				this.py = this.ry = this._character.py + path.b;
				break;
			}
			default: break;
		}
	}
};

Game_Bullet.prototype.getPathType = function(data, path) {
	if(path.type !== -1) {
		return path.type;
	}
	return data.type;
};

Game_Bullet.prototype.getPathActiveData = function(data, path) {
	const key = path.end;
	if(!this._pathActiveDatas[key]) {
		this._pathActiveDatas[key] = this.initPathActiveData(data, path);
	}
	return this._pathActiveDatas[key];
};

Game_Bullet.prototype.initPathActiveData = function(data, path) {
	switch(this.getPathType(data, path)) {
		case 1: {
			this._vx = Math.random() * (path.g - path.b) + path.b;
			if(path.h) {
				this._vx *= this._direction;
			}
			this._vy = Math.random() * (path.d - path.e) + path.e;
			break;
		}
		case 2: {
			const speed = path.a;
			const dx = $gamePlayer.px - this.px;
			const dy = $gamePlayer.py - ($gamePlayer.hitOffsetB() + $gamePlayer.hitOffsetT()) / 2 - this.py;
			let initData = null;
			if(dx === 0 && dy === 0) {
				initData = {a:Math.sqrt(speed), b:Math.sqrt(speed)};
			} else if(dx === 0) {
				initData = {a:0, b:speed*Utils.sign(dy)};
			} else if(dy === 0) {
				initData = {a:speed*Utils.sign(dx), b:0};
			} else {
				const d = Math.atan(Math.abs(dx / dy));
				initData = {a:Utils.sign(dx) * speed * Math.sin(d), b:Utils.sign(dy) * speed * Math.cos(d)};
			}
			this.orderRotationInitAB(initData);
			return initData;
		}
		case 3: {
			const speed = path.a;
			let initData = {a:0, b:speed};
			this.orderRotationInitAB(initData);
			return initData;
		}
		case 4: {
			const speed = path.a;
			const d = Math.sqrt(Math.pow(this._character._bodyAttackParameterA, 2) + Math.pow(this._character._bodyAttackParameterB, 2));
			const a = speed * this._character._bodyAttackParameterA / d;
			const b = speed * this._character._bodyAttackParameterB / d;
			this.setRotation(Utils.rotationDXDY(this._character._bodyAttackParameterA, this._character._bodyAttackParameterB));
			return {a:a, b:b};
		}
	}
	return {};
};

Game_Bullet.prototype.orderRotationInitAB = function(initData) {
	const rotation = this._creationOrder / this._parentBulletDuplicateNum * Math.PI * 2;
	const rotationX = initData.a * Math.cos(rotation) + initData.b * Math.sin(rotation);
	const rotationY = -initData.a * Math.sin(rotation) + initData.b * Math.cos(rotation);
	initData.a = rotationX;
	initData.b = rotationY;
};

Game_Bullet.prototype.getAttackTime = function(data) {
	for(const time of data.attackTime) {
		if(this._time >= time.start && this._time <= time.end) {
			return time;
		}
	}
	return null;
};

Game_Bullet.prototype.getPath = function(data) {
	for(const one of data.path) {
		if(this._time >= one.start && this._time <= one.end) {
			return one;
		}
	}
	return null;
};

Game_Bullet.prototype.updateHit = function(info) {
	const hit = $gameMap.hitTest(this, $gameMap._physicsGrid, false);
	const data = this.data();
	if(hit) {
		for(const obj of hit) {
			if(!$gameMap.checkSameTeam(this, obj) && !this.isInAttackInterval(obj) && obj.battleObject() && !obj.isInvincible() && (!obj.fix || !obj.battleObject().unlimitHp)) {
				const vertices = this.vertices.map((p) => { return {x:p.x+this.px, y:p.y+this.py}; });
				const effectPos = obj.randAttackPos(vertices);
				if(!data.latestAttackingCounterDamageScale) {		// 根据创建该bullet的技能的上一个技能的发动时间来决定伤害
					this._character.onBulletHit(new Game_BodyOnHit(data.onHit, this), obj, effectPos);
				} else {
					const oldScale = this._character._bodyAttackExtensions.atkUp;
					const upVal = Math.max(0.1, Math.min(Math.pow(this._latestBodyAttackingLaunchFrame / data.latestAttackingCounterDamageScale, 3), 1)) - 1;
					this._character._bodyAttackExtensions.atkUp = upVal;
					this._character.onBulletHit(new Game_BodyOnHit(data.onHit, this), obj, effectPos);
					this._character._bodyAttackExtensions.atkUp = oldScale;
				}
				this._hitObjCd.push({time: info.interval, obj:obj});
			}
		}
	}
};

Game_Bullet.prototype.isInAttackInterval = function(obj) {
	return this._hitObjCd.some((cd) => { return cd.obj === obj; });
};

Game_Bullet.prototype.updateAttackInterval = function() {
	this._hitObjCd = this._hitObjCd.filter((cd) => {
		cd.time--;
		if(cd.time <= 0) {
			return false;
		}
		return true;
	});
};

Game_Event.prototype.resetHitOffset = function() {
	if(this.battleObject() && this.battleObject().hitRect && !this.vertices) {
		this.setHitRect(this.battleObject().hitRect);
	} else {
		Game_CharacterBase.prototype.resetHitOffset.call(this);
	}
};

Game_Bullet.prototype.screenX = function() {
	return -$gameMap.displayX() * $gameMap.tileWidth() + this.px;
};

Game_Bullet.prototype.screenY = function() {
	return -$gameMap.displayY() * $gameMap.tileHeight() + this.py;
};

Game_Bullet.prototype.isUpperBullet = function() {
	return this.data().upper;
};

Game_Bullet.prototype.setLatestAttackingLaunchFrame = function(counter) {
	this._latestBodyAttackingLaunchFrame = counter;
};

Game_Event.prototype.resizeHp = function(rate) {
	this.battleObject().hp = this.battleObject().mhp = Math.round(this.battleObject().mhp * rate);
};

NYA.STATEM.Game_Event_setupPageSettings = Game_Event.prototype.setupPageSettings;
Game_Event.prototype.setupPageSettings = function() {
	NYA.STATEM.Game_Event_setupPageSettings.apply(this, arguments);
	this.clearBattleObject();
	this.clearLight();
	const page = this.page();
	if(page) {
		for(const command of page.list) {
			if(command.code === 357) {
				const para = command.parameters;
				if(para[0] === "NYA.EVENT.AI_Adapter") {
					switch(para[1]) {
						case "ai": {
							const ai = para[3];
							this.physics = true;
							this.fix = ai.fix === "true" ? true : false;
							this.searchSmoothFloorOutside = ai.smoothfloor === "true" ? true : false;
							this._statemType = ai.type;
							const battleObjectId = Utils.tryParseInt(ai.battleObject);
							if(battleObjectId !== 0) { 
								this.initBattleObject(battleObjectId);
							}
							const direction = Utils.tryParseInt(ai.direction, 4);
							this.setDirection(direction);
							this._skipFloorSearch = ai.skipSmoothfloor === "true" ? true : false;
							break;
						}
						case "terrain_damage": {
							const info = para[3];
							const damage = Utils.tryParseInt(info.damage);
							const staggerTime = Utils.tryParseInt(info.staggerTime);
							const fx = Utils.tryParseInt(info.fx);
							const fy = Utils.tryParseInt(info.fy);
							const alive = info.alive === "true" ? true : false;
							const mirror = info.mirror === "true" ? true : false;
							const real = info.real === "true" ? true : false;
							const moveBack = info.moveBack === "true";
							this.triggerDamage = {damage:damage, staggerTime:staggerTime, fx:fx, fy:fy, alive:alive, mirror:mirror, real:real, moveBack:moveBack};
							break;
						}
						case "attach_vertices": {
							const info = para[3];
							const verticesId = Utils.tryParseInt(info.verticesId);
							this._preventAutoPhAnchor = true;
							const verticesInfo = $gameMap.getExternalVertices(verticesId);
							const vertices = verticesInfo.vertices;
							this.px = this.rx = verticesInfo.ox;
							this.py = this.ry = verticesInfo.oy;
							this.setVertices(vertices);
							break;
						}
						case "eventOffset": {
							const info = para[3];
							const ox = Utils.tryParseInt(info.ox);
							const oy = Utils.tryParseInt(info.oy);
							this.rx = this.px = this.px + ox;
							this.ry = this.py = this.py + oy;
							break;
						}
						case "setPath": {
							const info = para[3];
							const path = [];
							if(info.x1 !== "0" || info.y1 !== "0" || info.smooth1 !== "0") {
								path.push({x:parseInt(info.x1), y:parseInt(info.y1), smooth:parseInt(info.smooth1)});
							}
							if(info.x2 !== "0" || info.y2 !== "0" || info.smooth2 !== "0") {
								path.push({x:parseInt(info.x2), y:parseInt(info.y2), smooth:parseInt(info.smooth2)});
							}
							if(info.x3 !== "0" || info.y3 !== "0" || info.smooth3 !== "0") {
								path.push({x:parseInt(info.x3), y:parseInt(info.y3), smooth:parseInt(info.smooth3)});
							}
							if(info.x4 !== "0" || info.y4 !== "0" || info.smooth4 !== "0") {
								path.push({x:parseInt(info.x4), y:parseInt(info.y4), smooth:parseInt(info.smooth4)});
							}
							if(info.x5 !== "0" || info.y5 !== "0" || info.smooth5 !== "0") {
								path.push({x:parseInt(info.x5), y:parseInt(info.y5), smooth:parseInt(info.smooth5)});
							}
							this.battleObject().targets = path;
							this.battleObject().maxWaiting = info.maxWaiting === "0" ? 400 : parseInt(info.maxWaiting);
							this.battleObject().minWaiting = info.minWaiting === "0" ? 1060 : parseInt(info.minWaiting);
							break;
						}
						case "setBattleObjectPara": {
							const info = para[3];
							const obj = this.battleObject();
							if(typeof obj[info.name] === "number") {
								obj[info.name] = Utils.tryParseNumber(info.para);
							} else {
								obj[info.name] = JSON.parse(info.para);
							}
							break;
						}
						case "setLight": {
							const info = para[3];
						    const r = Utils.tryParseNumber(info.r);
							const g = Utils.tryParseNumber(info.g);
							const b = Utils.tryParseNumber(info.b);
							const max = Utils.tryParseNumber(info.max, 0.0);
							const radius = Utils.tryParseInt(info.radius);
							const upper = Utils.tryParseBoolean(info.upper);
							const night = Utils.tryParseBoolean(info.night);
							const type = info.type;
							if(upper && type === "0") {
								this.setUpperLightingMultiply({r:r,g:g,b:b,max:max,radius:radius,night:night});
							} else if(!upper && type === "0") {
								this.setLowerLightingMultiply({r:r,g:g,b:b,max:max,radius:radius,night:night});
							} else if(upper && type === "1") {
								this.setUpperLightingAdd({r:r,g:g,b:b,max:max,radius:radius,night:night});
							} else if(!upper && type === "1") {
								this.setLowerLightingAdd({r:r,g:g,b:b,max:max,radius:radius,night:night});
							}
							break;
						}
					}
				}
			}
		}
		if(this.statemType()) {
			this.initStatemMembers(this.statemMembers());
		}
		this.executeFloorSearch();
	}
};

Game_CharacterBase.prototype.executeFloorSearch = function() {
	if(!this._physics || this._skipFloorSearch) {
		return;
	}
	let i = 0;
	if(this.searchSmoothFloorOutside) {
		while(i < $gameMap.tileHeight()) {
			i++;
			if(this.hitPreview(0, i)) {
				this.py = this.ry = this.py + i - 1;
				return;
			}
		}
	} else {
		while(i < $gameMap.tileHeight()) {
			if(!this.hitPreview(0, -i)) {
				this.py = this.ry = this.py - i;
				return;
			}
			i++;
		}
	}
};

NYA.STATEM.Game_Event_clearPageSettings = Game_Event.prototype.clearPageSettings;
Game_Event.prototype.clearPageSettings = function() {
	NYA.STATEM.Game_Event_clearPageSettings.apply(this, arguments);
	this.clearBattleObject();
	this.clearLight();
};

Game_Event.prototype.clearBattleObject = function() {
	this.physics = false;
	this._statemType = 0;
	this.fix = false;
	this._statemMembers = {};
};

NYA.STATEM.CONST = {};

// statem 1
NYA.STATEM.CONST.STATE_LEFT = 1;
NYA.STATEM.CONST.STATE_RIGHT = 0;

NYA.STATEM.CONST.STATE_UP = 0;
NYA.STATEM.CONST.STATE_DOWN = 1;

const S = NYA.STATEM.CONST;

NYA.STATEM.Game_Event_initMembers = Game_Event.prototype.initMembers;
Game_Event.prototype.initMembers = function() {
	NYA.STATEM.Game_Event_initMembers.apply(this, arguments);
	this._statemType = 0;
	this._statemPara = [];
	this._statemMembers = {};
	this._statemPause = false;		// 一些剧情演出上需要暂停事件的AI逻辑，由剧情演出自身控制
	this._playerAttached = false;	// 
	this._zxcOnce = false;
	this._immueFixObject = false;
};

Game_Event.prototype.statemType = function() {
	return this._statemType;
};

Game_Event.prototype.statemMembers = function() {
	return this._statemMembers;
};

Game_Event.prototype.statemPara = function(idx) {
	return this._statemPara[idx];
};

Game_Event.prototype.initStatemMembers = function(members) {
	switch(this.statemType()) {
		case 0: break;
		default: this["initStatemMembers" + this.statemType()](members);
	}
};

Game_Event.prototype.doPState = function(state) {
	Game_CharacterBase.prototype.doPState.apply(this, arguments);
	const members = this.statemMembers();
	if(this._statemPause) {
		this.commonCommandDoPState(members, state);
		return;
	}
	switch(this.statemType()) {
		case 0: break;
		default: this["doPState" + this.statemType()](members, state);
	}
};

Game_Event.prototype.doPStateChange = function(oldState, newState) {
	Game_CharacterBase.prototype.doPStateChange.apply(this, arguments);
	switch(this.statemType()) {
		case 0: break;
		default: this["doPStateChange" + this.statemType()](this.statemMembers(), oldState, newState);
	}
};

Game_Event.prototype.detectState = function() {
	Game_CharacterBase.prototype.detectState.apply(this, arguments);
	const type = this.statemType();
	const members = this.statemMembers();
	switch(type) {
		case 0: break;
		default: this["detectState" + type](members);
	}
};

Game_Event.prototype.pauseStatem = function() {
	this._statemPause = true;
};

Game_Event.prototype.resumeStatem = function() {
	this._statemPause = false;
};

Game_Event.prototype.commonCommandDoPState = function(members, state) {
	const command = members._commonCommand;
	if(command) {
		const name = command.name;
		switch(name) {
			case "moveTo": {
				const x = command.x;
				const y = command.y;
				const dir = command.direction;
				if(this.isPointIn(x, y)) {
					this.setDirection(dir);
					this.delCommonCommand(members);
				} else if(!this.isXIn(x)) {
					const dir = this.px > x ? 4 : 6;
					this.commonDirectionMove(dir);
					if(this.isGrounding() && this.py - this.hitOffsetT() + this.hitOffsetB() > y) {
						this.vy = this.battleObject().jumpStrength;
					}
				}
				break;
			}
			case "moveToAdvance": {
				const x = command.x;
				const y = command.y;
				const dir = command.direction;
				const gridWidth = command.gridWidth;
				const gridHeight = command.gridHeight;
				if(this.checkInProperGridPathGoal(x, y, $gameMap.tileWidth(), $gameMap.tileHeight())) {
					this.setDirection(dir);
					this.delCommonCommand(members);
				} else {
					this.processFinderResult(this.findPathTo(x, y, $gameMap.tileWidth() / 2, $gameMap.tileHeight() / 2, members, gridWidth, gridHeight));
				}
				break;
			}
			case "moveToScreenEdge": {
				if(this.isXOutOfScreen() || (this.impactObject() && (this.impactObject().type === 3 || this.impactObject().type === 4))) {
					this.delCommonCommand(members);
					this.erase();
				} else {
					const dir = command.direction;
					this.commonDirectionMove(dir);
					if(this.isGrounding() && this.impactObject() && this._impactDirection === 0) {
						this.vy = this.battleObject().jumpStrength;
					}
				}
				break;
			}
			default: this.delCommonCommand(members); break;
		}
	}
};

Game_Event.prototype.delCommonCommand = function(members) {
	members._commonCommand = null;
};

Game_Event.prototype.setCommonCommand = function(name, para) {
	const members = this.statemMembers();
	members._commonCommand = {};
	members._commonCommand.name = name;
	Object.assign(members._commonCommand, para);
};

NYA.STATEM.Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
	NYA.STATEM.Game_Map_initialize.apply(this, arguments);
	this._specialCircleHit = [];
};

NYA.STATEM.Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function() {
	NYA.STATEM.Game_Map_setup.apply(this, arguments);
	this._specialCircleHit = [];
};

NYA.STATEM.Game_Map_updatePhysicsOther = Game_Map.prototype.updatePhysicsOther;
Game_Map.prototype.updatePhysicsOther = function() {
	NYA.STATEM.Game_Map_updatePhysicsOther.call(this);
	this.updateSpecialCircleHit();
};

Game_Map.prototype.addSpecialCircleHit = function(evid, specailHitFlag) {
	this._specialCircleHit.push({id:evid, time:0, flag:specailHitFlag});
};

Game_Map.prototype.updateSpecialCircleHit = function() {
	const delObj = [];
	this._specialCircleHit = this._specialCircleHit.filter((obj) => {
		if(obj.time < this.circleHitDelayTime()) {
			obj.time++;
			return true;
		} 
		delObj.push(obj);
		return false;
	});
	for(const obj of delObj) {
		const evid = obj.id;
		const event = $gameMap.event(evid);
		this.requestCircleHit(event, obj.flag);
	}
};

Game_Map.prototype.circleHitDelayTime = function() {
	return 6;
};

Game_Map.prototype.requestCircleHit = function(event, flag) {
	const hit = AttackFrame.info("fake_terrain").hit[0];
	event.bodyAttackHit(new Game_BodyHit(hit));
};

Game_Map.prototype.checkSameTeam = function(obj1, obj2) {
	return obj1.checkSameTeam(obj2);
};

Game_CharacterBase.prototype.checkSameTeam = function(obj) {
	const team1 = this.battleTeam();
	const team2 = obj.battleTeam();
	if(team1 === -2 || team2 === -2) {		// 中立，-2对于所有人都是友方，适用于NPC
		return true;
	}
	if(team1 === -1 || team2 === -1) {		// 混战，-1为除了自己其他所有人都是敌方
		return false;
	}
	return team2 === team1; 
};

Game_Player.prototype.checkSameTeam = function(obj) {
	if(obj === $gameLily && !$gameMap.isEventRunning()) {
		return false;
	} else {
		return Game_CharacterBase.prototype.checkSameTeam.apply(this, arguments);
	}
};

Game_CharacterBase.prototype.updateTerrainDamage = function() {
	if(this.terrainDamageCD) {
		this.terrainDamageCD--;
	} else {
		const obj = this.selectTerrainDamageObject();
		if(obj) {
			this.performTerrainDamage(obj);
		}
	}
	if(this.triggerDamage) {
		const obj = this._groundHitObj || this.impactObject();
		if(obj && !obj.terrainDamageCD && obj.battleObject()) {
			obj.performTerrainDamage(this);
		}
	}
	if(this._delayRevertToLastGroundingPosTime) {
		this._delayRevertToLastGroundingPosTime--;
		if(this._delayRevertToLastGroundingPosTime === 0 && !this.isDeath()) {
			this.revertToLastGroundingPos();
			this.requestAnimation(51, {staticPosition:true, x:this.physicsCenterX(), y:this.py, z:this.screenZ()});
		}
	}
};

Game_CharacterBase.prototype.selectTerrainDamageObject = function() {
	if(this._groundHitObj && this._groundHitObj.triggerDamage) {
		return this._groundHitObj;
	}
	if(this.impactObject() && this.impactObject().triggerDamage) {
		return this.impactObject();
	}
	return null;
};

Game_CharacterBase.prototype.performTerrainDamage = function(obj) {
	const alive = obj.triggerDamage.alive;
	const fx = obj.triggerDamage.mirror ? (this._mirrorLR ? -obj.triggerDamage.fx : obj.triggerDamage.fx) : obj.triggerDamage.fx;
	const fy = obj.triggerDamage.fy;
	const damage = obj.triggerDamage.damage;
	const staggerTime = obj.triggerDamage.staggerTime;
	const real = obj.triggerDamage.real;
	const back = obj.triggerDamage.moveBack;
	if(!$gameMap.checkSameTeam(obj, this) && (!alive || !obj.isDeath())) {
		this.terrainDamageCD = 30;
		const team = this.battleTeam();
		if(back && !this.isInWater()) {
			//坠落坑，中立生物不受伤害，敌对生物会被秒杀，友方生物受到damage伤害
			this._staggerTime = staggerTime;
			if(team === 0) {
				this.requestNormalDamage(damage);
			} else if(team !== -2) {
				this.requestNormalDamage(this.battleObject().mhp);
			}
			this._delayRevertToLastGroundingPosTime = Math.round(staggerTime / 2);
		} else {
			// 一般地形伤害，中立生物不受伤害，敌对生物不受伤害，友方生物受到damage伤害
			if(team === 0) {
				if(real) {
					this.requestRealDamage(damage, staggerTime);
				} else {
					this.requestNormalDamage(damage, staggerTime);
				}
			}
		}
	}
};

Game_Map.prototype.allEventCommandComplete = function() {
	return this._physicsDynamicObject.every((character) => {
		if(character.constructor === Game_Event) {
			return !character.statemMembers()._commonCommand;
		}
		return true;
	});
};

NYA.STATEM.Game_Player_locate = Game_Player.prototype.locate;
Game_Player.prototype.locate = function() {
	NYA.STATEM.Game_Player_locate.apply(this, arguments);
	this.executeFloorSearch();
	$gameMap.syncCamera();
	this.initTerrainGrounding();
};

Game_CharacterBase.prototype.isCharacterInRect = function(ch, l, t, r, b) {
	return ch.px >= this.px - l && ch.px <= this.px + r && ch.py >= this.py - t && ch.py <= this.py + b;
};

function Game_BodyHit() {
	this.initialize(...arguments);
}

Game_BodyHit.prototype.initialize = function(hit) {
	this.metaData = hit;
	this.time = hit.time;
	this.delay = hit.delay;
	this.onHit = new Game_BodyOnHit(hit.onHit);
};

function Game_BodyOnHit() {
	this.initialize(...arguments);
}

Game_BodyOnHit.prototype.initialize = function(onHit, bulletOwner) {
	this.hitObjs = [];
	this.hitCDObjs = [];
	this.firstHitObj = null;
	this.bulletOwner = bulletOwner;
	this.metaData = onHit;
};

Game_BodyOnHit.prototype.updateHitObjCD = function() {
	this.hitCDObjs = this.hitCDObjs.filter((obj) => {
		if(obj.time) {
			obj.time--;
			return true;
		}
		return false;
	});
};

Game_BodyOnHit.prototype.isObjectInHitCD = function(character) {
	for(const obj of this.hitCDObjs) {
		if(character.eventId() == obj.id) {
			return true;
		}
	}
	return false;
};

Game_BodyOnHit.prototype.enterObjectHitCD = function(character) {
	this.hitCDObjs.push({id:character.eventId(),time:this.metaData.hitCDTime});
};

function Game_BulletCreate() {
	this.initialize(...arguments);
}

Game_BulletCreate.prototype.initialize = function(data) {
	this.created = false;
	this.delay = data.delay;
	this.metaData = data;
};

Game_CharacterBase.prototype.onMushroomHit = function() {
};

Game_Player.prototype.onMushroomHit = function() {
	this.frameJump = false;
	this.useDoubleJump = false;
	if(this._bodyAttacking === "dash" || this._bodyAttacking === "reverse_dash" || this._bodyAttacking === "zxc_fish3" ||
		this._bodyAttacking === "dash_through" || this._bodyAttacking === "reverse_dash_through" ||
		this._bodyAttacking === "toru_dash_attack_p" || this._bodyAttacking === "toru_reverse_dash_attack_p" ||
		this._bodyAttacking === "toru_dash_attack_p_through" || this._bodyAttacking === "toru_reverse_dash_attack_p_through") {
		this.endBodyAttack(false);
	}
};

Game_CharacterBase.prototype.updateFallDown = function() {
	if(this._impact && this._impact.constructor === Game_Terrain) {
		if(this._impact.type === 2) {
			this.requestRemove();
		}
	}
};

Game_Player.prototype.updateFallDown = function() {
	if(this._impact && this._impact.constructor === Game_Terrain && !this.isTransferring()) {
		if(this._impact.type === 2) {
			this.revertToLastGroundingPos();
			this.requestStagger(35);
			AudioManager.playPlayerRoundSe(this, "player_fall");
		}
	}
};

Game_Event.prototype.revertToLastGroundingPos = function() {
	const prevFallDownReset = this.battleObject().fallDownReset;
	const hp = this.battleObject().hp;
	this.locate(this.event().x, this.event().y);
	this.setupPage();
	let maxTry = 0;
	const py = this.py;
	while(this.hitPreviewNoVGround() && maxTry < 8) {
		this.ry = this.py = this.py - $gameMap.tileHeight();
		maxTry++;
	}
	if(maxTry === 8) {
		this.ry = this.py = py;
	}
	this.battleObject().hp = hp;
	this.battleObject().fallDownReset = prevFallDownReset;
};

Game_Event.prototype.updateFallDown = function() {
	if(this._impact && this._impact.constructor === Game_Terrain) {
		if(this._impact.type === 2) {
			if(this.battleObject() && this.battleObject().fallDownReset) {
				this.revertToLastGroundingPos();
				this.battleObject().fallDownSe && AudioManager.playPlayerRoundSe(this, this.battleObject().fallDownSe);
				if(this.battleObject().fallDownCommonEventId) {
					$gameTemp.reserveCommonEvent(this.battleObject().fallDownCommonEventId);
				}
			} else {
				this.requestRemove();
				this.battleObject().hp = 0;
				this.erase();
			}
		}
	}
};

Game_CharacterBase.prototype.makeSquash = function(time) {
	this._squashTime = time;
};

Game_CharacterBase.prototype.isSquash = function() {
	return this._squashTime > 0;
};

Game_CharacterBase.prototype.updateSquash = function() {
	if(this.isSquash()) {
		if(this._squashTime === 1) {
			if(!this.resumeSquashRect()) {
				return;
			}
		}
		this._squashTime--;
	}
};

Game_CharacterBase.prototype.requestSquashEffect = function() {
	if(!this.battleObject().immueSquash) {
		this.makeSquash(600);
		this.battleObject().addBuff("atk_down", 600, 0.5, false);
		this.battleObject().addBuff("jump_down", 600, 0.3, false);
		this.battleObject().addBuff("mov_down", 600, 0.3, false);
		const rect = this.battleObject().hitRect;
		this.setHitRect({l:rect.l, t:rect.t/2, r:rect.r, b:rect.b/2});
		AudioManager.playPlayerRoundSe(this, "squash");
	}
};

Game_Player.prototype.requestSquashEffect = function() {
	Game_CharacterBase.prototype.requestSquashEffect.call(this);
	$gameScreen.startShake(4, 20, 30);
};

Game_CharacterBase.prototype.resumeSquashRect = function() {
	const rect = this.battleObject().hitRect;
	this.setHitRect(rect);
	this.setImmueVground(true);
	const result = !this.hitPreviewNoVGround();
	this.setImmueVground(false);
	if(!result) {
		this.setHitRect({l:rect.l, t:rect.t/2, r:rect.r, b:rect.b/2});
	}
	return result;
};

Game_CharacterBase.prototype.modifyVerticesForSquash = function(vertices) {
	const y = this.py + this.hitOffsetB();
	return vertices.map((p) => {
		return {x:p.x, y:p.y + (y - p.y) / 2};
	});
};

Game_CharacterBase.prototype.setDefenceShieldEffect = function(val, se = true) {
	const old = this._defenceShieldEffect;
	this._defenceShieldEffect = val;
	if(!se) {
		return;
	}
	if(!old && val) {
		AudioManager.playPlayerRoundSe(this, 'Raise3');
	} else if(old && !val) {
		AudioManager.playPlayerRoundSe(this, 'shield_close');
	}
};

Game_CharacterBase.prototype.isShieldEffect = function() {
	return this._defenceShieldEffect;
};

Game_Player.prototype.updateDefenceShieldOrnaments = function() {
	if(!this.isShieldEffect()) {
		if(this._shieldEffectCounter > 0) {
			this._shieldEffectCounter--;
		} else if(this.actor().isDefenceShieldOrnaments()) {
			this.setDefenceShieldEffect(true);
		}
	} else if(!this.actor().isDefenceShieldOrnaments()) {
		this.setDefenceShieldEffect(false, false);
	}
};

Game_CharacterBase.prototype.setNoControlTime = function(time) {
	this._noControlTime = time;
};

Game_CharacterBase.prototype.enableTempFriction = function(val, time) {
	if(this._tempFrictionTime === 0) {
		this._tempAirFriction = this._airfriction;
		this._tempFriction = this._friction;
		this._tempFrictionTime = time;
		this.setAirFriction(val);
		this.setFriction(val);
	} else {
		this._tempFrictionTime = time;
	}
};

Game_CharacterBase.prototype.updateTempFriction = function() {
	if(this._tempFrictionTime > 0) {
		this._tempFrictionTime--;
		if(this._tempFrictionTime === 0) {
			this.setAirFriction(this._tempAirFriction);
			this.setFriction(this._tempFriction);
		}
	}
};

Game_Player.prototype.updateBowOrnaments = function() {
	if(this.isGrounding() && this._impact && this._impactvy && (this._impact.terrain || this._impact.fix)) {
		const actor = this.actor();
		if(actor.isBowOrnaments()) {
			for(const obj of $gameMap._physicsDynamicObject) {
				if(obj !== this && !obj.isDeath() && !$gameMap.checkSameTeam(this, obj) && obj.py + obj.hitOffsetB() === this.py + this.hitOffsetB()) {
					const maxDistance = 48;
					const minDistance = 240;
					const dx = Math.abs(obj.px - this.px).clamp(maxDistance, minDistance);
					const basex = 4;
					const basey = -2.5;
					const baseNoControlTime = 35;
					const rate = (minDistance - dx) / (minDistance - maxDistance);
					if(rate > 0) {
						const rate2 = Math.sqrt(rate);
						obj.impu(obj.px > this.px ? basex * rate2 : -basex * rate2, basey * rate2);
						obj.setNoControlTime(Math.trunc(baseNoControlTime * rate2));
						obj.requestNormalDamage(5);
					}
				}
			}
			this.requestAnimation(9, {staticPosition:true, x:this.px, y:this.py});
		}
	}
};

Game_CharacterBase.prototype.pixelDistanceToPlayer = function() {
	return this.pixelDistanceToCharacter($gamePlayer);
};

Game_CharacterBase.prototype.pixelDistanceToCharacter = function(character) {
	return $gameMap.pixelDistance(this.px, this.py, character.px, character.py);
};

Game_Player.prototype.isAttachAnyEvent = function() {
	for(const event of $gameMap._physicsDynamicObject) {
		if(event.battleObject()) {
			const distance = event.battleObject().playerAttachDistance;
			if(distance) {
				const playerDistance = event.pixelDistanceToPlayer();
				if(playerDistance < distance) {
					return true;
				}
			}
		}
	}
	return false;
};

Game_Player.prototype.updateFootStepSe = function(state) {
	switch(state) {
		case 1: case 8: {
			if(this._groundHitObj && this._groundHitObj.terrain && this._groundHitObj.footstepId) {
				AudioManager.playRandLoopSe(this._groundHitObj.footstepId);
				return;
			}
		}
	}
	AudioManager.stopRandLoopSe(AudioManager.RL_PLAYER_FOOTSTEP);
};

Game_CharacterBase.prototype.isNoHpSmallBar = function() {
	return this._isNoHpSmallBar;
};

Game_CharacterBase.prototype.setNoHpSmallBar = function(val) {
	this._isNoHpSmallBar = val;
};

Game_CharacterBase.prototype.faceToPlayer = function() {
	this.faceToCharacter($gamePlayer);
};

Game_CharacterBase.prototype.faceToCharacter = function(character) {
	this.setDirection(character.px - this.px > 0 ? 6 : 4);
};

Game_CharacterBase.prototype.backToCharacter = function(character) {
	this.setDirection(character.px - this.px > 0 ? 4 : 6);
};

Game_CharacterBase.prototype.backToPlayer = function() {
	this.backToCharacter($gamePlayer);
};

Game_CharacterBase.prototype.setMoveSuspendFriction = function(val) {
	this._moveSuspendFriction = val;
};

Game_CharacterBase.prototype.pollMoveSuspendFriction = function() {
	if(this._moveSuspendFriction) {
		this._moveSuspendFriction = false;
		return true;
	}
	return false;
};

Game_CharacterBase.prototype.updateMoveSimple = function(isTriggerLeft, speedAdd = 1, noDirectionSet = false, moveStrengthAdd = 1) {
	const moveStrength = this.battleObject().moveStrength * moveStrengthAdd;
	const maxMoveSpeed = this.battleObject().maxMoveSpeed * speedAdd;
	this.performMove(moveStrength, maxMoveSpeed, isTriggerLeft, !isTriggerLeft, noDirectionSet);
};

// 之所以有这个是因为要把事件的控制操作（攻击移动等）放在和玩家相同的位置，即detectState函数之前，否则这一帧触发的操作不会立刻生效，因为已经detectState过了
// 这可能导致一些机制的不正常，例如zxc出立绘cutscene时不显示第一帧动作
Game_Event.prototype.eventControl = function() {
};

// 让单位暂时无视碰撞
Game_CharacterBase.prototype.requestTemporaryPhysicsFlag1 = function() {
	if(!this._temporaryChangePhysicsFlag1) {
		this._originalPhysicsFlag = this._physicsFlag;
	}
	this._requestPhysicsFlag1 = true;
	this._temporaryChangePhysicsFlag1 = true;
};

Game_CharacterBase.prototype.cancelTemporaryPhysicsFlag1 = function() {
	this._requestPhysicsFlag1 = false;
};

// 让单位暂时无视碰撞（来自技能）
Game_CharacterBase.prototype.requestSkillTemporaryPhysicsFlag1 = function() {
	if(!this._temporaryChangePhysicsFlag1) {
		this._originalPhysicsFlag = this._physicsFlag;
	}
	this._skillRequestPhysicsFlag1 = true;
	this._temporaryChangePhysicsFlag1 = true;
};

Game_CharacterBase.prototype.cancelSkillTemporaryPhysicsFlag1 = function() {
	this._skillRequestPhysicsFlag1 = false;
};

Game_CharacterBase.prototype.isTemporaryPhysicsFlag1 = function() {
	return this._skillRequestPhysicsFlag1 || this._requestPhysicsFlag1;
};

Game_CharacterBase.prototype.updateTemporaryPhysicsFlag1 = function() {
	if(this.isTemporaryPhysicsFlag1()) {
		this._physicsFlag = 5;
	} else if(this._temporaryChangePhysicsFlag1) {
		this._physicsFlag = this._originalPhysicsFlag;
		if(!this.hitPreviewNoVGround()) {
			this._temporaryChangePhysicsFlag1 = false;
		} else {
			this._physicsFlag = 5;
		}
	}
};

// 计算当前地图所有对象产生的吸力，有些怪攻击会产生吸引力
Game_CharacterBase.prototype.attackDragFx = function() {
	if(!$gameMap._physicsDynamicObject || this.battleObject().noHotEvent) {
		return 0;
	}
	if(this.isBodyAttacking()) {
		const currentInfo = AttackFrame.info(this._bodyAttacking);
		if(currentInfo.enableFx) {
			return 0;
		}
	}
	let result = 0;
	for(const character of $gameMap._physicsDynamicObject) {
		if(this !== character && character.isBodyAttacking()) {
			const info = AttackFrame.info(character._bodyAttacking);
			if(info.specialAction === "drag_fx") {
				for(const hit of character._bodyHit) {
					if(!hit.delay && (hit.time || hit.time === -1)) {
						const fx = hit.onHit.metaData.fx;
						const f = this.calcDragFx(character, fx);
						result += f;
					}
				}
			}
		}
		const fixFx = character.dragFx();
		if(fixFx && !$gameMap.checkSameTeam(character, this)) {
			result += this.calcDragFx(character, fixFx);
		}
	}
	return result;
};

Game_CharacterBase.prototype.calcDragFx = function(character, fx) {
	const distanceX = Math.abs(this.px - character.px);
	return distanceX < fx * 2 ? 0 : (character.px > this.px ? fx : -fx);
};

// 重写后在存活期间持续对周围产生吸力
Game_CharacterBase.prototype.dragFx = function() {
	return 0;
};

Game_CharacterBase.prototype.updateAttackDragFx = function() {
	if(this.battleObject() && !this.fix && !this._moveSuspendFriction) {
		const fx = this.attackDragFx();
		const vx = this.vx;
		if(fx < 0 && vx > fx || fx > 0 && vx < fx) {
			this.vx = fx;
			this.setMoveSuspendFriction(true);
		}
	}
};

Game_Player.prototype.savePointRecover = function() {
	if(this.battleObject().hp < this.battleObject().mhp) {
		this.battleObject()._hp += 5;
		this.battleObject()._hp = Math.min(this.battleObject()._hp, this.battleObject().mhp);
	}
	if(Graphics.frameCount % 15 === 0) {
		this.requestAnimation(16, {physicsPosition:true});
	}
};

Game_CharacterBase.prototype.findUpperEvent = function(res = []) {
	for(const character of (this.hitPreviewNoVGround(0, -1) || [])) {
		if(character.constructor === Game_Terrain) {
			continue;
		}
		if(!res.includes(character)) {
			res.push(character);
			character.findUpperEvent(res);
		}
	}
	return res;
};

// 寻找初始落脚点，解决进新房间没有任何落脚点直接掉坑里的问题
Game_Player.prototype.initTerrainGrounding = function() {
	this._terrainGroundingX = this.px;
	this._terrainGroundingY = this.py;
};

Game_CharacterBase.prototype.setSpecProgress = function(val) {
	this._specProgressVisible = true;
	this._specProgress = val;
};

Game_CharacterBase.prototype.specProgress = function() {
	return this._specProgress;
};

Game_CharacterBase.prototype.specProgressVisible = function() {
	return this._specProgressVisible;
};

Game_CharacterBase.prototype.clearSpecProgress = function() {
	this._specProgressVisible = false;
	this._specProgress = 0;
};

Game_CharacterBase.prototype.resetStatem = function() {
	this._pRealState = 0;
	this._pBufferState = -1;
	this._deathAnimationCompleted = false;
	this._deathFadeoutCounter = 0;
};

Game_Player.prototype.startRecordBossScore = function() {
	this._bossScoreUseConsumables = false;
	this._bossScoreUseOrnaments = false;
	this._bossScoreOnHit = false;
	this._bossScoreRecording = true;
	if($gameSystem.difficulty() === 1) {
		this.battleObject().delBuff("hp_resume_very_easy");
	}
};

Game_Player.prototype.updateBossScoreRecording = function() {
	if(this._bossScoreRecording) {
		if(!this._bossScoreUseOrnaments) {
			this._bossScoreUseOrnaments = this.actor()._ornaments.isAnyEquip();
		}
		if(!this._bossScoreUseConsumables) {
			this._bossScoreUseConsumables = this.battleObject().allBuff().some((buff) => {
				return buff.src === "consumables";
			});
		}
	}
};

Game_Player.prototype.triggerBossScoreOnHit = function() {
	if(this._bossScoreRecording && !this._bossScoreOnHit) {
		this._bossScoreOnHit = true;
	}
};

Game_Player.prototype.triggerBossScoreUseConsumables = function() {
	if(this._bossScoreRecording && !this._bossScoreUseConsumables) {
		this._bossScoreUseConsumables = true;
	}
};

Game_Player.prototype.endRecordBossScore = function(battleObjectId) {
	this._bossScoreRecording = false;
	const score = this.generateBossScore();
	if(!$gamePlayer.isDeath()) {
		ConfigManager.recordBossScore(battleObjectId, score);
		$gameMap.requestBossScorePopUp();
	}
};

Game_Player.prototype.generateBossScore = function() {
	if($gameSystem.difficulty() === 1) {
		if(!this._bossScoreOnHit && !this._bossScoreUseOrnaments && !this._bossScoreUseConsumables) {
			return 5;
		} else if(!this._bossScoreUseOrnaments && !this._bossScoreUseConsumables) {
			return 4;
		} else {
			return 3;
		}
	} else if($gameSystem.difficulty() === 0) {
		return 2;
	} else {
		return 1;
	}
};

Game_Player.prototype.updateInWater = function() {
	if(this.isInWater()) {
		this.refreshAir();
	}
};

// Game_Player -1
// Game_Lily -2
// Game_Event 1-999
// dynamicCharacter 1000+
Game_CharacterBase.prototype.eventId = function() {
	return this._linkId;
};

Game_CharacterBase.prototype.setLinkId = function(val) {
	this._linkId = val;
};

Game_Player.prototype.eventId = function() {
	return -1;
};

Game_CharacterBase.prototype.baseDoPStateChange = function(oldState, newState) {
	const obj = this.battleObject();
	switch(newState) {
		case 0: this.resetImage(obj.standingImage); break;
		case 1: case 2: case 3: case 4: case 5: this.resetImage(obj.movingImage); break;
		case 6: this.resetImage(obj.staggerImage); break;
		case 7: case 8: case 9: { 
			if(!this.normalAttackCompatibleStateGroup().includes(oldState)) {
				this.resetFrameAnimation(); 
			}
			this.setImage(this.preferAttackImage(newState));
			break;
		}
		default: this.resetImage(obj.movingImage); break;
	}
};

Game_CharacterBase.prototype.isXOutOfScreen = function() {
	const pw = this.patternWidth();
	const min = $gameMap.displayX() * $gameMap.tileWidth() - pw;
	const max = min + pw * 2 + Graphics.width;
	return this.px <= min || this.px >= max;
};

Game_CharacterBase.elasticSe = [[],["cloud_elastic1", "cloud_elastic2", "cloud_elastic3"]];

Game_CharacterBase.prototype.updateSpecialGrounding = function() {
	if(this.battleObject() && !this.isStagger()) {
		if(this._groundHitObj) {
			this.doSpecialElastic(this._groundHitObj, 1);
		} else if(this.impactObject() && this._impactDirection === 1) {
			this.doSpecialElastic(this.impactObject(), -1);
		}
	}
	if(this.elasticSeCd > 0) {
		this.elasticSeCd--;
	}
};

Game_CharacterBase.prototype.doSpecialElastic = function(tobj, dir) {
	const upElastic = tobj.upElasticWithJumpStrength();
	if(upElastic !== 0) {
		this._vy = upElastic * this.battleObject().jumpStrength * dir;
		if(!this.elasticSeCd && tobj.elasticSe) {
			AudioManager.playPlayerRoundSe(this, Game_CharacterBase.elasticSe[tobj.elasticSe].randomElement());
			this.elasticSeCd = 12;
		}
	}
};

Game_Player.prototype.doSpecialElastic = function(tobj, dir) {
	Game_CharacterBase.prototype.doSpecialElastic.apply(this, arguments);
	if(dir === 1) {
		const upElastic = tobj.upElasticWithJumpStrength();
		this._noGroundingInteract = upElastic !== 0;
	}
};

Game_CharacterBase.prototype.upElasticWithJumpStrength = function() {
	if(this.battleObject()) {
		return this.battleObject().upElasticWithJumpStrength | 0;
	}
};

Game_Terrain.prototype.upElasticWithJumpStrength = function() {
	return this.upElastic;
};


// 通用动态创建的独立物理对象
function Game_CharacterDynamicCreate() {
	this.initialize(...arguments);
}

Game_CharacterDynamicCreate.prototype = Object.create(Game_CharacterBase.prototype);
Game_CharacterDynamicCreate.prototype.constructor = Game_CharacterDynamicCreate;

Game_CharacterDynamicCreate.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.call(this);
	this._physics = true;
	this.initBattleObject();
};

Game_CharacterDynamicCreate.prototype.battleObject = function() {
	return this._battleObject;
};

Game_CharacterDynamicCreate.prototype.initBattleObject = function() {
	const templateId = this.battleObjectId();
	this._battleObject = new Game_BattleObject(templateId);
};

Game_CharacterDynamicCreate.prototype.battleObjectId = function() {
	return 0;
};

Game_CharacterDynamicCreate.prototype.updateDeathAnimation = function() {
	Game_CharacterBase.prototype.updateDeathAnimation.call(this);
	if(this.isDeath() && this.opacity() === 0 && !this.isRemove()) {
		this.requestRemove();
	}
};

Game_CharacterDynamicCreate.prototype.doPStateChange = function(oldState, newState) {
	Game_CharacterBase.prototype.doPStateChange.apply(this, arguments);
	this.baseDoPStateChange(...arguments);
};

Game_CharacterDynamicCreate.prototype.resetHitOffset = function() {
	if(this.vertices) {
		return;
	}
	this.setHitRect(this.battleObject().hitRect);
};

Game_Player.prototype.controlWeaponChange = function(actor) {
	if(Input.isStrictTriggered("cfish")) {
		this.setWeaponChange();
		actor.changeWeapon(actor.nextWeapon());
		AudioManager.playNormalSe("cfish");
	}
};

Game_Player.prototype.setWeaponChange = function() {
	this._weaponChangeRequest = true;
};

Game_Player.prototype.pollWeaponChange = function() {
	if(this._weaponChangeRequest) {
		this._weaponChangeRequest = false;
		return true;
	}
	return false;
};

function Game_BodyAttackExtensions() {
	this.initialize(...arguments);
}

Game_BodyAttackExtensions.prototype.initialize = function() {
	this.clear();
};

Game_BodyAttackExtensions.prototype.clear = function() {
	this.changePhysicsFlag = 0;
	this.staticAnimationId = 0;
	this.atkUp = 0;
};

NYA.STATEM.Game_Variables_clear = Game_Variables.prototype.clear;
Game_Variables.prototype.clear = function() {
	NYA.STATEM.Game_Variables_clear.apply(this, arguments);
	this._coinStoneData = {};
};

Game_Variables.prototype.getCoinStoneBeHitNum = function(mapId, eventId) {
	const id = this.coinStoneId(mapId, eventId);
	return this._coinStoneData[id] | 0;
};

Game_Variables.prototype.setCoinStoneBeHitNum = function(mapId, eventId, val) {
	const id = this.coinStoneId(mapId, eventId);
	this._coinStoneData[id] = val;
};

Game_Variables.prototype.coinStoneId = function(mapId, eventId) {
	return mapId * 1000 + eventId;
};

Game_Player.prototype.requestGetDown = function() {
	if(this.isSquash() || !this.isGrounding()) {
		return;
	}
	this._isGetDown = true;
	this.resetHitOffset();
};

Game_Player.prototype.resetHitOffset = function() {
	const rect = this.actor().hitRect();
	this._hitOffsetL = rect.l;
	this._hitOffsetR = rect.r;
	if(this._isGetDown) {
		this._hitOffsetB = rect.b / 2;
		this._hitOffsetT = rect.t / 2;
	} else {
		this._hitOffsetB = rect.b;
		this._hitOffsetT = rect.t;
	}
};

Game_Player.prototype.updateGetDown = function(left, right, up, down) {			// 按了左右键或者上键，打断，处于攻击状态，则判断该攻击是否打断趴下（写死），非浮空打断，被压瘪打断，被硬直也打断
	if(this._isGetDown) {
		const left = Input.isPressed('left') || TouchInput.isScreenButtonPressed('left');
		const right = Input.isPressed('right') || TouchInput.isScreenButtonPressed('right');
		const up = Input.isPressed('up') || TouchInput.isScreenButtonPressed('up');
		const down = Input.isPressed('down') || TouchInput.isScreenButtonPressed('down');
		const unlockMove = this.actor().isStoneUnlock(4);
		if(this.isStagger() || (!unlockMove && (left || right)) || up || !down || !this.isGrounding() || this.isSquash() || this.checkInBreakGetDownAttack()) {
			this._isGetDown = false;
			this.resetHitOffset();
			this.setImmueVground(true);
			const result = this.hitPreviewNoVGround();
			this.setImmueVground(false);
			if(result) {
				this._isGetDown = true;
				this.resetHitOffset();
			}
		}
	}
};

Game_Player.prototype.checkInBreakGetDownAttack = function() {
	if(this.isBodyAttacking()) {
		if(this._bodyAttacking !== "toru_get_down_normal") {
			return true;
		}
	}
	return false;
};

Game_Player.prototype.controlGetDown = function() {
	if(!this._isGetDown) {
		const down = Input.isPressed('down') || TouchInput.isScreenButtonPressed('down');
		if(down) {
			this.requestGetDown();
		}
	}
};

Game_CharacterBase.prototype.createBulletDirectly = function(x, y, name, creationOrder = 0, maxNum = 0) {
	const bullet = new Game_Bullet(name, x, y, this);
	const dir = this._mirrorLR ? -1 : 1;
	bullet.setDirection(dir);
	if(maxNum) {
		bullet.setCreationOrder(creationOrder, maxNum);
	}
	$gameMap.addBullet(bullet);
};

Game_CharacterBase.prototype.setCommonImage = function(name) {
	this.battleObject().standingImage = this.battleObject().movingImage = this.battleObject().staggerImage = name;
	this.resetImage(name);
};

Game_Player.prototype.isZPEnoughForZXC = function() {
	const zxcName = $gamePlayer.actor()._weapons.currentZXCName();
	const info = AttackFrame.info(zxcName);
	return this.battleObject().zp >= info.zp;
};


Game_Event.prototype.respawn = function() {
	this.physics = true;
	this._deathAnimationCompleted = false;
	this._deathFadeoutCounter = 0;
	this._staggerTime = 0;
	this.setOpacity(255);
	this.setupPageSettings();
};

Game_CharacterBase.prototype.randAttackPos = function(vertices) {
	const ltx = this.px - this.hitOffsetL();
	const lty = this.py - this.hitOffsetT();
	const rdx = this.px + this.hitOffsetR();
	const rdy = this.py + this.hitOffsetB();
	const attackRect = $gameMap.verticesBound(vertices);
	return Utils.randomRectHalfIntersectPoint(ltx, lty, rdx, rdy, attackRect.minX, attackRect.minY, attackRect.maxX, attackRect.maxY);
};

Game_CharacterBase.prototype.clearLatestHitObjectsConstructor = function() {
	this._latestHitObjectsConstructor.length = 0;
};

Game_CharacterBase.prototype.isLatestHitObject = function(c) {
	return this._latestHitObjectsConstructor.includes(c.name);
};

Game_Map.prototype.pixelWidth = function() {
	return this.width() * this.tileWidth();
};

Game_Map.prototype.pixelHeight = function() {
	return this.height() * this.tileHeight();
};

Game_Event.prototype.immueFixObject = function() {
	return this._immueFixObject;
};

NYA.GAME = {};
Scene_Base.prototype.startFadeOut = function(duration, white) {
    this._fadeSign = -1;
    this._fadeDuration = duration || 30;
    this._fadeWhite = white;
    this.updateColorFilter();
};

// ---------------- Scene_Boot ----------------------//

NYA.GAME.Scene_Boot_initialize = Scene_Boot.prototype.initialize;
Scene_Boot.prototype.initialize = function() {
	NYA.GAME.Scene_Boot_initialize.apply(this, arguments);
	this._realProgress = 0;
	this._fadeOutStarted = false;
	this._ruruSpeed = 0;
	this._isSplashScreenShowed = false;
	this._isSplashScreenShowing = false;
	this._splashScreenShowingTime = 0;
	Graphics.app.renderer.plugins.interaction.removeTickerListener();
	Graphics.app.renderer.plugins.accessibility.destroy();
};

NYA.GAME.Scene_Boot_isReady = Scene_Boot.prototype.isReady;
Scene_Boot.prototype.isReady = function() {
	return PackageManager.isBootFileLoaded() && this.bootResReady() && Scene_Base.prototype.isReady.apply(this, arguments);
};

Scene_Boot.prototype.bootResReady = function() {
	if(!NYA.DEBUG) {
		return NYA.PACKAGE.BOOT_RESOURCE.every((bootRes) => { 
			const folder = bootRes.substr(0, bootRes.lastIndexOf('/') + 1);
			const name = bootRes.substr(bootRes.lastIndexOf('/') + 1);
			const ext = name.substr(name.lastIndexOf('.'));
			const realname = name.substr(0, name.lastIndexOf('.'));
			switch(ext) {
				case '.png': return ImageManager.loadBitmap(folder, realname).isReady(); 
				default: return true;
			}
		});
	}
	return true;
};

NYA.GAME.Scene_Boot_create = Scene_Boot.prototype.create;
Scene_Boot.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.resizeScreen();
    StorageManager.updateForageKeys();
	if(NYA.DEBUG) {
		NYA.PACKAGE.BOOT_RESOURCE.forEach((bootRes) => { 
			const folder = bootRes.substr(0, bootRes.lastIndexOf('/') + 1);
			const name = bootRes.substr(bootRes.lastIndexOf('/') + 1);
			const ext = name.substr(name.lastIndexOf('.'));
			const realname = name.substr(0, name.lastIndexOf('.'));
			switch(ext) {
				case '.png': ImageManager.loadBitmap(folder, realname); break; 
				default: break;
			}
		});
	}
	this._fadeOpacity = 255;
	this.updateColorFilter();
};

NYA.GAME.Scene_Boot_start = Scene_Boot.prototype.start;
Scene_Boot.prototype.start = function() {
	Scene_Base.prototype.start.apply(this, arguments);
	const background = new Sprite(ImageManager.loadUI('preload'));
	background.anchor.set(0.5);
	background.x = Graphics.width / 2;
	background.y = Graphics.height / 2;
	this.addChild(background);
	this._ruru = new Sprite_KeyFrameAnimation('preload_ruru', 4, 'img/ui/');
	this._ruru.x = 440 + (Graphics.width - NYA.BASE_SCREEN_WIDTH) / 2;
	this._ruru.y = 314;
	this.addChild(this._ruru);
	this._cat = new Sprite_KeyFrameAnimation('preload_cat', 4, 'img/ui/');
	this._cat.x = Graphics.width - 166;
	this._cat.y = 610;
	this._cat.start(2);
	this.addChild(this._cat);
	this._progressSprite = new Sprite_Progress({
		lowerNames:['preload_bar_lower']
		, upperNames:[]
		, progressName:'preload_bar_content'
		, tilingName:'preload_bar_tiling'
		, tilingSpeed:-1
	});
	this._progressSprite.x = (Graphics.width - this._progressSprite.progressWidth()) / 2;
	this._progressSprite.y = 524;
	this.addChild(this._progressSprite);
	if(!NYA.DEBUG) {
		PackageManager.loadResourceIndex();
		PackageManager.loadResource();
	}
	else {
		PreloadManager.start();
	}
	this.startFadeIn(25, 0);
	
	if(!Utils.isLegalMode()) {
		this.createEngineIcon();
	} else {
		this.create4399Icon();
	}
	this.createNotificationBar();
	this.ensureColorFilter();
	//Graphics._switchFPSCounter();
};

Scene_Boot.prototype.update = function() {
	Scene_Base.prototype.update.call(this);
	if(!NYA.DEBUG) {
		if(PackageManager.isFileLoaded() && PreloadManager.state() === NYA.PRELOAD.STATE_DEFAULT) {
			PreloadManager.start();
		}
	}
	this.applyProgress();
};

Scene_Boot.prototype.createEngineIcon = function() {
	const sprite = new Sprite_SplashIcon({
		backName:''
		,nyaEngineIconName:'nya_engine_icon'
		,baseEngineIconOffset:{x:Graphics.width - 560, y:614}
	});
	this.addChild(sprite);
};

Scene_Boot.prototype.create4399Icon = function() {
	const sprite = new Sprite(ImageManager.loadUI("4399"));
	this.addChild(sprite);
	sprite.anchor.set(1);
	sprite.x = Graphics.width - 166;
	sprite.y = Graphics.height - 26;
};

Scene_Boot.prototype.applyProgress = function() {
	let progress = 0;
	if(NYA.DEBUG) {
		progress = PreloadManager.progress();
	}
	else if(PackageManager.isIndexLoaded()) {
		progress = PackageManager.progress();
	}
	if(this._realProgress < progress) {
		this._realProgress = progress;
	}
	this._progressSprite.progress = this._realProgress;
	if(this.checkHiddenLoadingAction() && !this._fadeOutStarted) {
		this.startFadeOut(60, 0);
		this._fadeOutStarted = true;
	}
	if(this._fadeOutStarted && !this.isBusy()) {
		if(this._isSplashScreenShowed) {
			this.gotoNextScene();
		} else if(!this._isSplashScreenShowing) {
			this.createSplashScreen();
			this.startFadeIn(60, 0);
			this._isSplashScreenShowing = true;
		} else {
			this.processSplashScreenShowing();
		}
	} else if(this._fadeOutStarted && !this._isSplashScreenShowing) {
		this.applyRuruProgress();
	}
};

Scene_Boot.prototype.createSplashScreen = function() {
	const sprite = new Sprite_SplashScreen();
	this.addChild(sprite);
};

Scene_Boot.prototype.processSplashScreenShowing = function() {
	if(Input.isAnyTriggered() || this._splashScreenShowingTime > this.splashScreenMaxShowingTime()) {
		this.startFadeOut(60, 0);
		this._isSplashScreenShowed = true;
	} else {
		this._splashScreenShowingTime++;
	}
};

Scene_Boot.prototype.splashScreenMaxShowingTime = function() {
	return 120;
};

NYA.GAME.Scene_Boot_loadPlayerData = Scene_Boot.prototype.loadPlayerData;
Scene_Boot.prototype.loadPlayerData = function() {
	NYA.GAME.Scene_Boot_loadPlayerData.apply(this, arguments);
	DataManager.cacheThumbnailMapData();
};

Scene_Boot.prototype.applyRuruProgress = function() {
	if(this._realProgress >= 1) {
		this._ruruSpeed += 0.5;
		this._ruruSpeed = Math.min(15, this._ruruSpeed);
		this._ruru.x += Math.ceil(this._ruruSpeed);
	}
};

Scene_Boot.prototype.checkHiddenLoadingAction = function() {
	if(this._realProgress < 1) {
		return false;
	}
	if(!PreloadManager.isCompleted()) {
		return false;
	}
	if(!this._databaseLoaded) {
        if (
            DataManager.isDatabaseLoaded() &&
            StorageManager.forageKeysUpdated()
        ) {
			StorageManager.postWorkerGameId();
            this._databaseLoaded = true;
            this.onDatabaseLoaded();
        }
        return false;
    }
	if(!FontManager.isReady()) {
		return false;
	}
	if(!this.isPlayerDataLoaded()) {
		return false;
	}
	this.doSomethingPreprocess();
	return true;
};

Scene_Boot.prototype.gotoNextScene = function() {
	SoundManager.preloadImportantSounds();
    if (DataManager.isBattleTest()) {
        DataManager.setupBattleTest();
        SceneManager.goto(Scene_Battle);
    } else if (DataManager.isEventTest()) {
        DataManager.setupEventTest();
        SceneManager.goto(Scene_Map);
    } else {
		if(!Utils.isLegalMode()) {
			this.startNormalGame();
		} else {
			SceneManager.goto(Scene_LegalTips);
		}
    }
};

Scene_Boot.prototype.resizeScreen = function() {
    const screenWidth = NYA.SCREEN_WIDTH;
    const screenHeight = NYA.SCREEN_HEIGHT;
    Graphics.resize(screenWidth, screenHeight);
    this.adjustBoxSize();
    this.adjustWindow();
};

Scene_Boot.prototype.adjustBoxSize = function() {
    const uiAreaWidth = NYA.SCREEN_WIDTH;
    const uiAreaHeight = NYA.SCREEN_HEIGHT;
    const boxMargin = 4;
    Graphics.boxWidth = uiAreaWidth - boxMargin * 2;
    Graphics.boxHeight = uiAreaHeight - boxMargin * 2;
};

Scene_Boot.prototype.doSomethingPreprocess = function() {
};

NYA.GAME.Scene_Boot_terminate = Scene_Boot.prototype.terminate;
Scene_Boot.prototype.terminate = function() {
	NYA.GAME.Scene_Boot_terminate.apply(this, arguments);
	ConfigManager.syncScreenWidth(0);
};

// ---------------- Scene_Title ----------------------//

Scene_Title.prototype.initialize = function() {
	Scene_Base.prototype.initialize.call(this);
	this._animation = new AnimationController();
	this._checkBusy = false;
	this._closeActiveObj = null;
};

NYA.GAME.Scene_Title_start = Scene_Title.prototype.start;
Scene_Title.prototype.start = function() {
	NYA.GAME.Scene_Title_start.call(this);
	if(SceneManager.isPreviousScene(Scene_Popup)) {		// 全屏模式的屏幕大小自适应
		this.pressOption();
	}
};

Scene_Title.prototype.createBackground = function() {
	this._backSprite1 = new Sprite(
        ImageManager.loadUI('title')
    );
	this._backSprite1.anchor.set(0.5);
	this._backSprite1.x = Graphics.width / 2;
	this._backSprite1.y = Graphics.height / 2;
    this._backSprite2 = new Sprite();
    this.addChild(this._backSprite1);
    this.addChild(this._backSprite2);
};

Scene_Title.prototype.createForeground = function() {
	this.createLogo();
	this.createCharacterArtwork();
	this.createSelectGroup();
	this.createGallery();
	this.createCGView();
	this.createLoad();
	this.createMusic();
	this.createOption();
	this.createWindowLayer();
	this.createConfirmWindow();
	this.createNotificationBar();
};

Scene_Title.prototype.createDimmer = function() {
	this.optionDimmer = new PIXI.Graphics();
	this.optionDimmer.beginFill(0x000000);
	this.optionDimmer.drawRect(0, 0, Graphics.width, Graphics.height);
	this.optionDimmer.endFill(0);
	this.optionDimmer.alpha = 0.5;
	this.optionDimmer.visible = false;
	this.addChild(this.optionDimmer);
};

Scene_Title.prototype.createOption = function() {
	this.createDimmer();
	
	this._option = new Sprite_Option({
		backgroundName:'option_background'
		, cursorName:'option_cursor'
		, moveSignName: 'option_move_sign'
		, frameMinY:118
		, frameMaxY:576
		, itemsCenterX:816
		, pageItemXLayout:[197,197,197,197,197,197,197]
		, textSize:28
		, singleItemWidth:330
		, screenButtonConfig: {
			limitStartY:232
			,backName:"screen_button_config_back"
			,limitTipsBackName:"screen_button_config_tips_back"
			,textColor:"#551717"
			,textSize:24
			,buttonSelectedName:"screen_button_config_selected"
			,buttonUnselectedName:"screen_button_config_unselected"
			,buttonOffset:{x:Graphics.width - 314, y:46}
			,buttonPadding:16
			,cancelButtonOffset:{x:156, y:58}
		}
	});
	this._option.x = Utils.baseHalfWidth();
	this._option.y = -Graphics.height;
	this._option.pressCancel = this.pressOptionCancel.bind(this);
	this._option.visible = false;
	this.addChild(this._option);
	
};

Scene_Title.prototype.createMusic = function() {
	this._music = new Sprite_Music({
		cursorName:'music_cursor', 
		cursorOffset:{x:0, y:0}, 
		lockName:'music_item', 
		upperName:'',
		upperOffset:{}, 
		thumbnailRect:{}, 
		margin:{width:0, height:10}, 
		pageMax:{x:1, y:4}, 
		moveSignName:'title_move_sign', 
		
		textOffsetX:146,
		playButtonOffset:{x:34,y:21},
		playName:'music_play',
		unplayName:'music_pause',
		
		cursorCatName:'title_load_cursor_cat', 
		cursorCatOffset:{x:799,y:33}, 
		cursorCatQT:{duration:25, scaleDuration:12, minScaleY:0.75},
		cursorCatAnimationHeight:6,
	});
	this._music.y = -this._music.pageHeight();
	this._music.pressCancel = this.pressMusicCancel.bind(this);
	this._music.pressOk = this.pressMusicOk.bind(this);
	this._music.visible = false;
	this.addChild(this._music);
};

Scene_Title.prototype.createConfirmWindow = function() {
	const confirmWidth = 580;
	const confirmHeight = 250;
	const confirmX = (Graphics.width - confirmWidth) / 2;
	const confirmY = (Graphics.height - confirmHeight) / 2;
	this._confirm = new Window_Alert({x:confirmX,y:confirmY,width:confirmWidth,height:confirmHeight}, '', {hasButton:true, buttonText:"STATIC_TEXT_OK"});
	this._confirm.visible = false;
	this._confirm.pressOk = this._confirm.pressCancel = this.closeConfirm.bind(this);
	this._confirm.deactivate();
	this.addWindow(this._confirm);
};

Scene_Title.prototype.createCGView = function() {
	this._cgView = new Sprite_CG();
	this._cgView.pressCancel = this.pressCGViewCancel.bind(this);
	this.addChild(this._cgView);
};

Scene_Title.prototype.createSelectGroup = function() {
	const y = 72;
	const commandObjs = {
		"STATIC_TEXT_TITLE_SELECT_STORY_MODE" : {y:y, pressed: this.pressStory.bind(this)}
		, "STATIC_TEXT_TITLE_LOAD_SAVED_GAME" : {y:y, pressed: this.pressLoad.bind(this)}
		, "STATIC_TEXT_TITLE_OPTIONS" : {y:y, pressed: this.pressOption.bind(this)}
		, "STATIC_TEXT_TITLE_CG_GALLERY" : {y:y, pressed: this.pressGallery.bind(this)}
		, "STATIC_TEXT_TITLE_MUSIC_BOX" : {y:y, pressed: this.pressMusic.bind(this)}
		, "STATIC_TEXT_TITLE_EXIT" : {y:y, pressed: this.pressExit.bind(this)}
	};
	this._selectGroup = new Sprite_SelectGroup(['title_select_background'], [], commandObjs);
	this._selectGroup.active();
	this._selectGroup.y = 586;
	this._selectGroup.x = 0;
	if(DataManager.isAnySavefileExists()) {
		this._selectGroup.select('STATIC_TEXT_TITLE_LOAD_SAVED_GAME');
	} else {
		this._selectGroup.select('STATIC_TEXT_TITLE_SELECT_STORY_MODE');
	}
	this.addChild(this._selectGroup);
};

Scene_Title.prototype.pressLoad = function() {
	this.clearMainAnimation();
	this.suspendMainAnimation();
	this._selectGroup.deactive();
	this._load.active();
	this._load.visible = true;
	const controller = this._animation;
	controller.clear(this._load);
	controller.add(this._load, {data:[{to:140, duration:30, property:'y', easingType:'easeOutQuart'}]});
};

Scene_Title.prototype.pressStory = function() {
	DataManager.setupNewGame();
	this._selectGroup.deactive();
    this.fadeOutAll();
	AudioManager.playNormalSe("newgame");
	EffectManager.destroyPreverveAnimation();
    SceneManager.goto(Scene_Map);
};

Scene_Title.prototype.pressExit = function() {
	this.fadeOutAll();
	this._selectGroup.deactive();
	this._checkBusy = this.onExit;
};

Scene_Title.prototype.pressGallery = function() {
	this.clearMainAnimation();
	this.suspendMainAnimation();
	this._selectGroup.deactive();
	this._gallery.active();
	this._gallery.visible = true;
	const controller = this._animation;
	controller.clear(this._gallery);
	controller.add(this._gallery, {data:[{to:120, duration:30, property:'y', easingType:'easeOutQuart'}]});
};

Scene_Title.prototype.pressMusic = function() {
	this.clearMainAnimation();
	this.suspendMainAnimation();
	this._selectGroup.deactive();
	this._music.active();
	this._music.visible = true;
	const controller = this._animation;
	controller.clear(this._music);
	controller.add(this._music, {data:[{to:120, duration:30, property:'y', easingType:'easeOutQuart'}]});
};

Scene_Title.prototype.pressOption = function() {
	this.clearMainAnimation();
	this.suspendMainAnimation();
	this._selectGroup.deactive();
	this._option.active();
	this._option.visible = true;
	const controller = this._animation;
	controller.clear(this._option);
	controller.add(this._option, {data:[{to:0, duration:30, property:'y', easingType:'easeOutQuart'}]});
	this.optionDimmer.visible = true;
};

Scene_Title.prototype.pressGalleryCancel = function() {
	this.clearMainAnimation();
	this.resumeMainAnimation();
	this._selectGroup.active();
	this._gallery.deactive();
	const controller = this._animation;
	controller.clear(this._gallery);
	controller.add(this._gallery, {data:[{to:-this._gallery.pageHeight(), duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onGalleryEasingComplete.bind(this)});
};

Scene_Title.prototype.onGalleryEasingComplete = function() {
	this._gallery.visible = false;
};

Scene_Title.prototype.pressMusicCancel = function() {
	this.clearMainAnimation();
	this.resumeMainAnimation();
	this._selectGroup.active();
	this._music.deactive();
	const controller = this._animation;
	controller.clear(this._music);
	controller.add(this._music, {data:[{to:-this._music.pageHeight(), duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onMusicEasingComplete.bind(this)});
};

Scene_Title.prototype.onMusicEasingComplete = function() {
	this._music.visible = false;
};

Scene_Title.prototype.pressGalleryOk = function() {
	const sprite = this._gallery.selectedSprite();
	SoundManager.playOk();
	if(sprite.cgarr && sprite.cgarr.length > 0) {
		this._gallery.deactive();
		this._cgView.setup(sprite, 25);
	}
};

Scene_Title.prototype.pressMusicOk = function() {
	const music = this._music;
	const playIndex = music.playIndex();
	if(music.selectIndex() === playIndex) {
		AudioManager.stopBgm();
		music.setPlayIndex(-1);
		music.refreshSelectedItems();
		music.refreshCatSprite();
	} else {
		music.setPlayIndex(music.selectIndex());
		AudioManager.playBgm({name: music.data()[music.selectIndex()], volume:100, pan: 0, pitch: 100, pos: 0});
		music.refreshSelectedItems();
		music.refreshCatSprite();
		if(playIndex !== -1) {
			music.refreshIndexItems(playIndex);
		}
	}
};

Scene_Title.prototype.pressCGViewCancel = function() {
	this._gallery.active();
};

Scene_Title.prototype.createGallery = function() {
	this._gallery = new Sprite_Gallery({
		cursorName:'gallery_cursor', 
		cursorOffset:{x:-3, y:-2}, 
		lockName:'gallery_lock', 
		upperName:'gallery_upper',
		upperOffset:{x:5,y:12}, 
		thumbnailRect:{x:15,y:21,width:317,height:178}, 
		margin:{width:32, height:21}, 
		pageMax:{x:3, y:2}, 
		moveSignName:'title_move_sign', 
	});
	this._gallery.y = -this._gallery.pageHeight();
	this._gallery.pressCancel = this.pressGalleryCancel.bind(this);
	this._gallery.pressOk = this.pressGalleryOk.bind(this);
	this._gallery.visible = false;
	this.addChild(this._gallery);
};

Scene_Title.prototype.pressLoadCancel = function() {
	this.clearMainAnimation();
	this.resumeMainAnimation();
	this._selectGroup.active();
	this._load.deactive();
	const controller = this._animation;
	controller.clear(this._load);
	controller.add(this._load, {data:[{to:-this._load.pageHeight(), duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onLoadEasingComplete.bind(this)});
};

Scene_Title.prototype.onLoadEasingComplete = function() {
	this._load.visible = false;
};

Scene_Title.prototype.pressLoadOk = function() {
	const data = this._load.data();
	const savefileId = this._load.selectIndex() + this._load._dataStart;
	if(!DataManager.isSaveFileExist(savefileId)) {
		return;
	}
	DataManager.loadGame(savefileId)
        .then(() => this.onLoadSuccess())
        .catch(() => this.onLoadFailure());
	this._load.deactive();
};

Scene_Title.prototype.pressOptionCancel = function() {
	this.clearMainAnimation();
	this.resumeMainAnimation();
	this._selectGroup.active();
	this._option.deactive();
	const controller = this._animation;
	controller.clear(this._option);
	controller.add(this._option, {data:[{to:-Graphics.height, duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onOptionEasingComplete.bind(this)});
	this.optionDimmer.visible = false;
	ConfigManager.save();
};

Scene_Title.prototype.onOptionEasingComplete = function() {
	this._option.visible = false;
};

Scene_Title.prototype.onLoadFailure = function() {
    this.showConfirm("STATIC_TEXT_LOAD_FAILURE", this._load);
};

Scene_Title.prototype.showConfirm = function(message, activeObj) {
	activeObj.deactive();
	this._closeActiveObj = activeObj;
	this._confirm.setText(message);
	this._confirm.visible = true;
	this._confirm.openness = 0;
	this._confirm.open();
	this._confirm.activate();
};

Scene_Title.prototype.closeConfirm = function() {
	this._closeActiveObj.active();
	this._closeActiveObj = null;
};

Scene_Title.prototype.onLoadSuccess = function() {
	$gameMap.completeLoad();
	this.fadeOutAll();
    // RM原有的重载机制：在游戏编辑之后读取之前的存档就会对Game_Map进行重新setup，所有事件重置，但此机制不适用于我们的游戏
	//Scene_Load.prototype.reloadMapIfUpdated.call(this);
	this._loadSuccess = true;
	SoundManager.playLoad();
    SceneManager.goto(Scene_Map);
};

Scene_Title.prototype.createLoad = function() {
	this._load = new Sprite_SaveLoad({
		cursorName:'achieve_cursor', 
		cursorOffset:{x:-1, y:-1}, 
		lockName:'achieve_item', 
		upperName:'', 
		upperOffset:{}, 
		thumbnailRect:{x:26,y:28,width:SceneManager.thumbnailWidth(),height:SceneManager.thumbnailHeight()}, 
		margin:{width:18, height:14}, 
		pageMax:{x:2, y:2}, 
		moveSignName:'title_move_sign', 
		
		newestName:'STATIC_TEXT_SAVELOAD_NEWEST', 
		newestOffset:{x:515,y:25}, 
		infoOffset:{x:322,y:46}, 
		infoMargin:13, 
		infoLineHeight:18, 
		cursorCatName:'title_load_cursor_cat', 
		cursorCatOffset:{x:472,y:140}, 
		cursorCatQT:{duration:25, scaleDuration:12, minScaleY:0.75},
		cursorCatAnimationHeight:6,
		mode:"load",
		autoLoadCatOptions:{
			catLeftPos:{x:39,y:23}
			,backName:'soft_guide_back'
			,catName:'soft_guide_cat'
			,textSize:24
			,textColor:'#551717'
		}
	});
	this._load.y = -this._load.pageHeight();
	this._load.pressCancel = this.pressLoadCancel.bind(this);
	this._load.pressOk = this.pressLoadOk.bind(this);
	this._load.visible = false;
	this.addChild(this._load);
};

Scene_Title.prototype.clearMainAnimation = function() {
	const controller = this._animation;
	controller.clear(this._logo);
	controller.clear(this._artwork1);
	controller.clear(this._artwork2);
};

Scene_Title.prototype.suspendMainAnimation = function() {
	const controller = this._animation;
	const options = {data:[
		{to:-263, duration:40, property:'x', easingType:'easeOutQuart'}
	],loop:false};
	controller.add(this._logo, options);
	const optionsa1 = {data:[
		{to:490 + Graphics.width, duration:40, property:'x', easingType:'easeOutQuart'}
	],loop:false};
	controller.add(this._artwork1, optionsa1);
	
	const optionsa2 = {data:[
		{to:377 + Graphics.width, duration:20, property:'x', easingType:'easeOutQuart',delay:20}
	],loop:false};
	controller.add(this._artwork2, optionsa2);
};

Scene_Title.prototype.onExit = function() {
	SceneManager.terminate();
};

Scene_Title.prototype.createCommandWindow = function() {
};

Scene_Title.prototype.createLogo = function() {
	this._logo = new Sprite(ImageManager.loadUI(this.logoName()));
	this._logo.x = -263;
	this._logo.y = 243;
	this._logo.anchor.x = 0.5;
	this._logo.anchor.y = 0.5;
	this.addChild(this._logo);
};

Scene_Title.prototype.logoName = function() {
	switch($dataLanguage) {
		case "schinese" : return "logo";
	}
	return "logo_english"
};

Scene_Title.prototype.onLogoEasingCompleted = function() {
	const options = {data:[
		{to:251, duration:70, property:'y', easingType:'linear'}
		,{to:243, duration:70, property:'y', easingType:'linear'}
		,{to:235, duration:70, property:'y', easingType:'linear'}
		,{to:243, duration:70, property:'y', easingType:'linear'}
	],loop:true};
	const controller = this._animation;
	controller.clear(this._logo);
	controller.add(this._logo, options);
};

Scene_Title.prototype.createCharacterArtwork = function() {
	this._artwork1 = new Sprite_Live2D("title");
	this._artwork2 = new Sprite_Live2D("title2");
	this.addChild(this._artwork1);
	this.addChild(this._artwork2);
	
	const scale = 0.43;
	
	this._artwork1.x = 490 + Graphics.width;
	this._artwork1.y = 307;
	this._artwork1.scale.x = scale;
	this._artwork1.scale.y = scale;
	
	this._artwork2.x = 377 + Graphics.width;
	this._artwork2.y = 376;
	this._artwork2.scale.x = scale;
	this._artwork2.scale.y = scale;
	
	//sp1.playMotion('idle');
	//sp2.playMotion('idle');
	this._artwork1.playMotion('idle');
	this._artwork2.playMotion('idle');
	
	this.startMainAnimation();
};

Scene_Title.prototype.startMainAnimation = function() {
	const controller = this._animation;
	const optionsa1 = {data:[
		{to:892 + Utils.baseHalfWidth() * 1.5, duration:40, property:'x', easingType:'easeOutQuart'}
	],loop:false,complete:this.onCharacterArtwork1EasingCompleted.bind(this)};
	controller.add(this._artwork1, optionsa1);
	
	const optionsa2 = {data:[
		{to:945 + Graphics.width - NYA.BASE_SCREEN_WIDTH, duration:20, property:'x', easingType:'easeOutQuart',delay:20}
	],loop:false,complete:this.onCharacterArtwork2EasingCompleted.bind(this)};
	controller.add(this._artwork2, optionsa2);
	
	const logoOptions = {data:[
		{to:233 + Utils.baseHalfWidth(), duration:40, property:'x', easingType:'easeOutQuart'}
	],loop:false,complete:this.onLogoEasingCompleted.bind(this)};
	controller.add(this._logo, logoOptions);
};

Scene_Title.prototype.resumeMainAnimation = function() {
	const controller = this._animation;
	const optionsa1 = {data:[
		{to:892 + Utils.baseHalfWidth() * 1.5, duration:40, property:'x', easingType:'easeOutQuart'}
	],loop:false,complete:this.onCharacterArtwork1EasingCompleted.bind(this)};
	controller.add(this._artwork1, optionsa1);
	
	const optionsa2 = {data:[
		{to:945 + Graphics.width - NYA.BASE_SCREEN_WIDTH, duration:20, property:'x', easingType:'easeOutQuart',delay:20}
	],loop:false,complete:this.onCharacterArtwork2EasingCompleted.bind(this)};
	controller.add(this._artwork2, optionsa2);
	
	const logoOptions = {data:[
		{to:233 + Utils.baseHalfWidth(), duration:40, property:'x', easingType:'easeOutQuart'}
	],loop:false,complete:this.onLogoEasingCompleted.bind(this)};
	controller.add(this._logo, logoOptions);
};

Scene_Title.prototype.onCharacterArtwork1EasingCompleted = function() {
	const options = {data:[
		{to:297, duration:240, property:'y', easingType:'linear'}
		,{to:307, duration:240, property:'y', easingType:'linear'}
	],loop:true};
	const options2 = {data:[
		{to:899 + Utils.baseHalfWidth() * 1.5, duration:240, property:'x', easingType:'linear'}
		,{to:892 + Utils.baseHalfWidth() * 1.5, duration:240, property:'x', easingType:'linear'}
	],loop:true};
	const controller = this._animation;
	controller.clear(this._artwork1);
	controller.add(this._artwork1, options);
	controller.add(this._artwork1, options2);
};

Scene_Title.prototype.onCharacterArtwork2EasingCompleted = function() {
	const options = {data:[
		{to:369, duration:240, property:'y', easingType:'linear'}
		,{to:376, duration:240, property:'y', easingType:'linear'}
	],loop:true};
	const options2 = {data:[
		{to:935 + Graphics.width - NYA.BASE_SCREEN_WIDTH, duration:240, property:'x', easingType:'linear'}
		,{to:945 + Graphics.width - NYA.BASE_SCREEN_WIDTH, duration:240, property:'x', easingType:'linear'}
	],loop:true};
	const controller = this._animation;
	controller.clear(this._artwork2);
	controller.add(this._artwork2, options);
	controller.add(this._artwork2, options2);
};

Scene_Title.prototype.adjustBackground = function() {
};

Scene_Title.prototype.isBusy = function() {
	return Scene_Base.prototype.isBusy.call(this);
};

Scene_Title.prototype.onLanguageChange = function() {
	this._option.onLanguageChange();
	this._confirm.onLanguageChange();
	this._load.onLanguageChange();
	this._logo.bitmap = ImageManager.loadUI(this.logoName());
	this._selectGroup.onLanguageChange();
};

Scene_Title.prototype.update = function() {
	this._animation.update();
	Scene_Base.prototype.update.call(this);
	if(this._checkBusy && !this.isBusy()) {
		this._checkBusy();
	}
};

NYA.GAME.Scene_Title_terminate = Scene_Title.prototype.terminate;
Scene_Title.prototype.terminate = function() {
	NYA.GAME.Scene_Title_terminate.apply(this, arguments);
	if(this._loadSuccess) {
		$gameSystem.onAfterLoad();
	}
};

function Scene_Save() {
	this.initialize(...arguments);
}

Scene_Save.prototype = Object.create(Scene_Base.prototype);
Scene_Save.prototype.constructor = Scene_Save;

Scene_Save.prototype.initialize = function() {
	Scene_Base.prototype.initialize.call(this);
	this._animation = new AnimationController();
};

Scene_Save.prototype.start = function() {
	Scene_Base.prototype.start.call(this);
};

Scene_Save.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.createBackground();
	this.createSave();
	this.createWindowLayer();
	this.createConfirmWindow();
	this.createNotificationBar();
	this.createAutoSaveBar();
};

Scene_Save.prototype.createBackground = function() {
	const background = SceneManager.backGroundSprite();
	const shader = new PIXI.filters.ColorMatrixFilter();
	shader.brightness(0.5);
	background.filters = [shader];
	this.addChild(background);
	this._backgroundFromPreviousScene = background;
};

Scene_Save.prototype.savefileId = function() {
    return this._save.selectIndex() + this._save._dataStart;
};

Scene_Save.prototype.update = function() {
	Scene_Base.prototype.update.call(this);
	this._animation.update();
};

Scene_Save.prototype.createSave = function() {
	this._save = new Sprite_SaveLoad({
		cursorName:'achieve_cursor', 
		cursorOffset:{x:-1, y:-1}, 
		lockName:'achieve_item', 
		upperName:'', 
		upperOffset:{}, 
		thumbnailRect:{x:26,y:28,width:SceneManager.thumbnailWidth(),height:SceneManager.thumbnailHeight()}, 
		margin:{width:18, height:14}, 
		pageMax:{x:2, y:2}, 
		moveSignName:'title_move_sign', 
		
		newestName:'STATIC_TEXT_SAVELOAD_NEWEST', 
		newestOffset:{x:515,y:25}, 
		infoOffset:{x:322,y:46}, 
		infoMargin:13, 
		infoLineHeight:18, 
		cursorCatName:'title_load_cursor_cat', 
		cursorCatOffset:{x:472,y:140}, 
		cursorCatQT:{duration:25, scaleDuration:12, minScaleY:0.75},
		cursorCatAnimationHeight:6,
		mode:"save"
	});
	this._save.y = -this._save.pageHeight();
	this._save.pressCancel = this.pressSaveCancel.bind(this);
	this._save.pressOk = this.pressSaveOk.bind(this);
	this._save.active();
	this.addChild(this._save);
	
	const controller = this._animation;
	controller.add(this._save, {data:[{to:140, duration:30, property:'y', easingType:'easeOutQuart'}]});
};

Scene_Save.prototype.createConfirmWindow = function() {
	const confirmWidth = 580;
	const confirmHeight = 250;
	const confirmX = (Graphics.width - confirmWidth) / 2;
	const confirmY = (Graphics.height - confirmHeight) / 2;
	const rect = {x:confirmX,y:confirmY,width:confirmWidth,height:confirmHeight};
	this._confirm = new Window_Alert(rect, '', {hasButton:true, buttonText:"STATIC_TEXT_OK"});
	this._confirm.visible = false;
	this._confirm.pressOk = this._confirm.pressCancel = this.closeConfirm.bind(this);
	this._confirm.deactivate();
	this.addWindow(this._confirm);
	
	this._confirmOverwrite = new Window_Confirm(rect, '', {defaultSelected: 'no', canEscape:true});
	this._confirmOverwrite.visible = false;
	this._confirmOverwrite.pressOk = this.executeSave.bind(this);
	this._confirmOverwrite.pressCancel = this.closeConfirmOverwrite.bind(this);
	this._confirmOverwrite.deactivate();
	this.addWindow(this._confirmOverwrite);
};

Scene_Save.prototype.onLanguageChange = function() {
	this._confirm.onLanguageChange();
	this._confirmOverwrite.onLanguageChange();
	this._save.onLanguageChange();
};

Scene_Save.prototype.pressSaveCancel = function() {
	this._save.deactive();
	SceneManager.pop();
};

Scene_Save.prototype.pressSaveOk = function() {
	if(!DataManager.savefileInfo(this.savefileId())) {
		this.executeSave();
		SoundManager.playOk();
	} else {
		this.showConfirmOverwrite("STATIC_TEXT_CONFIRM_OVERWRITE", this._save);
	}
};

Scene_Save.prototype.closeConfirm = function() {
	Scene_Title.prototype.closeConfirm.apply(this, arguments);
};

Scene_Save.prototype.showConfirm = function(message, activeObj) {
	Scene_Title.prototype.showConfirm.apply(this, arguments);
};

Scene_Save.prototype.closeConfirmOverwrite = function(message, callback) {
	this._closeActiveObj.active();
	this._closeActiveObj = null;
};

Scene_Save.prototype.showConfirmOverwrite = function(message, activeObj) {
	activeObj.deactive();
	this._closeActiveObj = activeObj;
	this._confirmOverwrite.setText(message);
	this._confirmOverwrite.visible = true;
	this._confirmOverwrite.no();
	this._confirmOverwrite.openness = 0;
	this._confirmOverwrite.open();
	this._confirmOverwrite.activate();
};

Scene_Save.prototype.executeSave = function() {
	$gameSystem.onBeforeSave();
	DataManager.saveGame(this.savefileId())
        .then(() => this.onSaveSuccess())
        .catch(() => this.onSaveFailure());
};

Scene_Save.prototype.onSaveSuccess = function() {
	if(this._confirmOverwrite.active) {
		this.closeConfirmOverwrite();
	} else {
		this._save.active();
	}
	DataManager.updateThumbnailCache(this.savefileId());
	this._save.refreshData();
	this._save.clearAllNewest();
	this._save.refreshSelectedItems();
};

Scene_Save.prototype.onSaveFailure = function() {
	if(this._confirmOverwrite.active) {
		this.closeConfirmOverwrite();
	}
	this.showConfirm("STATIC_TEXT_SAVE_FAILURE", this._save);
};

Scene_Map.prototype.updateCallMenu = function() {
    if (this.isMenuEnabled() && this.isMenuCalled()) {
        this.callMenu();
    }
};

Scene_Map.prototype.isMenuCalled = function() {
    return Input.isTriggered("menu") || (this._touchUI && this._touchUI.isMenuCalled());
};

function Scene_Menu() {
	this.initialize(...arguments);
}

Scene_Menu.prototype = Object.create(Scene_Base.prototype);
Scene_Menu.prototype.constructor = Scene_Menu;

Scene_Menu.prototype.initialize = function() {
    Scene_Base.prototype.initialize.call(this);
	this._animation = new AnimationController();
	Input.setLatestButtonCodeTriggered();
};

Scene_Menu.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.createBackground();
	this.createMenuLogo();
	this.createCancelButton();
	this.createMenuButton();
	this.createOption();
	this.createLoad();
	
	this.createWindowLayer();
	this.createAllWindow();
	this.createNotificationBar();
	this.createAutoSaveBar();
};

Scene_Menu.prototype.start = function() {
    Scene_Base.prototype.start.call(this);
	if(SceneManager.isPreviousScene(Scene_Popup)) {		// 全屏模式的屏幕大小自适应
		let idx = 0;
		for(const item of this._menuCommand._items) {
			if(item.panel === this._systemPanel) {
				break;
			}
			idx++;
		}
		this._menuCommand.moveSelectedDirect(idx);
		this._menuCommand.deactive();
		this._systemPanel.deactive();
		this.pressOption();
	}
};

Scene_Menu.prototype.createBackground = function() {
	Scene_Save.prototype.createBackground.call(this);
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this._panelSprite = new Sprite();
	this.addChild(this._panelSprite);
	this._background = new Sprite(ImageManager.loadUI('menu_background'));
	this._baseSprite.addChild(this._background);
};

Scene_Menu.prototype.createAllWindow = function() {
	const confirmWidth = 580;
	const confirmHeight = 250;
	const confirmX = (Graphics.width - confirmWidth) / 2;
	const confirmY = (Graphics.height - confirmHeight) / 2;
	const rect = {x:confirmX,y:confirmY,width:confirmWidth,height:confirmHeight};
	this._tips = new Window_Alert(rect, '', {hasButton:true, buttonText:"STATIC_TEXT_OK"});
	this._tips.visible = false;
	this._tips.pressOk = this._tips.pressCancel = this.closeTips.bind(this);
	this._tips.deactivate();
	this.addWindow(this._tips);
	
	this._confirm = new Window_Confirm(rect, '', {defaultSelected: 'no', canEscape:true});
	this._confirm.visible = false;
	this._confirm.pressOk = this.executeConfirm.bind(this);
	this._confirm.pressCancel = this.closeConfirm.bind(this);
	this._confirm.deactivate();
	this.addWindow(this._confirm);
};

Scene_Menu.prototype.onLanguageChange = function() {
	this._tips.onLanguageChange();
	this._confirm.onLanguageChange();
	this._option.onLanguageChange();
	this._systemPanel.onLanguageChange();
	this._mapPanel.onLanguageChange();
	this._menuCommand.onLanguageChange();
	this._itemPanel.onLanguageChange();
	this._load.onLanguageChange();
	this._bookPanel.onLanguageChange();
	if(this._touchUI) {
		this._touchUI.onLanguageChange();
	}
};

Scene_Menu.prototype.closeTips = function() {
	this._closeActiveObj.active();
	this._closeActiveObj.touchActive();
	this._menuCommand.touchActive();
};

Scene_Menu.prototype.showTips = function(text, closeActiveObj) {
	this._closeActiveObj = closeActiveObj;
	this._closeActiveObj.deactive();
	this._closeActiveObj.touchDeactive();
	this._menuCommand.touchDeactive();
	this._tips.visible = true;
	this._tips.setText(text);
	this._tips.activate();
	this._tips.openness = 0;
	this._tips.open();
};

Scene_Menu.prototype.closeConfirm = function() {
	this._closeActiveObj.active();
	this._closeActiveObj.touchActive();
	this._menuCommand.touchActive();
};

Scene_Menu.prototype.executeConfirm = function() {
	this._confirmCallback();
};

Scene_Menu.prototype.showConfirm = function(text, closeActiveObj, confirmCallback) {
	this._closeActiveObj = closeActiveObj;
	this._closeActiveObj.deactive();
	this._closeActiveObj.touchDeactive();
	this._menuCommand.touchDeactive();
	this._confirmCallback = confirmCallback;
	this._confirm.visible = true;
	this._confirm.setText(text);
	this._confirm.activate();
	this._confirm.openness = 0;
	this._confirm.open();
};

Scene_Menu.prototype.onSystemPanelReturnToTitle = function() {
	this.showConfirm("STATIC_TEXT_MENU_SYSTEM_RETURN_TO_TITLE_CONFIRM", this._systemPanel, this.onSystemPanelReturnToTitleOk.bind(this));
};

Scene_Menu.prototype.onSystemPanelReturnToTitleOk = function() {
	SceneManager.goto(Scene_Title);
};

Scene_Menu.prototype.onSystemPanelExitGame = function() {
	this.showConfirm("STATIC_TEXT_MENU_SYSTEM_EXIT_GAME_CONFIRM", this._systemPanel, SceneManager.terminate);
};

Scene_Menu.prototype.createMenuButton = function() {
	this._menuCommand = new Sprite_MenuCommand({
		selectedCatName:'menu_command_cursor_selected'
		, unselectedCatName:'menu_command_cursor_unselected'
		, rotation:-0.45
		, itemMargin:8
		, textStartX:65
		, textSize:26
		, selectedTextSize:32
		, textOffsetY:-10
		, textColor:'#ffffff'
		, selectedColor:'#ff9bb7'
		, selectedOutlineColor:'#ffffff'
		, selectedOutlineWidth:3
		, selectedAnimitionHeight:10
		, items:[
			{name:"STATIC_TEXT_MENU_ITEM", panel:this.createItemPanel()}
			, {name:"STATIC_TEXT_MENU_SKILL", panel:this.createSkillPanel()}
			, {name:"STATIC_TEXT_MENU_MAP", panel:this.createMapPanel()}
			, {name:"STATIC_TEXT_MENU_BOOK", panel:this.createBookPanel()}
			, {name:"STATIC_TEXT_MENU_SYSTEM", panel:this.createSystemPanel()}
		]
	});
	this._menuCommand.x = 13;
	this._menuCommand.y = 244;
	this._menuCommand.pressCancel = this.popScene.bind(this);
	this._baseSprite.addChild(this._menuCommand);
};

Scene_Menu.prototype.createMenuLogo = function() {
	this._fish = new Sprite_QT(ImageManager.loadUI('menu_logo_fish'), {
		duration:30
		, scaleDuration:12
		, minScaleY:0.75
		, minY:184 - 22
		, maxY:184 + 22
		, x:47
		, y:184
	});
	this._star1 = new Sprite(ImageManager.loadUI('menu_logo_star1'));
	this._star1.anchor.x = this._star1.anchor.y = 0.5;
	this._star1.x = 89;
	this._star1.y = 212;
	this._star2 = new Sprite(ImageManager.loadUI('menu_logo_star2'));
	this._star2.anchor.x = this._star2.anchor.y = 0.5;
	this._star2.x = 137;
	this._star2.y = 193;
	this._star3 = new Sprite(ImageManager.loadUI('menu_logo_star3'));
	this._star3.anchor.x = this._star3.anchor.y = 0.5;
	this._star3.x = 193;
	this._star3.y = 163;
	this._star4 = new Sprite(ImageManager.loadUI('menu_logo_star4'));
	this._star4.anchor.x = this._star4.anchor.y = 0.5;
	this._star4.x = 221;
	this._star4.y = 114;
	this._star5 = new Sprite(ImageManager.loadUI('menu_logo_star5'));
	this._star5.anchor.x = 0.53; this._star5.anchor.y = 0.47;
	this._star5.x = 220;
	this._star5.y = 52;
	this._baseSprite.addChild(this._fish, this._star1, this._star2, this._star3, this._star4, this._star5);
	
	const controller = this._animation;
	const duration = 60;
	const to = 2 * Math.PI;
	controller.add(this._star1, {data:[{
		property:'rotation', from:0, to:to, duration:duration, easingType:'linear'
	}], loop:true});
	controller.add(this._star2, {data:[{
		property:'rotation', from:0, to:to, duration:duration, easingType:'linear'
	}], loop:true});
	controller.add(this._star3, {data:[{
		property:'rotation', from:0, to:to, duration:duration, easingType:'linear'
	}], loop:true});
	controller.add(this._star4, {data:[{
		property:'rotation', from:0, to:to, duration:duration, easingType:'linear'
	}], loop:true});
	controller.add(this._star5, {data:[{
		property:'rotation', from:0, to:to, duration:duration, easingType:'linear'
	}], loop:true});
	this._baseSprite.x = -250;
	controller.add(this._baseSprite, {data:[
		{to:0, property:'x', duration:30, easingType:'easeOutExpo'}
	]});
};

Scene_Menu.prototype.createCancelButton = function() {
	this._cancelSprite = new Sprite(ImageManager.loadUI("cancel"));
	this._cancelSprite.anchor.set(0.5);
	this._cancelSprite.x = 276;
	this._cancelSprite.y = 54;
	this._baseSprite.addChild(this._cancelSprite);
};

Scene_Menu.prototype.update = function() {
	Scene_Base.prototype.update.call(this);
	this._animation.update();
	this.updateQuickAutoLoad();
	this.updateCancelButton();
};

Scene_Menu.prototype.updateCancelButton = function() {
	if(this._tips.active || this._confirm.active || this._option._active) {
		return;
	}
	if(TouchInput.isClicked() && this._cancelSprite.isBeingTouched()) {
		SoundManager.playCancel();
		this.popScene();
	}
	if(TouchInput.isPressed()) {
		if(this._cancelSprite.isBeingTouched()) {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel_press");
		} else {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
		}
	} else if(TouchInput.isReleased()) {
		this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
	}
};

Scene_Menu.prototype.updateQuickAutoLoad = function() {
	if(Input.isPressed('bullet') && Input.isPressed('zxc') && this.isAnyPanelActive()) {
		this.pressAutoLoad();
	}
};

Scene_Menu.prototype.isAnyPanelActive = function() {
	return this._menuCommand._active || this._panelSprite.children.some((sprite) => { return sprite._active; });
};

Scene_Menu.prototype.createDefaultPanel = function() {
	const panel = new Sprite_MenuBase({
		rect: this.panelRect()
	});
	panel.pressCancel = this.pressPanelCancel.bind(this);
	this._panelSprite.addChild(panel);
	return panel;
};

Scene_Menu.prototype.pressPanelCancel = function() {
	this._menuCommand.active();
};

Scene_Menu.prototype.panelRect = function() {
	return {x:this._background.width, y:0, width:Graphics.width - this._background.width, height:Graphics.height};
};

Scene_Menu.prototype.createSystemPanel = function() {
	this._systemPanel = new Sprite_MenuSystem({
		rect: this.panelRect()
		, items: [
					{name:"STATIC_TEXT_MENU_SYSTEM_RETURN_TO_TITLE", callback:this.onSystemPanelReturnToTitle.bind(this)}
					, {name:"STATIC_TEXT_MENU_SYSTEM_RETURN_LOAD_GAME", callback:this.pressLoad.bind(this)}
					, {name:"STATIC_TEXT_MENU_SYSTEM_OPTIONS", callback:this.pressOption.bind(this)}
					, {name:"STATIC_TEXT_MENU_SYSTEM_EXIT_GAME", callback:this.onSystemPanelExitGame.bind(this)}
				]
		, playTimeTextSize:22
		, playTimeTextColor:'#ffffff'
		, playTimeMargin:18
		, playTimeBackName:'menu_system_playtime'
		, cursorName:'menu_system_cursor'
		, cursorOffset:{x:-4, y:-3}
		, backName:'menu_system_back'
		, selectedShadowBlur:16
		, selectedShadowColor:'#ff9bb7'
		, selectedColor:'#ff9bb7'
		, selectedSize:32
		, selectedOutlineColor:'#ffffff'
		, selectedOutlineWidth:3
		, unselectedSize:26
		, unselectedColor:'#551717'
		, itemMargin:30
	});
	this._systemPanel.pressCancel = this.pressPanelCancel.bind(this);
	this._panelSprite.addChild(this._systemPanel);
	return this._systemPanel;
};

Scene_Menu.prototype.createMapPanel = function() {
	this._mapPanel = new Sprite_MapInfo({
		rect: this.panelRect()
		, mapContentName: 'menu_map_content'
		, mapProgressName: 'menu_map_progress'
		, mapNameBoxName: 'menu_map_namebox'
		, margin:39
		, textSize:22
		, textColor:'#551717'
		, nameBoxTextOffset:{x:21, y:4}
		, tipsBackName:'menu_map_tips'
		, tipsTextColor:'#ffffff'
		, tipsOffsetY:40
		, taskSelectOptions:{
				pageNum:5
				,moveSignName:'option_move_sign'
				,itemName:'menu_map_task_select_back'
				,cursorName:'menu_map_task_select_cursor'
				,textSize:22
				,textColor:'#551717'
				,mainTaskColor:'#c10000'
				,itemMargin:8
				,textStartX:94
				,noTaskTipsTextColor:'#551717'
				,moveSignMargin:0
		}
		, signatureSampleBackName:"signature_sample_back"
	});
	this._mapPanel.pressCancel = this.pressPanelCancel.bind(this);
	this._panelSprite.addChild(this._mapPanel);
	return this._mapPanel;
};

Scene_Menu.prototype.createItemPanel = function() {
	this._itemPanel = new Sprite_Item({
		rect: this.panelRect()
	});
	this._panelSprite.addChild(this._itemPanel);
	this._itemPanel.pressCancel = this.pressPanelCancel.bind(this);
	return this._itemPanel;
};

Scene_Menu.prototype.createSkillPanel = function() {
	const mobile = Utils.isMobileDeviceTouchMode();
	const buttonName = mobile ? "screen_button_unpressed" : "menu_skill_button";
	const buttonNameHold = mobile ? "screen_button_pressed" : "menu_skill_button";
	this._skillPanel = new Sprite_MenuSkill({
		rect: this.panelRect()
		,paddingWidth:48
		,paddingHeight:78
		,controlOptions:{
			upArrowName:'menu_skill_arrow'
			,buttonName:buttonName
			,plusName:'menu_skill_plus'
			,upArrowNameHold:'menu_skill_arrow'
			,buttonNameHold:buttonNameHold
			,equalName:'menu_skill_equal'
			,itemPadding:12
			,imagePadding:0
			,buttonTextSize:18
			,buttonTextColor:'#551717'
		}
	});
	this._panelSprite.addChild(this._skillPanel);
	return this._skillPanel;
};

Scene_Menu.prototype.createBookPanel = function() {
	this._bookPanel = new Sprite_MenuBook({
		rect: this.panelRect()
		, commandMargin:10
		, commandShiftY:12
		, commandSelectShiftY:16
		, commandName:"menu_book_command_unselect"
		, commandSelectName:"menu_book_command_select"
		, backName:"menu_book_back"
		, commandTextSize:24
		, commandTextColor:"#551717"
		, moveSignName:"option_move_sign"
	});
	this._bookPanel.pressCancel = this.pressPanelCancel.bind(this);
	this._panelSprite.addChild(this._bookPanel);
	return this._bookPanel;
};

Scene_Menu.prototype.createOption = function() {
	Scene_Title.prototype.createOption.call(this);
};

Scene_Menu.prototype.createDimmer = function() {
	Scene_Title.prototype.createDimmer.call(this);
};

Scene_Menu.prototype.createLoad = function() {
	Scene_Title.prototype.createLoad.call(this);
};

Scene_Menu.prototype.pressOptionCancel = function() {
	this._systemPanel.active();
	this._systemPanel.touchActive();
	this._menuCommand.touchActive();
	this._option.deactive();
	const controller = this._animation;
	controller.clear(this._option);
	controller.add(this._option, {data:[{to:-Graphics.height, duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onOptionEasingComplete.bind(this)});
	this.optionDimmer.visible = false;
	ConfigManager.save();
};

Scene_Menu.prototype.onOptionEasingComplete = function() {
	this._option.visible = false;
};

Scene_Menu.prototype.pressOption = function() {
	this._systemPanel.deactive();
	this._systemPanel.touchDeactive();
	this._menuCommand.touchDeactive();
	this._option.active();
	this._option.visible = true;
	const controller = this._animation;
	controller.clear(this._option);
	controller.add(this._option, {data:[{to:0, duration:30, property:'y', easingType:'easeOutQuart'}]});
	this.optionDimmer.visible = true;
};

Scene_Menu.prototype.pressLoadCancel = function() {
	this._systemPanel.active();
	this._systemPanel.touchActive();
	this._menuCommand.touchActive();
	this._load.deactive();
	this.optionDimmer.visible = false;
	const controller = this._animation;
	controller.clear(this._load);
	controller.add(this._load, {data:[{to:-this._load.pageHeight(), duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onLoadEasingComplete.bind(this)});
};

Scene_Menu.prototype.onLoadEasingComplete = function() {
	this._load.visible = false;
};

Scene_Menu.prototype.pressLoadOk = function() {
	const data = this._load.data();
	const savefileId = this._load.selectIndex() + this._load._dataStart;
	if(!DataManager.isSaveFileExist(savefileId)) {
		return;
	}
	DataManager.loadGame(savefileId)
        .then(() => this.onLoadSuccess())
        .catch(() => this.onLoadFailure());
	this._load.deactive();
};

Scene_Menu.prototype.pressAutoLoad = function() {
	if(!DataManager.isSaveFileExist(0)) {
		return;
	}
	DataManager.loadGame(0)
        .then(() => {this.allDeactive(); this.onLoadSuccess();})
        .catch(() => this.onLoadFailure());
};

Scene_Menu.prototype.allDeactive = function() {
	this._menuCommand.deactive();
	this._panelSprite.children.forEach((sprite) => {sprite.deactive();});
};

Scene_Menu.prototype.onLoadSuccess = function() {
	Scene_Title.prototype.onLoadSuccess.call(this);
};

Scene_Menu.prototype.onLoadFailure = function() {
    this.showTips("STATIC_TEXT_LOAD_FAILURE", this._load);
};

Scene_Menu.prototype.pressLoad = function() {
	this._systemPanel.deactive();
	this._systemPanel.touchDeactive();
	this._menuCommand.touchDeactive();
	this._load.active();
	this._load.visible = true;
	this.optionDimmer.visible = true;
	const controller = this._animation;
	controller.clear(this._load);
	controller.add(this._load, {data:[{to:140, duration:30, property:'y', easingType:'easeOutQuart'}]});
};

NYA.GAME.Scene_Menu_terminate = Scene_Menu.prototype.terminate;
Scene_Menu.prototype.terminate = function() {
	NYA.GAME.Scene_Menu_terminate.apply(this, arguments);
	if(this._loadSuccess) {
		$gameSystem.onAfterLoad();
	}
};

Scene_Map.prototype.fadeSpeed = function() {
    return 12;
};

Scene_Map.prototype.onTransferEnd = function() {
    $gameMap.autoplay();
	if(DataManager.shouldAutoSaveAfterTransfer && $gameTemp.triggerAutoSave()) {
		DataManager.autoSaveGame();
	}
};

Scene_Map.prototype.createDisplayObjects = function() {
	this.createSpriteset();
	this.createWeaponChange();
	this.createBattleBar();
	this.createMovingCursor();
	this.createSpecProgress();
	this.createArtwork();
	this.createSkipStory();
	this.createBossScore();
    this.createWindowLayer();
    this.createAllWindows();
    this.createButtons();
	this.createNotificationBar();
	this.createTaskNotificationBar();
	
	this.setMesaageWindowToArtwork();
	this.createSoftGuideBar();
	this.createZXCArtwork();
	this.createAutoSaveBar();
};

NYA.GAME.Scene_Map_initialize = Scene_Map.prototype.initialize;
Scene_Map.prototype.initialize = function() {
	NYA.GAME.Scene_Map_initialize.apply(this, arguments);
	this._animation = new AnimationController();
	this._battleBarHiding = true;
};

NYA.GAME.Scene_Map_update = Scene_Map.prototype.update;
Scene_Map.prototype.update = function() {
    this.updateMainMultiply();
    if (this.isSceneChangeOk()) {
        this.updateScene();
    } else if (SceneManager.isNextScene(Scene_Battle)) {
        this.updateEncounterEffect();
    }
    this.updateWaitCount();
	
	this._animation.update();
	this.checkMessageBusy();
	this.updateNewTaskAdd();
	this.updateHardGuideAdd();
	this.updateItemObtain();
	this.updateAutoSaveRequest();
	
	Scene_Message.prototype.update.call(this);
};

Scene_Map.prototype.checkMessageBusy = function() {
	const controller = this._animation;
	const busy = $gameMessage.isBusy() || $gameMap.isEventRunning() || this.isBarShelterPlayer();
	if(!this._battleBarHiding && busy) {
		controller.clear(this._playerBar);
		controller.add(this._playerBar, {data:[{
			to:-500, duration:18, easingType:'easeOutQuart', property:'x', delay:3
		}]});
		this._battleBarHiding = true;
	} 
	if(this._battleBarHiding && !busy) {
		controller.clear(this._playerBar);
		controller.add(this._playerBar, {data:[{
			to:this.playerBarX(), duration:12, easingType:'easeOutQuart', property:'x'
		}]});
		this._battleBarHiding = false;
	}
	if(this._touchUI) {
		this.updateTouchUIVisible();
	}
	if($gameMessage.isSkipMode() && !$gameMap.isEventRunning()) {
		$gameMessage.resetSkipMode();
	}
};

Scene_Map.prototype.isBarShelterPlayer = function() {
	const barX = 0;
	const barY = 0;
	const sx = -$gameMap.displayX() * $gameMap.tileWidth() + $gamePlayer.px;
	const sy = -$gameMap.displayY() * $gameMap.tileHeight() + $gamePlayer.py;
	const hl = $gamePlayer.hitOffsetL();
	const ht = $gamePlayer.hitOffsetT();
	const hr = $gamePlayer.hitOffsetR();
	const hb = $gamePlayer.hitOffsetB();
	const width = 460;
	const height = 108;
	return !physicsASM.isRectOutBound(sx, sy, hl, ht, hr, hb, barX, barY, 0, 0, width, height);
};

Scene_Map.prototype.updateTouchUIVisible = function() {
	this._touchUI.visible = !$gameMap.isEventCurrentRunning() && Input.mode() === undefined;
};

Scene_Map.prototype.createSoftGuideBar = function() {
	this._softGuideBar = new Sprite_SoftGuide({
		catLeftPos:{x:39,y:23}
		,backName:'soft_guide_back'
		,catName:'soft_guide_cat'
		,textSize:24
		,textColor:'#551717'
		,menuCallback:this.isMenuCalled.bind(this)
	});
	this.addChild(this._softGuideBar);
};

Scene_Map.prototype.createBattleBar = function() {
	this._damageDigit = new Sprite_DamageDigitGroup();
	this.addChild(this._damageDigit);
	this._playerBar = new Sprite_PlayerBar({
		hp: {
			backName:'map_player_hp_back'
			,rollName:'map_player_hp_roll'
			,progressName:'map_player_hp_progress'
			,progressOffset:{x:1,y:6}
			,rollSpeed:1/180
			,progressSpeed:1/30
			,rollInterval:180
			,x:90
			,y:0
		}
		,sp: {
			backName:'map_player_sp_back'
			,progressName:'map_player_sp_progress'
			,progressOffset:{x:1,y:18}
			,progressSpeed:1/30
			,x:90
			,y:15
		}
		,zp: {
			backName:'map_player_zp_back'
			,progressName:'map_player_zp_progress'
			,progressOffset:{x:2,y:1}
			,progressSpeed:1/30
			,x:78
			,y:51
		}
		,face: {
			backName:'map_player_face_back'
			,faceName:$gamePlayer.battleObject().faceName
			,dangerFaceName:$gamePlayer.battleObject().dangerFaceName
			,faceOffset:{x:54,y:56}
			,x:-8
			,y:-29
		}
		,buff: {
			x:84
			,y:84
			,iconBackName:"buff_status"
		}
		
		,hpNumberTextSize:26
		,hpNumberTextOutlineWidth:4
		,hpNumberTextColorStart:'#ff9bb7'
		,hpNumberTextColorStop:'#ffffff'
		,hpNumberTextOutlineColor:'#551717'
		,hpNumberOffset:{x:388,y:1}
		,statusBackName:'map_player_status_back'
		,backName:'map_player_bar_back'
		,backOffset:{x:30,y:-59}
	});
	this.addChild(this._playerBar);
	if(Utils.isNoPopupBarScene()) {
		this._playerBar.x = this.playerBarX();
	} else {
		this._playerBar.x = -500;
	}
	this._playerBar.y = this.playerBarY();
	this._enemyBar = new Sprite_EnemyHpBar({
		backName:'map_enemy_hp_back'
		,rollName:'map_enemy_hp_roll'
		,progressName:'map_enemy_hp_progress'
		,progressOffset:{x:32,y:47}
		,rollSpeed:1/120
		,progressSpeed:1/30
		,rollInterval:120
		,showX:962 + Graphics.width - NYA.BASE_SCREEN_WIDTH
		,showY:Utils.isMobileDevice() ? 140 : 622
		,hiddenDuration:18
	});
	this._enemyBar.x = this._enemyBar.hiddenX();
	this.addChild(this._enemyBar);
	this._smallMap = new Sprite_SmallMap({
		backName:'map_thumbnail'
		,padding:6
		,hiddenDuration:18
	});
	this.addChild(this._smallMap);
	this._bossBar = new Sprite_BossHpBar({
		backName:'map_boss_hp_back'
		,backOffset:{x:-41, y:-62}
		,rollName:'map_boss_hp_roll'
		,progressName:'map_boss_hp_progress'
		,progressOffset:{x:37,y:3}
		,rollSpeed:1/120
		,progressSpeed:1/30
		,rollInterval:120
		,showX:848 + Graphics.width - NYA.BASE_SCREEN_WIDTH
		,showY:45
		,hiddenDuration:18
		,face: {
			backName:'map_boss_face_back'
			,faceName:""
			,dangerFaceName:""
			,faceOffset:{x:54,y:56}
			,x:-67
			,y:-45
		}
		,buff: {
			x:38
			,y:48
			,iconBackName:"buff_status"
		}
		,scoreStar: {
			x:52
			,y:-2
		}
	});
	this.addChild(this._bossBar);
};

Scene_Map.prototype.playerBarX = function() {
	return 24;
};

Scene_Map.prototype.playerBarY = function() {
	return 30;
};

Scene_Map.prototype.createMovingCursor = function() {
	this._movingCursor = new Sprite_MapMovingCursor({
		backName:'map_moving_cursor_back'
		,cursorName:'map_moving_cursor'
		,cursorMargin:3
	});
	this._movingCursor.x = Graphics.width / 2;
	this._movingCursor.y = Graphics.height - 110;
	this.addChild(this._movingCursor);
};

Scene_Map.prototype.createSpecProgress = function() {
	this._specProgress = new Sprite_SpecProgress({
			backName:'spec_progress_back'
			,progressName:'spec_progress'
			,progressOffset:{x:9,y:8}
			,progressSpeed:1/30
	});
	this._specProgress.x = (Graphics.width - this._specProgress.allWidth()) / 2;
	this._specProgress.y = Graphics.height - 70;
	this.addChild(this._specProgress);
};

NYA.GAME.Scene_Map_terminate = Scene_Map.prototype.terminate;
Scene_Map.prototype.terminate = function() {
	NYA.GAME.Scene_Map_terminate.apply(this, arguments);
	$gameMap.clearHotEvent();
	$gameSystem.clearSoftGuide();
	AudioManager.stopAllRandLoopSe();
	ConfigManager.onMapChange();
	if(SceneManager.isNextScene(Scene_Map)) {
		$gameSystem.saveMapDeathStatus();
		$gameMap.clearBossEvent();
	}
};

Scene_Map.prototype.createTaskNotificationBar = function() {
	this._notificationBarTaskMain = new Sprite_NotificationBar({
		backName:'notification_task_main'
		, mainTextOffset:{x:32, y:70}
		, subTextOffset:{x:32, y:112}
		, mainTextSize:24
		, subTextSize:24
		, mainTextColor:'#551717'
		, subTextColor:'#c10000'
		, y:160
		, align:'center'
		, runDuration:30
		, runningMaxShowingTime:240
	});
	this._notificationBarTaskSub = new Sprite_NotificationBar({
		backName:'notification_task_sub'
		, mainTextOffset:{x:32, y:38}
		, subTextOffset:{x:32, y:75}
		, mainTextSize:24
		, subTextSize:24
		, mainTextColor:'#551717'
		, subTextColor:'#551717'
		, y:340
		, align:'center'
		, runDuration:30
		, runningMaxShowingTime:240
	});
	this.addChild(this._notificationBarTaskMain, this._notificationBarTaskSub);
};

Scene_Map.prototype.createBossScore = function() {
	this._bossScore = new Sprite_BossScore({
		backName:"boss_score_back"
		, starBottomPadding:10
	});
	this._bossScore.y = 48;
	this.addChild(this._bossScore);
};

Scene_Map.prototype.createButtons = function() {
	this._touchUI = null;
	if(Utils.isMobileDevice()) {
		this._touchUI = new Sprite_TouchUI({
			textSize:20
			, textColor:"#551717"
			, textOffsetX:16
			, menuButtonOffset:{x:474, y:18}
		});
		this.addChild(this._touchUI);
		this.updateTouchUIVisible();
	}
};

Scene_Map.prototype.createWeaponChange = function() {
	this._weaponChange = new Sprite_WeaponChanging();
	this.addChild(this._weaponChange);
};

Scene_Map.prototype.updateHardGuideAdd = function() {
	if($gameSystem.hardGuide()) {
		SceneManager.push(Scene_HardGuide);
	}
};

Scene_Map.prototype.updateNewTaskAdd = function() {
	if($gameMessage.isBusy() || $gameMap.isEventRunning()) {
		return;
	}
	const noticeMain = this._notificationBarTaskMain;
	const noticeSub = this._notificationBarTaskSub;
	if(noticeMain.isRunning() || noticeSub.isRunning()) {
		return;
	}
	const actor = $gamePlayer.actor();
	const completeTaskId = actor.getCompleteShowingTask();
	if(completeTaskId) {
		this.showTaskNotification(completeTaskId, TextManager['STATIC_TEXT_COMPLETE_TASK']);
		AudioManager.playNormalSe("del_task");
		return;
	}
	const taskId = actor.getShowingTask();
	if(taskId) {
		this.showTaskNotification(taskId, TextManager['STATIC_TEXT_NEW_TASK']);
		AudioManager.playNormalSe("add_task");
	}
};

Scene_Map.prototype.updateItemObtain = function() {
	if($gameSystem.hasLastObtainItem()) {
		SceneManager.push(Scene_ItemObtain);
	}
};

Scene_Map.prototype.updateAutoSaveRequest = function() {
	if($gameTemp.pollAutoSaveRequest()) {
		DataManager.autoSaveGame();
	}
};

Scene_Map.prototype.showTaskNotification = function(taskId, mainText) {
	const subText = DataManager.taskFullName(taskId);
	const type = $dataTask[taskId].type;
	const notice = type === 0 ? this._notificationBarTaskMain : this._notificationBarTaskSub;
	notice.setText(mainText, subText);
	notice.run();
};

Scene_Map.prototype.createSkipStory = function() {
	this._skipStory = new Sprite_SkipStory({
		buttonName:"skip_story_button"
		, buttonDownName:"skip_story_button_down"
		, buttonOffset:{x:14,y:8}
		, buttonTextOffsetY:-4
		, textColor:"#551717"
		, textSize:18
		, signName:"skip_story_sign"
		, hideHeight:53
		, signOffset:{x:100, y:16}
	});
	this.addChild(this._skipStory);
};

Scene_Message.prototype.messageWindowRect = function() {
	const ww = Graphics.width;
    const wh = ImageManager.loadUI('message').height;
    const wx = 0;
    const wy = Graphics.height - wh;
    return new Rectangle(wx, wy, ww, wh);
};

Window_Message.prototype.loadWindowskin = function() {
};

Window_Message.prototype._refreshBack = function() {
};


NYA.GAME.Window_Message_initialize = Window_Message.prototype.initialize;
Window_Message.prototype.initialize = function() {
	NYA.GAME.Window_Message_initialize.apply(this, arguments);
	this._animation = new AnimationController();
	this._mutiline = true;
	this._seThinningCounter = 0;
	this.createBackground();
	this.createCat();
};

Window_Message.prototype.createBackground = function() {
	const spriteLT = new Sprite(ImageManager.loadUI("message_lt"));
	spriteLT.x = 0;
	spriteLT.y = 20;
	this._container.addChildAt(spriteLT, 0);
	const spriteRB = new Sprite(ImageManager.loadUI("message_rb"));
	spriteRB.x = Graphics.width - spriteRB.width;
	spriteRB.y = 179;
	spriteRB.anchor.y = 1;
	this._container.addChildAt(spriteRB, 0);
	const sprite = new Sprite(ImageManager.loadUI('message'));
	sprite.x = -2 + Graphics.width / 2;
	sprite.anchor.x = 0.5;
	sprite.y = 8;
	this._container.addChildAt(sprite, 0);
	const spriteLeft = new Sprite(ImageManager.loadUI("message_left"));
	spriteLeft.x = 0;
	spriteLeft.y = 8;
	this._container.addChildAt(spriteLeft, 0);
	const spriteRight = new Sprite(ImageManager.loadUI("message_right"));
	spriteRight.x = Graphics.width - spriteRight.width;
	spriteRight.y = 8;
	this._container.addChildAt(spriteRight, 0);
	sprite.scale.x = (Graphics.width - spriteLeft.width - spriteRight.width) / sprite.width;
};

Window_Message.prototype.createCat = function() {
	this._cat = new Sprite(ImageManager.loadUI('message_cat'));
	this._container.addChild(this._cat);
	this._cat.anchor.x = this._cat.anchor.y = 0.5;
	this._cat.x = this.width - 80;
	this._cat.y = this.height - 59;
	const r = -0.3;
	const duration = 30;
	this._animation.add(this._cat, {data:[{property:'rotation', to:r, duration:duration, easingType:'linear'}
	,{property:'rotation', to:-r, duration:duration, easingType:'linear'}],loop:true});
};

NYA.GAME.Window_Message_update = Window_Message.prototype.update;
Window_Message.prototype.update = function() {
	NYA.GAME.Window_Message_update.apply(this, arguments);
	this._cat.visible = this.pause;
	this._animation.update();
};

Window_Message.prototype.isTriggered = function() {
	$gameMessage.updateSkipMode();
    const triggered = (
        Input.isUIRepeated("ok") ||
        Input.isRepeated("cancel") ||
		TouchInput.isReleased() || 
		$gameMessage.isSkipMode()
    );
	if(triggered) {
		$gameSystem.setGuideCompleted("talk");
		return true;
	}
	return false;
};

Window_Message.prototype.newLineX = function(textState) {
    const faceExists = $gameMessage.faceName() !== "";
    const faceWidth = ImageManager.faceWidth;
    const spacing = 20;
    const margin = faceExists ? faceWidth + spacing : this.textStartX();
	const center = $gameMessage.center();
	if(center) {
		this._mutiline = false;
		const textSize = this.textSizeEx(textState.text.substr(textState.index));
		this._mutiline = true;
		if(textSize.width <= this.maxLineWidth()) {
			return (this.innerWidth - textSize.width) / 2;
		}
	}
	return textState.rtl ? this.innerWidth - margin : margin;
};

NYA.GAME.Window_Message_newPage = Window_Message.prototype.newPage;
Window_Message.prototype.newPage = function(textState) {
	NYA.GAME.Window_Message_newPage.apply(this, arguments);
    textState.y = this.textStartY();
	this._seThinningCounter = 0;
};

Window_Message.prototype.textStartX = function() {
	return 280 + Utils.baseHalfWidth();
};

Window_Message.prototype.textStartY = function() {
	if($gameMessage.positionType() === 2) {
		return 40;
	} else {
		return (this.height - this.lineHeight()) / 2;
	}
};

Window_Message.prototype.lineMargin = function() {
	return 0;
};

Window_Message.prototype.updatePadding = function() {
    this.padding = 0;
};

Window_Message.prototype.resetFontSettings = function() {
    this.contents.fontFace = $gameSystem.mainFontFace();
    this.contents.fontSize = $gameSystem.mainFontSize();
	if($gameMessage.positionType() === 2) {
		this.contents.textColor = '#551717';
		this.contents.outlineWidth = 0;
	} else {
		this.contents.textColor = '#ffffff';
		this.contents.outlineWidth = 3;
	}
};

NYA.GAME.Window_Message_flushTextState = Window_Message.prototype.flushTextState;
Window_Message.prototype.flushTextState = function(textState) {
	NYA.GAME.Window_Message_flushTextState.apply(this, arguments);
	if(this._mutiline && this._textState.outputWidth > this.maxLineWidth() && !this.shouldWaitForSpacingNewLine()) {
		textState.x = this.newLineX(textState);
		textState.y += textState.height;
		textState.y += this.lineMargin();
		textState.outputWidth = 0;
	}
};

Window_Message.prototype.shouldWaitForSpacingNewLine = function() {
	return Utils.isSpacingNewLineLanguage() && this._textState.text[this._textState.index] !== " ";
};

Window_Message.prototype.updateMessage = function() {
    const textState = this._textState;
    if (textState) {
        while (!this.isEndOfText(textState)) {
            if (this.needsNewPage(textState)) {
                this.newPage(textState);
            }
            this.updateShowFast();
			this.processCharacter(textState);
			if(this.checkFastTextSpeed(textState)) {
				this.processCharacter(textState);
			}
			this.flushTextState(textState);
			this.playTextSe();
            if (this.shouldBreakHere(textState)) {
                break;
            }
        }
        if (this.isEndOfText(textState) && !this.isWaiting()) {
            this.onEndOfText();
        }
        return true;
    } else {
        return false;
    }
};

Window_Message.prototype.playTextSe = function() {
	if(this._seThinningCounter % 3 === 0) {
		if(Utils.randomInt(0, 1) === 0) {
			AudioManager.playNormalSe("text1");
		} else {
			AudioManager.playNormalSe("text2");
		}
	}
	this._seThinningCounter++;
};

NYA.GAME.Window_Message_shouldBreakHere = Window_Message.prototype.shouldBreakHere;
Window_Message.prototype.shouldBreakHere = function() {
	return NYA.GAME.Window_Message_shouldBreakHere.apply(this, arguments) && !this.checkInTimeTextSpeed();
};

Window_Message.prototype.checkFastTextSpeed = function(textState) {
	const speed = ConfigManager.getTextSpeed();
	return speed === NYA.CONFIG.CONST.TEXT_SPEED_FAST && textState.index < textState.text.length;
};

Window_Message.prototype.checkInTimeTextSpeed = function() {
	const speed = ConfigManager.getTextSpeed();
	return speed === NYA.CONFIG.CONST.TEXT_SPEED_IN_TIME;
};

Window_Base.prototype.flushTextState = function(textState) {
    const text = textState.buffer;
    const rtl = textState.rtl;
    const width = this.textWidth(text);
    const height = textState.height;
    const x = rtl ? textState.x - width : textState.x;
    const y = textState.y;
    if (textState.drawing) {
        this.contents.drawText(text, x, y, width, height);
    }
    textState.x += rtl ? -width : width;
    textState.buffer = this.createTextBuffer(rtl);
    const outputWidth = Math.abs(textState.x - textState.startX);
    if (textState.outputWidth < outputWidth) {
        textState.outputWidth = outputWidth;
    }
    textState.outputHeight = y - textState.startY + height;
};

Window_Message.prototype.maxLineWidth = function() {
	return this.width - this.textStartX() * 2;
};

Object.defineProperty(Window_Message.prototype, "openness", {
    get: function() {
        return this._openness;
    },
    set: function(value) {
        if (this._openness !== value) {
            this._openness = value.clamp(0, 255);
            this._container.y = this.height * (1 - this._openness / 255);
			if(this._openness === 0) {
				this.visible = false;
			} else {
				this.visible = true;
			}
        }
    },
    configurable: true
});

Window_Message.prototype.drawShape = function(graphics) {
    if (graphics) {
        const width = this.width;
        const height = this.height;
        const x = this.x;
        const y = this.y + this._container.y;
        graphics.beginFill(0xffffff);
        graphics.drawRoundedRect(x, y, width, height, 0);
        graphics.endFill();
    }
};

NYA.GAME.Window_NameBox_initialize = Window_NameBox.prototype.initialize;
Window_NameBox.prototype.initialize = function() {
    NYA.GAME.Window_NameBox_initialize.apply(this, arguments);
	this.createBackground();
};

Window_NameBox.prototype.createBackground = function() {
	this._background = new Sprite(ImageManager.loadUI('message_namebox'));
	this._container.addChildAt(this._background, 0);
};

Window_NameBox.prototype.updatePlacement = function() {
    this.width = this.windowWidth();
    this.height = this.windowHeight();
    const messageWindow = this._messageWindow;
    if ($gameMessage.artworkPos() >= 2) {
        this.x = messageWindow.width - this.width - this.shiftX();
		this._background.scale.x = -1;
		this._background.x = this.width;
    } else {
        this.x = this.shiftX();
		this._background.scale.x = 1;
		this._background.x = 0;
    }
    if (messageWindow.y > 0) {
        this.y = -this.height / 2;
    } else {
        this.y = messageWindow.height;
    }
	if(!this._name) {
		this.hide();
	} else {
		this.show();
	}
};

Window_NameBox.prototype.shiftX = function() {
	return 230 + Utils.baseHalfWidth();
};

Window_NameBox.prototype.loadWindowskin = function() {
};

Window_NameBox.prototype._refreshBack = function() {
};

Window_NameBox.prototype.windowWidth = function() {
    return this._background.width;
};

Window_NameBox.prototype.windowHeight = function() {
    return this._background.height;
};

Window_NameBox.prototype.resetFontSettings = function() {
    this.contents.fontFace = $gameSystem.mainFontFace();
    this.contents.fontSize = 22;
	this.contents.textColor = this.speakerColor();
    this.contents.outlineWidth = 2;
	this.contents.outlineColor = '#551717';
};

Window_NameBox.prototype.speakerColor = function() {
	const speakerId = $gameMessage.speakerId();
	if($dataActors[speakerId] && $dataActors[speakerId].meta.color) {
		return $dataActors[speakerId].meta.color;
	}	
	return '#ffffff';
};

Window_NameBox.prototype.baseTextRect = function() {
	const width = this.textWidth(this._name);
	let shiftX = 0;
	if ($gameMessage.artworkPos() >= 2) {
        shiftX = -24;
    } else {
        shiftX = 4;
    }
	const shiftY = 10;
	return new Rectangle((this.width - width) / 2 + shiftX, shiftY, width, this.height);
};

Object.defineProperty(Window_NameBox.prototype, "openness", {
    get: function() {
        return this._openness;
    },
    set: function(value) {
        if (this._openness !== value) {
            this._openness = value.clamp(0, 255);
        }
    },
    configurable: true
});

Scene_Message.prototype.createNameBoxWindow = function() {
    this._nameBoxWindow = new Window_NameBox();
    this._messageWindow._container.addChild(this._nameBoxWindow);
};

Scene_Map.prototype.createArtwork = function() {
	this._artwork = new Sprite_Artwork();
	this.addChild(this._artwork);
};

Scene_Map.prototype.createZXCArtwork = function() {
	this._zxcArtwork = new Sprite_ZXCArtwork();
	this.addChild(this._zxcArtwork);
};

Scene_Map.prototype.setMesaageWindowToArtwork = function() {
	this._artwork.setMessageWindow(this._messageWindow);
};

Window_ChoiceList.prototype.drawItem = function(index) {
    const rect = this.itemLineRect(index);
	const name = this.commandName(index);
	const size = this.textSizeEx(name);
	const x = Math.trunc((rect.width - size.width) / 2) + this.padding;
    this.drawTextEx(this.commandName(index), x, rect.y, rect.width);
};

Window_ChoiceList.prototype.windowWidth = function() {
    return Graphics.width * 0.5;
};

Window_ChoiceList.prototype.windowY = function() {
    return (Graphics.height - this.windowHeight()) / 2;
};

Window_ChoiceList.prototype._makeCursorAlpha = function() {
    const baseAlpha = this.contentsOpacity / 255;
    return baseAlpha;
};

Window_ChoiceList.prototype.drawItemBackground = function(index) {
    const rect = this.itemRect(index);
	const name = "" + index;
	if(!this._contentsBackSprite.getChildByName(name)) {
		const nsprite = new Sprite();
		nsprite.name = name;
		this._contentsBackSprite.addChild(nsprite);
	}
	const sprite = this._contentsBackSprite.getChildByName(name);
	sprite.x = rect.x;
	sprite.y = rect.y;
	sprite.bitmap = ImageManager.loadUI('choice_item');
	sprite.scale.x = rect.width / sprite.width;
};


NYA.GAME.Window_ChoiceList_clearItem = Window_ChoiceList.prototype.clearItem;
Window_ChoiceList.prototype.clearItem = function(index) {
    NYA.GAME.Window_ChoiceList_clearItem.apply(this, arguments);
	const name = "" + index;
	const child = this._contentsBackSprite.getChildByName(name);
	if(child) { this._contentsBackSprite.removeChild(child); }
};

NYA.GAME.Window_ChoiceList_drawAllItems = Window_ChoiceList.prototype.drawAllItems;
Window_ChoiceList.prototype.drawAllItems = function() {
	this._contentsBackSprite.removeChildren();
	NYA.GAME.Window_ChoiceList_drawAllItems.apply(this, arguments);
};

NYA.GAME.Window_ChoiceList_initialize = Window_ChoiceList.prototype.initialize;
Window_ChoiceList.prototype.initialize = function() {
	NYA.GAME.Window_ChoiceList_initialize.apply(this, arguments);
	this.visible = false;
};

NYA.GAME.Window_ChoiceList_open = Window_ChoiceList.prototype.open;
Window_ChoiceList.prototype.open = function() {
	NYA.GAME.Window_ChoiceList_open.apply(this, arguments);
	this.visible = true;
};

NYA.GAME.Window_ChoiceList_close = Window_ChoiceList.prototype.close;
Window_ChoiceList.prototype.close = function() {
	NYA.GAME.Window_ChoiceList_close.apply(this, arguments);
	this.visible = false;
};

NYA.GAME.Scene_Base_terminate = Scene_Base.prototype.terminate;
Scene_Base.prototype.terminate = function() {
	NYA.GAME.Scene_Base_terminate.apply(this, arguments);
	if(this._notificationBarSystem) { 
		Input.unsetGamepadConnectedHandler();
	}
};

Scene_Base.prototype.createNotificationBar = function() {
	this._notificationBarSystem = new Sprite_NotificationBar({
		backName:'notification'
		, mainTextOffset:{x:55, y:75}
		, subTextOffset:{x:20, y:112}
		, mainTextSize:24
		, subTextSize:18
		, mainTextColor:'#551717'
		, subTextColor:'#551717'
		, y:420
		, align:'center'
		, runDuration:30
		, runningMaxShowingTime:180
	});
	this.addChild(this._notificationBarSystem);
	Input.setGamepadConnectedHandler(this.onGamepadConnected.bind(this));
};

Scene_Base.prototype.createAutoSaveBar = function() {
	this._autoSaveBar = new Sprite_AutoSave();
	this.addChild(this._autoSaveBar);
	if(Utils.isMobileDevice()) {
		this._autoSaveBar.x = Graphics.width - 360;
		this._autoSaveBar.y = 96;
	} else {
		this._autoSaveBar.x = Graphics.width - 124;
		this._autoSaveBar.y = Graphics.height - 110;
	}
};

Scene_Base.prototype.requestNotificationSystem = function(mainText, subText) {
	if(this._notificationBarSystem) {
		const notice = this._notificationBarSystem;
		if(notice.isRunning()) {
			notice.terminateRunning();
		}
		notice.setText(mainText, subText);
		notice.run();
	}
};

Scene_Base.prototype.onGamepadConnected = function() {
	//this.requestNotificationSystem(TextManager.STATIC_TEXT_GAMEPAD_CONNECTED, TextManager.STATIC_TEXT_AFTER_GAMEPAD_CONNECTED);
};

NYA.GAME.Scene_Base_update = Scene_Base.prototype.update;
Scene_Base.prototype.update = function() {
	NYA.GAME.Scene_Base_update.apply(this, arguments);
	this.checkStoryLoadingError();
	this.checkStoryLoadingSuccess();
	this.checkLanguageChange();
};

Scene_Base.prototype.checkStoryLoadingError = function() {
	const errorLanguage = DataManager.checkStoryLoadingError();
	if(errorLanguage) {
		this.requestNotificationSystem(TextManager.STATIC_TEXT_LANGUAGE_LOAD_FAILED.format(errorLanguage), TextManager.STATIC_TEXT_LANGUAGE_RESET_DEFAULT.format($dataLanguage));
	}
};

Scene_Base.prototype.checkStoryLoadingSuccess = function() {
	if(DataManager.checkStoryLoadingSuccess()) {
		this.requestNotificationSystem(TextManager.STATIC_TEXT_LANGUAGE_LOAD_SUCCESS, TextManager.STATIC_TEXT_LANGUAGE_APPLY);
	}
};

Scene_Base.prototype.checkLanguageChange = function() {
	if(DataManager.checkLanguageChange()) {
		this.onLanguageChange();
	}
};

Scene_Base.prototype.onLanguageChange = function() {
	// ...
};

function Scene_Transport() {
	this.initialize(...arguments);
}

Scene_Transport.prototype = Object.create(Scene_Base.prototype);
Scene_Transport.prototype.constructor = Scene_Transport;

Scene_Transport.prototype.initialize = function() {
	Scene_Base.prototype.initialize.apply(this, arguments);
	this._animation = new AnimationController();
};

Scene_Transport.prototype.create = function() {
	Scene_Base.prototype.create.apply(this, arguments);
	this.createBackground();
	this._transport = new Sprite_Transport({
		regionTitleBackName:"transport_title_back"
		,regionTitleOffset:{x:15,y:0}
		,regionTitleTextOffset:{x:20,y:5}
		,textSize:22
		,textColor:'#551717'
		,regionImagePadding:42
		,regionCommandOffset:{x:82 + Utils.baseHalfWidth(),y:114}
		,regionCommandBackName:'transport_command_back'
		,regionMapBackName:'transport_map_back'
		
		,commandBackName:'transport_command_item_back'
		,commandLockName:'transport_command_lock'
		,commandCursorName:'transport_command_cursor'
		,commandMaskPadding:2
		,cursorOffset:{x:-3,y:-2}
		,lockOffset:{x:1,y:3}
		,moveSignMargin:20
		,moveSignName:'option_move_sign'
		
		,tipsBackName:'transport_tips'
		,tipsTextColor:'#ffffff'
		
		,taskSelectOptions: {
				pageNum:6
				,moveSignName:'option_move_sign'
				,itemName:'task_select_item'
				,cursorName:'task_select_cursor'
				,textSize:22
				,textColor:'#551717'
				,mainTaskColor:'#c10000'
				,itemMargin:8
				,textStartX:26
				,noTaskTipsTextColor:'#551717'
				,moveSignMargin:0
		}
	});
	this.addChild(this._transport);
	this._transport.y = -Graphics.height;
	this._transport.x = 0;
	this._transport.pressOk = this.pressOk.bind(this);
	this._transport.pressCancel = this.popScene.bind(this);
};

Scene_Transport.prototype.start = function() {
	Scene_Base.prototype.start.apply(this, arguments);
	this.startTransportFadeIn();
};

Scene_Transport.prototype.pressOk = function() {
	const regionId = this._transport.selectRegion();
	if($gameSystem.isRegionUnlock(regionId) && DataManager.regionId() !== regionId) {
		const cell = $dataRegion[regionId].transportCell;
		const mapId = cell.mapId;
		const mapData = DataManager.getCachedData(mapId);
		const x = mapData.transport[0][0];
		const y = mapData.transport[0][1];
		$gameTemp.setTransport(mapId, x, y, regionId);
		$gameTemp.reserveCommonEvent(26);
		this.popScene();
		return true;
	} else {
		return false;
	}
};

Scene_Transport.prototype.startTransportFadeIn = function() {
	const controller = this._animation;
	controller.clear(this._transport);
	controller.add(this._transport, {data:[{
		property:'y', duration:30, easingType:'easeOutQuart', to:0 
	}]});
};

Scene_Transport.prototype.onLanguageChange = function() {
	Scene_Base.prototype.onLanguageChange.call(this);
	this._transport.onLanguageChange();
};

Scene_Transport.prototype.createBackground = function() {
	Scene_Save.prototype.createBackground.call(this);
};

Scene_Transport.prototype.update = function() {
	Scene_Base.prototype.update.apply(this, arguments);
	this._animation.update();
};

Scene_Gameover.prototype.createBackground = function() {
	this._backSprite = new Sprite();
    this._backSprite.bitmap = ImageManager.loadUI("gameover");
	this._backSprite.visible = false;
    this.addChild(this._backSprite);
};

NYA.GAME.Scene_Gameover_initialize = Scene_Gameover.prototype.initialize;
Scene_Gameover.prototype.initialize = function() {
	NYA.GAME.Scene_Gameover_initialize.apply(this, arguments);
	this._deathAnimationTimelineIndex = 0;
	this._deathAnimationCounter = 0;
	this._animation = new AnimationController();
};

Scene_Gameover.prototype.animationTimeline = function() {
	return [
		[0,40]
		,[1,128]
		,[2,80]
		,[3,24]
		,[4,50]
		,[5,96]
	];
};

Scene_Gameover.prototype.animationPrefix = function() {
	return ";toru_gameover";
};

Scene_Gameover.prototype.start = function() {
    Scene_Base.prototype.start.call(this);
    this.adjustBackground();
};

NYA.GAME.Scene_Gameover_create = Scene_Gameover.prototype.create;
Scene_Gameover.prototype.create = function() {
	NYA.GAME.Scene_Gameover_create.apply(this, arguments);
	this.createTitle();
	this.createSelectBox();
	this.createArtwork();
	this.createHint();
	this.createDimmer();
	this.createLoad();
	this.createWindowLayer();
	this.createAllWindow();
	this.createSnapSprite();
};

Scene_Gameover.prototype.playGameoverMusic = function() {
};

Scene_Gameover.prototype.createSnapSprite = function() {
	this._baseSnapSprite = new Sprite();
	this.addChild(this._baseSnapSprite);
	this._snapSprite = SceneManager.backGroundSprite();
	this._baseSnapSprite.addChild(this._snapSprite);
	
	this._playerDeathAnimationSprite = new Sprite_Character($gamePlayer);
	this._baseSnapSprite.addChild(this._playerDeathAnimationSprite);
	$gamePlayer.makeInvincible(0);
	this._playerDeathAnimationSprite.update();
};

Scene_Gameover.prototype.createTitle = function() {
	const titleName = Utils.isLegalMode() ? 'gameover_title_legal' : 'gameover_title';
	this._titleSprite = new Sprite(ImageManager.loadUI(titleName));
	this.addChild(this._titleSprite);
	this._titleSprite.x = -this._titleSprite.width;
	this._titleSprite.y = 72;
};

Scene_Gameover.prototype.createSelectBox = function() {
	this._selectBox = new Sprite_GameoverBox({
		buttonSelectedName:'gameover_button_selected'
		,backName:'gameover_select_box_back'
		,buttonUnselectedName:'gameover_button_unselected'
		,buttonMargin:18
		,textSizeSelected:24
		,textSizeUnselected:24
		,textColor:'#551717'
		,titleOffsetY:98
	});
	this._selectBox.setTitle('STATIC_TEXT_GAMEOVER_CONTINUE');
	this._selectBox.setButtonName('STATIC_TEXT_CONTINUE_YES', 'STATIC_TEXT_CONTINUE_NO');
	this.addChild(this._selectBox);
	this._selectBox.y = Graphics.height;
	this._selectBox.x = Graphics.width - 471;
	this._selectBox.pressOk = this.pressBoxOk.bind(this);
};

Scene_Gameover.prototype.createArtwork = function() {
	this._artwork = new Sprite_KeyFrameAnimation('gameover_artwork', 2, 'img/ui/');
	const bitmap1 = ImageManager.loadUI("gameover_artwork1");
	this._artwork.x = (Graphics.width - bitmap1.width) / 2 - 60;
	if(!$gamePlayer.isSquash()) {
		this._artwork.y = (Graphics.height - bitmap1.height) / 2;
	} else {
		const realHeight = bitmap1.height / 2;
		this._artwork.y = (Graphics.height - realHeight) / 2;
		this._artwork.scale.y = 0.5;
	}
	this.addChild(this._artwork);
};

Scene_Gameover.prototype.pressBoxOk = function() {
	const name = this._selectBox.selectedButton();
	switch(name) {
		case "up": this.pressLoad(); break;
		case "down": this._selectBox.deactive(); this.backToTown(); break;
		default: break;
	}
};

Scene_Gameover.prototype.backToTown = function() {
	this._baseSnapSprite.removeChild(this._playerDeathAnimationSprite);
	this._playerDeathAnimationSprite.destroy();
	this._playerDeathAnimationSprite = null;
	$gamePlayer.battleObject()._hp = $gamePlayer.battleObject().mhp;
	$gamePlayer.battleObject().clearBuff();
	$gamePlayer.actor().deductCoin(Math.ceil($gamePlayer.actor().coin() * 0.2));
	$gamePlayer._deathFadeoutCounter = 0;
	$gamePlayer.unlockSkillInvincible();
	$gamePlayer.updateStatem();
	$gamePlayer.startTransport(6, 11, 9, false);
	$gamePlayer.endTransport();
	if(!$gameLily.isRemove()) {
		$gameLily.startTransport(6, 11, 9, false);
		$gameLily.endTransport();
	}
	$gameLily.endWallFight();
	AudioManager.stopSe();
	SceneManager.goto(Scene_Map);
};

Scene_Gameover.prototype.pressLoad = function() {
	if(this.shouldAutoload()) {
		DataManager.loadGame(0)
			.then(() => { this.onLoadSuccess(); this._selectBox.deactive(); })
			.catch(() => this.onLoadFailure());
	} else {
		this._selectBox.deactive();
		this._load.active();
		this._load.visible = true;
		this.optionDimmer.visible = true;
		const controller = this._animation;
		controller.clear(this._load);
		controller.add(this._load, {data:[{to:140, duration:30, property:'y', easingType:'easeOutQuart'}]});
	}
};

Scene_Gameover.prototype.pressLoadCancel = function() {
	this._selectBox.active();
	this._load.deactive();
	this.optionDimmer.visible = false;
	const controller = this._animation;
	controller.clear(this._load);
	controller.add(this._load, {data:[{to:-this._load.pageHeight(), duration:30, property:'y', easingType:'easeOutQuart'}]
		, complete:this.onLoadEasingComplete.bind(this)});
};

Scene_Gameover.prototype.pressLoadOk = function() {
	Scene_Title.prototype.pressLoadOk.call(this);
};

Scene_Gameover.prototype.onLoadSuccess = function() {
	Scene_Title.prototype.onLoadSuccess.call(this);
	AudioManager.stopSe();
};

Scene_Gameover.prototype.onLoadEasingComplete = function() {
	Scene_Title.prototype.onLoadEasingComplete.call(this);
};

Scene_Gameover.prototype.createDimmer = function() {
	Scene_Title.prototype.createDimmer.call(this);
};

Scene_Gameover.prototype.createHint = function() {
	this._hintSprite = null;
	const hintId = $gameMap.checkBossHint();
	if(hintId) {
		this._hintSprite = new Sprite_BossHint(hintId);
		this._hintSprite.x = -this._hintSprite.allWidth();
		this.addChild(this._hintSprite);
	}
};

NYA.GAME.Scene_Gameover_update = Scene_Gameover.prototype.update;
Scene_Gameover.prototype.update = function() {
	Scene_Base.prototype.update.apply(this, arguments);
	this.updateAnimationTimeline();
	this.updateScaleEffect();
	if(!this.isBusy() && !this._loadSuccess) {
		$gamePlayer.update();
		$gamePlayer.flush();
	}
	this._animation.update();
};

Scene_Gameover.prototype.updateAnimationTimeline = function() {
	const line = this.animationTimeline();
	if(this._deathAnimationTimelineIndex < line.length) {
		const lineOne = line[this._deathAnimationTimelineIndex];
		const maxTime = lineOne[1];
		if(Input.isUITriggered("menu") || TouchInput.isLongPressed()) {
			this._deathAnimationTimelineIndex = line.length - 1;		// 跳过游戏结束动画
			this._deathAnimationCounter = maxTime;
		}
		if(this._deathAnimationCounter >= maxTime) {
			this._deathAnimationCounter = 0;
			this._deathAnimationTimelineIndex++;
			if(this._deathAnimationTimelineIndex === 1) {
				AudioManager.playNormalSe("gameover");
			}
			if(this._deathAnimationTimelineIndex === line.length) {
				this._backSprite.visible = true;
				this._animation.add(this._baseSnapSprite, {
					data:[{to:0, property:'alpha', duration:48, easingType:'linear'}]
					, complete:this.onAlphaEasingCompleted.bind(this)
				});
				if(this._hintSprite) {
					this._animation.add(this._hintSprite, {
						data:[{to:0, property:'x', duration:24, easingType:'easeOutQuart', delay:24}]
					});
				}
			} else {
				$gamePlayer.resetImage(this.animationPrefix() + this._deathAnimationTimelineIndex);
			}
		} else {
			this._deathAnimationCounter++;
		}
	}
};

Scene_Gameover.prototype.onAlphaEasingCompleted = function() {
	this._animation.add(this._titleSprite, {data:[{
		property:'x', to:32, easingType:'easeOutQuart', duration:24
	}]});
	this._animation.add(this._selectBox, {data:[{
		property:'y', to:389, easingType:'easeOutQuart', duration:24
	}]});
	this._selectBox.active();
};

Scene_Gameover.prototype.updateScaleEffect = function() {
	if(this._deathAnimationTimelineIndex === 4 && this._deathAnimationCounter === 0) {
		const easingType = 'linear';
		const duration = 48;
		const scale = 2;
		this._animation.add(this, {data:[
			{to:scale, property:'baseSnapScaleX', easingType:easingType, duration:duration}
		]});
		this._animation.add(this, {data:[
			{to:scale, property:'baseSnapScaleY', easingType:easingType, duration:duration}
		]});
		const scaleScreenWidth = Graphics.width / scale;
		const scaleScreenHeight = Graphics.height / scale;
		const centerX = $gamePlayer.physicsCenterX();
		const centerY = $gamePlayer.physicsCenterY();
		const targetX0 = -$gameMap.displayX() * $gameMap.tileWidth() + centerX - scaleScreenWidth / 2;
		const targetY0 = -$gameMap.displayY() * $gameMap.tileHeight() + centerY - scaleScreenHeight / 2;
		const targetX = targetX0.clamp(0, Graphics.width - scaleScreenWidth) | 0;
		const targetY = targetY0.clamp(0, Graphics.height - scaleScreenHeight) | 0;
		this._animation.add(this._baseSnapSprite, {data:[
			{to:-targetX * scale, property:'x', easingType:easingType, duration:duration}
		]});
		this._animation.add(this._baseSnapSprite, {data:[
			{to:-targetY * scale, property:'y', easingType:easingType, duration:duration}
		]});
	}
};

Scene_Gameover.prototype.isTriggered = function() {
	return false;
};

Scene_Gameover.prototype.createLoad = function() {
	Scene_Title.prototype.createLoad.call(this);
};

Scene_Gameover.prototype.onLoadFailure = function() {
	Scene_Title.prototype.onLoadFailure.call(this);
};

Scene_Gameover.prototype.createAllWindow = function() {
	Scene_Title.prototype.createConfirmWindow.call(this);
};

Scene_Gameover.prototype.showConfirm = function() {
	Scene_Title.prototype.showConfirm.apply(this, arguments);
};

Scene_Gameover.prototype.closeConfirm = function() {
	Scene_Title.prototype.closeConfirm.apply(this, arguments);
};

// 是否应该直接不显示读档界面直接读取自动存档
Scene_Gameover.prototype.shouldAutoload = function() {
	return DataManager.isSaveFileExist(0);
};

Object.defineProperty(Scene_Gameover.prototype, "baseSnapScaleX", {
	get: function() {
        return this._baseSnapSprite.scale.x;
    },
    set: function(value) {
        this._baseSnapSprite.scale.x = value;
    },
    configurable: true
});

Object.defineProperty(Scene_Gameover.prototype, "baseSnapScaleY", {
	get: function() {
        return this._baseSnapSprite.scale.y;
    },
    set: function(value) {
        this._baseSnapSprite.scale.y = value;
    },
    configurable: true
});

Scene_Map.prototype.needsFadeIn = function() {
    return (
        SceneManager.isPreviousScene(Scene_Battle) ||
        SceneManager.isPreviousScene(Scene_Load) ||
		SceneManager.isPreviousScene(Scene_Gameover)
    );
};

Scene_Map.prototype.needsSlowFadeOut = function() {
    return (
        SceneManager.isNextScene(Scene_Title)
    );
};

Scene_Gameover.prototype.onLanguageChange = function() {
	Scene_Base.prototype.onLanguageChange.call(this);
	this._selectBox.onLanguageChange();
	if(this._hintSprite) {
		this._hintSprite.onLanguageChange();
	}
};

Scene_Gameover.prototype.terminate = function() {
	Scene_Base.prototype.terminate.call(this);
	if(this._loadSuccess) {
		$gameSystem.onAfterLoad();
	}
};

function Scene_Shop() {
	this.initialize(...arguments);
}

Scene_Shop.prototype = Object.create(Scene_Base.prototype);
Scene_Shop.prototype.constructor = Scene_Shop;

Scene_Shop.prototype.initialize = function() {
	Scene_Base.prototype.initialize.call(this);
	this._animation = new AnimationController();
	this._activeUI = false;
	this._fadeOutAnimationRunning = false;
	this._prepareText = "";
	this._lockTextTime = 0;
};

Scene_Shop.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.createBackground();
	this.createDimmer();
	this.createBackgroundBanner();
	this.createBackgroundContent();
	this.createTilingBackground();
	this.createOtherBackground();
	this.createArtwork();
	this.createTextBalloon();
	this.createCoinBar();
	this.createShopBar();
	this.createCancelButton();
	this.createShopSelect();
	this.createWindowLayer();
	this.createConfirmWindow();
};

Scene_Shop.prototype.createDimmer = function() {
	Scene_Title.prototype.createDimmer.call(this);
	this.optionDimmer.visible = true;
};

Scene_Shop.prototype.createBackgroundContent = function() {
	this._contentSprite = new Sprite();
	this._contentSprite.alpha = 0;
	this.addChild(this._contentSprite);
};

Scene_Shop.prototype.start = function() {
	Scene_Base.prototype.start.call(this);
};

Scene_Shop.prototype.createBackground = function() {
	this._backSprite = SceneManager.backGroundSprite();
	this._backSprite.anchor.set(0.5);
	this._backSprite.x = Graphics.width / 2;
	this._backSprite.y = Graphics.height / 2;
	this.addChild(this._backSprite);
};

Scene_Shop.prototype.createBackgroundBanner = function() {
	this._bannerUp = new Sprite(ImageManager.loadUI("shop_background_up"));
	this._bannerDown = new Sprite(ImageManager.loadUI("shop_background_down"));
	this._bannerUp.anchor.x = this._bannerDown.anchor.x = 0.5;
	this._bannerUp.x = this._bannerDown.x = Graphics.width / 2;
	this._bannerMiddle = new Sprite(ImageManager.loadUI("shop_background_middle"));
	this.addChild(this._bannerMiddle, this._bannerUp, this._bannerDown);
	this._bannerUp.y = -this._bannerUp.height;
	this._bannerDown.y = Graphics.height;
	this._bannerMiddle.x = -this._bannerMiddle.width;
	const controller = this._animation;
	const duration = this.fadeInAnimationTime();
	controller.add(this._bannerUp, {data:[
		{property:'y', duration:duration, easingType:'easeOutQuart', to:0}
	]});
	controller.add(this._bannerDown, {data:[
		{property:'y', duration:duration, easingType:'easeOutQuart', to:Graphics.height - this._bannerDown.height}
	]});
	controller.add(this._bannerMiddle, {data:[
		{property:'x', duration:duration, easingType:'easeOutQuart', to:(Graphics.width - 1760) / 2}
	], complete:this.enterUI.bind(this)});
};

Scene_Shop.prototype.fadeInAnimationTime = function() {
	return 25;
};

Scene_Shop.prototype.createTilingBackground = function() {
	const bitmapUp = ImageManager.loadUI("shop_background_up_tiling");
	const bitmapDown = ImageManager.loadUI("shop_background_down_tiling");
	this._bannerUpTiling = new TilingSprite(bitmapUp);
	this._bannerDownTiling = new TilingSprite(bitmapDown);
	this._bannerUpTiling.move(0, 0, Graphics.width, this._bannerUp.height);
	this._bannerDownTiling.move(0, Graphics.height - this._bannerDown.height, Graphics.width, this._bannerDown.height);
	this._contentSprite.addChild(this._bannerUpTiling, this._bannerDownTiling);
};

Scene_Shop.prototype.createOtherBackground = function() {
	this._bannerRectString = new Sprite(ImageManager.loadUI("shop_background_rect"));
	this._bannerRectString.anchor.set(0.5);
	this._bannerRectString.x = Graphics.width / 2;
	this._bannerRectString.y = Graphics.height / 2;
	this._contentSprite.addChild(this._bannerRectString);
};

Scene_Shop.prototype.createCancelButton = function() {
	this._cancelSprite = new Sprite(ImageManager.loadUI("cancel"));
	this._cancelSprite.anchor.set(0.5);
	this._cancelSprite.x = 230 + Utils.baseHalfWidth();
	this._cancelSprite.y = 66;
	this._contentSprite.addChild(this._cancelSprite);
};

Scene_Shop.prototype.createArtwork = function() {
	this._artwork = new Sprite();
	this._contentSprite.addChild(this._artwork);
	this._artwork.anchor.y = 1;
	this._artwork.anchor.x = 1;
	this._artwork.y = Graphics.height + 400;
	this._artwork.x = Graphics.width + 100;
	if($gameVariables.value(12) === 0) {
		this._artwork.bitmap = ImageManager.loadArtwork("shop_normal");
	} else {
		this._artwork.bitmap = ImageManager.loadArtwork("shop_normal2");
	}
};

Scene_Shop.prototype.createCoinBar = function() {
	this._coinBar = new Sprite_Coin({
		backName:'shop_coin_back'
		,textColor:'#551717'
		,textSize:16
		,textOffset:{x:11,y:1}
	});
	this._contentSprite.addChild(this._coinBar);
	this._coinBar.x = 15;
	this._coinBar.y = 15;
};

Scene_Shop.prototype.createTextBalloon = function() {
	this._balloon = new Sprite_TextBalloon({
		backName:"shop_balloon"
		,textPadding:14
		,linePadding:6
		,textSize:18
		,textColor:"#551717"
	});
	this._contentSprite.addChild(this._balloon);
	this._balloon.x = 655 + Graphics.width - NYA.BASE_SCREEN_WIDTH;
	this._balloon.y = 75;
};

Scene_Shop.prototype.createShopBar = function() {
	this._shopInfoBar = new Sprite_ShopInfoBar({
		nameX:94
		,priceX:310
		,hasNumX:400
		,backName:'shop_info_bar_back'
		,textSize:24
		,textColor:"#551717"
		,textOffsetY:8
	});
	this._shopInfoBar.x = 41 + Utils.baseHalfWidth();
	this._shopInfoBar.y = 77;
	this._contentSprite.addChild(this._shopInfoBar);
};

Scene_Shop.prototype.createShopSelect = function() {
	this._shopSelect = new Sprite_ShopSelect({
		pageNum:7
		,moveSignName:'shop_move_sign'
		,itemName:'shop_select_item'
		,cursorName:'shop_select_cursor'
		,textSize:24
		,textColor:'#551717'
		,itemMargin:19
		,textStartX:0
		,noTaskTipsTextColor:'#551717'
		,moveSignMargin:-2
		
		,nameX:74
		,priceX:300
		,hasNumX:440
		,iconX:30
		,itemMaskOffsetWidth:46 + Utils.baseHalfWidth()   // 蒙版往左延伸的宽度，为了做选项从左边飞入的缓动效果
	});
	this._shopSelect.x = 46 + Utils.baseHalfWidth();
	this._shopSelect.y = 190;
	this._contentSprite.addChild(this._shopSelect);
	this._shopSelect.pressOk = this.onShopSelect.bind(this);
	this._shopSelect.pressCancel = this.onShopCancel.bind(this);
	this._shopSelect.pressDisable = this.pressDisable.bind(this);
	this._shopSelect.onCursorMove = this.onCursorMove.bind(this);
	this._shopSelect.visible = false;
};

Scene_Shop.prototype.onShopSelect = function() {
	const item = this._shopSelect.selectDataId();
	const price = (NYA.DEMO ? item.demoPrice : item.price) || 4000;
	if(item.itemNum > 0) {
		if($gamePlayer.actor().isCoinEnough(price)) {
			this._confirm.resetItemData(item);
			this.openConfirm();
			return true;
		} else {
			this.coinNotEnough();
		}
	}
	return false;
};

Scene_Shop.prototype.onShopSelectOk = function() {
	const item = this._shopSelect.selectDataId();
	const price = (NYA.DEMO ? item.demoPrice : item.price) || 4000;
	const purchaseNum = this._confirm.purchaseNum();
	if(item.itemNum > 0) {
		if($gamePlayer.actor().deductCoin(price * purchaseNum)) {
			item.itemNum-=purchaseNum;
			item.hasNum+=purchaseNum;
			$gamePlayer.actor().addItem(item, false, item.type !== "consumables", purchaseNum);
			this._shopSelect.refreshSelectedItemText();
			this._shopSelect.refreshSelectedItemEnable();
			this._shopSelect.active();
			return true;
		} else {
			this.coinNotEnough();
		}
	}
	this._shopSelect.active();
	return false;
};

Scene_Shop.prototype.onShopCancel = function() {
	this.popScene();
	this._shopSelect.deactive();
	this._confirm.visible = false;
	this._confirm.deactivate();
};

Scene_Shop.prototype.updateCancelButton = function() {
	if(TouchInput.isClicked() && this._cancelSprite.isBeingTouched()) {
		SoundManager.playCancel();
		this.onShopCancel();
	}
	if(TouchInput.isPressed()) {
		if(this._cancelSprite.isBeingTouched()) {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel_press");
		} else {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
		}
	} else if(TouchInput.isReleased()) {
		this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
	}
};

Scene_Shop.prototype.pressDisable = function() {
	if($gameVariables.value(12) === 0) {
		this.lockTextBalloon(4, 180, "shop_disable");
	} else {
		this.lockTextBalloon(282, 180, "shop_normal2");
	}
};

Scene_Shop.prototype.coinNotEnough = function() {
	if($gameVariables.value(12) === 0) {
		this.lockTextBalloon(67, 180, "shop_coin_not_enough");
	} else {
		this.lockTextBalloon(283, 180, "shop_coin_not_enough2");
	}
};

Scene_Shop.prototype.lockTextBalloon = function(storyId, time, artworkName) {
	if(!this._lockTextTime) {
		this._prepareText = this._balloon.currentText();
	}
	this._lockTextTime = time;
	this._artwork.bitmap = ImageManager.loadArtwork(artworkName);
	this._balloon.setText($dataStory[storyId][0].contents);
};

Scene_Shop.prototype.updateTextLock = function() {
	if(this._lockTextTime > 0) {
		this._lockTextTime--;
		if(this._lockTextTime === 0 && this._prepareText) {
			this._balloon.setText(this._prepareText);
			this._prepareText = "";
			if($gameVariables.value(12) === 0) {
				this._artwork.bitmap = ImageManager.loadArtwork("shop_normal");
			} else {
				this._artwork.bitmap = ImageManager.loadArtwork("shop_normal2");
			}
		}
	}
};

Scene_Shop.prototype.onCursorMove = function() {
	const item = this._shopSelect.selectDataId();
	if(!this._lockTextTime) {
		this._balloon.setText(item.desc);
	} else {
		this._prepareText = item.desc;
	}
};

Scene_Shop.prototype.enterUI = function() {
	this._activeUI = true;
	const controller = this._animation;
	const duration = (this.fadeInAnimationTime() / 2) | 0;
	controller.add(this._contentSprite, {data:[
		{to:1, easingType:'linear', property:'alpha', duration:duration}
	]});
	this._shopSelect.active();
	this._shopSelect.visible = true;
	this.onCursorMove();
	this.startShopSelectFadeIn();
};

Scene_Shop.prototype.startShopSelectFadeIn = function() {
	this._shopSelect.startFadeInEffect();
};

Scene_Shop.prototype.update = function() {
	Scene_Base.prototype.update.call(this);
	this._animation.update();
	if(this._activeUI) {
		this.updateTilingBackground();
	}
	this.updateTextLock();
	if(!this.isBusy()) {
		this.updateCancelButton();
	}
};

Scene_Shop.prototype.updateTilingBackground = function() {
	this._bannerUpTiling.origin.x += 2;
	this._bannerDownTiling.origin.x -= 2;
};

Scene_Shop.prototype.isBusy = function() {
	return Scene_Base.prototype.isBusy.call(this) || this.isFadeOutAnimationRunning();
};

Scene_Shop.prototype.isFadeOutAnimationRunning = function() {
	return this._fadeOutAnimationRunning;
};

Scene_Shop.prototype.stop = function() {
	Scene_Base.prototype.stop.call(this);
	this.performStopAnimation();
};

Scene_Shop.prototype.performStopAnimation = function() {
	this._fadeOutAnimationRunning = true;
	const controller = this._animation;
	controller.clear(this._bannerUp);
	controller.clear(this._bannerDown);
	controller.clear(this._bannerMiddle);
	controller.clear(this._contentSprite);
	const duration = this.fadeInAnimationTime();
	const durationFast = (duration / 2) | 0;
	controller.add(this._bannerUp, {data:[
		{property:'y', duration:duration, easingType:'easeOutQuart', to:-this._bannerUp.height}
	]});
	controller.add(this._bannerDown, {data:[
		{property:'y', duration:duration, easingType:'easeOutQuart', to:Graphics.height}
	]});
	controller.add(this._bannerMiddle, {data:[
		{property:'x', duration:duration, easingType:'easeOutQuart', to:-this._bannerMiddle.width}
	], complete:this.completeStopAnimation.bind(this)});
	controller.add(this._contentSprite, {data:[
		{to:0, easingType:'linear', property:'alpha', duration:durationFast}
	]});
};

Scene_Shop.prototype.completeStopAnimation = function() {
	this._fadeOutAnimationRunning = false;
};

Scene_Shop.prototype.onLanguageChange = function() {
	this._shopInfoBar.onLanguageChange();
};

Scene_Shop.prototype.createConfirmWindow = function() {
	this._confirm = new Window_ShopConfirm(this._shopSelect.selectDataId());
	this._confirm.pressCancel = this.closeConfirm.bind(this);
	this._confirm.pressOk = this.onShopSelectOk.bind(this);
	this._confirm.deactivate();
	this._confirm.visible = false;
	this.addWindow(this._confirm);
};

Scene_Shop.prototype.openConfirm = function() {
	this._shopSelect.deactive();
	this._confirm.visible = true;
	this._confirm.openness = 0;
	this._confirm.open();
	this._confirm.activate();
};

Scene_Shop.prototype.closeConfirm = function() {
	this._shopSelect.active();
};


function Scene_HardGuide() {
	this.initialize(...arguments);
}

Scene_HardGuide.prototype = Object.create(Scene_Base.prototype);
Scene_HardGuide.prototype.constructor = Scene_HardGuide;

Scene_HardGuide.prototype.initialize = function() {
	Scene_Base.prototype.initialize.call(this);
};

Scene_HardGuide.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.createBackground();
	this.createGuide();
};

Scene_HardGuide.prototype.createBackground = function() {
	this._backSprite = SceneManager.backGroundSprite();
	this.addChild(this._backSprite);
};

Scene_HardGuide.prototype.start = function() {
	Scene_Base.prototype.start.call(this);
	AudioManager.playNormalSe("guide");
};

Scene_HardGuide.prototype.createGuide = function() {
	this._guide = new Sprite_HardGuide({
		backName:"hard_guide_back"
		, continueCatName:"hard_guide_cat"
		, continueTextPadding:28
		, continueTextSize:22
		, continueTextColor:'#ff9bb7'
		, continueTextOutlineColor:'#ffffff'
		, continueTextOutlineWidth:3
		, continueOffsetY:374
	});
	this._guide.pressOk = this.popScene.bind(this);
	this._guide.x = Graphics.width / 2;
	this._guide.y = Graphics.height / 2;
	this.addChild(this._guide);
};

Scene_HardGuide.prototype.onLanguageChange = function() {
	Scene_Base.prototype.onLanguageChange.call(this);
	this._guide.onLanguageChange();
};

Scene_HardGuide.prototype.terminate = function() {
	Scene_Base.prototype.terminate.call(this);
	$gameSystem.clearHardGuide();
};


function Scene_ItemObtain() {
	this.initialize(...arguments);
}

Scene_ItemObtain.prototype = Object.create(Scene_Base.prototype);
Scene_ItemObtain.prototype.constructor = Scene_ItemObtain;

Scene_ItemObtain.prototype.initialize = function() {
	Scene_Base.prototype.initialize.call(this);
};

Scene_ItemObtain.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.createBackground();
	this.createDimmer();
	this.createObtain();
};

Scene_ItemObtain.prototype.start = function() {
	Scene_Base.prototype.start.call(this);
	AudioManager.playNormalSe("item_obtain");
};

Scene_ItemObtain.prototype.createObtain = function() {
	this._obtainItem = new Sprite_ItemObtain({
		catName:"obtain_item_cat"
		,lightName:"obtain_item_light"
		,textAreaName:"obtain_item_text_back"
		,auraName:"obtain_item_aura"
		,nameTextPadEdge:"obtain_item_name_pad_edge"
		,nameTextPadInner:"obtain_item_name_pad_inner"
		,catRotation:-0.6
		,catScrollSpeed:2
		,catPosArr:[{x:78,y:56}, {x:152,y:94}, {x:Graphics.width-78,y:Graphics.height-56}, {x:Graphics.width-152,y:Graphics.height-94}]
		,lightRotationSpeed:0.025
		,textAreaY:546
		,nameTextSize:26
		,descTextSize:18
		,textColor:"#551717"
		,artworkYMin:230
		,artworkYMax:368
		,artworkXSpeedMin:12
		,artworkXSpeedMax:18
		,artworkJumpIntervalMin:10
		,artworkJumpIntervalMax:20
		,artworkJumpStrengthMin:6
		,artworkJumpStrengthMax:8
		,artworkJumpGravity:0.4
	});
	this.addChild(this._obtainItem);
	this._obtainItem.pressOk = this.popScene.bind(this);
};

Scene_ItemObtain.prototype.createDimmer = function() {
	Scene_Shop.prototype.createDimmer.call(this);
};

Scene_ItemObtain.prototype.onLanguageChange = function() {
	Scene_Base.prototype.onLanguageChange.call(this);
	this._obtainItem.onLanguageChange();
};

Scene_ItemObtain.prototype.createBackground = function() {
	this._backSprite = SceneManager.backGroundSprite();
	this.addChild(this._backSprite);
};

Window_Selectable.prototype.isOkTriggered = function() {
	return this._canRepeat ? Input.isUIRepeated("ok") : Input.isUITriggered("ok");
};

Scene_Map.prototype.createMapNameWindow = function() {
    const rect = this.mapNameWindowRect();
    this._mapNameWindow = new Window_MapName(rect);
};

NYA.GAME.Scene_Message_createNumberInputWindow = Scene_Message.prototype.createNumberInputWindow;
Scene_Message.prototype.createNumberInputWindow = function() {
    this._numberInputWindow = new Window_NumberInput();
};

NYA.GAME.Scene_Message_createEventItemWindow = Scene_Message.prototype.createEventItemWindow;
Scene_Message.prototype.createEventItemWindow = function() {
    const rect = this.eventItemWindowRect();
    this._eventItemWindow = new Window_EventItem(rect);
};

NYA.GAME.Scene_Message_createScrollTextWindow = Scene_Message.prototype.createScrollTextWindow;
Scene_Message.prototype.createScrollTextWindow = function() {
	const rect = this.scrollTextWindowRect();
    this._scrollTextWindow = new Window_ScrollText(rect);
};

NYA.GAME.Scene_Message_createGoldWindow = Scene_Message.prototype.createGoldWindow;
Scene_Message.prototype.createGoldWindow = function() {
	const rect = this.goldWindowRect();
    this._goldWindow = new Window_Gold(rect);
};

function Scene_AndroidExitGame() {
	this.initialize(...arguments);
}

Scene_AndroidExitGame.prototype = Object.create(Scene_Base.prototype);
Scene_AndroidExitGame.prototype.constructor = Scene_AndroidExitGame;

Scene_AndroidExitGame.prototype.initialize = function() {
	Scene_Base.prototype.initialize.apply(this, arguments);
};

Scene_AndroidExitGame.prototype.create = function() {
	Scene_Base.prototype.create.apply(this, arguments);
	this.createBackground();
	this.createWindowLayer();
	const confirmWidth = 580;
	const confirmHeight = 250;
	const confirmX = (Graphics.width - confirmWidth) / 2;
	const confirmY = (Graphics.height - confirmHeight) / 2;
	
	const rect = {x:confirmX,y:confirmY,width:confirmWidth,height:confirmHeight};
	
	this._confirm = new Window_Confirm(rect, '', {defaultSelected: 'no', canEscape:true});
	this._confirm.pressOk = this.pressConfirmOk.bind(this);
	this._confirm.pressCancel = this.pressConfirmCancel.bind(this);
	this.addWindow(this._confirm);
	this._confirm.setText("STATIC_TEXT_MENU_SYSTEM_EXIT_GAME_CONFIRM");
};

Scene_AndroidExitGame.prototype.createBackground = function() {
	const background = new PIXI.Sprite(SceneManager._exitGameBackgroundTexture);
	this.addChild(background);
};

Scene_AndroidExitGame.prototype.start = function() {
	Scene_Base.prototype.start.apply(this, arguments);
	this._confirm.openness = 0;
	this._confirm.open();
	this._confirm.activate();
};

Scene_AndroidExitGame.prototype.pressConfirmOk = function() {
	SceneManager.terminate();
};

Scene_AndroidExitGame.prototype.pressConfirmCancel = function() {
	SceneManager.resumeScene();
};

Scene_AndroidExitGame.prototype.onLanguageChange = function() {
	Scene_Base.prototype.onLanguageChange.call(this);
	this._confirm.onLanguageChange();
};

SceneManager.requestAndroidBackButton = function() {
	if(this._scene && this._scene.constructor !== Scene_AndroidExitGame && this._scene.constructor !== Scene_Boot) {
		this.snapForExitGameBackground();
		this.suspendScene(Scene_AndroidExitGame);
	}
};

SceneManager.snapForExitGameBackground = function() {
	const stage = this._scene;
	const width = Graphics.width;
    const height = Graphics.height;
	const renderer = Graphics.app.renderer;
	if(this._exitGameBackgroundTexture) {
		this._exitGameBackgroundTexture.destroy({ destroyBase: true });
	}
	this._exitGameBackgroundTexture = PIXI.RenderTexture.create(width, height);
	renderer.render(stage, this._exitGameBackgroundTexture);
};

function Scene_Popup() {
	this.initialize(...arguments);
}

Scene_Popup.prototype = Object.create(Scene_Base.prototype);
Scene_Popup.prototype.constructor = Scene_Popup;

Scene_Popup.prototype.start = function() {
	Scene_Base.prototype.start.call(this);
	this.popScene();
};


function Scene_LegalTips() {
	this.initialize(...arguments);
}

Scene_LegalTips.prototype = Object.create(Scene_Base.prototype);
Scene_LegalTips.prototype.constructor = Scene_LegalTips;

Scene_LegalTips.prototype.initialize = function() {
	Scene_Base.prototype.initialize.call(this);
	this._waitCounter = 0;
};

Scene_LegalTips.prototype.create = function() {
	Scene_Base.prototype.create.call(this);
	this.createLegalTips();
};

Scene_LegalTips.prototype.createLegalTips = function() {
	const bitmap = new Bitmap(Graphics.width, Graphics.height);
	bitmap.outlineWidth = 0;
	bitmap.fontSize = 24;
	const hour = new Date().getHours();
	const isNight = hour >= 18 || hour < 6;
	if(isNight) {
		bitmap.textColor = "#ffffff";
		bitmap.fillAll("black");
	} else {
		bitmap.textColor = "#000000";
		bitmap.fillAll("white");
	}
	const sprite = new Sprite(bitmap);
	this.addChild(sprite);
	
	const lineHeight = bitmap.fontSize;
	const margin = 12;
	const baseY = (Graphics.height - lineHeight * 5 - margin * 4) / 2;
	bitmap.drawText(TextManager.STATIC_TEXT_LEGAL_GAME_TIPS5, 0, baseY, bitmap.width, bitmap.fontSize, "center");
	bitmap.drawText(TextManager.STATIC_TEXT_LEGAL_GAME_TIPS1, 0, baseY + (margin + lineHeight), bitmap.width, bitmap.fontSize, "center");
	bitmap.drawText(TextManager.STATIC_TEXT_LEGAL_GAME_TIPS2, 0, baseY + (margin + lineHeight) * 2, bitmap.width, bitmap.fontSize, "center");
	bitmap.drawText(TextManager.STATIC_TEXT_LEGAL_GAME_TIPS3, 0, baseY + (margin + lineHeight) * 3, bitmap.width, bitmap.fontSize, "center");
	bitmap.drawText(TextManager.STATIC_TEXT_LEGAL_GAME_TIPS4, 0, baseY + (margin + lineHeight) * 4, bitmap.width, bitmap.fontSize, "center");
};

Scene_LegalTips.prototype.start = function() {
	Scene_Base.prototype.start.call(this);
	this.startFadeIn(60, 0);
};

Scene_LegalTips.prototype.update = function() {
	Scene_Base.prototype.update.call(this);
	if(!this.isBusy()) {
		this._waitCounter++;
		if((this._waitCounter > 120 || Input.isAnyTriggered()) && !SceneManager.isSceneChanging()) {
			this.startFadeOut(60, 0);
			DataManager.setupNewGame();
			SceneManager.goto(Scene_Title);
			Window_TitleCommand.initCommandPosition();
		}
	}
};













NYA.MAP = {};
NYA.MAP.CONST = {};
NYA.MAP.CONST.TURN_UP = 0;
NYA.MAP.CONST.TURN_DOWN = 1;
NYA.MAP.CONST.TURN_LEFT = 2;
NYA.MAP.CONST.TURN_RIGHT = 3;
NYA.MAP.CONST.DATA_ID = 1;

DataManager._cacheBellTotalNum = 0;
DataManager.cacheThumbnailMapData = function() {
	let data = this.getCachedData(NYA.MAP.CONST.DATA_ID);
	this._thumbnailMapCell = {};
	this._thumbnailMap = {};
	this._thumbnailPage = {};
	this._thumbnailPageInfo = {};
	this._thumbnailRegion = {};
	const width = data.width;
	const height = data.height;
	for(const event of data.events) {
		if(!event) {
			continue;
		}
		let mapId = event.meta.m;
		
		let x = event.x;
		let y = event.y;
		let z = 5;
		const page = event.meta.p || 0;
		if(event.meta.start) {
			this.startX = x;
			this.startY = y;
			this.x = this.x || x;
			this.y = this.y || y;
		}
		let regionId = data.data[(z * height + y) * width + x] || 0;
		let posKey = this.makePosKey(x, y);
		
		if(!this._thumbnailMapCell[posKey]) {
			this._thumbnailMapCell[posKey] = {};
		}
		this._thumbnailMapCell[posKey].regionId = regionId;
		this._thumbnailMapCell[posKey].mapId = mapId;
 		this._thumbnailMapCell[posKey].l = !!event.meta.l;	// LTRB Block, default is false
		this._thumbnailMapCell[posKey].t = !!event.meta.t;
		this._thumbnailMapCell[posKey].r = !!event.meta.r;
		this._thumbnailMapCell[posKey].b = !!event.meta.b;
		this._thumbnailMapCell[posKey].pl = !!event.meta.pl;
		this._thumbnailMapCell[posKey].pt = !!event.meta.pt;
		this._thumbnailMapCell[posKey].pr = !!event.meta.pr;
		this._thumbnailMapCell[posKey].pb = !!event.meta.pb;
		this._thumbnailMapCell[posKey].x = x;
		this._thumbnailMapCell[posKey].y = y;
		this._thumbnailMapCell[posKey].page = page;
		const connectEventId = event.meta.c || 0;
		this._thumbnailMapCell[posKey].connect = 0;
		if(connectEventId) {
			const cev = data.events[connectEventId];
			this._thumbnailMapCell[posKey].connect = this.makePosKey(cev.x, cev.y);
		}
		this._thumbnailMapCell[posKey].collectItem = [];
		
		if(!this._thumbnailMap[mapId]) {
			this._thumbnailMap[mapId] = {};
			this._thumbnailMap[mapId].data = [];
		}
		this._thumbnailMap[mapId].data.push({x:x,y:y});
		
		if(!this._thumbnailPage[page]) {
			this._thumbnailPage[page] = [];
		}
		this._thumbnailPage[page].push(posKey);
		
		if(!this._thumbnailRegion[regionId]) {
			this._thumbnailRegion[regionId] = [];
		}
		this._thumbnailRegion[regionId].push(posKey);
	}
	for(const page in this._thumbnailPage) {
		this._thumbnailPageInfo[page] = {};
		this._thumbnailPageInfo[page].transport = [];
		let minX = null; let minY = null; let maxX = null; let maxY = null;
		for(const posKey of this._thumbnailPage[page]) {
			const cell = this._thumbnailMapCell[posKey];
			if(minX === null || cell.x < minX) {
				minX = cell.x;
			}
			if(maxX === null || cell.x > maxX) {
				maxX = cell.x;
			}
			if(minY === null || cell.y < minY) {
				minY = cell.y;
			}
			if(maxY === null || cell.y > maxY) {
				maxY = cell.y;
			}
			if(cell.pl && this._thumbnailMapCell[this.makePosKey(cell.x - 1, cell.y)]) {
				const linkPosKey = this.makePosKey(cell.x - 1, cell.y);
				const linkCell = this._thumbnailMapCell[linkPosKey];
				const linkPage = linkCell.page;
				this._thumbnailPageInfo[page].transport.push({page:linkPage,posKey:posKey,linkPosKey:linkPosKey});
			} else if(cell.pr && this._thumbnailMapCell[this.makePosKey(cell.x + 1, cell.y)]) {
				const linkPosKey = this.makePosKey(cell.x + 1, cell.y);
				const linkCell = this._thumbnailMapCell[linkPosKey];
				const linkPage = linkCell.page;
				this._thumbnailPageInfo[page].transport.push({page:linkPage,posKey:posKey,linkPosKey:linkPosKey});
			} else if(cell.pt && this._thumbnailMapCell[this.makePosKey(cell.x, cell.y - 1)]) {
				const linkPosKey = this.makePosKey(cell.x, cell.y - 1);
				const linkCell = this._thumbnailMapCell[linkPosKey];
				const linkPage = linkCell.page;
				this._thumbnailPageInfo[page].transport.push({page:linkPage,posKey:posKey,linkPosKey:linkPosKey});
			} else if(cell.pb && this._thumbnailMapCell[this.makePosKey(cell.x, cell.y + 1)]) {
				const linkPosKey = this.makePosKey(cell.x, cell.y + 1);
				const linkCell = this._thumbnailMapCell[linkPosKey];
				const linkPage = linkCell.page;
				this._thumbnailPageInfo[page].transport.push({page:linkPage,posKey:posKey,linkPosKey:linkPosKey});
			}
		}
		this._thumbnailPageInfo[page].minX = minX;
		this._thumbnailPageInfo[page].minY = minY;
		this._thumbnailPageInfo[page].maxX = maxX;
		this._thumbnailPageInfo[page].maxY = maxY;
	}
	for(const mapId in this._thumbnailMap) {
		const info = this._thumbnailMap[mapId].data;
		
		let minX = null; let minY = null; let maxX = null; let maxY = null;
		for(const pos of info) {
			if(minX === null || pos.x < minX) {
				minX = pos.x;
			}
			if(maxX === null || pos.x > maxX) {
				maxX = pos.x;
			}
			if(minY === null || pos.y < minY) {
				minY = pos.y;
			}
			if(maxY === null || pos.y > maxY) {
				maxY = pos.y;
			}
		}
		this._thumbnailMap[mapId].minX = minX;
		this._thumbnailMap[mapId].minY = minY;
		this._thumbnailMap[mapId].maxX = maxX;
		this._thumbnailMap[mapId].maxY = maxY;
	}
};

DataManager.getThumbnailExplore = function() {
	const pos = this.getPlayerThumbnailPos();
	if(!pos) { return {has:0, all:0}; }
	const key = this.makePosKey(pos.x, pos.y);
	const cell = this._thumbnailMapCell[key];
	if(cell) {
		const regionId = cell.regionId;
		return this.getRegionThumbnailExplore(regionId);;
	}
	return {has:0, all:0};
};

DataManager.getRegionThumbnailExplore = function(regionId) {
	const all = this._thumbnailRegion[regionId].length;
	let has = 0;
	for(const posKey of this._thumbnailRegion[regionId]) {
		if($gameSystem.isThumbnailActive(posKey)) {
			has++;
		}
	}
	return {has:has, all:all};
};

DataManager.thumbnailCell = function(x, y) {
	const key = this.makePosKey(x, y);
	if($gameSystem.isThumbnailActive(key)) {
		return this._thumbnailMapCell[key];
	}
	return undefined;
};

DataManager.thumbnailCellWithoutActive = function(x, y) {
	return this._thumbnailMapCell[this.makePosKey(x, y)];
};

DataManager.thumbnailMargin = function() {
	return 4;
};

DataManager.thumbnailInnerCellWidth = function() {
	return 16;
};

DataManager.thumbnailCellWidth = function() {
	return 22;
};

DataManager.thumbnailCellRounded = function() {
	return 6;
};

DataManager.regionColor = function(region) {
	switch(region) {
		case 1: return 0x969b00;
		case 2: return 0x367f00;
		case 3: return 0x2e63fd;
		case 4: return 0xc146fb;
		case 5: return 0x45b3ba;
		case 6: return 0x8d31ff;
		case 7: return 0x454b7f;
		default: return 0x000000;
	}
};

DataManager.makePosKey = function(x, y) {
	return y * 1024 + x;
};

DataManager.taskCell = function(id) {
	const evid = $dataTask[id].ev;
	const dataMap = this.getCachedData(NYA.MAP.CONST.DATA_ID);
	const dataEvent = dataMap.events[evid];
	const posKey = this.makePosKey(dataEvent.x, dataEvent.y);
	const cell = this._thumbnailMapCell[posKey];
	return cell;
};

DataManager.taskRegion = function(id) {
	return this.taskCell(id).regionId;
};

DataManager.taskPage = function(id) {
	return this.taskCell(id).page;
};

DataManager.mapRegion = function(mapId) {
	if(!this._thumbnailMap[mapId]) {
		return 0;
	}
	const data = this._thumbnailMap[mapId].data;
	const posKey = this.makePosKey(data[0].x, data[0].y);
	const cell = this._thumbnailMapCell[posKey];
	return cell.regionId;
};

DataManager.thumbnailMapDraw = function(width, height, callback) {
	const pos = this.getPlayerThumbnailPos();
	if(!pos) { return; }
	const centerX = pos.x;
	const centerY = pos.y;
	const cell = this._thumbnailMapCell[this.makePosKey(centerX, centerY)];
	const page = cell ? cell.page : 0;
	for(let x = centerX - width; x <= centerX + width; x++) {
		for(let y = centerY - height; y <= centerY + height; y++) {
			const posKey = this.makePosKey(x, y);
			if($gameSystem.isThumbnailActive(posKey)) {
				const cell = this._thumbnailMapCell[posKey];
				if(cell && (cell.page === page || page === 0)) {
					callback(cell);
				}
			}
		}
	}
};

DataManager.thumbnailPageDraw = function(callback) {
	const pos = this.getPlayerThumbnailPos();
	if(!pos) { return; }
	const centerX = pos.x;
	const centerY = pos.y;
	const cell = this._thumbnailMapCell[this.makePosKey(centerX, centerY)];
	if(cell) {
		const page = cell.page;
		this.thumbnailPageDrawEx(callback, page);
	}
};

DataManager.thumbnailPageDrawEx = function(callback, page) {
	this._thumbnailPage[page].forEach((posKey) => {
		if($gameSystem.isThumbnailActive(posKey)) {
			const pageCell = this._thumbnailMapCell[posKey];
			if(pageCell) { 
				callback(pageCell);
			}
		}
	});
};

DataManager.getCurrentThumbnailCell = function() {
	const pos = this.getPlayerThumbnailPos();
	if(!pos) { return null; }
	const centerX = pos.x;
	const centerY = pos.y;
	const cell = this._thumbnailMapCell[this.makePosKey(centerX, centerY)];
	return cell;
};

DataManager.regionId = function() {
	const cell = this.getCurrentThumbnailCell();
	if(cell) { return cell.regionId; }
	return 0;
};

DataManager.getPlayerThumbnailPos = function() {
	const xr = $gamePlayer.px / $dataMap.width / $gameMap.tileWidth();
	const yr = $gamePlayer.py / $dataMap.height / $gameMap.tileHeight();
	const mapId = $gameMap.mapId();
	const thumbnail = this._thumbnailMap[mapId];
	if(!thumbnail) { return null; }
	const x = Math.trunc((thumbnail.maxX - thumbnail.minX + 1) * xr.clamp(0,0.9999)) + thumbnail.minX;
	const y = Math.trunc((thumbnail.maxY - thumbnail.minY + 1) * yr.clamp(0,0.9999)) + thumbnail.minY;
	return {x:x, y:y};
};

DataManager.getThumbnailPos = function(evx, evy, mapId) {
	const data = DataManager.getCachedData(mapId);
	const xr = evx / data.width;
	const yr = evy / data.height;
	const thumbnail = this._thumbnailMap[mapId];
	if(!thumbnail) { return null; }
	const x = Math.trunc((thumbnail.maxX - thumbnail.minX + 1) * xr) + thumbnail.minX;
	const y = Math.trunc((thumbnail.maxY - thumbnail.minY + 1) * yr) + thumbnail.minY;
	return {x:x, y:y};
};

DataManager.getThumbnailCell = function(evx, evy, mapId) {
	const pos = this.getThumbnailPos(evx, evy, mapId);
	if(!pos) { return null; }
	const centerX = pos.x;
	const centerY = pos.y;
	const cell = this._thumbnailMapCell[this.makePosKey(centerX, centerY)];
	return cell;
};

NYA.MAP.Game_System_initialize = Game_System.prototype.initialize;
Game_System.prototype.initialize = function() {
	NYA.MAP.Game_System_initialize.apply(this, arguments);
	this._thumbnailInfo = {};
	this._regionTransportUnlock = [];
	this._achieveUnlockRegion = [];
};

Game_System.prototype.moveThumbnail = function() {
	const pos = DataManager.getPlayerThumbnailPos();
	if(!pos) { return; }
	const key = DataManager.makePosKey(pos.x, pos.y);
	const cell = DataManager._thumbnailMapCell[key];
	if(cell) {
		this._thumbnailInfo[key] = true;
	}
};

Game_System.prototype.isThumbnailActive = function(key) {
	return !!this._thumbnailInfo[key];
};

Game_System.prototype.unlockRegion = function() {
	const arg = [...arguments];
	arg.forEach((regionId) => {
		if(!this.isRegionUnlock(regionId)) {
			this._regionTransportUnlock.push(regionId);
		}
	});
};

Game_System.prototype.unlockRegionAchieve = function() {
	const arg = [...arguments];
	arg.forEach((regionId) => {
		if(!this._achieveUnlockRegion.includes(regionId)) {
			this._achieveUnlockRegion.push(regionId);
		}
	});
};

Game_System.prototype.achieveUnlockRegion = function() {
	return this._achieveUnlockRegion;
};

Game_System.prototype.isRegionUnlock = function(regionId) {
	return this._regionTransportUnlock.includes(regionId);
};

NYA.MAP.Game_Player_performTransfer = Game_Player.prototype.performTransfer;
Game_Player.prototype.performTransfer = function() {
	NYA.MAP.Game_Player_performTransfer.apply(this, arguments);
	const cell = DataManager.getCurrentThumbnailCell();
	if(cell) {
		$gameSystem.unlockRegionAchieve(cell.regionId);	
		if($dataMap.transportUnlock) {
			$gameSystem.unlockRegion(cell.regionId);
		}
	}
};

NYA.MAP.Game_Player_flush = Game_Player.prototype.flush;
Game_Player.prototype.flush = function() {
	NYA.MAP.Game_Player_flush.apply(this, arguments);
	$gameSystem.moveThumbnail();
};

function Sprite_MapThumbnail() {
	this.initialize(...arguments);
}

Sprite_MapThumbnail.prototype = Object.create(Sprite.prototype);
Sprite_MapThumbnail.prototype.constructor = Sprite_MapThumbnail;

Sprite_MapThumbnail.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this._letterBitmaps = {};
	this._currentCell = null;
	this._smallMap = false;
	this._mapWidth = 0;
	this._mapHeight = 0;
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this.createAllParts();
	this.currentPosAlpha = 0;
	this.currentPosAlphaSign = 1;
	this.currentPosCellSprite = null;
	this._pageInfo = {maxX:0, maxY:0, minX:0, minY:0};
	this._taskSignatureColor = [255, 255, 255, 255];
	this._newCollectedSprite = null;
};

Sprite_MapThumbnail.prototype.destroy = function() {
	Sprite.prototype.destroy.apply(this, arguments);
	Object.values(this._letterBitmaps).forEach((bitmap) => {
		bitmap.destroy();
	});
	this._itemCollectBitmap.destroy();
};

Sprite_MapThumbnail.prototype.createAllParts = function() {
	this._pathSprite = new Sprite();
	this._baseSprite.addChild(this._pathSprite);
	this._cellSprite = new Sprite();
	this._baseSprite.addChild(this._cellSprite);
	this._upperPathSprite = new Sprite();
	this._baseSprite.addChild(this._upperPathSprite);
	this._taskSignatureSprite = new Sprite();
	this._baseSprite.addChild(this._taskSignatureSprite);
	this._letterSprite = new Sprite();
	this._baseSprite.addChild(this._letterSprite);
	
	const innerCellWidth = DataManager.thumbnailInnerCellWidth();
	this._itemCollectBitmap = new Bitmap(innerCellWidth, innerCellWidth);
	const rectWidth = Math.round(innerCellWidth / 2);
	const pos = Math.round((innerCellWidth - rectWidth) / 2);
	this._itemCollectBitmap.fillRect(pos, pos, rectWidth, rectWidth, 0xffffff);
	this._itemCollectBitmap.strokeRect(pos, pos, rectWidth, rectWidth, 0x888888);
};

Sprite_MapThumbnail.prototype.createLetterBitmap = function(letter) {
	if(this._letterBitmaps[letter]) {
		return this._letterBitmaps[letter];
	} 
	const bitmap = new Bitmap(DataManager.thumbnailInnerCellWidth(), DataManager.thumbnailInnerCellWidth());
	bitmap.fontSize = DataManager.thumbnailInnerCellWidth();
	bitmap.textColor = "#%1".format(this.currentPosColor().toString(16));
	bitmap.outlineWidth = 0;
	bitmap.drawCenterText(letter);
	this._letterBitmaps[letter] = bitmap;
	return bitmap;
};

Sprite_MapThumbnail.prototype.createItemCollectSprite = function() {
	const sprite = new Sprite(ImageManager.loadUI("collection_complete"));
	sprite.anchor.set(0.5);
	return sprite;
};

Sprite_MapThumbnail.prototype.allWidth = function() {
	return (this._pageInfo.maxX - this._pageInfo.minX + 1) * (DataManager.thumbnailCellWidth() + DataManager.thumbnailMargin()) - DataManager.thumbnailMargin();
};

Sprite_MapThumbnail.prototype.allHeight = function() {
	return (this._pageInfo.maxY - this._pageInfo.minY + 1) * (DataManager.thumbnailCellWidth() + DataManager.thumbnailMargin()) - DataManager.thumbnailMargin();
};

Sprite_MapThumbnail.prototype.setCurrentCell = function(cell) {
	this._currentCell = cell;
};

Sprite_MapThumbnail.prototype.currentPosColor = function() {
	return 0xffffff;
};

Sprite_MapThumbnail.prototype.clear = function() {
	this._pathSprite.removeChildren().forEach((ch) => {
		ch.destroy(true);
	});
	this._cellSprite.removeChildren().forEach((ch) => {
		ch.destroy(true);
	});
	this._upperPathSprite.removeChildren().forEach((ch) => {
		ch.destroy(true);
	});
	this._letterSprite.removeChildren();
	this.clearTaskSignature();
	this._newCollectedSprite = null;
};

Sprite_MapThumbnail.prototype.clearTaskSignature = function() {
	this._taskSignatureSprite.children.forEach((ch) => {
		ch.destroy();
	});
	this._taskSignatureSprite.removeChildren();
};

// 数据地图上的事件ID转换成对应贴图格子的中心坐标
Sprite_MapThumbnail.prototype.evidToCellPosition = function(evid) {
	const dataMap = DataManager.getCachedData(NYA.MAP.CONST.DATA_ID);
	const dataEvent = dataMap.events[evid];
	const posKey = DataManager.makePosKey(dataEvent.x, dataEvent.y);
	const cell = DataManager._thumbnailMapCell[posKey];
	const page = cell.page;
	const pageInfo = DataManager._thumbnailPageInfo[page];
	const smallMap = this._smallMap;
	const currCell = this.currCell();
	const currPageInfo = DataManager._thumbnailPageInfo[currCell.page];
	let realCell = null;
	const isCrossPage = currCell.page !== page;
	
	if(isCrossPage) {			// 和玩家当前不在同一个page的任务指引点，直接转换成离玩家当前最近的page边界格子
		let minDistance = 0;
		// A*算法找到最临近的任务指引点
		let currentNode = null;
		const openNodes = [{cell:currCell, g:0, f:Math.abs(currCell.x - cell.x) + Math.abs(currCell.y - cell.y), parent:null}];
		const closeNodes = [];
		const dirArr = [{x:0,y:1,d:"b",pd:"pb"}, {x:0,y:-1,d:"t",pd:"pt"}, {x:-1,y:0,d:"l",pd:"pl"}, {x:1,y:0,d:"r",pd:"pr"}];
		while(openNodes.length > 0) {
			currentNode = null;
			for(const node of openNodes) {
				if(currentNode === null || currentNode.f + currentNode.g > node.f + node.g) {
					currentNode = node;
				}
			}
			openNodes.remove(currentNode);
			closeNodes.push(currentNode.cell);
			if(currentNode.cell === cell) {
				break;
			}
			for(const dir of dirArr) {
				if(currentNode.cell[dir.d]) {		// 该方向有阻挡
					continue;
				}
				const nextCellX = currentNode.cell.x + dir.x;
				const nextCellY = currentNode.cell.y + dir.y;
				const nextCell = DataManager._thumbnailMapCell[DataManager.makePosKey(nextCellX, nextCellY)];
				if(!nextCell) {
					continue;
				}
				if(nextCell.page !== currentNode.cell.page && !currentNode.cell[dir.pd]) {		// 跨page的格子，必须要有pl/pr/pb/pt标签才能通过
					continue;
				}
				const isInCloseNodes = closeNodes.some((closeCell) => {
					return closeCell === nextCell;
				});
				if(isInCloseNodes) {
					continue;
				}
				const isInOpenNodes = openNodes.some((openNode) => {
					return openNode.cell === nextCell;
				});
				if(isInOpenNodes) {
					continue;
				}

				openNodes.push({cell:nextCell, g:currentNode.g + 1, f:Math.abs(nextCell.x - cell.x) + Math.abs(nextCell.y - cell.y), parent:currentNode});
			}
			if(currentNode.cell.connect) {
				const connectNext = DataManager._thumbnailMapCell[currentNode.cell.connect];
				if(!connectNext) {
					continue;
				}
				const isConnectInCloseNodes = closeNodes.some((closeCell) => {
					return closeCell === connectNext;
				});
				if(isConnectInCloseNodes) {
					continue;
				}
				const isConnectInOpenNodes = openNodes.some((openNode) => {
					return openNode.cell === connectNext;
				});
				if(isConnectInOpenNodes) {
					continue;
				}

				openNodes.push({cell:connectNext, g:currentNode.g + 1, f:1, parent:currentNode});
			}
		}
		while(currentNode.parent) {		// 从目标节点往源节点找，如果发现parent.cell.page === currCell.page && currentNode.cell.page !== parent.cell.page，返回currentNode
			if(currentNode.parent.cell.page === currCell.page && currentNode.cell.page !== currentNode.parent.cell.page) {
				if(currentNode.parent.cell.connect) {
					realCell = currentNode.parent.cell;
				} else {
					realCell = currentNode.cell;
				}
				break;
			}
			currentNode = currentNode.parent;
		}
	} else { 
		realCell = cell;
	}
	if(!realCell) {
		return null;
	}
	const minX = smallMap ? currCell.x : (isCrossPage ? currPageInfo.minX : pageInfo.minX);
	const minY = smallMap ? currCell.y : (isCrossPage ? currPageInfo.minY : pageInfo.minY);
	const margin = DataManager.thumbnailMargin();
	const itemWidth = DataManager.thumbnailCellWidth() + margin;
	const x = (realCell.x - minX) * itemWidth;
	const y = (realCell.y - minY) * itemWidth;
	const center = DataManager.thumbnailCellWidth() / 2;
	return {x:x+center, y:y+center, cell:realCell};
};

Sprite_MapThumbnail.prototype.aStarFindPageEdge = function() {
};

Sprite_MapThumbnail.prototype.taskSignature = function() {
	const sprite = new Sprite(ImageManager.loadUI("task_signature"));
	sprite.setBlendColor(this._taskSignatureColor);
	return sprite;
};

Sprite_MapThumbnail.prototype.setTaskSignatureColor = function(color) {
	this._taskSignatureColor = color;
};

Sprite_MapThumbnail.prototype.insertTaskSignature = function(insertTaskId = 0) {
	const currCell = this.currCell();
	if(!currCell) {
		return;
	}
	for(const taskId of $gamePlayer.actor().tasks()) {
		if(insertTaskId !== 0 && insertTaskId === taskId) {
			continue;
		}
		const pos = this.evidToCellPosition($dataTask[taskId].ev);
		if(!pos) {
			continue;
		}
		const cell = pos.cell;
		if(this._smallMap && (Math.abs(currCell.x - cell.x) > this._mapWidth || Math.abs(currCell.y - cell.y) > this._mapHeight)) {
			continue;
		}
		const sprite = this.taskSignature();
		sprite.anchor.x = sprite.anchor.y = 0.5;
		sprite.x = pos.x;
		sprite.y = pos.y;
		this._taskSignatureSprite.addChild(sprite);
	}
};

Sprite_MapThumbnail.prototype.firstTaskSignatureSprite = function() {
	return this._taskSignatureSprite.children[0];
};

Sprite_MapThumbnail.prototype.currCell = function() {
	return this._currentCell ? this._currentCell : DataManager.getCurrentThumbnailCell();
};

Sprite_MapThumbnail.prototype.buildPage = function(smallMap = false, width = 0, height = 0, drawPage = 0) {
	this.clear();
	const currCell = this.currCell();
	const currPage = currCell ? currCell.page : 0;
	const page = drawPage ? drawPage : currPage;
	if(!page) { return; }
	const pageInfo = DataManager._thumbnailPageInfo[page];
	const cellWidth = DataManager.thumbnailCellWidth();
	const innerCellWidth = DataManager.thumbnailInnerCellWidth();
	const innerMargin = (cellWidth - innerCellWidth) / 2;
	this._pageInfo = pageInfo;
	const margin = DataManager.thumbnailMargin();
	const itemWidth = cellWidth + margin;
	const minX = smallMap ? currCell.x : pageInfo.minX;
	const minY = smallMap ? currCell.y : pageInfo.minY;
	const rounded = DataManager.thumbnailCellRounded();
	const fillSprite = new Sprite();
	const callback = function(cell) {
		const color = DataManager.regionColor(cell.regionId);
		const graphics = new PIXI.Graphics();
		const upperColor = Utils.upperColor(color, 2);
		graphics.lineStyle(innerMargin, color, 1, 0);
		graphics.beginFill(upperColor);
		graphics.drawRoundedRect(0, 0, cellWidth, cellWidth, rounded);
		graphics.lineStyle(0);
		graphics.beginFill(this.currentPosColor());
		
		const cwdiv2 = cellWidth / 2;
		const cwsubmar = cellWidth - innerMargin;
		if(cell.pt) {
			graphics.drawPolygon([new PIXI.Point(cwdiv2, innerMargin), new PIXI.Point(innerMargin, cwdiv2), new PIXI.Point(cwsubmar, cwdiv2)]);
			graphics.drawPolygon([new PIXI.Point(cwdiv2, cwdiv2), new PIXI.Point(innerMargin, cwsubmar), new PIXI.Point(cwsubmar, cwsubmar)]);
		} else if(cell.pl) {
			graphics.drawPolygon([new PIXI.Point(innerMargin, cwdiv2), new PIXI.Point(cwdiv2, innerMargin), new PIXI.Point(cwdiv2, cwsubmar)]);
			graphics.drawPolygon([new PIXI.Point(cwdiv2, cwdiv2), new PIXI.Point(cwsubmar, cwsubmar), new PIXI.Point(cwsubmar, innerMargin)]);
		} else if(cell.pr) {
			graphics.drawPolygon([new PIXI.Point(cwsubmar, cwdiv2), new PIXI.Point(cwdiv2, innerMargin), new PIXI.Point(cwdiv2, cwsubmar)]);
			graphics.drawPolygon([new PIXI.Point(cwdiv2, cwdiv2), new PIXI.Point(innerMargin, innerMargin), new PIXI.Point(innerMargin, cwsubmar)]);
		} else if(cell.pb) {
			graphics.drawPolygon([new PIXI.Point(cwdiv2, cwsubmar), new PIXI.Point(innerMargin, cwdiv2), new PIXI.Point(cwsubmar, cwdiv2)]);
			graphics.drawPolygon([new PIXI.Point(cwdiv2, cwdiv2), new PIXI.Point(cwsubmar, innerMargin), new PIXI.Point(innerMargin, innerMargin)]);
		}
		graphics.endFill();
		const x = (cell.x - minX) * itemWidth;
		const y = (cell.y - minY) * itemWidth;
		graphics.x = x;
		graphics.y = y;
		this._cellSprite.addChild(graphics);
		
		const letter = this.determineCellFlag(cell);
		const collected = this.checkCellAllItemCollected(cell);
		if(letter !== "") {
			const bitmap = this.createLetterBitmap(letter);
			const letterSprite = new Sprite(bitmap);
			letterSprite.anchor.x = letterSprite.anchor.y = 0.5;
			letterSprite.x = x + cwdiv2;
			letterSprite.y = y + cwdiv2;
			this._letterSprite.addChild(letterSprite);
		} else if(collected || (cell === currCell && cell.collectItem.length > 0)) {
			const collectSprite = this.createItemCollectSprite();
			collectSprite.x = x + cwdiv2;
			collectSprite.y = y + cwdiv2;
			this._letterSprite.addChild(collectSprite);
			if(!collected) {
				this._newCollectedSprite = collectSprite;
				collectSprite.visible = false;
			}
		}
		const lcella = DataManager.thumbnailCell(cell.x - 1, cell.y);
		const tcella = DataManager.thumbnailCell(cell.x, cell.y - 1);
		const rcella = DataManager.thumbnailCell(cell.x + 1, cell.y);
		const bcella = DataManager.thumbnailCell(cell.x, cell.y + 1);
		
		const lcell = DataManager.thumbnailCellWithoutActive(cell.x - 1, cell.y);
		if(!cell.l && lcell) {
			const gra = new PIXI.Graphics();
			gra.beginFill(color);
			if(lcell.mapId !== cell.mapId || !lcella) {
				gra.drawRect(0, 0, margin / 2, margin * 4);
				gra.x = x - margin / 2;
				gra.y = y + (cellWidth - margin * 4) / 2;
				this._pathSprite.addChild(gra);
			} else {
				const drawWidth = (innerMargin + 1) * 2 + margin;
				gra.drawRect(1, -innerMargin, drawWidth - 2, innerMargin);
				gra.drawRect(1, cwsubmar - innerMargin, drawWidth - 2, innerMargin);
				gra.beginFill(upperColor);
				gra.drawRect(0, 0, drawWidth, innerCellWidth);
				gra.x = x - innerMargin - margin - 1;
				gra.y = y + innerMargin;
				this._upperPathSprite.addChild(gra);
			}
			gra.endFill();
			
		}
		const rcell = DataManager.thumbnailCellWithoutActive(cell.x + 1, cell.y);
		if(!cell.r && rcell) {
			const gra = new PIXI.Graphics();
			gra.beginFill(color);
			if(rcell.mapId !== cell.mapId || !rcella) {			// 两个格子不是同一个房间，填充连接点 
				gra.drawRect(0, 0, margin / 2, margin * 4);
				gra.x = x + cellWidth;
				gra.y = y + (cellWidth - margin * 4) / 2;
				this._pathSprite.addChild(gra);
			} else {
				const drawWidth = (innerMargin + 1) * 2 + margin;	// 两个格子是同一个房间，把两个方格完整的外框连接上，把连接的部分用浅色填充上，使其浑然一体
				gra.drawRect(1, -innerMargin, drawWidth - 2, innerMargin);
				gra.drawRect(1, cwsubmar - innerMargin, drawWidth - 2, innerMargin);
				gra.beginFill(upperColor);
				gra.drawRect(0, 0, drawWidth, innerCellWidth);
				gra.x = x + cellWidth - innerMargin - 1;
				gra.y = y + innerMargin;
				this._upperPathSprite.addChild(gra);
			}
			gra.endFill();
		}
		const tcell = DataManager.thumbnailCellWithoutActive(cell.x, cell.y - 1);
		if(!cell.t && tcell) {
			const gra = new PIXI.Graphics();
			gra.beginFill(color);
			if(tcell.mapId !== cell.mapId || !tcella) {
				gra.drawRect(0, 0, margin * 4, margin / 2);
				gra.x = x + (cellWidth - margin * 4) / 2;
				gra.y = y - margin / 2;
				this._pathSprite.addChild(gra);
			} else {
				const drawWidth = (innerMargin + 1) * 2 + margin;
				gra.drawRect(-innerMargin, 1, innerMargin, drawWidth - 2);
				gra.drawRect(cwsubmar - innerMargin, 1, innerMargin, drawWidth - 2);
				gra.beginFill(upperColor);
				gra.drawRect(0, 0, innerCellWidth, drawWidth);
				gra.x = x + innerMargin;
				gra.y = y - innerMargin - margin - 1;
				this._upperPathSprite.addChild(gra);
			}
			gra.endFill();
		}
		const bcell = DataManager.thumbnailCellWithoutActive(cell.x, cell.y + 1);
		if(!cell.b && bcell) {
			const gra = new PIXI.Graphics();
			gra.beginFill(color);
			if(bcell.mapId !== cell.mapId || !bcella) {			// 超出地图边界和未解锁均不视为同一房间
				gra.drawRect(0, 0, margin * 4, margin / 2);
				gra.x = x + (cellWidth - margin * 4) / 2;
				gra.y = y + cellWidth;
				this._pathSprite.addChild(gra);
			} else {
				const drawWidth = (innerMargin + 1) * 2 + margin;
				gra.drawRect(-innerMargin, 1, innerMargin, drawWidth - 2);
				gra.drawRect(cwsubmar - innerMargin, 1, innerMargin, drawWidth - 2);
				gra.beginFill(upperColor);
				gra.drawRect(0, 0, innerCellWidth, drawWidth);
				gra.x = x + innerMargin;
				gra.y = y + cellWidth - innerMargin - 1;
				this._upperPathSprite.addChild(gra);
			}
			gra.endFill();
		}
		// 检测是否需要把四个方格中间的区域用浅色填充上，四个方格同为一个房间的情况
		const ltcella = DataManager.thumbnailCell(cell.x - 1, cell.y - 1);
		const rdcella = DataManager.thumbnailCell(cell.x + 1, cell.y + 1);
		
		if(lcella && tcella && ltcella && cell.mapId === lcella.mapId && lcella.mapId === tcella.mapId && tcella.mapId === ltcella.mapId) {
			const graFillRect = new PIXI.Graphics();
			graFillRect.x = x;
			graFillRect.y = y;
			graFillRect.beginFill(upperColor);
			graFillRect.drawRect(-margin - innerMargin, -margin - innerMargin, margin + innerMargin * 2, margin + innerMargin * 2);
			fillSprite.addChild(graFillRect);
		}
		// 右下角的格子没探索的情况，使用左上角的格子作为四方格检测
		if(!rdcella || (smallMap && (cell.y - currCell.y === height || cell.x - currCell.x === width))) {
			if(rcella && bcella && rdcella && cell.mapId === rcella.mapId && rcella.mapId === bcella.mapId && bcella.mapId === rdcella.mapId) {
				const graFillRect = new PIXI.Graphics();
				graFillRect.x = x + cellWidth + margin;
				graFillRect.y = y + cellWidth + margin;
				graFillRect.beginFill(upperColor);
				graFillRect.drawRect(-margin - innerMargin, -margin - innerMargin, margin + innerMargin * 2, margin + innerMargin * 2);
				fillSprite.addChild(graFillRect);
			}
		}
	}.bind(this);
	if(!smallMap) {
		DataManager.thumbnailPageDrawEx(callback, page);
	} else {
		DataManager.thumbnailMapDraw(width, height, callback);
	}
	this._upperPathSprite.addChild(fillSprite);
	this.currentPosCellSprite = new PIXI.Graphics();
	this.currentPosCellSprite.beginFill(this.currentPosColor());
	this.currentPosCellSprite.drawRoundedRect(0, 0, cellWidth, cellWidth, rounded);
	this.currentPosCellSprite.x = (currCell.x - minX) * itemWidth;
	this.currentPosCellSprite.y = (currCell.y - minY) * itemWidth;
	this.currentPosCellSprite.endFill();
	this.currentPosCellSprite.alpha = 0;
	this._upperPathSprite.addChild(this.currentPosCellSprite);
	this._smallMap = smallMap;
	this._mapWidth = width;
	this._mapHeight = height;
};

Sprite_MapThumbnail.prototype.duration = function() {
	return 36;
};

Sprite_MapThumbnail.prototype.minAlpha = function() {
	return 0;
};

Sprite_MapThumbnail.prototype.maxAlpha = function() {
	return 196;
};

Sprite_MapThumbnail.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this.currentPosCellSprite) {
		this.currentPosAlpha += this.currentPosAlphaSign * (this.maxAlpha() - this.minAlpha()) / this.duration();
		if(this.currentPosAlpha < this.minAlpha()) {
			this.currentPosAlphaSign = 1;
		} else if(this.currentPosAlpha > this.maxAlpha()) {
			this.currentPosAlphaSign = -1;
		}
		this.currentPosCellSprite.alpha = this.currentPosAlpha / 255;
	}
	this.updateTaskSignature();
	this.updateCollectItem();
};

Sprite_MapThumbnail.prototype.updateCollectItem = function() {
	if(this._newCollectedSprite) {
		const currCell = this.currCell();
		if(currCell) {
			const result = this.checkCellAllItemCollected(currCell);
			if(result) {
				this._newCollectedSprite.visible = true;
				this._newCollectedSprite = null;
			}
		}
	}
};

Sprite_MapThumbnail.prototype.updateTaskSignature = function() {
	for(const gra of this._taskSignatureSprite.children) {
		gra.rotation += 0.06;
	}
};

Sprite_MapThumbnail.prototype.checkCellAllItemCollected = function(cell) {
	if(cell.collectItem.length > 0) {
		return cell.collectItem.every((eventId) => {
			return $gameSelfSwitches.value([cell.mapId, eventId, "A"]);
		});
	}
	return false;
};

// 格子上的字，例如T代表传送点，S代表存档点，R代表回复点
Sprite_MapThumbnail.prototype.determineCellFlag = function(cell) {
	const mapId = cell.mapId;
	const mapData = DataManager.getCachedData(mapId);
	const savepoint = mapData.savepoint.some((save) => {
		const evx = save[0];
		const evy = save[1];
		const pos = DataManager.getThumbnailPos(evx, evy, mapId);
		if(pos && pos.x === cell.x && pos.y === cell.y) {
			return true;
		}
		return false;
	});
	if(savepoint) {
		return "S";
	}
	const transport = mapData.transport.some((trans) => {
		const evx = trans[0];
		const evy = trans[1];
		const pos = DataManager.getThumbnailPos(evx, evy, mapId);
		if(pos && pos.x === cell.x && pos.y === cell.y) {
			return true;
		}
		return false;
	});
	if(transport) {
		return "T";
	}
	return "";
};

NYA.MAP.Scene_Map_fadeOutForTransfer = Scene_Map.prototype.fadeOutForTransfer;
Scene_Map.prototype.fadeOutForTransfer = function() {
    const fadeType = $gamePlayer.extraFadeType();
	if(fadeType !== 0) {
		this.startExtraFade(-1);
	}
	else {
		NYA.MAP.Scene_Map_fadeOutForTransfer.apply(this, arguments);
	}
};

NYA.MAP.Game_Player_initMembers = Game_Player.prototype.initMembers;
Game_Player.prototype.initMembers = function() {
	NYA.MAP.Game_Player_initMembers.apply(this, arguments);
	this._extraFadeSpeed = 0;
	this._extraFadeType = 0;
	this._extraFadeDelay = 0;
};

NYA.MAP.Scene_Map_create = Scene_Map.prototype.create;
Scene_Map.prototype.create = function() {
	NYA.MAP.Scene_Map_create.apply(this, arguments);
	const fadeType = $gamePlayer.extraFadeType();
	if(fadeType !== 0) {
		this.createExtraFadeSprite(fadeType);
	}
};

Scene_Map.prototype.createExtraFadeSprite = function(fadeType) {
	switch(fadeType) {
		case 6: {
			if(this.mask) { this.removeChild(this.mask); }
			this.mask = new Sprite(this.loadNekoTransformMask()); 
			this.mask.bitmap.smooth = false;
			this.mask.anchor.x = 0.5; 
			this.mask.anchor.y = 0.5; 
			this.mask.x = Graphics.width / 2;
			this.mask.y = Graphics.height / 2;
			this.addChild(this.mask);
			break;
		}
		default: this.mask = new PIXI.Graphics(); break;
	}
};

NYA.MAP.Scene_Map_destroy = Scene_Map.prototype.destroy;
Scene_Map.prototype.destroy = function() {
	NYA.MAP.Scene_Map_destroy.apply(this, arguments);
	if(this.mask) {
		this.mask.destroy();
	}
};

Scene_Map.prototype.circleFadeSpeed = function() {
	const extraFadeSpeed = $gamePlayer.extraFadeSpeed();
	return extraFadeSpeed ? extraFadeSpeed : 48;
};

Scene_Map.prototype.rollFadeSpeedLR = function() {
	const extraFadeSpeed = $gamePlayer.extraFadeSpeed();
	return extraFadeSpeed ? extraFadeSpeed : 48;
};

Scene_Map.prototype.rollFadeSpeedBT = function() {
	const extraFadeSpeed = $gamePlayer.extraFadeSpeed();
	return extraFadeSpeed ? extraFadeSpeed : 27;
};

Scene_Map.prototype.nekoFadeSpeed = function() {
	const extraFadeSpeed = $gamePlayer.extraFadeSpeed();
	return extraFadeSpeed ? extraFadeSpeed : 105;
};

Scene_Map.prototype.startExtraFade = function(fadeSign) {
	const fadeType = $gamePlayer.extraFadeType();
	this.createExtraFadeSprite(fadeType);
	const duration = this.calcExtraFadeDuration();
	this._fadeDuration = duration;
	this._fadeSign = fadeSign;
	this.updateFade();
};

NYA.MAP.Scene_Map_updateFade = Scene_Map.prototype.updateFade;
Scene_Map.prototype.updateFade = function() {
	switch ($gamePlayer.extraFadeType()) {
		case 0: NYA.MAP.Scene_Map_updateFade.apply(this, arguments); break;
        case 1: this.updateCircleFade(); break;
		case 2: this.updateRollFade({x:-1,y:0});  break;
		case 3: this.updateRollFade({x:0,y:-1});  break;
		case 4: this.updateRollFade({x:1,y:0});  break;
		case 5: this.updateRollFade({x:0,y:1});  break;
		case 6: this.updateNekoFade(); break;
		default: break;
    }
};

Scene_Map.prototype.calcExtraFadeDuration = function() {
	switch($gamePlayer.extraFadeType()) {
		case 1: return this.calcCircleFadeDuration() + $gamePlayer.extraFadeDelay();
		case 2: case 4: return this.calcRollFadeDurationLR() + $gamePlayer.extraFadeDelay();
		case 3: case 5: return this.calcRollFadeDurationBT() + $gamePlayer.extraFadeDelay();  //dir : LTRB
		case 6: return this.calcNekoFadeDuration() + $gamePlayer.extraFadeDelay();
		default: return 0;
	}
};

Scene_Map.prototype.calcNekoFadeDuration = function() {
	const maskBitmap = this.loadNekoTransformMask();
	const scale = Math.max(Graphics.width / maskBitmap.width, Graphics.height / maskBitmap.height) * this.nekoFadeScale();
	return Math.ceil(scale * 1000 / this.nekoFadeSpeed());
};

Scene_Map.prototype.nekoFadeScale = function() {
	return 2.5;
};

Scene_Map.prototype.loadNekoTransformMask = function() {
	return ImageManager.loadPicture('neko_transform');
};

Scene_Map.prototype.calcCircleFadeDuration = function() {
	return Math.ceil(Math.sqrt(Math.pow(Graphics.width, 2) + Math.pow(Graphics.height, 2)) / this.circleFadeSpeed());
};

Scene_Map.prototype.calcRollFadeDurationLR = function() {
	return Math.ceil(Graphics.width / this.rollFadeSpeedLR());
};

Scene_Map.prototype.calcRollFadeDurationBT = function() {
	return Math.ceil(Graphics.height / this.rollFadeSpeedBT());
};

Scene_Map.prototype.updateCircleFade = function() {
	if(this._fadeDuration) {
		const mask = this.mask;
		mask.clear();
		mask.beginFill(0xff0000);
		const realDuration = Math.max(0, this._fadeDuration - 1 - $gamePlayer.extraFadeDelay());
		const radius = this._fadeSign > 0 ? (this.calcCircleFadeDuration() - realDuration) * this.circleFadeSpeed() : realDuration * this.circleFadeSpeed();
		mask.drawCircle(Graphics.width / 2, Graphics.height / 2, radius);
		mask.endFill();
		this._fadeDuration--;
		if(!this._fadeDuration && this._fadeSign > 0) {
			this.clearExtraDuration();
		}
	}
};

Scene_Map.prototype.updateRollFade = function(dir) {
	if(this._fadeDuration) {
		const mask = this.mask;
		mask.clear();
		mask.beginFill(0xff0000);
		const realDuration = Math.max(0, this._fadeDuration - 1 - $gamePlayer.extraFadeDelay());
		const width = dir.x ? (this._fadeSign > 0 ? (this.calcRollFadeDurationLR() - realDuration) * this.rollFadeSpeedLR() : realDuration * this.rollFadeSpeedLR()) : Graphics.width;
		const height = dir.y ? (this._fadeSign > 0 ? (this.calcRollFadeDurationBT() - realDuration) * this.rollFadeSpeedBT() : realDuration * this.rollFadeSpeedBT()) : Graphics.height;
		const rectX = dir.x === 1 ? Graphics.width - width : 0;
		const rectY = dir.y === 1 ? Graphics.height - height : 0;
		mask.drawRect(rectX, rectY, width, height);
		mask.endFill();
		this._fadeDuration--;
		if(!this._fadeDuration && this._fadeSign > 0) {
			this.clearExtraDuration();
		}
	}
};

Scene_Map.prototype.updateNekoFade = function() {
	if(this._fadeDuration) {
		const mask = this.mask;
		const realDuration = Math.max(0, this._fadeDuration - 1 - $gamePlayer.extraFadeDelay());
		const maxDuration = this.calcNekoFadeDuration();
		const scale = this._fadeSign > 0 ? (this.calcNekoFadeDuration() - realDuration) * this.nekoFadeSpeed() / 1000 : realDuration * this.nekoFadeSpeed() / 1000;
		mask.scale.x = mask.scale.y = Math.pow(scale, 3);
		const maxy = 900;
		const maskBitmap = mask.bitmap;
		const maxScale = Math.max(Graphics.width / maskBitmap.width, Graphics.height / maskBitmap.height) * this.nekoFadeScale();
		const scale2 = Math.max(0.6, scale);
		const dy = scale2 / maxScale * maxy;
		mask.y = Graphics.height / 2 - dy;
		this._fadeDuration--;
		if(!this._fadeDuration && this._fadeSign > 0) {
			this.clearExtraDuration();
			this.removeChild(mask);
		}
	}
};

Scene_Map.prototype.clearExtraDuration = function() {
	this.mask = null;
	this._fadeSign = 0;
	$gamePlayer.clearTransferFade();
};

NYA.MAP.Scene_Map_fadeInForTransfer = Scene_Map.prototype.fadeInForTransfer;
Scene_Map.prototype.fadeInForTransfer = function() {
    const fadeType = $gamePlayer.extraFadeType();
    if(fadeType !== 0) {
        this.startExtraFade(1);
	}
	else {
		NYA.MAP.Scene_Map_fadeInForTransfer.apply(this, arguments);
	}
};


Game_Player.prototype.reserveTransferFade = function(fadeType, speed, delay) {
	this._extraFadeType = fadeType;
	this._extraFadeSpeed = speed;
	this._extraFadeDelay = delay;
};

Game_Player.prototype.clearTransferFade = function() {
	this._extraFadeType = 0;
	this._extraFadeSpeed = 0;
};

Game_Player.prototype.extraFadeType = function() {
	return this._extraFadeType;
};

Game_Player.prototype.extraFadeSpeed = function() {
	return this._extraFadeSpeed;
};

Game_Player.prototype.extraFadeDelay = function() {
	return this._extraFadeDelay;
};

Utils.upperColor = function(color, times) {
	const r = Math.trunc((0xff - ((color & 0xff0000) >> 16)) / times);
	const g = Math.trunc((0xff - ((color & 0x00ff00) >> 8)) / times);
	const b = Math.trunc((0xff - (color & 0x0000ff)) / times);
	return color + (r << 16) + (g << 8) + b;
};

Spriteset_Map.prototype.createCharacter = function(character) {
	const sprite = new Sprite_Character(character);
	this._characterSprites.push(sprite);
	this._tilemap.addChild(sprite);
};

Spriteset_Map.prototype.createCharacters = function() {
    this._characterSprites = [];
    for (const event of $gameMap.events()) {
        this.createCharacter(event);
    }
    for (const vehicle of $gameMap.vehicles()) {
        this.createCharacter(vehicle);
    }
    for (const follower of $gamePlayer.followers().reverseData()) {
        this.createCharacter(follower);
    }
    this.createCharacter($gamePlayer);
	for(const character of $gameMap.dynamicCharacters()) {
		this.createCharacter(character);
	}
	Window_FloatMessage.clearCache();
};

NYA.MAP.Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
	NYA.MAP.Game_Map_initialize.apply(this, arguments);
	this._dynamicCharacters = [];
	this._reserveCharacters = [];
	this._movingCursorProgress = 0;
	this._specProgressVisible = false;
	this._specProgress = 0;
	this._specProgressType = 0;
	this._bossScorePopUp = false;
	this._dynamicCharactersPosMap = [];
	this._dynamicCharactersCounter = 1000;
};

NYA.MAP.Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function() {
	this._dynamicCharacters = [];
	this._reserveCharacters = [];
	this._dynamicCharactersPosMap = [];
	this._dynamicCharactersCounter = 1000;
	NYA.MAP.Game_Map_setup.apply(this, arguments);
	this._movingCursorProgress = 0;			// 地图中间下方显示的进度游标，一般用作大炮发射的力度
	this._specProgressVisible = false;		// 地图中间最下方显示的特殊机制条，一般用来表现boss特殊机制的发动过程
	this._specProgress = 0;
	this._specProgressType = 0;
	this._bossScorePopUp = false;
};

Game_Map.prototype.setSpecProgress = function(val, type = 0) {
	this._specProgressVisible = true;
	this._specProgress = val;
	this._specProgressType = type;
};

Game_Map.prototype.specProgress = function() {
	return this._specProgress || 0;
};

Game_Map.prototype.specProgressVisible = function() {
	return this._specProgressVisible;
};

Game_Map.prototype.clearSpecProgress = function() {
	this._specProgressVisible = false;
	this._specProgress = 0;
};

Game_Map.prototype.specProgressType = function() {
	return this._specProgressType;
};

Game_Map.prototype.setMovingCursorProgress = function(val) {
	this._movingCursorProgress = val;
};

Game_Map.prototype.movingCursorProgress = function() {
	return this._movingCursorProgress;
};

Game_Map.prototype.allCharacters = function() {
	return this.events().concat(this.dynamicCharacters(), [$gamePlayer]);
};

Spriteset_Map.prototype.updateCharacterCreate = function() {
	if($gameMap.reserveCharacters().length !== 0) {
		for(const character of $gameMap.reserveCharacters()) {
			this.createCharacter(character);
		}
		$gameMap.clearReserveCharacter();
	}
};

NYA.MAP.Spriteset_Map_update = Spriteset_Map.prototype.update;
Spriteset_Map.prototype.update = function() {
	NYA.MAP.Spriteset_Map_update.apply(this, arguments);
	this.updateCharacterCreate();
	this.updateCharacterRemove();
};

Spriteset_Map.prototype.updateCharacterRemove = function() {
	this._characterSprites = this._characterSprites.filter((sprite) => {
		const remove = sprite._character.isRemove();
		if(remove) {
			this._tilemap.removeChild(sprite);
			sprite.destroy();
		}
		return !remove;
	});
};

NYA.MAP.Game_Map_event = Game_Map.prototype.event;
Game_Map.prototype.event = function(eventId) {
	switch(eventId) {
		case -1: {
			return $gamePlayer;
		}
		case -2: {
			return $gameLily;
		}
		default: {
			if(eventId < 1000) {
				return NYA.MAP.Game_Map_event.call(this, eventId);
			} else {
				for(let pos = 0; pos < this._dynamicCharactersPosMap.length; pos++) {
					const id = this._dynamicCharactersPosMap[pos];
					if(id === eventId) {
						return this._dynamicCharacters[pos];
					}
				}
				return undefined;
			}
		}
	}
};

Game_Map.prototype.createCharacter = function(character) {
	this._reserveCharacters.push(character);
};

Game_Map.prototype.clearReserveCharacter = function() {
	for(const character of this.reserveCharacters()) {
		const id = this._dynamicCharactersCounter++;
		const pos = this._dynamicCharacters.length;
		this._dynamicCharacters.push(character);
		character.setLinkId(id);
		this._dynamicCharactersPosMap.push(id);
	}
	this._reserveCharacters = [];
};

Game_Map.prototype.removeDynamicCharacter = function(eventId) {
	let idx = -1;
	for(let i = 0; i < this._dynamicCharacters.length; i++) {
		const character = this._dynamicCharacters[i];
		if(character.eventId() === eventId) {
			idx = i;
		}
	}
	if(idx >= 0) {
		this._dynamicCharacters.splice(idx, 1);
		this._dynamicCharactersPosMap.splice(idx, 1);
	}
};

Game_Map.prototype.reserveCharacters = function() {
	return this._reserveCharacters;
};

Game_Map.prototype.dynamicCharacters = function() {
	return this._dynamicCharacters;
};

Game_Map.prototype.rebuildDynamicCharacterPosMap = function() {
	this._dynamicCharactersCounter = 1000;
	this._dynamicCharactersPosMap = [];
	for(const character of this._dynamicCharacters) {
		character.setLinkId(this._dynamicCharactersCounter++);
		this._dynamicCharactersPosMap.push(character.eventId());
	}
};

NYA.MAP.Game_Map_updateEvents = Game_Map.prototype.updateEvents;
Game_Map.prototype.updateEvents = function() {
	NYA.MAP.Game_Map_updateEvents.apply(this, arguments);
	let i = 0;
	let deletedIds = [];
	this._dynamicCharacters = this._dynamicCharacters.filter((ch) => {
		if(ch.isRemove()) {
			deletedIds.push(i);
			i++;
			return false;
		} else {
			ch.update();
			i++;
			return true;
		}
	});
	deletedIds.reverse();
	for(const idx of deletedIds) {
		this._dynamicCharactersPosMap.splice(idx, 1);
	}
};

Game_Map.prototype.dropCoin = function(x, y, num, scale = 1, dir = 0) {
	const character = new Game_MapCoin(num);
	character.px = character.rx = x;
	character.py = character.ry = y;
	character.flush();
	character.setRandomSpeed(scale, dir);
	this.createCharacter(character);
};

NYA.MAP.Game_CharacterBase_initMembers = Game_CharacterBase.prototype.initMembers;
Game_CharacterBase.prototype.initMembers = function() {
	NYA.MAP.Game_CharacterBase_initMembers.apply(this, arguments);
	this._remove = false;
};

Game_CharacterBase.prototype.requestRemove = function() {
	this.setRemove(true);
};

Game_CharacterBase.prototype.setRemove = function(val) {
	this._remove = val;
};

Game_CharacterBase.prototype.isRemove = function() {
	return this._remove;
};

function Game_MapCoin() {
	this.initialize(...arguments);
}

Game_MapCoin.prototype = Object.create(Game_CharacterBase.prototype);
Game_MapCoin.prototype.constructor = Game_MapCoin;

Game_MapCoin.prototype.initialize = function(num) {
	Game_CharacterBase.prototype.initialize.apply(this, arguments);
	this._coin = num;
	this._physicsFlag = 1;
	this.determineCharacterName();
	this.setFriction(0.2);
	this.setAirFriction(0.2);
	this.elastic = 0.5;
	this.physics = true;
	this.isTouched = false;
	this.removeAnimationFrame = 0;
	this.mushroomHitCounter = 0;
	this._battleObject = new Game_BattleObject();
	this._battleObject.team = -2;
	this.setScale(0.5);
};

Game_MapCoin.prototype.coin = function() {
	return this._coin;
};

Game_MapCoin.prototype.battleObject = function() {
	return this._battleObject;
};

Game_MapCoin.prototype.doPState = function() {
	this.checkPlayerHit();
};

Game_MapCoin.prototype.doPStateChange = function() {
};

Game_MapCoin.prototype.determineCharacterName = function() {
	if(this._coin === 20) {
		this.setImage(";coin_gold", 0);
	}
	if(this._coin === 5) {
		this.setImage(";coin_silver", 0);
	}
	if(this._coin === 1) {
		this.setImage(";coin_copper", 0);
	}
};

Game_MapCoin.prototype.resetHitOffset = function() {
	Game_CharacterBase.prototype.resetHitOffset.call(this);
	this._hitOffsetL = this._hitOffsetL / Graphics.scaleX;
	this._hitOffsetR = this._hitOffsetR / Graphics.scaleX;
	this._hitOffsetT = this._hitOffsetT / Graphics.scaleY;
	this._hitOffsetB = this._hitOffsetB / Graphics.scaleY;
};

Game_MapCoin.prototype.checkPlayerHit = function() {
	const orgFlag = this._physicsFlag;
	this._physicsFlag = 0;
	if(!this.isTouched) {
		if(this._impact && Math.abs(this.vy) > 1 && this._impactDirection === 1) {
			AudioManager.playPlayerRoundSe(this, "coin");
		}
		const orgFlag2 = $gamePlayer._physicsFlag;
		$gamePlayer._physicsFlag = 0;
		if(this.hitTest($gamePlayer)) {
			$gamePlayer.addCoin(this.coin());
			this.isTouched = true;
			this.resetImage(this.characterName() + "_remove");
			this.suspendGravity();
			this.vx = this.vy = 0;
			AudioManager.playNormalSe("coin_pick");
		}
		$gamePlayer._physicsFlag = orgFlag2;
	} else if(this.removeAnimationFrame > 24) {
		this.requestRemove();
	} else {
		this.removeAnimationFrame++;
	}
	this._physicsFlag = orgFlag;
};

Game_MapCoin.prototype.g = function() {
	return 0.2;
};

Game_MapCoin.prototype.setRandomSpeed = function(scale, dir) {
	const fix = Math.sqrt(scale);
	const baseVY = -25 * fix;
	const baseVX = 22 * fix;
	this.impu(Math.random() * baseVX * dir, Math.random() * baseVY);
};

// 掉到蘑菇上的钱会越弹越多
Game_MapCoin.prototype.onMushroomHit = function(delta = 1) {
	this.mushroomHitCounter += delta;			
	if(this.mushroomHitCounter % 5 === 0) {
		this.updateCoinNum();
	}
};

Game_MapCoin.prototype.updateCoinNum = function() {
	switch(this._coin) {
		case 1: this._coin = 5; this.determineCharacterName(); break;
		case 5: this._coin = 20; this.determineCharacterName(); break;
	}
};

DataManager.getExploreItem = function() {
	const cell = this.getCurrentThumbnailCell();
	if(cell) {
		return this.getRegionExploreItem(cell.regionId);
	}
	return {has:0, all:0};
};

DataManager.getRegionExploreItem = function(regionId) {
	let all = 0;
	let has = 0;
	for(const data of $dataRegion[regionId].exploreItem) {
		const mapId = data[0];
		const eventId = data[1];
		if($gameSelfSwitches.value([mapId, eventId, "A"])) {
			has++;
		}
		all++;
	}
	return {has:has, all:all};
};

DataManager.cacheExploreItem = function() {
	for(const mapIdStr in this._cacheMapData) {
		const mapId = parseInt(mapIdStr);
		const dataMap = this._cacheMapData[mapIdStr];
		dataMap.itempoint.forEach((eventId) => {
			const eventData = dataMap.events[eventId];
			const x = eventData.x;
			const y = eventData.y;
			const cell = DataManager.getThumbnailCell(x, y, mapId);
			if(cell) {
				const regionId = cell.regionId;
				$dataRegion[regionId].exploreItem.push([mapId, eventId]);
				cell.collectItem.push(eventId);
			}
		});
	}
};

Game_Map.prototype.isEventCurrentRunning = function() {
	return this._interpreter.isRunning();
};

function Game_MapRecover() {
	this.initialize(...arguments);
}

Game_MapRecover.prototype = Object.create(Game_CharacterBase.prototype);
Game_MapRecover.prototype.constructor = Game_MapRecover;

Game_MapRecover.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.apply(this, arguments);
	this.setImage(";empty_character", 0);
	this._battleObject = new Game_BattleObject();
	this._battleObject.team = -2;
	this._physicsFlag = 5;
	this.setHitRect({l:12,t:12,r:12,b:12});
	this.physics = true;
	this.lockInvincible();
};

Game_MapRecover.prototype.battleObject = function() {
	return this._battleObject;
};

Game_MapRecover.prototype.shouldUsePhysicsPostion = function() {
	return false;
};

Game_MapRecover.prototype.doPState = function() {
	this.checkPlayerHit();
	this.requestAnimation(this.displayAnimationId(), {unique:true, physicsPosition:this.shouldUsePhysicsPostion()});
};

Game_MapRecover.prototype.displayAnimationId = function() {
	return 23;
};

Game_MapRecover.prototype.recoverAnimationId = function() {
	return 22;
};

Game_MapRecover.prototype.doPStateChange = function() {
};

Game_MapRecover.prototype.checkPlayerHit = function() {
	const orgFlag = this._physicsFlag;
	this._physicsFlag = 0;
	if(!this.isRemove()) {
		const character = this.targetCharacter();
		const orgFlag2 = character._physicsFlag;
		character._physicsFlag = 0;
		if($gameMap.hitTest(this, new PhysicsGrid([character]), false)) {
			const add = this.recoverNum();
			character.battleObject().addHp(add);
			this.requestRemove();
			character.requestAnimation(this.recoverAnimationId());
			$gameMap.addDamageDigit(character, -add);
			AudioManager.playPlayerRoundSe(this, this.recoverSeName());
		}
		character._physicsFlag = orgFlag2;
	}
	this._physicsFlag = orgFlag;
};

Game_MapRecover.prototype.recoverSeName = function() {
	return "Recovery2";
};

Game_MapRecover.prototype.requestRemove = function() {
	Game_CharacterBase.prototype.requestRemove.call(this);
	$gameTemp.requestRemoveAnimation([this], this.displayAnimationId());
};

Game_MapRecover.prototype.targetCharacter = function() {
	return $gamePlayer;
};

Game_MapRecover.prototype.recoverNum = function() {
	if($gameSystem.difficulty() === -1) {
		return 10;
	}
	return 5;
};

function Game_AttackFragment() {
	this.initialize(...arguments);
}

Game_AttackFragment.prototype = Object.create(Game_CharacterBase.prototype);
Game_AttackFragment.prototype.constructor = Game_AttackFragment;

Game_AttackFragment.prototype.initialize = function(characterName) {
	Game_CharacterBase.prototype.initialize.call(this);
	this.setImage(characterName, 0);
	this._battleObject = new Game_BattleObject();
	this._physicsFlag = 5;
	this.physics = true;
	this.elastic = 0.5;
	this.setAirFriction(0.1);
	this.setFriction(0.1);
	this._triggerRemove = 0;
};

Game_AttackFragment.prototype.battleTeam = function() {
	return -2;
};

Game_AttackFragment.prototype.battleObject = function() {
	return this._battleObject;
};

Game_AttackFragment.prototype.doPState = function() {
	if(!this.isGrounding()) {
		this.setRotation(this._vx * 0.01 + this.rotation());
	} else if(this._triggerRemove === 0) {
		this._triggerRemove = 1;
	}
	if(this._triggerRemove > 0) {
		this._triggerRemove++;
	}
	if(this._triggerRemove > 10) {
		if(this.opacity() > 0) {
			this.setOpacity(this.opacity() - 5);
		} else {
			this.requestRemove();
		}
	}
};

Game_AttackFragment.prototype.doPStateChange = function() {
};

// 橘花猫分身在一段时间后生成的血球，生成之后加速靠近boss给boss回血
function Game_BossRecover() {
	this.initialize(...arguments);
}

Game_BossRecover.prototype = Object.create(Game_MapRecover.prototype);
Game_BossRecover.prototype.constructor = Game_BossRecover;

Game_BossRecover.prototype.initialize = function() {
	Game_MapRecover.prototype.initialize.apply(this, arguments);
	this._bossId = 0;
	this.suspendGravity();
	this.suspendFriction();
	this.lockInvincible();
	this._physicsFlag = 3;
	this._initV = 6;
	this._initDelay = 90;
};

Game_BossRecover.prototype.setupBossId = function(bossId, recoverNum) {
	this._recoverNum = recoverNum;
	this._bossId = bossId;
};

Game_BossRecover.prototype.targetCharacter = function() {
	return $gameMap.event(this._bossId);
};

Game_BossRecover.prototype.doPState = function() {
	Game_MapRecover.prototype.doPState.apply(this, arguments);
	this.updatePosition();
	if(this.targetCharacter().isDeath()) {
		this.requestRemove();
		$gameTemp.requestRemoveAnimation([this], this.displayAnimationId());
	}
};

Game_BossRecover.prototype.updatePosition = function() {
	if(this._initDelay) {
		this._initDelay--;
		return;
	}
	const character = this.targetCharacter();
	const dx = character.physicsCenterX() - this.px;
	const dy = character.physicsCenterY() - this.py;
	if(dx === 0 && dy === 0) {
		this.vx = this.vy = 0;
	} else if(dx === 0) {
		this.vy = this._initV;
	} else if(dy === 0) {
		this.vx = this._initV;
	} else {
		const k = dy / dx;			// y = kx x^2 + y^2 = this._initV
		// (1+k^2)*x^2=this._initV;
		// x = 
		this.vx = Math.sqrt(this._initV*this._initV/(1+k*k));
		this.vy = Math.abs(k) * this.vx;
	}
	this.vx *= Utils.sign(dx);
    this.vy *= Utils.sign(dy);
	this._initV += 0.5;
	this._initV = Math.min(18, this._initV);
};

Game_BossRecover.prototype.recoverNum = function() {
	return this._recoverNum;
};

Game_BossRecover.prototype.recoverSeName = function() {
	return "Heal1";
};

Game_BossRecover.prototype.displayAnimationId = function() {
	return 32;
};

Game_BossRecover.prototype.recoverAnimationId = function() {
	return 33;
};

Game_BossRecover.prototype.checkPlayerHit = function() {
	if(!this._initDelay) {
		Game_MapRecover.prototype.checkPlayerHit.call(this);
	}
};

function Game_OrangeCatObsorb() {
	this.initialize(...arguments);
}

Game_OrangeCatObsorb.prototype = Object.create(Game_CharacterBase.prototype);
Game_OrangeCatObsorb.prototype.constructor = Game_OrangeCatObsorb;

Game_OrangeCatObsorb.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.apply(this, arguments);
	this.initBattleObject();
	this._physicsFlag = 3;
	this.suspendFriction();
	this.suspendGravity();
	this.physics = true;
	this._power = 1;
	this._animationCreated = false;
	this._targetCharacter = null
};

Game_OrangeCatObsorb.prototype.dragFx = function() {
	return this._power;
};

Game_OrangeCatObsorb.prototype.updateImageAnimation = function() {
	this.requestAnimation(29, {unique:true, physicsPosition:true, scale:this._power/2});
};

Game_OrangeCatObsorb.prototype.setupPosition = function(x, y, power, character) {
	this.px = x;
	this.py = y;
	this._targetCharacter = character;
	this.initPower(power);
	this.updateVertices();
};

Game_OrangeCatObsorb.prototype.initPower = function(power) {
	this._power = power;
};

Game_OrangeCatObsorb.prototype.updateVertices = function() {
	const r = 23 * this._power;
	const side = 10;
	const baseVertices = [];
	for(let i = 0; i < side; i++) {
		const angle = Math.PI * 2 * i / side;
		baseVertices.push({x:Math.round(Math.sin(angle) * r),y:Math.round(Math.cos(angle) * r)});
	}
	this.setVertices(baseVertices);
};

Game_OrangeCatObsorb.prototype.initBattleObject = function() {
	this._battleObject = new Game_BattleObject(60);
};

Game_OrangeCatObsorb.prototype.beHit = function() {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	this._power--;
	if(this._power > 2) {
		this.updateVertices();
		this.updateImageAnimation();
	} else {
		this.requestRemove();
		this.requestDeathAnimation();
		$gameTemp.requestRemoveAnimation([this], 29);
	}
};

Game_OrangeCatObsorb.prototype.battleObject = function() {
	return this._battleObject;
};

Game_OrangeCatObsorb.prototype.doPState = function() {
	this.vx = this.vy = 0;
	this.suspendGravity();
	if(!this._animationCreated) {
		this.updateImageAnimation();
		this._animationCreated = true;
	}
	if(this._targetCharacter.isDeath()) {
		this.requestRemove();
		$gameTemp.requestRemoveAnimation([this], 29);
	}
};

Game_OrangeCatObsorb.prototype.doPStateChange = function() {
};

Game_Map.prototype.pollBossScorePopUp = function() {
	if(this._bossScorePopUp) {
		this._bossScorePopUp = false;
		return true;
	}
	return false;
};

Game_Map.prototype.requestBossScorePopUp = function() {
	this._bossScorePopUp = true;
};

DataManager.addCacheBellTotalNum = function() {
	this._cacheBellTotalNum++;
};

DataManager.clearCacheBellTotalNum = function() {
	this._cacheBellTotalNum = 0;
};

DataManager.bellTotalNum = function() {
	return this._cacheBellTotalNum;
};

function Game_BerriesShieldRecover() {
	this.initialize(...arguments);
}

Game_BerriesShieldRecover.prototype = Object.create(Game_BossRecover.prototype);
Game_BerriesShieldRecover.prototype.constructor = Game_BerriesShieldRecover;

Game_BerriesShieldRecover.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.apply(this, arguments);
	this._battleObject = new Game_BattleObject(115);
	this.physics = true;
	this.setImage(this._battleObject.standingImage, 0);
	this.setVertices([{"x":13,"y":-48},{"x":35,"y":-35},{"x":48,"y":-13},{"x":48,"y":13},{"x":35,"y":35},{"x":13,"y":48},{"x":-13,"y":48},{"x":-35,"y":35},{"x":-48,"y":13},{"x":-48,"y":-13},{"x":-35,"y":-35},{"x":-13,"y":-48}]);
	this._physicsFlag = 5;
	
	this._bossId = 0;
	this.suspendGravity();
	this.suspendFriction();
	this._initV = 6;
	this._initDelay = 35;
	this._isBreak = false;
	this.setOpacity(0);
};

Game_BerriesShieldRecover.prototype.updatePosition = function() {
	if(this._isBreak) {
		Game_BossRecover.prototype.updatePosition.call(this);
	} else if(this.isStagger()) {
		this._isBreak = true;
		this.setImage(";empty_character", 0);
		this.setVertices(null);
		this.setHitRect({l:12,t:12,r:12,b:12});
		this.vx = this.vy = 0;
		this.lockInvincible();
		this._physicsFlag = 3;
		this._battleObject.team = -2;
		this.requestAnimation(70, {physicsPosition:true});
	} else {
		this.vx = this.vy = 0;
		if(this.opacity() < 255) {
			this.setOpacity(Math.min(255, this.opacity() + 10));
		}
	}
};

Game_BerriesShieldRecover.prototype.targetCharacter = function() {
	return this._bossId === 0 ? $gamePlayer : Game_BossRecover.prototype.targetCharacter.call(this);
};

Game_BerriesShieldRecover.prototype.displayAnimationId = function() {
	return this._bossId === 0 ? 23 : 68;
};

Game_BerriesShieldRecover.prototype.recoverAnimationId = function() {
	return this._bossId === 0 ? 22 : 69;
};

Game_BerriesShieldRecover.prototype.shouldUsePhysicsPostion = function() {
	return true;
};

Game_BerriesShieldRecover.prototype.updateSpecialGrounding = function() {
};
NYA.MAP.LAYER = {};

NYA.MAP.LAYER.CONST = {};
NYA.MAP.LAYER.CONST.RESOURCE_ROOT = "img/overlays/";

NYA.MAP.LAYER.Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
	NYA.MAP.LAYER.Game_Map_initialize.apply(this, arguments);
	this._layerInfo = {};
	this._scale = 1;
};

NYA.MAP.LAYER.Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function() {
	NYA.MAP.LAYER.Game_Map_setup.apply(this, arguments);
	this.setupTilemapLayers();
	this.resetScale();
};

Game_Map.prototype.resetScale = function() {
	this._scale = 1;
};

Game_Map.prototype.setScale = function(val) {
	this._scale = val;
};

Game_Map.prototype.scale = function() {
	return this._scale;
};

Game_Map.prototype.setupTilemapLayers = function() {
	this._layerInfo = {};
	if($dataMap.richMeta.layer) {
		$dataMap.richMeta.layer.forEach((layer) => {
			this.createTilemapLayer(layer);
		});
	}
};

Game_Map.prototype.createTilemapLayer = function(layer) {
	const day = Utils.tryParseInt(layer.day, 0);
	const night = Utils.tryParseInt(layer.night, 0);
	if(day && this.isNight() || night && this.isDay()) {
		return;
	}
	if(layer.res == null) { layer.res = layer.name; }
	if(layer.name == null) { layer.name = layer.res; }
	let maxFrame = Utils.tryParseInt(layer.maxFrame, 0);
	let res = layer.res;
	this._layerInfo[layer.name] = {
		name:layer.name,
		res:res,
		maxFrame:maxFrame,
		frameSpeed:Utils.tryParseInt(layer.frameSpeed, 8),
		currentFrame:0,
		z:Utils.tryParseNumber(layer.z, 0),
		scrollX:Utils.tryParseNumber(layer.scrollX, 1),
		scrollY:Utils.tryParseNumber(layer.scrollY, 1),
		offsetX:Utils.tryParseIntEx(layer.offsetX, 0),
		offsetY:Utils.tryParseIntEx(layer.offsetY, 0),
		alpha:Utils.tryParseNumber(layer.alpha, 1),
		type:layer.type || 'normal',
		blendMode:Utils.tryParseInt(layer.blendMode,PIXI.BLEND_MODES.NORMAL),
		originX:Utils.tryParseNumber(layer.originX, 0),
		originY:Utils.tryParseNumber(layer.originY, 0),
		origin:{x:Utils.tryParseIntEx(layer.initOriginX),y:Utils.tryParseIntEx(layer.initOriginY)},
		tilingIndentX:Utils.tryParseInt(layer.tilingIndentX),
		tilingIndentY:Utils.tryParseInt(layer.tilingIndentY),
		h:Utils.tryParseInt(layer.h),
		s:Utils.tryParseInt(layer.s),
		l:Utils.tryParseInt(layer.l),
		scale:Utils.tryParseNumber(layer.scale, 1),
		alphaAnimation:Utils.tryParseNumber(layer.alphaAnimation, 0),
		alphaAnimationDirection:Utils.tryParseNumber(layer.alphaAnimationDirection, 1)
	};
};

Game_Map.prototype.refreshDayNightLayers = function() {
	if($dataMap.richMeta.layer) {
		$dataMap.richMeta.layer.forEach((layer) => {
			const day = Utils.tryParseInt(layer.day, 0);
			const night = Utils.tryParseInt(layer.night, 0);
			if(day && this.isNight() || night && this.isDay()) {
				delete this._layerInfo[layer.name];
			} else if(day || night) {
				this.createTilemapLayer(layer);
			}
		});
	}
	this._refreshDayNightTerrain = true;
};

Game_Map.prototype.pollRefreshDayNight = function() {
	if(this._refreshDayNightTerrain) {
		this._refreshDayNightTerrain = false;
		return true;
	}
	return false;
};

Game_Map.prototype.layerInfo = function() {
	return this._layerInfo;
};

Game_Map.prototype.setLayerInfo = function(info) {
	this._layerInfo = info;
};

NYA.MAP.LAYER.Game_Map_update = Game_Map.prototype.update;
Game_Map.prototype.update = function() {
	NYA.MAP.LAYER.Game_Map_update.apply(this, arguments);
	this.updateTilemapLayers();
};

Game_Map.prototype.updateTilemapLayers = function() {
	let keys = Object.keys(this._layerInfo);
	const shoundFixTilingPosition = Graphics.width > this.width() * this.tileWidth();
	const fixX = (Graphics.width - this.width() * this.tileWidth()) / 2;
	for(var i = 0; i < keys.length; i++) {
		var layer = this._layerInfo[keys[i]];
		layer.x = this.displayX() * (0 - $gameMap.tileWidth()) * layer.scrollX + layer.offsetX;
		layer.y = this.displayY() * (0 - $gameMap.tileHeight()) * layer.scrollY + layer.offsetY;
		switch(layer.type) {
			case 'normal': break;
			case 'effect': layer.x += this.width() * this.tileWidth() / 2; layer.y += this.height() * this.tileHeight() / 2; break;
			case 'tiling': case 'tiling_h': case 'tiling_v': if(shoundFixTilingPosition && layer.tilingIndentX === 0) {layer.x = fixX;} layer.origin.x -= layer.originX; layer.origin.y -= layer.originY; break;
			default: break;
		}
		if(layer.maxFrame && Graphics.frameCount % layer.frameSpeed === 0) {
			layer.currentFrame++;
			if(layer.currentFrame >= layer.maxFrame) {
				layer.currentFrame = 0;
			}
		}
		if(layer.alphaAnimation) {
			const d = layer.alphaAnimationDirection;
			const t = layer.alphaAnimation;
			layer.alpha += (1/t*d);
			if(d === 1 && layer.alpha > 1) {
				layer.alpha = 1;
				layer.alphaAnimationDirection = -1;
			} else if(d === -1 && layer.alpha < 0) {
				layer.alpha = 0;
				layer.alphaAnimationDirection = 1;
			}
		}
	}
};

ImageManager.loadOverlay = function(src) {
	return ImageManager.loadBitmap(NYA.MAP.LAYER.CONST.RESOURCE_ROOT, src);
};

NYA.MAP.LAYER.Game_Map_createTilemap = Spriteset_Map.prototype.createTilemap;
Spriteset_Map.prototype.createTilemap = function() {
	NYA.MAP.LAYER.Game_Map_createTilemap.apply(this, arguments);
	this.createOverlays();
};

Spriteset_Map.prototype.createOverlays = function() {
	this._layerNames = [];
	let allLayers = $gameMap.layerInfo();
	Object.values(allLayers).forEach((layer) => {
		this.createOverlay(layer);
	});
	this.updateOverlays();
};

Spriteset_Map.prototype.createOverlay = function(layer) {
	let sprite = null;
	switch(layer.type) {
		case 'tiling': case 'tiling_h': case 'tiling_v': sprite = new TilingSprite(); break;
		case 'effect': {
			const isInPreserved = this.checkEffectInPreserve(layer.name);
			if(!isInPreserved) {
				sprite = this.createEffectLayer(layer); 
			} else {
				return null; 
			} 
			break;
		}
		default: sprite = new Sprite(); break;
	}
	sprite.name = layer.name;
	if(layer.type === "effect") {
		this._effectsContainer.addChild(sprite);
	} else {
		if(layer.h || layer.s || layer.l) {
			sprite.filters = [Utils.colorMatrixHSL(layer.h, layer.s, layer.l)];
		}
		this._tilemap.addChild(sprite);
	}
	this._layerNames.push(layer.name);
	return sprite;
};

Spriteset_Map.prototype.checkEffectInPreserve = function(name) {
	if(EffectManager.preverveAnimation) {
		for(const sprite of EffectManager.preverveAnimation) {
			if(sprite.name === name) {
				return true;
			}
		}
	}
	return false;
};

Spriteset_Map.prototype.createEffectLayer = function(layer) {
	const sprite = new Sprite_AnimationEx();
    const previous = null;
    sprite.setup([], $dataAnimations[layer.res], false, 0, previous);
    this._animationSprites.push(sprite);
	return sprite;
};

NYA.MAP.LAYER.Game_Map_updateTilemap = Spriteset_Map.prototype.updateTilemap;
Spriteset_Map.prototype.updateTilemap = function() {
	NYA.MAP.LAYER.Game_Map_updateTilemap.apply(this, arguments);
	this.updateOverlays();
	this.updateUseConsumable();
	this.updateMapScale();
	this.updateBullets();
};

Spriteset_Map.prototype.updateMapScale = function() {
	const scale = $gameMap.scale();
	this.scale.set(scale);
};

Spriteset_Map.prototype.updateUseConsumable = function() {
	this._useConsumableIcon.x = -$gameMap.displayX() * $gameMap.tileWidth() + $gamePlayer.px + ($gamePlayer._mirrorLR ? -34 : 34);
	this._useConsumableIcon.y = -$gameMap.displayY() * $gameMap.tileHeight() + $gamePlayer.py - 64;
	const actor = $gamePlayer.actor();
	if(!this._useConsumableIcon.visible && actor.isConsumableUsing()) {
		this._useConsumableIcon.refreshIdx(actor.consumableUsing());
	}
	this._useConsumableIcon.visible = actor.isConsumableUsing();
};

Spriteset_Map.prototype.updateOverlays = function() {
	let allLayers = $gameMap.layerInfo();
	Object.values(allLayers).forEach((layer) => {
		let name = layer.name;
		let sprite = this._tilemap.getChildByName(name);
		if(!sprite) {		// effect 特效在切场景时会被保留
			sprite = this.createOverlay(layer);
		}
		if(!sprite) {
			return;
		}
		if(!this.updateOverlay(sprite, layer)) {
			sprite = this.createOverlay(layer);
			this.updateOverlay(sprite, layer)
		}
	});
	this._layerNames = this._layerNames.filter((name) => {
		if(!allLayers[name]) {
			let childDeleted = this._tilemap.getChildByName(name);
			if(childDeleted) {
				this.deleteOverlay(childDeleted);
			}
			return false;
		}
		return true;
	});
};

Spriteset_Map.prototype.deleteOverlay = function(childDeleted) {
	if(childDeleted instanceof Sprite_Animation) {
		this._animationSprites.remove(childDeleted);
		this._effectsContainer.removeChild(childDeleted);
	} else {
		this._tilemap.removeChild(childDeleted);
	}
	childDeleted.destroy();
};

Spriteset_Map.prototype.updateOverlay = function(sprite, layer) {
	sprite.x = layer.x;
	sprite.y = layer.y;
	sprite.z = layer.z;
	sprite.alpha = layer.alpha;
	sprite.blendMode = layer.blendMode;
	switch(layer.type) {
		case 'tiling': case 'tiling_h': case 'tiling_v': sprite.origin.x = layer.origin.x; sprite.origin.y = layer.origin.y; break;
		case 'effect': sprite.externalTargetX = layer.x; sprite.externalTargetY = layer.y; break;
		case 'normal': sprite.scale.set(layer.scale || 1); break;
		default: break;
	}
	if((sprite.prototype === TilingSprite && layer.type !== 'tiling') || (sprite.prototype === Sprite && layer.type !== 'normal') || (sprite.prototype === Sprite_AnimationEx && layer.type !== 'effect')) {
		this.deleteOverlay(child);
		this._layerNames = this._layerNames.filter((name) => {
			return name !== sprite.name;
		});
		return false;
	}
	const res = layer.maxFrame ? layer.res + layer.currentFrame : layer.res;
	if(sprite.res != res && layer.type !== "effect") {		// 粒子特效不支持中途更换内容
		const shouldResetTiling = !sprite.res;
		sprite.res = res;
		sprite.bitmap = ImageManager.loadOverlay(res);
		if(!shouldResetTiling) {
			return true;
		}
		const indentX = layer.tilingIndentX;
		const indentY = layer.tilingIndentY;
		const mapWidth = $gameMap.width() * $gameMap.tileWidth();
		const shouldUseFixWidth = Graphics.width > mapWidth && indentX === 0;
		if(layer.type === 'tiling') {
			sprite.bitmap.addLoadListener((bitmap) => {
				const width = shouldUseFixWidth ? mapWidth : $gameMap.width() * $gameMap.tileWidth() + Math.abs(layer.offsetX) - indentX;
				sprite.move(0, 0, width, $gameMap.height() * $gameMap.tileHeight() + Math.abs(layer.offsetY) - indentY);
			});
		} else if(layer.type === 'tiling_h') {
			sprite.bitmap.addLoadListener((bitmap) => {
				const width = shouldUseFixWidth ? mapWidth : $gameMap.width() * $gameMap.tileWidth() + Math.abs(layer.offsetX) - indentX;
				sprite.move(0, 0, width, bitmap.height - indentY);
			});
		} else if(layer.type === 'tiling_v') {
		sprite.bitmap.addLoadListener((bitmap) => {
				const width = shouldUseFixWidth ? mapWidth : bitmap.width - indentX;
				sprite.move(0, 0, width, $gameMap.height() * $gameMap.tileHeight() + Math.abs(layer.offsetY) - indentY);
			});
		}
	}
	return true;
};

function Sprite_BulletGroup() {
	this.initialize(...arguments);
}

Sprite_BulletGroup.prototype = Object.create(Sprite.prototype);
Sprite_BulletGroup.prototype.constructor = Sprite_BulletGroup;

Sprite_BulletGroup.prototype.initialize = function(upper) {
	Sprite.prototype.initialize.call(this);
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this._upper = upper;
};

Sprite_BulletGroup.prototype.updateBullet = function(bullet) {
	if(!this.isInChildren(bullet)) {
		const sprite = new Sprite_Bullet();
		sprite.setup(bullet);
		this._baseSprite.addChild(sprite);
	}
};

Sprite_BulletGroup.prototype.isInChildren = function(bullet) {
	return this._baseSprite.children.some((sprite) => {
		return sprite._bullet === bullet;
	});
};

NYA.MAP.LAYER.Spriteset_Map_createLowerLayer = Spriteset_Map.prototype.createLowerLayer;
Spriteset_Map.prototype.createLowerLayer = function() {
	this._animationSprites = [];
	NYA.MAP.LAYER.Spriteset_Map_createLowerLayer.apply(this, arguments);
	this._bulletGroupLower = new Sprite_BulletGroup(false);
	this._bulletGroupLower.z = 3.5;
	this._bulletGroupUpper = new Sprite_BulletGroup(true);
	this._bulletGroupUpper.z = 6;
	this._tilemap.addChild(this._bulletGroupLower, this._bulletGroupUpper);
	this._useConsumableIcon = new Sprite_ItemIcon("consumables", 0);
	this._useConsumableIcon.z = 3;
	this._useConsumableIcon.anchor.set(0.5);
	this._useConsumableIcon.visible = false;
	this._tilemap.addChild(this._useConsumableIcon);
};

Spriteset_Map.prototype.updateBullets = function() {
	const bullets = $gameMap.bullets();
	for(const bullet of bullets) {
		if(bullet.isUpperBullet()) {
			this._bulletGroupUpper.updateBullet(bullet);
		} else {
			this._bulletGroupLower.updateBullet(bullet);
		}
	}
};

function Sprite_Bullet() {
	this.initialize(...arguments);
}

Sprite_Bullet.prototype = Object.create(Sprite.prototype);
Sprite_Bullet.prototype.constructor = Sprite_Bullet;

Sprite_Bullet.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this.anchor.x = this.anchor.y = 0.5;
	this.scale.x = Graphics.scaleX;
	this.scale.y = Graphics.scaleY;
	this._frameSpeed = 0;
	this._currentFrame = 0;
	this._maxFrameX = 0;
	this._maxFrameY = 0;
	this._nextFrameCounter = 0;
	this._frameWidth = 0;
	this._frameHeight = 0;
	this._name = "";
};

Sprite_Bullet.prototype.setup = function(bullet) {
	this._bullet = bullet;
};

Sprite_Bullet.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._bullet) {
		const bullet = this._bullet;
		this.updateDestroy(bullet);
		this.updateImage(bullet);
		this.updatePos(bullet);
		this.updateKeyFrame();
		this.updateAlpha();
		this.updateDirection();
	}
};

Sprite_Bullet.prototype.updateDirection = function() {
	this.scale.x = this._bullet.direction() * Graphics.scaleX;
};

Sprite_Bullet.prototype.updateAlpha = function() {
	this.alpha = this._bullet.fadeAlpha();
};

Sprite_Bullet.prototype.updateDestroy = function(bullet) {
	if(bullet.isDestroy()) {
		this.parent.removeChild(this);
	}
};

Sprite_Bullet.prototype.updateImage = function(bullet) {
	const name = bullet.image();
	if(this._name !== name) {
		this._name = name;
		this.bitmap = ImageManager.loadCharacter(name);
		if(name !== "") {
			const info = ImageFrame.info(name);
			const width = info.width;
			const height = info.height;
			const frameSpeed = info.frameSpeed;
			this._frameSpeed = frameSpeed;
			this._currentFrame = 0;
			this._nextFrameCounter = 0;
			this._frameWidth = this.bitmap.width / width;
			this._frameHeight = this.bitmap.height / height;
			this._maxFrameX = width;
			this._maxFrameY = height;
			this.blendMode = info.blendMode;
		}
	}
};

Sprite_Bullet.prototype.updateKeyFrame = function() {
	if(this._name !== "") {
		this.setFrame((this._currentFrame % this._maxFrameX) * this._frameWidth, Math.trunc(this._currentFrame / this._maxFrameX) * this._frameHeight, this._frameWidth, this._frameHeight);
		this._nextFrameCounter++
		if(this._nextFrameCounter >= this._frameSpeed) {
			this._currentFrame++;
			this._nextFrameCounter = 0;
			if(this._currentFrame >= this._maxFrameX * this._maxFrameY) {
				this._currentFrame = 0;
			}
		}
	}
};

Sprite_Bullet.prototype.updatePos = function(bullet) {
	this.x = bullet.screenX();
	this.y = bullet.screenY();
	this.rotation = bullet.rotation();
};

NYA.MAP.LAYER.Sprite_Character_update = Sprite_Character.prototype.update;
Sprite_Character.prototype.update = function() {
	NYA.MAP.LAYER.Sprite_Character_update.apply(this, arguments);
	this.updateInvincibleBlendColor();
};

Sprite_Character.prototype.invincibleBlendColor = function() {
	return [255,255,255,168];
};

Sprite_Character.prototype.updateInvincibleBlendColor = function() {
	if(this._character.isVisibleInvincible()) {
		this._invincibleBlendCounter++;
	} else if(this._invincibleBlendCounter > 0) {
		this._invincibleBlendCounter = 0;
		this._contentSprite.setBlendColor([0,0,0,0]);
	}
	if(this._invincibleBlendCounter) {
		if(this._invincibleBlendCounter % 2 === 0) {
			this._contentSprite.setBlendColor(this.invincibleBlendColor());
		} else {
			this._contentSprite.setBlendColor([0,0,0,0]);
		}
	}
};

NYA.MAP.LAYER.Sprite_Character_initMembers = Sprite_Character.prototype.initMembers;
Sprite_Character.prototype.initMembers = function() {
	NYA.MAP.LAYER.Sprite_Character_initMembers.apply(this, arguments);
	this._invincibleBlendCounter = 0;
};








NYA.PRELOAD = {};

DataManager._cacheMapData = {};

NYA.PRELOAD.DataManager_loadMapData = DataManager.loadMapData;
DataManager.loadMapData = function(mapId) {
	if(this._cacheMapData[mapId]) {
		$dataMap = this._cacheMapData[mapId];
	}
	else {
		NYA.PRELOAD.DataManager_loadMapData.apply(this, arguments);
	}
};

DataManager.getCachedData = function(mapId) {
	return this._cacheMapData[mapId];
};

NYA.PRELOAD.DataManager_onXhrLoad = DataManager.onXhrLoad;
DataManager.onXhrLoad = function(xhr, name, src, url) {
	NYA.PRELOAD.DataManager_onXhrLoad.apply(this, arguments);
	this.makeCache(name, src);
};

DataManager.makeCache = function(name, src) {
	if (name === "$dataMap") {
		var regexp = /Map(\d+)\.json/i;
		if(src.match(regexp)) {
			let mapId = Number.parseInt(RegExp.$1);
			this._cacheMapData[mapId] = window[name];
		}
    }
};	

NYA.PRELOAD.STATE_DEFAULT = 0;
NYA.PRELOAD.STATE_LOADING_SYSTEM_BASE = 1;
NYA.PRELOAD.STATE_LOADING_MAP_BASE = 2;
NYA.PRELOAD.STATE_LOADING_RESOURCE = 3;
NYA.PRELOAD.STATE_COMPLETE = 4;

function PreloadManager() {
    throw new Error("This is a static class");
}

PreloadManager._state = NYA.PRELOAD.STATE_DEFAULT;
PreloadManager._managedL2D = [];

PreloadManager.start = function() {
	this._state = NYA.PRELOAD.STATE_LOADING_SYSTEM_BASE;
	DataManager.loadDatabase();
};

PreloadManager.state = function() {
	return this._state;
};

PreloadManager.update = function() {
	let state = this.state();
	if(state === NYA.PRELOAD.STATE_LOADING_SYSTEM_BASE) {
		this.checkSystemBase();
	}
	else if(state === NYA.PRELOAD.STATE_LOADING_MAP_BASE) {
		this.checkMapBase();
	}
	else if(state === NYA.PRELOAD.STATE_LOADING_RESOURCE) {
		this.checkResource();
	}
};

PreloadManager.isCompleted = function() {
	return (this.state() === NYA.PRELOAD.STATE_COMPLETE);
};

PreloadManager.isStarted = function() {
	return (this.state() !== NYA.PRELOAD.STATE_DEFAULT);
};

PreloadManager.progress = function() {
	const state = this.state();
	if(state === NYA.PRELOAD.STATE_LOADING_MAP_BASE) {
		let total = 0;
		let current = 0;
		for(const mapInfo of $dataMapInfos) {
			if(mapInfo) {
				total++;
				if(DataManager._cacheMapData[mapInfo.id]) {
					current++;
				}
			}
		}
		return Utils.safeDivide(current, total) * 0.1;
	}
	else if(state === NYA.PRELOAD.STATE_LOADING_RESOURCE) {
		return Utils.safeDivide(this._totalResourceProgress - LoadingPool.allLength(), this._totalResourceProgress) * 0.9 + 0.1;
	}
	else if(state === NYA.PRELOAD.STATE_COMPLETE) {
		return 1;
	}
	// TODO 
	return 0;
};

PreloadManager.checkSystemBase = function() {
	if(DataManager.isDatabaseLoaded()) {
		DataManager._cacheMapData = {};
		this.extractMapPreloadInfo();
		this._state = NYA.PRELOAD.STATE_LOADING_MAP_BASE;
	}
};

PreloadManager.extractMapPreloadInfo = function() {
	LoadingPool.setOnstart(function(id) {DataManager.loadMapData(id);});
	LoadingPool.setWorking(function(id) {return !!DataManager._cacheMapData[id];});
	for(const mapInfo of $dataMapInfos) {
		if(mapInfo) {
			let mapId = mapInfo.id;
			LoadingPool.add(mapId);
		}
	}
};

PreloadManager.checkMapBase = function() {
	if(LoadingPool.isEmpty()) {
		this.extractResourceData();
		this._state = NYA.PRELOAD.STATE_LOADING_RESOURCE;
	}
};

DataManager.isMapDataBaseLoaded = function() {
	for(const mapInfo of $dataMapInfos) {
		if(mapInfo) {
			if(!DataManager._cacheMapData[mapInfo.id]) {
				return false
			}
		}
	}
	return true;
};

PreloadManager.extractResourceData = function() {
	this._totalResourceProgress = 0;
	this._loadedResource = {};
	LoadingPool.setOnstart((id) => { return this.startLoadResource(id); });
	LoadingPool.setWorking((id) => { return this.checkLoadResource(id); });
	this.extractMapResourceData();
	let uis = this.extractUIResourceData();
	if(Utils.isMobileDevice()) {
		uis = uis.concat(this.extractUIResourceDataForMobile());
	} else {
		uis = uis.concat(this.extractUIResourceDataForPC());
	}
	uis.forEach((ui) => {
		this.addLoadResource('img', 'ui', ui);
	});
	const pis = this.extractPictureResourceData();
	pis.forEach((pic) => {
		this.addLoadResource('img', 'pictures', pic);
	});
	const ais = this.extractArtworkResourceData();
	ais.forEach((art) => {
		if(!art.live2d) {
			this.addLoadResource('img', 'artwork', art.name);
		} else {
			this.addLoadResource('#live2d', '', art.name);
		}
	});
	const cgs = this.extractCGResourceData();
	cgs.forEach((cg) => {
		this.addLoadResource('img', 'pictures', cg);
	});
	this.extractZXCResourceData();
	for(const animation of $dataAnimations) {
		if(animation) {
			this.addLoadResource('#effect', '', animation.effectName);
		}
	}
	this.extractOtherResourceData();
};

PreloadManager.extractZXCResourceData = function() {
	for(const data of Object.values(AttackFrame.data)) {
		if(data.zxc) {
			this.addLoadResource('img', 'artwork', data.zxc);
		}
	}
};

PreloadManager.extractCGResourceData = function() {
	const res = [];
	for(const cgkey in ConfigManager._allCg) {
		ConfigManager._allCg[cgkey].forEach((cg) => { res.push(cg); });
	}
	return res;
};

PreloadManager.extractArtworkResourceData = function() {
	const res = [];
	for(const id in $dataStory) {
		for(const command of $dataStory[id]) {
			switch(command.name) {
				case "story": {
					const speaker = command.speaker;
					const live2d = command.live2d;
					const artwork = command.artwork;
					if(!live2d && artwork !== "") {
						res.push({live2d:false, name:DataManager.actorAliasName(speaker) + "/" + artwork});
					} else if(live2d) {
						res.push({live2d:true, name:DataManager.actorAliasName(speaker)});
					}
					break;
				}
				default: break;
			}
		}
	}
	return res;
};

PreloadManager.extractMapResourceData = function() {
	let mapIds = Object.keys(DataManager._cacheMapData);
	let oldDataMap = $dataMap;
	for(const mapIdStr of mapIds) {
		const mapId = parseInt(mapIdStr);
		$dataMap = DataManager._cacheMapData[mapId];
		this.initMapFlags($dataMap);
		if(mapId !== NYA.MAP.CONST.DATA_ID) {
			const tmxfile = DataManager.tmxFileName(mapId);
			this.addLoadResource('#tilemap', '', tmxfile);
		}
		if($dataMap.autoplayBgm)
		{
			this.addLoadResource('audio', 'bgm', $dataMap.bgm.name);
		}
		if($dataMap.richMeta.layer) {
			for(const layer of $dataMap.richMeta.layer) {
				if(layer.type !== "effect") {
					if(layer.maxFrame) {
						const maxFrame = Utils.tryParseInt(layer.maxFrame);
						const name = layer.res || layer.name;
						for(let i = 0; i < maxFrame; i++) {
							this.addLoadResource('img', 'overlays', name + i);
						}
					} else {
						this.addLoadResource('img', 'overlays', layer.res || layer.name);
					}
				}
			}
		}
		for(var j = 0; j < $dataMap.events.length; j++)
		{
			if($dataMap.events[j] == null) { continue; }
			for(var k = 0; k < $dataMap.events[j].pages.length; k++)
			{
				var charName = $dataMap.events[j].pages[k].image.characterName;
				const eventId = $dataMap.events[j].id;
				this.addLoadResource('img', 'characters', charName);
				for(var l = 0; l < $dataMap.events[j].pages[k].list.length; l++)
				{
					var command = $dataMap.events[j].pages[k].list[l];
					this.extractCommandResource(command, eventId);
					this.generateMapFlags($dataMap, mapId, $dataMap.events[j], j, command);
				}
			}
		}
	}
	$dataMap = oldDataMap;
	for(var i = 0; i < $dataCommonEvents.length; i++)
	{
		if($dataCommonEvents[i] == null)
		{
			continue;
		}
		for(var j = 0; j < $dataCommonEvents[i].list.length; j++)
		{
			var command = $dataCommonEvents[i].list[j];
			this.extractCommandResource(command);
		}
	}
};

PreloadManager.extractCommandResource = function(command, eventId = 0) {
	switch(command.code)
	{
		case 231: this.addLoadResource('img', 'pictures', command.parameters[1]); break;  //show picture
		case 322: this.addLoadResource('img', 'characters', command.parameters[1]); break;  //change actor image
		case 205: for(var m = 0; m < command.parameters[1].list.length; m++) { var subCommand = command.parameters[1].list[m]; 
		if(subCommand.code == 41) { this.addLoadResource('img', 'characters', subCommand.parameters[0]); }  } break;
		case 284: this.addLoadResource('img', 'parallaxes', command.parameters[0]); break;  //change parallaxes
		case 250: this.addLoadResource('audio', 'se', command.parameters[0].name); break;
		case 241: this.addLoadResource('audio', 'bgm', command.parameters[0].name); break;
		case 245: this.addLoadResource('audio', 'bgs', command.parameters[0].name); break;
		case 357: this.extractPluginResource(command, eventId); break;
		default: break;
	}				
};

PreloadManager.extractPluginResource = function(command, eventId) {
	const para = command.parameters;
	const pluginsName = para[0];
	const operationName = para[1];
	if(pluginsName === "NYA.EVENT.TRIGGER_Adapter" && operationName === "range") {
		const range = para[3];
		this.addLoadResource('audio', 'se', range.se);
	} else if(pluginsName === "NYA.Utils" && eventId && (operationName === "addItem" || operationName === "add_coin")) {
		if(para[3].antiCollection !== "true") {
			$dataMap.itempoint.push(eventId);
		}
		if(para[3].type === "bell") {
			DataManager.addCacheBellTotalNum();
		}
	} else if(pluginsName === "NYA.EVENT.AI_Adapter" && operationName === "ai" && para[3].type === "60") {
		$dataMap.itempoint.push(eventId);
	}
};

PreloadManager.initMapFlags = function(dataMap) {
	dataMap.savepoint = [];
	dataMap.transport = [];
	dataMap.itempoint = [];
	DataManager.clearCacheBellTotalNum();
};

PreloadManager.generateMapFlags = function(dataMap, mapId, dataEvent, eventId, command) {
	switch(command.code) {
		case 352: dataMap.savepoint.push([dataEvent.x, dataEvent.y]); break;
		default: break;
	}
	if(dataEvent.meta.transport) {
		dataMap.transport.push([dataEvent.x, dataEvent.y + 2]);
		dataMap.transportUnlock = true;
	}
};

PreloadManager.extractUIResourceData = function() {
	return [
		"title_select_background"
		, "title"
		, "logo"
		, "logo_english"
		, "gallery_cursor"
		, "gallery_lock"
		, "gallery_upper"
		, "achieve_cursor"
		, "achieve_item"
		, "title_move_sign"
		, "title_load_cursor_cat"
		, "button_left_selected"
		, "button_right_selected"
		, "button_inner_selected"
		, "button_left"
		, "button_right"
		, "button_inner"
		, "music_cursor"
		, "music_item"
		, "music_pause"
		, "music_play"
		, "option_background"
		, "option_cursor"
		, "option_single_selected"
		, "option_single_unselected"
		, "option_progress_cursor"
		, "option_switch_pad"
		, "option_switch_cursor"
		, "option_control_cursor"
		, "menu_background"
		, "menu_logo_fish"
		, "menu_logo_star1"
		, "menu_logo_star2"
		, "menu_logo_star3"
		, "menu_logo_star4"
		, "menu_logo_star5"
		, "menu_command_cursor_selected"
		, "menu_command_cursor_unselected"
		, "menu_system_playtime"
		, "menu_system_back"
		, "menu_system_cursor"
		, "menu_map_content"
		, "menu_map_progress"
		, "menu_map_namebox"
		, "option_move_sign"
		, "menu_item_cursor"
		, "menu_item_cat"
		, "menu_item_selected_back0"
		, "menu_item_selected_back1"
		, "menu_item_selected_back2"
		, "menu_item_selected_back3"
		, "menu_item_consumables"
		, "menu_item_weapons"
		, "menu_item_stones"
		, "menu_item_ornaments"
		, "map_player_face_back"
		, "map_player_status_back"
		, "map_coin_back"
		, "message"
		, "message_left"
		, "message_right"
		, "message_lt"
		, "message_rb"
		, "message_namebox"
		, "message_cat"
		, "choice_item"
		, "notification"
		, "map_enemy_hp_back"
		, "map_enemy_hp_roll"
		, "map_enemy_hp_progress"
		, "map_digit_recover"
		, "map_digit_player_damage"
		, "map_digit_enemy_damage"
		, "interact"
		, "interact_down"
		, "map_thumbnail"
		, "transport_title_back"
		, "transport_command_back"
		, "transport_map_back"
		, "transport_command_item_back"
		, "transport_command_lock"
		, "transport_command_cursor"
		, "map_sp_small"
		, "map_sp_small_progress"
		, "map_sp_small_letter"
		, "map_hp_small"
		, "map_hp_small_progress"
		, "map_hp_small_letter"
		, "map_hp_small_enemy"
		, "map_hp_small_enemy_progress"
		, "map_hp_small_enemy_letter"
		, "task_signature"
		, "notification_task_main"
		, "notification_task_sub"
		, "gameover_title"
		, "gameover_title_legal"
		, "gameover_select_box_back"
		, "gameover_button_selected"
		, "gameover_button_unselected"
		, "transport_tips"
		, "task_select_cursor"
		, "task_select_item"
		, "menu_map_tips"
		, "menu_map_task_select_back"
		, "menu_map_task_select_cursor"
		, "menu_skill_plus"
		, "menu_skill_button"
		, "menu_skill_arrow"
		, "menu_skill_equal"
		, "shop_background_up"
		, "shop_background_down"
		, "shop_background_middle"
		, "shop_background_rect"
		, "shop_background_up_tiling"
		, "shop_background_down_tiling"
		, "gameover_artwork1"
		, "gameover_artwork2"
		, "shop_balloon"
		, "shop_coin_back"
		, "shop_info_bar_back"
		, "shop_move_sign"
		, "shop_select_cursor"
		, "shop_select_item"
		, "guide_button_back"
		, "soft_guide_back"
		, "soft_guide_cat"
		, "hard_guide_back"
		, "hard_guide_cat"
		, "buff_status"
		, "map_boss_hp_back"
		, "map_boss_hp_roll"
		, "map_boss_hp_progress"
		, "map_boss_face_back"
		, "icons"
		, "obtain_item_artwork1"
		, "obtain_item_artwork2"
		, "obtain_item_cat"
		, "obtain_item_light"
		, "obtain_item_text_back"
		, "obtain_item_aura"
		, "obtain_item_name_pad_edge"
		, "obtain_item_name_pad_inner"
		, "buff_icons"
		, "map_moving_cursor_back"
		, "map_moving_cursor"
		, "spec_progress_back"
		, "spec_progress"
		, "spec_progress_small_back"
		, "spec_progress_small"
		, "boss_score_back"
		, "boss_score_star"
		, "menu_book_command_unselect"
		, "menu_book_command_select"
		, "menu_book_back"
		, "menu_boss_score_star"
		, "menu_boss_score_unknow"
		, "menu_map_status_progress_back"
		, "menu_map_status_progress"
		, "splash_edge_lt"
		, "splash_edge_rt"
		, "splash_edge_lb"
		, "splash_edge_rb"
		, "splash_edge_t"
		, "splash_edge_b"
		, "white_cat"
		, "cat_tail"
		, "cancel"
		, "cancel_press"
		, "screen_button_config_back"
		, "screen_button_config_tips_back"
		, "screen_button_config_selected"
		, "screen_button_config_unselected"
		, "button_cursor"
		, "autosave_cat"
		, "autosave_text"
		, "autosave_back1"
		, "autosave_back2"
		, "autosave_back3"
		, "autosave_back4"
		, "skip_story_button"
		, "skip_story_button_down"
		, "skip_story_sign"
		, "bell_back"
		, "signature_sample_back"
		, "shop_confirm_item_back"
		, "shop_confirm_icon_back"
		, "shop_confirm_select"
		, "shop_confirm_unselect"
		, "shop_confirm_add"
		, "shop_confirm_sub"
		, "collection_complete"
		, "map_player_bar_back"
		, "map_player_hp_back"
		, "map_player_hp_roll"
		, "map_player_hp_progress"
		, "map_player_sp_back"
		, "map_player_sp_progress"
		, "map_player_zp_back"
		, "map_player_zp_progress"
		, "zxc_effect1"
		, "zxc_effect2"
		, "zxc_effect3"
		, "zxc_effect4"
		, "task_guide_arrow"
		, "task_guide_pad_edge"
		, "task_guide_pad_inner"
		, "hint_artwork2"
		, "hint_artwork1"
	];
};

PreloadManager.extractUIResourceDataForMobile = function() {
	return [
		"joystick"
		, "joystick_pressed"
		, "joystick_unpressed"
		, "menu_pressed"
		, "menu_unpressed"
		, "attack"
		, "jump"
		, "bullet"
		, "zxc"
		, "subattack"
		, "screen_button_pressed"
		, "screen_button_unpressed"
		, "screen_button_pressed2"
		, "screen_button_unpressed2"
		, "screen_button_progress"
		, "screen_button_energy"
	];
};

PreloadManager.extractUIResourceDataForPC = function() {
	return [
	];
};

PreloadManager.extractPictureResourceData = function() {
	return [];
};

PreloadManager.extractOtherResourceData = function() {
	$dataActors.forEach((actor) => {
		if(actor) {
			this.addLoadResource('img', 'characters', actor.characterName);
		}
	});
	const iframe = ImageFrame.data;
	for(const name in iframe) {
		if(iframe[name].res) {
			this.addLoadResource('img', 'characters', iframe[name].res);
		} else {
			this.addLoadResource('img', 'characters', name);
		}
	}
	const consumables = Game_Consumables.prototype.data.call(this);
	for(const consumable of Object.values(consumables)) {
		this.addLoadResource('audio', 'se', consumable.se);
	}
	
	const battleObjects = Game_BattleObject.template();
	for(const battleObject of Object.values(battleObjects)) {
		if(battleObject.onHitSe) { battleObject.onHitSe.forEach((se) => { this.addLoadResource('audio', 'se', se); }); }
		this.addLoadResource('audio', 'se', battleObject.fallDownSe);
		this.addLoadResource('img', 'ui', battleObject.faceName);
		this.addLoadResource('img', 'ui', battleObject.dangerFaceName);
	}
	
	const attacks = AttackFrame.data;
	for(const attack of Object.values(attacks)) {
		this.addLoadResource('audio', 'se', attack.se);
		this.addLoadResource('audio', 'se', attack.se2);
		attack.hit.forEach((hit) => {
			this.addLoadResource('audio', 'se', hit.se);
			this.addLoadResource('audio', 'se', hit.se2);
			this.addLoadResource('audio', 'se', hit.onHit.se);
		});
	}
	
	const bullets = BulletFrame.data;
	for(const bullet of Object.values(bullets)) {
		this.addLoadResource('audio', 'se', bullet.end_se);
		for(const se of bullet.start_se) {
			this.addLoadResource('audio', 'se', bullet.se);
		}
	}
	
	this.addLoadResource('img', 'pictures', 'neko_transform');
	this.addLoadResource('img', 'pictures', 'defence_shield');
	this.addLoadResource('#live2d', '', 'title');
	this.addLoadResource('#live2d', '', 'title2');
	this.addLoadResource('img', 'characters', ';coin_silver');
	this.addLoadResource('img', 'characters', ';coin_gold');
	this.addLoadResource('img', 'characters', ';coin_copper');
	this.addLoadResource('img', 'characters', ';coin_silver_remove');
	this.addLoadResource('img', 'characters', ';coin_gold_remove');
	this.addLoadResource('img', 'characters', ';coin_copper_remove');
	this.addLoadResource('img', 'characters', ';toru_gameover1');
	this.addLoadResource('img', 'characters', ';toru_gameover2');
	this.addLoadResource('img', 'characters', ';toru_gameover3');
	this.addLoadResource('img', 'characters', ';toru_gameover4');
	this.addLoadResource('img', 'characters', ';toru_gameover5');
	this.addLoadResource('img', 'artwork', "shop_normal");
	this.addLoadResource('img', 'artwork', "shop_disable");
	this.addLoadResource('img', 'artwork', "shop_coin_not_enough");
	
	const otherSe = ['guide', 'cat3jump', 'enemy_jump1', 'enemy_jump2', 'enemy_jump3', 'zxc', 'mtv_jump1', 'mtv_jump2', 'coin', 'coin_get', 'newgame', 'terrain_boom', 'add_task', 'del_task', "Jump1"
		, "item_obtain", "mushroom", "buff_add", "player_fall", "squash", 'shield_close', 'Raise3', 'coin_pick', 'lily_bomb_boom', 'lily_zxc_shake', 'zxc_max', 'Explosion1', 'artillery_fire'
		, "broad_hit_floor", "Darkness7", "Heal1", "Recovery", "Recovery2", "gameover", "bubble_in", "stone_move", "cloud_elastic1", "cloud_elastic2", "cloud_elastic3", "text1", "text2", "throw_pie"
		, "cfish", "Thunder9", "Ice5", "Thunder11", "Paralyze1", "Thunder12", "berries_lightning_off", "rat_bite5", "Earthquake3", "Bluezone_BC0253_impact_11", "wall_bullet_division"];
	for(const se of otherSe) {
		this.addLoadResource('audio', 'se', se);
	}
	const otherBgm = ConfigManager._allBgm;
	for(const bgm of otherBgm) {
		this.addLoadResource('audio', 'bgm', bgm);
	}
	this.extractFootStepResourceData();
};

PreloadManager.extractFootStepResourceData = function() {
	const data = AudioManager.RL_DATA;
	for(const info of Object.values(data)) {
		this.addLoadResources('audio', 'se', info.sounds);
	}
};

PreloadManager.checkResource = function() {
	if(LoadingPool.isEmpty()) {
		this._state = NYA.PRELOAD.STATE_COMPLETE;
		this._managedL2D.forEach((l2d) => {
			l2d.destroy();
		});
		this._managedL2D = [];
	}
};

PreloadManager.addLoadResources = function(main, sub, srcArr) {
	for(const src of srcArr) {
		this.addLoadResource(main, sub, src);
	}
};

PreloadManager.addLoadResource = function(main, sub, src) {
	if(!src) { return; }
	let duplicateKey = main + sub + src;
	if(this._loadedResource[duplicateKey]) { return; }
	this._loadedResource[duplicateKey] = true;
	this._totalResourceProgress++;
	LoadingPool.add({main:main, sub:sub, src:src});
};

PreloadManager.startLoadResource = function(id) {
	let mainType = id.main;
	let subType = id.sub;
	let src = id.src;
	let folder = '';
	switch(mainType) {
		case 'audio': 
		folder = subType + '/';
		if(AudioManager.isPreloadType(subType, src)) {
			AudioManager.createBuffer(folder, src);
		}
		else {
			id.buffer = AudioManager.checkBuffer(folder, src);
		} break;
		case 'img' : 
		folder = 'img/' + subType + '/';
		if(ImageManager.isPreloadType(subType, src)) {
			ImageManager.loadBitmap(folder, src);
		}
		else {
			id.bitmap = ImageManager.checkBitmap(folder, src);
		} break;
		case '#live2d' : {
			const live2d = new Sprite_Live2D(src);
			this._managedL2D.push(live2d);
			break;
		}
		case '#tilemap': {
			PIXILoaderManager.load([{key:src, type:PIXI.LoaderResource.XHR_RESPONSE_TYPE.DEFAULT}], (resources) => {
				this.extractTilemapEditorImage(resources[src]);
			});
			break;
		}
		case '#effect': {
			EffectManager.load(src);
			break;
		}
		default : break;
	}
};

PreloadManager.extractTilemapEditorImage = function(resource) {
	const xmlString = resource.data;
    const pathToFile = resource.url;
    tmx.parse(xmlString, pathToFile, (error, map) => {
		if (error) throw error;
		resource.data = map;
		map.tileSets.forEach((tileSetData) => {
			this.addLoadResource('img', 'tilesets', Utils.baseName(tileSetData.image.source));
		});
		/* map.tileWidth = Game_Map.prototype.tileWidth.call(this) / Graphics.scaleX;
		map.tileHeight = Game_Map.prototype.tileHeight.call(this) / Graphics.scaleY;
		map.layers.forEach((layer) => {
			layer.offsetx *= Graphics.scaleX;
			layer.offsety *= Graphics.scaleY;
		});
		resource.data = map;
		map.tileSets.forEach((tileSetData) => {
			tileSetData.tileWidth = map.tileWidth;
			tileSetData.tileHeight = map.tileHeight;
			tileSetData.image.width *= Graphics.scaleX;
			tileSetData.image.height *= Graphics.scaleY;
			this.addLoadResource('img', 'tilesets', Utils.baseName(tileSetData.image.source));
		}); */
    });
};

PreloadManager.checkLoadResource = function(id) {
	let mainType = id.main;
	let subType = id.sub;
	let src = id.src;
	if(src === '') { return true; }
	let folder = '';
	switch(mainType) {
		case 'audio': 
		folder = subType + '/';
		if(AudioManager.isPreloadType(subType, src)) {
			let cacheId = folder + src;
			return !!AudioManager._cacheData[cacheId];
		}
		else {
			return !!id.buffer._isLoaded;
		} break;
		case 'img' : 
		folder = 'img/' + subType + '/';
		if(ImageManager.isPreloadType(subType, src)) {
			let cacheId = folder + src;
			return !!ImageManager._imageCache[cacheId] && ImageManager._imageCache[cacheId].isReady();
		}
		else {
			return id.bitmap._loadingState === 'loaded';
		} break;
		case '#live2d' :
			return PIXILoaderManager.isIdle();
		case '#tilemap':
			return PIXILoaderManager.isIdle();
		case '#effect':
			return EffectManager.isReady();
		default : break;
	}
};

AudioManager.isPreloadType = function(folder, name) {
	switch(folder) {
		case 'bgm' : return false;
		case 'bgs' : return false;
		default : return true;
	}
};

AudioManager._cacheData = {};
NYA.PRELOAD.AudioManager_createBuffer = AudioManager.createBuffer;
AudioManager.createBuffer = function(folder, name) {
	const id = folder + name;
	if(this._cacheData[id]) {
		this._cacheData[id].frameCount = Graphics.frameCount;
		return this._cacheData[id];
	}
    let buffer = NYA.PRELOAD.AudioManager_createBuffer.apply(this, arguments);
	if(folder === 'se/') {
		buffer.addLoadListener(() => {
			this._cacheData[id] = buffer;
		});
	}
	return buffer;
};

AudioManager.checkBuffer = function(folder, name) {
	const ext = this.audioFileExt();
    const url = this._path + folder + Utils.encodeURI(name) + ext;
	return new WebAudio(url, true);
};

NYA.PRELOAD.WebAudio_initialize = WebAudio.prototype.initialize;
WebAudio.prototype.initialize = function(url, preload = false, gentleLoad = false) {
	this._gentleLoad = gentleLoad;
	this._preload = preload;
	NYA.PRELOAD.WebAudio_initialize.call(this, url);
};

if(NYA.METHOD.WebAudio__startXhrLoading) { throw "method duplicate"; }
NYA.METHOD.WebAudio__startXhrLoading = WebAudio.prototype._startXhrLoading;
WebAudio.prototype._startXhrLoading = function(url) {
    const xhr = new XMLHttpRequest();
	let method = this._preload ? "HEAD" : "GET";
    xhr.open(method, url);
    xhr.responseType = "arraybuffer";
    xhr.onload = () => this._onXhrLoad(xhr);
    xhr.onerror = this._onError.bind(this);
    xhr.send();
};

if(NYA.METHOD.WebAudio__onXhrLoad) { throw "method duplicate"; }
NYA.METHOD.WebAudio__onXhrLoad = WebAudio.prototype._onXhrLoad;
WebAudio.prototype._onXhrLoad = function(xhr) {
    if (xhr.status < 400) {
		this._isLoaded = true;
		if(!this._preload) {
			this._data = new Uint8Array(xhr.response);
			this._updateBuffer();
		}
    } else {
        this._onError();
    }
};

if(NYA.METHOD.WebAudio__startFetching) { throw "method duplicate"; }
NYA.METHOD.WebAudio__startFetching = WebAudio.prototype._startFetching;
WebAudio.prototype._startFetching = function(url) {
    let options = { credentials: "same-origin" };
	if(this._preload) {
		options.method = "HEAD";
	}
    fetch(url, options)
        .then(response => this._onFetch(response))
        .catch(() => this._onError());
};

if(NYA.METHOD.WebAudio__onFetch) { throw "method duplicate"; }
NYA.METHOD.WebAudio__onFetch = WebAudio.prototype._onFetch;
WebAudio.prototype._onFetch = function(response) {
    if (response.ok) {
		if(this._preload) { this._isLoaded = true; return; }
        const reader = response.body.getReader();
        const readChunk = ({ done, value }) => {
            if (done) {
                this._isLoaded = true;
                if (this._fetchedSize > 0) {
                    this._concatenateFetchedData();
                    this._updateBuffer();
                    this._data = null;
                }
                return 0;
            } else {
                this._onFetchProcess(value);
                return reader.read().then(readChunk);
            }
        };
        reader
            .read()
            .then(readChunk)
            .catch(() => this._onError());
    } else {
        this._onError();
    }
};

NYA.PRELOAD.WebAudio__onError = WebAudio.prototype._onError;
WebAudio.prototype._onError = function() {
    NYA.PRELOAD.WebAudio__onError.apply(this, arguments);
	if(this._gentleLoad) {
		this._isError = false;
	}
};

ImageManager._imageCache = {};

ImageManager.clear = function() {
    this._cache = {};
};

if(NYA.METHOD.ImageManager_loadBitmap) { throw "method duplicate"; }
NYA.METHOD.ImageManager_loadBitmap = ImageManager.loadBitmap;
ImageManager.loadBitmap = function(folder, filename) {
    if (filename) {
		let id = folder + filename;
		if(this._imageCache[id]) {
			return this._imageCache[id];
		}
        const url = folder + Utils.encodeURI(filename) + ".png";
        let bitmap = this.loadBitmapFromUrl(url);
		this._imageCache[id] = bitmap;
		bitmap.addLoadListener(() => {
			if(folder === 'img/characters/') {
				bitmap.smooth = false;
			}
			if(folder === 'img/tilesets/') {
				bitmap.smooth = false;
			}
		});
		return bitmap;
    } else {
        return this._emptyBitmap;
    }
};

ImageManager.loadBitmapFromUrl = function(url) {
	return Bitmap.load(url);
};

ImageManager.isReady = function() {
    for (const bitmap of Object.values(this._imageCache)) {
        if (bitmap.isError()) {
			this.throwLoadError(bitmap);
		}
		if (!bitmap.isReady()) {
			return false;
		}
    }
    return true;
};

ImageManager.checkBitmap = function(folder, filename) {
	const url = folder + Utils.encodeURI(filename) + ".png";
	return Bitmap.load(url, true);
};

ImageManager.isPreloadType = function(folder, filename) {
	return true;
};

if(NYA.METHOD.Bitmap_load) { throw "method duplicate"; }
NYA.METHOD.Bitmap_load = Bitmap.load;
Bitmap.load = function(url, preload = false) {
    const bitmap = Object.create(Bitmap.prototype);
    bitmap.initialize();
    bitmap._url = url;
	bitmap._preload = preload;
    bitmap._startLoading();
    return bitmap;
};

NYA.PRELOAD.Bitmap__startLoading = Bitmap.prototype._startLoading;
Bitmap.prototype._startLoading = function() {
	if(this._preload) {
		const xhr = new XMLHttpRequest();
		let realUrl = this._url;
		if(Utils.hasEncryptedImages()) {
			realUrl = this._url + "_";
		}
		xhr.open("HEAD", realUrl);
		xhr.onload = () => this._onXhrPreLoad(xhr);
		xhr.onerror = this._onError.bind(this);
		xhr.send();
	}
	else {
		NYA.PRELOAD.Bitmap__startLoading.apply(this, arguments);
	}
};

Bitmap.prototype._onXhrPreLoad = function(xhr) {
    if (xhr.status < 400) {
        this._loadingState = "loaded";
    } else {
        this._onError();
    }
};

function LoadingPool() {
	throw new Error("This is a static class");
}

LoadingPool._workerNum = 8;
LoadingPool._worker = [];
LoadingPool._waiting = [];
LoadingPool._onstart = null;
LoadingPool._onwork = null;

LoadingPool.isEmpty = function() {
	return LoadingPool._waiting.length === 0 && LoadingPool._worker.length === 0;
};

LoadingPool.allLength = function() {
	return LoadingPool._waiting.length + LoadingPool._worker.length;
};

LoadingPool.setOnstart = function(cb) {
	this._onstart = cb;
};

LoadingPool.setWorking = function(cb) {
	this._onwork = cb;
};

LoadingPool.add = function(id) {
	if(this._worker.length < this._workerNum) {
		this._worker.push(id);
		this._onstart(id);
		return true;
	}
	this._waiting.push(id);
	return false;
};

LoadingPool.update = function() {
	if(this._worker.length > 0) {
		this._worker = this._worker.filter((id) => {
			if(this._onwork(id)) {
				return false;
			}
			return true;
		});
	}
	
	while(true) {
		let nextId = this._waiting.pop();
		if(nextId === undefined) { break; }
		if(!this.add(nextId)) { break; }
	}
};

NYA.PRELOAD.SceneManager_updateMain = SceneManager.updateMain;
SceneManager.updateMain = function() {
	NYA.PRELOAD.SceneManager_updateMain.apply(this, arguments);
	LoadingPool.update();
	PreloadManager.update();
};

AudioManager.stopSe = function() {
    for (const buffer of this._seBuffers) {
        buffer.stop();
    }
    this._seBuffers = [];
};

EffectManager.clear = function() {
};



(() => {
	if(typeof process === "object") {
		if(process.argv.includes('build') || process.argv.includes('build_web')) {
			global.NYA = global.NYA || {};
			NYA.BUILD = true;
			NYA.BUILD_WEB = process.argv.includes('build_web');
			NYA.BUILD_ARC = process.argv.includes('linux') ? "linux" : (process.argv.includes('ia32') ? "ia32" : "x64");
			global.pako = require("./../libs/pako.min.js");
			global.main = require("./../main.js");
			global.md5 = main.md5;
			global.Utils = {};
			global.Utils.encodeURI = function(str) {
				return encodeURIComponent(str).replace(/%2F/g, "/");
			}
		}
	}
})();
NYA.PACKAGE = {};

NYA.PACKAGE.MAX_FILE_SIZE = 64000000;
NYA.PACKAGE.RESOURCE_DIR = ['img/artwork', 'audio/se', 'data', 'img/characters', 'img/ui', 'img/live2d', 'img/overlays', 'img/pictures', 'img/system', 'img/tilesets'];
NYA.PACKAGE.RESOURCE_INDEX_NAME = 'resource.index';
NYA.PACKAGE.BOOT_RESOURCE_FILE = 'boot.data';
NYA.PACKAGE.BOOT_RESOURCE = ['img/system/Window.png',
		'img/ui/preload.png'
		,'img/ui/preload_bar_content.png'
		,'img/ui/preload_bar_lower.png'
		,'img/ui/preload_bar_tiling.png'
		,'img/ui/preload_cat1.png'
		,'img/ui/preload_cat2.png'
		,'img/ui/preload_cat3.png'
		,'img/ui/preload_cat4.png'
		,'img/ui/preload_ruru1.png'
		,'img/ui/preload_ruru2.png'
		,'img/ui/preload_ruru3.png'
		,'img/ui/preload_ruru4.png'
		,'img/ui/notification.png'
		,'img/ui/nya_engine_icon.png'];
NYA.PACKAGE.BOOT_INDEX_NAME = 'boot.index';
NYA.PACKAGE.BOOT_INDEX_HEADER = '#header';
NYA.PACKAGE.BOOT_INDEX_HEADER_FILE_INFO = 'fileinfo';
NYA.PACKAGE.BOOT_INDEX_CONTENT = '#content';
NYA.PACKAGE.BOOT_INDEX_HEADER_RESOURCE_INDEX_FILE_LENGTH = 'indexfilelength';

function PackageManager() {
	throw new Error("This is a static class");
}

PackageManager._bootIndex = undefined;
PackageManager._index = undefined;
PackageManager._progress = 0;
PackageManager._bootResource = undefined;
PackageManager._resource = undefined;

PackageManager.isBootIndexLoaded = function() {
	if(NYA.DEBUG) { return true; }
	return !!this._bootIndex;
};

PackageManager.isBootFileLoaded = function() {
	if(NYA.DEBUG) { return true; }
	if(!this.isBootIndexLoaded()) { return false; }
	return !!this._bootResource;
};

PackageManager.isIndexLoaded = function() {
	if(NYA.DEBUG) { return true; }
	return !!this._index;
};

PackageManager.isFileLoaded = function() {
	if(NYA.DEBUG) { return true; }
	if(!this.isIndexLoaded()) { return false; }
	if(!this.isBootIndexLoaded()) { return false; }
	let header = this._bootIndex[NYA.PACKAGE.BOOT_INDEX_HEADER];
	let resourceFileArr = Object.keys(header[NYA.PACKAGE.BOOT_INDEX_HEADER_FILE_INFO]);
	return !!this._resource && resourceFileArr.every((file) => {return !!this._resource[file]; });
};

PackageManager.isAllLoaded = function() {
	return this.isFileLoaded() && this.isBootFileLoaded();
};

PackageManager.build = function() {
	let rootPath = '';
	let readArr = NYA.PACKAGE.RESOURCE_DIR.map((f) => {return rootPath + f;});
	let info = [];
	this.buildFileLen(readArr, info);
	let fileListInfo = this.buildFileListInfo(info);
	let len = this.buildIndexFile(fileListInfo.res, NYA.PACKAGE.RESOURCE_INDEX_NAME);
	
	let header = fileListInfo.boot[NYA.PACKAGE.BOOT_INDEX_HEADER];
	header[NYA.PACKAGE.BOOT_INDEX_HEADER_RESOURCE_INDEX_FILE_LENGTH] = len;
	
	this.buildIndexFile(fileListInfo.boot, NYA.PACKAGE.BOOT_INDEX_NAME);
	if(!NYA.BUILD_WEB) {
		this.buildScriptChecker();
	}
};

PackageManager.buildScriptChecker = function() {
	const fs = require('fs');
	const dir = main.vac(NYA.BUILD_ARC);
	const checker = {};
	for(const file of dir) {
		this.buildChecker(file, checker);
	}
	const enc = new TextEncoder();
	const bin = enc.encode(JSON.stringify(checker));
	main.x(bin);
	fs.writeFileSync("leader", bin);
};

PackageManager.buildChecker = function(file, checker) {
	const fs = require('fs');
	let txt = fs.readFileSync(file, 'utf8');
	if(file === "index.html") {
		txt = txt.replace("src=\"js/main.js\">", ">nw.Window.get().evalNWBin(null, \"js/main.bin\");");
	}
	if(file === "package.json") {
		txt = txt.replace("rmmz-game", "nyaruru").replace("--force-color-profile=srgb", "--force-color-profile=srgb --enable-node-worker --ignore-gpu-blacklist --ignore-gpu-blocklist --in-process-gpu --disable-windows10-custom-titlebar --disable-direct-composition --disable-raf-throttling");
	}
	checker[file] = md5.compute(txt);
};

PackageManager.buildIndexFile = function(obj, filename) {
	let fs = require('fs');
	let enc = new TextEncoder();
	let bin = enc.encode(JSON.stringify(obj));
	let debin = pako.deflate(bin);
	main.x(debin);
	fs.writeFileSync(filename, debin);
	return debin.length;
};

PackageManager.decodeIndexFile = function(u8) {
	let de = pako.inflate(u8);
	let dec = new TextDecoder();
	let json = dec.decode(de);
	return JSON.parse(json);
};

PackageManager.buildFileLen = function(readArr, res) {
	let fs = require('fs');
	while(readArr.length > 0) {
		let folder = readArr.pop();
		let files = fs.readdirSync(folder);
		for(const file of files) {
			let filename = folder + '/' + file;
			let fileStat = fs.statSync(folder + '/' + file);
			let boot = NYA.PACKAGE.BOOT_RESOURCE.includes(filename);
			if(!fileStat.isDirectory()) {
				res.push({name:filename, size:fileStat.size, boot:boot});
			}
			else {
				this.buildFileLen([filename], res);
			}
		}
	}
};

PackageManager.buildFileListInfo = function(info) {
	let allFile = {};
	let currentFile = 0;
	let currentSize = 0;
	let fs = require('fs');
	let fd = 0;
	let bootFiles = [];
	let headerResFileObj = {};
	let currentFileName = '';
	const maxSize = NYA.PACKAGE.MAX_FILE_SIZE;
	for(const file of info) {
		if(file.boot) { 
			bootFiles.push(file);
			continue; 
		}
		let one = {};
		currentFileName = this.getResourceFileName(currentFile);
		if(fd === 0) {
			fd = fs.openSync(currentFileName, 'w');
			headerResFileObj[currentFileName] = {};
		}
		let buffer = fs.readFileSync(file.name);
		const u8 = new Uint8Array(buffer);
		main.x(u8, currentSize);
		fs.writeSync(fd, u8, 0, file.size);
		one.file = currentFile;
		one.pos = currentSize;
		one.size = file.size;
		allFile[Utils.encodeURI(file.name)] = one;
		currentSize += file.size;
		if(currentSize >= maxSize) {
			currentFile++;
			headerResFileObj[currentFileName].size = currentSize;
			currentSize = 0;
			fs.closeSync(fd);
			fd = 0;
		}
	}
	if(fd !== 0) {
		fs.closeSync(fd);
		headerResFileObj[currentFileName].size = currentSize;
	}
	let bootFileObj = {};
	
	// header
	bootFileObj[NYA.PACKAGE.BOOT_INDEX_HEADER] = {};
	let header = bootFileObj[NYA.PACKAGE.BOOT_INDEX_HEADER];
	header[NYA.PACKAGE.BOOT_INDEX_HEADER_FILE_INFO] = headerResFileObj;
	bootFileObj[NYA.PACKAGE.BOOT_INDEX_CONTENT] = {};
	let bootContent = bootFileObj[NYA.PACKAGE.BOOT_INDEX_CONTENT];
	
	fd = fs.openSync(NYA.PACKAGE.BOOT_RESOURCE_FILE, 'w');
	currentSize = 0;
	for(const bootFile of bootFiles) {
		let one = {};
		let buffer = fs.readFileSync(bootFile.name);
		const u8 = new Uint8Array(buffer);
		main.x(u8, currentSize);
		fs.writeSync(fd, u8, 0, bootFile.size);
		one.pos = currentSize;
		one.size = bootFile.size;
		bootContent[Utils.encodeURI(bootFile.name)] = one;
		currentSize += bootFile.size;
	}
	fs.closeSync(fd);
	return {res:allFile, boot:bootFileObj};
};

PackageManager.getResourceFileName = function(idx) {
	return 'file' + idx + '.data';
};

PackageManager.progress = function() {
	return this._progress;
};

PackageManager.loadResourceIndex = function() {
	this._progress = 0;
	this.loadFile(NYA.PACKAGE.RESOURCE_INDEX_NAME, function(u8) {
		PackageManager._index = PackageManager.decodeIndexFile(u8);
	}, function(loadbytes) {
		this._progress = loadbytes / PackageManager._bootIndex[NYA.PACKAGE.BOOT_INDEX_HEADER_RESOURCE_INDEX_FILE_LENGTH];
	}.bind(this));
};

PackageManager.loadResource = function() {
	this._progress = 0;
	let header = this._bootIndex[NYA.PACKAGE.BOOT_INDEX_HEADER];
	let resourceFileArr = Object.keys(header[NYA.PACKAGE.BOOT_INDEX_HEADER_FILE_INFO]);
	let resourceFileSizeArr = Object.values(header[NYA.PACKAGE.BOOT_INDEX_HEADER_FILE_INFO]);
	this._resource = {};
	let totalLength = 0;
	for(const resourceFileSize of resourceFileSizeArr) {
		totalLength += resourceFileSize.size;
	}	
	let loaded = 0;	
	for(const resourceFile of resourceFileArr) {
		this.loadFile(resourceFile, function(u8) {
			PackageManager._resource[resourceFile] = u8;
		}, function(loadbytes, length) {
			loaded += length;
			this._progress = loaded / totalLength;
		}.bind(this));
	}
};

PackageManager.loadBootResource = function() {
	this.loadFile(NYA.PACKAGE.BOOT_RESOURCE_FILE, function(u8) {
		PackageManager._bootResource = u8;
	});
};

PackageManager.getResource = function(url) {
	let res = this.getBuffer(this._bootIndex[NYA.PACKAGE.BOOT_INDEX_CONTENT], this._bootResource, url);
	if(res === null) {
		res = this.getBuffer(this._index, this._resource, url);
	}
	if(res) { return res; }
	throw('resource : ' + url + ' not find');
};

PackageManager.requestObjectURL = function(url) {
	let res = this.getBufferObjectURL(this._bootIndex[NYA.PACKAGE.BOOT_INDEX_CONTENT], this._bootResource, url);
	if(res === null) {
		res = this.getBufferObjectURL(this._index, this._resource, url);
	}
	if(res) { return res; }
	throw('resource : ' + url + ' not find');
};

PackageManager.getBuffer = function(indexSet, resourceSet, url) {
	if(indexSet) {
		let file = indexSet[url];
		if(file) {
			let realSet = resourceSet;
			if(file.file != null) {
				realSet = resourceSet[this.getResourceFileName(file.file)];
			}
			return realSet.subarray(file.pos, file.pos + file.size);
		}
	}
	return null;
};

PackageManager.getBufferObjectURL = function(indexSet, resourceSet, url) {
	if(indexSet) {
		let file = indexSet[url];
		if(file) {
			if(!file.objectURL) {
				let realSet = resourceSet;
				if(file.file != null) {
					realSet = resourceSet[this.getResourceFileName(file.file)];
				}
				let arr = realSet.subarray(file.pos, file.pos + file.size);
				file.objectURL = URL.createObjectURL(new Blob([arr]));
			}
			return file.objectURL;
		}
	}
	return null;
};

(() => {
	if(NYA.BUILD) {
		PackageManager.build();
		process.exit();
	}
})();

NYA.PACKAGE.PIXILoaderManager_realLoad = PIXILoaderManager.realLoad;
PIXILoaderManager.realLoad = function(resArr, callback) {
	if(NYA.DEBUG) {
		NYA.PACKAGE.PIXILoaderManager_realLoad.apply(this, arguments);
	}
	else {
		let resources = this.loader.resources;
		resArr.forEach((res) => {
			let ext = res.key.fileExtName();
			switch(ext) {
				case '.png': {
					resources[res.key].data = document.createElement('img');
					resources[res.key].data.src = PackageManager.requestObjectURL(res.key);
					resources[res.key].texture = PIXI.Texture.from(resources[res.key].data);
					break;
				}
				default : {
					switch(res.type) {
						case PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON: {
							let u8 = PackageManager.getResource(res.key);
							let dec = new TextDecoder();
							resources[res.key].data = JsonEx.parse(dec.decode(u8));
							break;
						}
						case PIXI.LoaderResource.XHR_RESPONSE_TYPE.DEFAULT: {
							let u8 = PackageManager.getResource(res.key);
							let dec = new TextDecoder();
							resources[res.key].data = dec.decode(u8);
							break;
						}
						default: resources[res.key].data = PackageManager.getResource(res.key);
					}
				}
			}
		});
		callback(resources);
		this.checkWorking();
	}
};

NYA.PACKAGE.WebAudio__startLoading = WebAudio.prototype._startLoading;
WebAudio.prototype._startLoading = function() {
	const url = this._realUrl();
	if(NYA.DEBUG || url.indexOf('audio/se') === -1) {
		NYA.PACKAGE.WebAudio__startLoading.apply(this, arguments);
	} else {
		if (WebAudio._context) {
			const url = this._realUrl();
			const currentTime = WebAudio._currentTime();
			this._lastUpdateTime = currentTime - 0.5;
			this._isError = false;
			this._destroyDecoder();
			if (this._shouldUseDecoder()) {
				this._createDecoder();
			}
			this._data = new Uint8Array(Utils.cloneArrayBufferFromUint8Array(PackageManager.getResource(url)));
			this._isLoaded = true;
			this._updateBuffer();
		}
	}
};

NYA.PACKAGE.Bitmap__startLoading = Bitmap.prototype._startLoading;
Bitmap.prototype._startLoading = function() {
	const regex = /^data\:image/i;
	if(!NYA.DEBUG && !this._url.match(regex)) {
		this._url = PackageManager.requestObjectURL(this._url);
	} 
	NYA.PACKAGE.Bitmap__startLoading.apply(this, arguments);
};

NYA.PACKAGE.DataManager_loadDataFile = DataManager.loadDataFile;
DataManager.loadDataFile = function(name, src) {
	if(NYA.DEBUG) {
		NYA.PACKAGE.DataManager_loadDataFile.apply(this, arguments);
	}
	else {
		let dec = new TextDecoder();
		const url = "data/" + src;
		window[name] = JSON.parse(dec.decode(PackageManager.getResource(url)));
		this.onLoad(window[name]);
		this.makeCache(name, src);
	}
};

DataManager.loadNormalFile = function(src, callback, errorCallback) {
	if(NYA.DEBUG) {
		fetch(src)
			.then((response) => {
				if(response.ok) {
					return response.arrayBuffer();
				} else if(errorCallback) {
					errorCallback();
				}
			})
			.then((buffer) => {
				callback(new Uint8Array(buffer));
			}).catch(() => {
				if(errorCallback) {
					errorCallback();
				}
			});
	} else {
		const res = PackageManager.getResource(src);
		callback(res);
	}
};

DataManager.loadNormalChunk = function(src, loadCallback, chunkCallback) {
	let size = 0;
	const fetchedData = [];
	if(Utils.isLocal()) {
		const xhr = new XMLHttpRequest();
		xhr.open("GET", src);
		xhr.responseType = "arraybuffer";
		xhr.onload = function() {
			const result = new Uint8Array(xhr.response);
			main.x(result);
			loadCallback(result);
		};
		xhr.onprogress = function(e) {
			const current = e.loaded;
			const length = current - size;
			chunkCallback(null, size, length);
			size = current;
		};
		xhr.send();
	} else {
		fetch(src).then((response) => {
			if(response.ok) {
				const reader = response.body.getReader();
				const readChunk = ({ done, value }) => {
					if (done) {
						const u8 = new Uint8Array(size);
						let currSize = 0;
						for(const chunk of fetchedData) {
							u8.set(chunk, currSize);
							currSize += chunk.length;
						}
						loadCallback(u8);
						return 0;
					} else {
						size += value.length;
						fetchedData.push(value);
						chunkCallback(value, size, value.length);
						return reader.read().then(readChunk);
					}
				};
				reader
					.read()
					.then(readChunk);
			}
		});
	}
};

PackageManager.loadFile = function(src, loadCallback, progressCallback) {
	DataManager.loadNormalChunk(src, loadCallback, function(chunk, size, length) {
		if(chunk) {
			main.x(chunk, size - length);
		}
		if(progressCallback) {
			progressCallback(size, length);
		}
	});
};

String.prototype.fileExtName = function() {
	let extDot = this.lastIndexOf('.');
	if(extDot === -1) { return ''; }
	return this.substring(extDot);
};

(() => {
	if(!NYA.DEBUG) {
		const idxName = NYA.PACKAGE.BOOT_INDEX_NAME;
		PackageManager.loadFile(idxName, function(buffer) {
			PackageManager._bootIndex = PackageManager.decodeIndexFile(buffer);
			PackageManager.loadBootResource();
		});
	}
})();
NYA.CONFIG = {};
NYA.CONFIG.CONST = {};
NYA.CONFIG.CONST.TEXT_SPEED_NORMAL = 0;
NYA.CONFIG.CONST.TEXT_SPEED_FAST = 1;
NYA.CONFIG.CONST.TEXT_SPEED_IN_TIME = 2;
NYA.CONFIG.CONST.PERFORMANCE_DISABLED = 0;
NYA.CONFIG.CONST.PERFORMANCE_FPS = 1;
NYA.CONFIG.CONST.PERFORMANCE_CPU = 2;

ConfigManager.keyMapper = {};
ConfigManager.gamepadMapper = {};
ConfigManager._tmpKeyMapper = {};
ConfigManager._tmpGamepadMapper = {};
ConfigManager.displayMode = 'window'; // or fullscreen
ConfigManager.textSpeed = NYA.CONFIG.CONST.TEXT_SPEED_NORMAL;
ConfigManager.attackBindingCancel = true;
ConfigManager.language = $dataLanguage;
ConfigManager.xAxesThreshold = 0.5;
ConfigManager.yAxesThreshold = 0.5;
ConfigManager.zxcCutsceneEnabled = true;
ConfigManager.cgUnlock = {};
ConfigManager.defaultKeyMapper = Input.keyMapper;
ConfigManager.defaultGamepadMapper = Input.gamepadMapper;
ConfigManager.defaultScreenButtons = function() {
	return [{name:"joystick",x:212,y:557,rad:400}, {name:"attack",x:NYA.SCREEN_WIDTH - 170,y:624,rad:80}, {name:"jump",x:NYA.SCREEN_WIDTH - 334,y:624,rad:80}, {name:"zxc",x:NYA.SCREEN_WIDTH - 408,y:478,rad:80}, {name:"subattack",x:NYA.SCREEN_WIDTH - 96,y:478,rad:80}, {name:"bullet",x:NYA.SCREEN_WIDTH - 252,y:428,rad:80}, {name:"consumable",x:NYA.SCREEN_WIDTH - 120,y:326,rad:52,scale:0.65}];
};
ConfigManager.screenButtons = ConfigManager.defaultScreenButtons();
ConfigManager.isFixedJoystick = true;
ConfigManager.isHintEnabled = true;
ConfigManager.performanceShowing = 0;		// 0disable 1fps 2cpu%
ConfigManager.screenWidth = NYA.SCREEN_WIDTH;
ConfigManager._allCg = {
	"1" : []
	,"2" : []
	,"3" : []
	,"4" : []
	,"5" : []
	,"6" : []
	,"7" : []
	,"8" : []
	,"9" : []
	,"10" : []
	,"11" : []
	,"12" : []
};
ConfigManager.bgmUnlock = {"main_theme":true};
ConfigManager._allBgm = [
	"main_theme", "meow_town", "black_forest", "magic_school", "boss_battle_lily", "cave"
];		// 这里要在翻译表里填对应的名字否则显示undefined
ConfigManager._bossScore = {};
ConfigManager._fullScreenExternalChangeHandler = [];
ConfigManager._previousGameover = false;
ConfigManager._storyRead = {};
ConfigManager._needNextMapSave = false;
ConfigManager._hint = {};
ConfigManager._reloadSceneReason = 0;
ConfigManager._batteryLevelChangeHandler = [];
ConfigManager._batteryChargeStatusChangeHandler = [];
ConfigManager._battery = null;

ConfigManager.ui = function() {
	return [
		{name:"STATIC_TEXT_DISPLAY_MODE", type:"single", callback:this.setDisplayMode.bind(this), externalChangeHandler:this.addFullScreenExternalChangeHandler.bind(this)
			, items:[{name:"STATIC_TEXT_DISPLAY_MODE_WINDOW",para:"window"}, {name:"STATIC_TEXT_DISPLAY_MODE_FULLSCREEN",para:"fullscreen"}], init:'displayMode', pcweb:true}
			, {name:"STATIC_TEXT_GRAPHICS_WIDTH", type:"single", callback:this.setScreenWidth.bind(this), items:[{para:1200},{para:1280},{para:1360},{para:1440},{para:1520}], init:'screenWidth', pc:true}
		, {name:"STATIC_TEXT_DISPLAY_MUSIC_VOLUME", type:"progress", callback:this.setBgmVolume.bind(this), init:this.getBgmVolume.bind(this)}
		, {name:"STATIC_TEXT_DISPLAY_SOUND_EFFECT_VOLUME", type:"progress", callback:this.setSeVolume.bind(this), init:this.getSeVolume.bind(this)}
		, {name:"STATIC_TEXT_JOYSTICK_FIXED", type:"single", callback:this.setJoystickFixed.bind(this)
			, items:[{name:"STATIC_TEXT_FIXED_MODE",para:true},{name:"STATIC_TEXT_FOLLOW_MODE",para:false}], init:'isFixedJoystick', mobile:true}
		, {name:"STATIC_TEXT_SCREEN_BUTTON_CONFIG", type:"screen_button_config", mobile:true}
		, {name:"STATIC_TEXT_TEXT_SPEED", type:"single", callback:this.setTextSpeed.bind(this)
			, items:[{name:"STATIC_TEXT_TEXT_SPEED_NORMAL",para:NYA.CONFIG.CONST.TEXT_SPEED_NORMAL},{name:"STATIC_TEXT_TEXT_SPEED_FAST",para:NYA.CONFIG.CONST.TEXT_SPEED_FAST},{name:"STATIC_TEXT_TEXT_SPEED_IN_TIME",para:NYA.CONFIG.CONST.TEXT_SPEED_IN_TIME}],init:'textSpeed'}
		, {name:"STATIC_TEXT_ATTACK_BINDING_CANCEL", type:"switch", callback:this.setAttackBindingCancel.bind(this), init:'attackBindingCancel', onText:'STATIC_TEXT_BINDING_CANCEL', offText:'STATIC_TEXT_BINDING_OK'}
		, {name:"STATIC_TEXT_CONTROL_SETTINGS", type:"key"}
		, {name:"STATIC_TEXT_JOYSTICK_X_AXES_THRESHOLD", type:"progress", callback:this.setXAxesTreshold.bind(this), init:'xAxesThreshold'}
		, {name:"STATIC_TEXT_JOYSTICK_Y_AXES_THRESHOLD", type:"progress", callback:this.setYAxesTreshold.bind(this), init:'yAxesThreshold'}
		, {name:"STATIC_TEXT_HINT_ENABLED", type:"switch", callback:this.setHintEnabled.bind(this), init:'isHintEnabled', onText:'STATIC_TEXT_ON', offText:'STATIC_TEXT_OFF'}
		, {name:"STATIC_TEXT_SHOW_SKILL_CUTSCENE", type:"switch", callback:this.setZXCCutsceneEnabled.bind(this), init:'zxcCutsceneEnabled', onText:'STATIC_TEXT_YES', offText:'STATIC_TEXT_NO'}
		, {name:"STATIC_TEXT_PERFORMANCE_STATE", type:"single", callback:this.setPerformaceShowing.bind(this)
			, items:[{name:"STATIC_TEXT_DISABLED",para:NYA.CONFIG.CONST.PERFORMANCE_DISABLED},{name:"STATIC_TEXT_SHOW_FPS",para:NYA.CONFIG.CONST.PERFORMANCE_FPS},{name:"STATIC_TEXT_SHOW_CPU",para:NYA.CONFIG.CONST.PERFORMANCE_CPU}], init:"performanceShowing"}
	];
};

ConfigManager.setSeVolume = function(val) {
	this.seVolume = Math.round(val * 100);
};

ConfigManager.setBgmVolume = function(val) {
	this.bgmVolume = Math.round(val * 100);
};

ConfigManager.getSeVolume = function() {
	return this.seVolume / 100;
};

ConfigManager.getBgmVolume = function() {
	return this.bgmVolume / 100;
};

ConfigManager.setXAxesTreshold = function(val) {
	this.xAxesThreshold = val.clamp(0.01, 0.99);
};

ConfigManager.setYAxesTreshold = function(val) {
	this.yAxesThreshold = val.clamp(0.01, 0.99);
};

ConfigManager.setZXCCutsceneEnabled = function(val) {
	this.zxcCutsceneEnabled = val;
};

ConfigManager.hackInputMapper = function() {
	Input.keyMapper = Object.assign({}, Input.defaultKeyMapper);
	Input.gamepadMapper = Object.assign({}, Input.defaultGamepadMapper);
	this.hackMapper(this.keyMapper, Input.keyMapper);
	this.hackMapper(this.gamepadMapper, Input.gamepadMapper);
};

ConfigManager.startRecordKeyConfig = function() {
	this._tmpKeyMapper = {};
	Object.assign(this._tmpKeyMapper, this.keyMapper);
	this._tmpGamepadMapper = {};
	Object.assign(this._tmpGamepadMapper, this.gamepadMapper);
};

ConfigManager.endRecordKeyConfig = function() {
	this._tmpKeyMapper = {};
	this._tmpGamepadMapper = {};
};

ConfigManager.isAnyModify = function() {
	const v1 = Object.assign({}, this.keyMapper);
	const v2 = Object.assign(v1, Input.keyMapper);
	const v3 = Object.assign({}, this.gamepadMapper);
	const v4 = Object.assign(v3, Input.gamepadMapper);
	for(const key of Object.keys(this._tmpKeyMapper)) {
		if(this._tmpKeyMapper[key] !== v2[key]) {
			return true;
		}
	}
	for(const key of Object.keys(this._tmpGamepadMapper)) {
		if(this._tmpGamepadMapper[key] !== v4[key]) {
			return true;
		}
	}
	return false;
};

ConfigManager.applyRecordKeyConfig = function() {
	this.keyMapper = {};
	Object.assign(this.keyMapper, this._tmpKeyMapper);
	this.gamepadMapper = {};
	Object.assign(this.gamepadMapper, this._tmpGamepadMapper);
	this.hackInputMapper();
};

ConfigManager.setKeyboard = function(code, name) {
	this._tmpKeyMapper[name] = code;
};

ConfigManager.checkDuplicate = function() {
	const keyMapper = {};
	for(const code in Input.keyMapper) {
		keyMapper[Input.keyMapper[code]] = parseInt(code);
	}
	for(const key in this._tmpKeyMapper) {
		const item = this._tmpKeyMapper[key];
		keyMapper[key] = item;
	}
	const keyChecker = [];
	for(const item in keyMapper) {
		const key = keyMapper[item];
		if(keyChecker.includes(key)) {
			return true;
		}
		keyChecker.push(key);
	}
	const gamepadMapper = {};
	for(const code in Input.gamepadMapper) {
		gamepadMapper[Input.gamepadMapper[code]] = parseInt(code);
	}
	for(const key in this._tmpGamepadMapper) {
		const item = this._tmpGamepadMapper[key];
		gamepadMapper[key] = item;
	}
	const gamepadChecker = [];
	for(const item in gamepadMapper) {
		const key = gamepadMapper[item];
		if(gamepadChecker.includes(key)) {
			return true;
		}
		gamepadChecker.push(key);
	}
	return false;
};

ConfigManager.setGamepad = function(code, name) {
	this._tmpGamepadMapper[name] = code;
};

ConfigManager.hackMapper = function(src, des) {
	let keys = Object.keys(src);
	for(const key of keys) {
		let code = src[key];
		for(const d_key of Object.keys(des)) {
			if(des[d_key] === key) {
				delete des[d_key];
			}
		}
		des[code] = key;
	}
};

ConfigManager.load = function() {
    StorageManager.loadObject("config")
        .then(config => this.applyData(config || {}))
        .catch(() => this.applyData({}))
        .then(() => {
            this._isLoaded = true;
            return 0;
        });
};

NYA.CONFIG.ConfigManager_makeData = ConfigManager.makeData;
ConfigManager.makeData = function() {
	const config = NYA.CONFIG.ConfigManager_makeData.apply(this, arguments);
	config.keyMapper = this.keyMapper;
	config.gamepadMapper = this.gamepadMapper;
	config.displayMode = this.displayMode;
	config.textSpeed = this.textSpeed;
	config.attackBindingCancel = this.attackBindingCancel;
	config.language = this.language;
	config.cgUnlock = this.cgUnlock;
	config.bgmUnlock = this.bgmUnlock;
	config.xAxesThreshold = this.xAxesThreshold;
	config.yAxesThreshold = this.yAxesThreshold;
	config.zxcCutsceneEnabled = this.zxcCutsceneEnabled;
	config.screenButtons = this.screenButtons;
	config.isFixedJoystick = this.isFixedJoystick;
	config.screenWidth = this.screenWidth;
	config.performanceShowing = this.performanceShowing;
	config._previousGameover = this._previousGameover;
	config._saveFromEventId = this._saveFromEventId;
	config._difficultyDownCounter = this._difficultyDownCounter;
	config._bossScore = this._bossScore;
	config._storyRead = this._storyRead;
	config._hint = this._hint;
	return config;
};

NYA.CONFIG.ConfigManager_applyData = ConfigManager.applyData;
ConfigManager.applyData = function(config) {
	NYA.CONFIG.ConfigManager_applyData.apply(this, arguments);
	document.onwebkitfullscreenchange = document.onfullscreenchange = this.onfullscreenchange.bind(this);
	this.keyMapper = config.keyMapper || this.keyMapper;
	this.gamepadMapper = config.gamepadMapper || this.gamepadMapper;
	this.hackInputMapper();
	this.applyDisplayMode(config.displayMode);
	this.textSpeed = config.textSpeed || this.textSpeed;
	this.attackBindingCancel = this.readFlag(config, 'attackBindingCancel', this.attackBindingCancel);
	if(!window.greenworks) {
		this.language = config.language || this.language;
	}
	this.applyLanguageChange();
	this.cgUnlock = config.cgUnlock || this.cgUnlock;
	this.bgmUnlock = config.bgmUnlock || this.bgmUnlock;
	this.xAxesThreshold = config.xAxesThreshold || this.xAxesThreshold;
	this.yAxesThreshold = config.yAxesThreshold || this.yAxesThreshold;
	this.zxcCutsceneEnabled = this.readFlag(config, 'zxcCutsceneEnabled', this.zxcCutsceneEnabled);
	this.screenButtons = config.screenButtons || this.screenButtons;
	this.isFixedJoystick = this.readFlag(config, 'isFixedJoystick', this.isFixedJoystick);
	this.screenWidth = config.screenWidth || this.screenWidth;
	this.setPerformaceShowing(config.performanceShowing || this.performanceShowing);
	this._previousGameover = config._previousGameover || this._previousGameover;
	this._saveFromEventId = config._saveFromEventId || this._saveFromEventId;
	this._difficultyDownCounter = config._difficultyDownCounter || this._difficultyDownCounter;
	this._bossScore = config._bossScore || this._bossScore;
	this._storyRead = config._storyRead || this._storyRead;
	this.ensureScreenButtons();
	this._hint = config._hint || this._hint;
};

ConfigManager.onfullscreenchange = function() {
	this.displayMode = Graphics._isFullScreen() ? 'fullscreen' : 'window';
	this._fullScreenExternalChangeHandler.forEach((handler) => { handler(); });
	if(Graphics._isFullScreen()) {
		Graphics.adjustScreen();
	} else {
		Graphics.adjustScreen(this.screenWidth, NYA.BASE_SCREEN_HEIGHT);
		Scene_Boot.prototype.adjustWindow.call(this);
	}
	this.reloadScreenScene(0);
};

ConfigManager.reloadScreenScene = function(reason) {
	const scene = SceneManager._scene;
	if(scene) {
		if(scene.constructor === Scene_Menu) {
			scene.removeChild(scene._backgroundFromPreviousScene);
			SceneManager.push(Scene_Popup);
		} else if(scene.constructor === Scene_Title) {
			SceneManager.push(Scene_Popup);
		} else if(scene.constructor === Scene_Map) {
			SceneManager.push(Scene_Popup);
		}
	}
	this._reloadSceneReason = reason;
};

ConfigManager.syncScreenWidth = function(reason) {
	if(!Graphics._isFullScreen() && !Utils.isMobileDevice()) {
		Graphics.adjustScreen(this.screenWidth, NYA.BASE_SCREEN_HEIGHT);
		Scene_Boot.prototype.adjustWindow.call(this);
		this.reloadScreenScene(reason);
	}
};

ConfigManager.addFullScreenExternalChangeHandler = function(handler) {
	this._fullScreenExternalChangeHandler.push(handler);
};

ConfigManager.clearExternalChangeHandler = function() {
	this._fullScreenExternalChangeHandler = [];
};

ConfigManager.setDisplayMode = function(mode) {
	if(!Utils.isMobileDevice() || typeof AndroidJsObject === "undefined") {			// 安卓APK全屏无效
		this.applyDisplayMode(mode);
	}
};

ConfigManager.applyDisplayMode = function(modeRequest) {
    const mode = modeRequest ? modeRequest : this.displayMode; 
	if(mode === 'window' && Graphics._isFullScreen()) {
		Graphics._cancelFullScreen();
	}
	else if(mode === 'fullscreen' && !Graphics._isFullScreen()) {
		Graphics._requestFullScreen();
	}
};

ConfigManager.setDisplayModeErrorHandler = function(handler) {
	this._displayModeErrorHandler = handler;
};

ConfigManager.setTextSpeed = function(speed) {
	this.textSpeed = speed;
};

ConfigManager.getTextSpeed = function() {
	return this.textSpeed;
};

ConfigManager.setAttackBindingCancel = function(val) {
	this.attackBindingCancel = val;
	DataManager.reloadLanguage();
};

ConfigManager.setLanguage = function(language) {
	this.language = language;
	this.applyLanguageChange();
};

ConfigManager.applyLanguageChange = function() {
	$dataLanguage = this.language;
	DataManager.loadLanguage();
};

ConfigManager.resetAll = function() {
	this.keyMapper = {};
	this.gamepadMapper = {};
	this._tmpKeyMapper = {};
	this._tmpGamepadMapper = {};
	this.hackInputMapper();
	this.displayMode = 'window';
	this.applyDisplayMode();
	this.attackBindingCancel = true;
	this.textSpeed = NYA.CONFIG.CONST.TEXT_SPEED_NORMAL;
	this.applyLanguageChange();
	this.xAxesThreshold = 0.5;
	this.yAxesThreshold = 0.5;
	this.zxcCutsceneEnabled = true;
	this.seVolume = 100;
	this.bgmVolume = 100;
	this.isFixedJoystick = true;
	this.screenWidth = NYA.BASE_SCREEN_WIDTH;
	this.setPerformaceShowing(NYA.CONFIG.CONST.PERFORMANCE_DISABLED);
	Input.keyMapper = this.defaultKeyMapper;
	Input.gamepadMapper = this.defaultGamepadMapper;
};

ConfigManager.unlockCG = function(name) {
	if(!this.cgUnlock[name]) {
		this.cgUnlock[name] = true;
		this.save();
	}
};

ConfigManager.isCGUnlock = function(name) {
	return !!this.cgUnlock[name];
};

ConfigManager.unlockBgm = function(name) {
	if(!this.bgmUnlock[name]) {
		this.bgmUnlock[name] = true;
		this.save();
	}
};

ConfigManager.isBgmUnlock = function(name) {
	return !!this.bgmUnlock[name];
};

NYA.CONFIG.AudioManager_playBgm = AudioManager.playBgm;
AudioManager.playBgm = function(bgm) {
	if(bgm.name) { 
		ConfigManager.unlockBgm(bgm.name);
	}
	NYA.CONFIG.AudioManager_playBgm.apply(this, arguments);
};

ConfigManager.getInputName = function(btn) {
	switch(Input.getMode()) {
		case "button": return keyCode(this.getInputNameInternal(btn, Input.keyMapper)).toUpperCase();
		case "gamepad": return this.getGamepadInputName(this.getInputNameInternal(btn, Input.gamepadMapper));
	}
};

ConfigManager.getInputNameInternal = function(btn, mapper) {
	for(const code of Object.keys(mapper)) {
		if(mapper[code] === btn) {
			return Number.parseInt(code);
		}
	}
	return 0;
};

ConfigManager.getGamepadInputName = function(code) {
	switch(code) {
		case 0 : return "A";
		case 1 : return "B";
		case 2 : return "X";
		case 3 : return "Y";
		case 4 : return "LB";
		case 5 : return "RB";
		case 6 : return "LT";
		case 7 : return "RT";
		case 8 : return "BACK";
		case 9 : return "START";
		case 12 : return "↑";
		case 13 : return "↓";
		case 14 : return "←";
		case 15 : return "→";
	}
	return 'BTN' + code;
};

ConfigManager.recordBossScore = function(battleObjectId, score) {
	if(this._bossScore[battleObjectId]) {
		if(this._bossScore[battleObjectId] < score) {
			this._bossScore[battleObjectId] = score;
			this.save();
		}
	} else {
		this._bossScore[battleObjectId] = score;
		this.save();
	}
};

ConfigManager.bossScore = function(battleObjectId) {
	return this._bossScore[battleObjectId] || 0;
};

ConfigManager.resetScreenButtons = function() {
	this.screenButtons = this.defaultScreenButtons();
};

ConfigManager.setJoystickFixed = function(val) {
	this.isFixedJoystick = val;
};

ConfigManager.recordStoryRead = function(storyId) {
	if(!this._storyRead[storyId]) {
		this.requestNextMapSave();
		this._storyRead[storyId] = true;
	}
};

ConfigManager.isStoryRead = function(storyId) {
	return !!this._storyRead[storyId];
};

ConfigManager.requestNextMapSave = function() {
	this._needNextMapSave = true;
};

ConfigManager.onMapChange = function() {
	if(this._needNextMapSave) {
		this._needNextMapSave = false;
		this.save();
	}
};

ConfigManager.ensureScreenButtons = function() {
	for(const button of this.defaultScreenButtons()) {
		const name = button.name;
		if(!this.screenButtons.some((button0) => { return button0.name === name; })) {
			this.resetScreenButtons();
			break;
		}
	}
};

ConfigManager.addHintUsage = function(battleObjectId, length) {
	if(!this._hint[battleObjectId]) {
		this._hint[battleObjectId] = 0;
	}
	const current = this._hint[battleObjectId];
	this._hint[battleObjectId] = current + 1;
	if(this._hint[battleObjectId] >= length) {
		this._hint[battleObjectId] = 0;
	}
	return current;
};

ConfigManager.setHintEnabled = function(val) {
	this.isHintEnabled = val;
};

ConfigManager.setScreenWidth = function(val) {
	this.screenWidth = val;
	this.syncScreenWidth(1);
};

ConfigManager.reloadSceneReason = function() {
	return this._reloadSceneReason;
};

ConfigManager.resetReloadSceneReason = function() {
	this._reloadSceneReason = 0;
};

ConfigManager.setPerformaceShowing = function(state) {
	this.performanceShowing = state;
	if(state === NYA.CONFIG.CONST.PERFORMANCE_DISABLED) {
		Graphics._fpsCounter.setDisable();
	} else if(state === NYA.CONFIG.CONST.PERFORMANCE_FPS) {
		Graphics._fpsCounter.setFPSEnable();
	} else if(state === NYA.CONFIG.CONST.PERFORMANCE_CPU) {
		Graphics._fpsCounter.setCPUEnable();
	}
};

ConfigManager.initBatteryStatus = function() {
	if(typeof navigator.getBattery === "function") {
		this._battery = navigator.getBattery();
		this._battery.addEventListener("levelchange", this.onBatteryLevelChange.bind(this));
		this._battery.addEventListener("chargingchange", this.onBatteryChargeStatusChange.bind(this));
	}
};

ConfigManager.onBatteryLevelChange = function() {
	this._batteryLevelChangeHandler.forEach((handler) => {
		handler(this.batteryLevel());
	});
};

ConfigManager.onBatteryChargeStatusChange = function() {
	this._batteryChargeStatusChangeHandler.forEach((handler) => {
		handler(this.isBatteryCharging());
	});
};

ConfigManager.batteryLevel = function() {
	if(this._battery !== null) {
		return this._battery.level;
	} else {
		return 0;
	}
};

ConfigManager.isBatteryCharging = function() {
	if(this._battery !== null) {
		return this._battery.charging;
	} else {
		return false;
	}
};

ConfigManager.addBatteryLevelChangeHandler = function(handler) {
	this._batteryLevelChangeHandler.addChild(handler);
};

ConfigManager.addBatteryLevelChangeHandler = function(handler) {
	this._batteryChargeStatusChangeHandler.addChild(handler);
};

ConfigManager.clearBatteryEventHandler = function() {
	this._batteryLevelChangeHandler.length = 0;
	this._batteryChargeStatusChangeHandler.length = 0;
};


NYA.EVENT = {};
NYA.EVENT.TRIGGER = {};

NYA.EVENT.TRIGGER.Game_Player_initMembers = Game_Player.prototype.initMembers;
Game_Player.prototype.initMembers = function() {
	NYA.EVENT.TRIGGER.Game_Player_initMembers.apply(this, arguments);
	this._interactSign = "";
	this._interactSignDown = "";
	this._isInteractSignClicked = false;
};

NYA.EVENT.TRIGGER.Game_Event_setupPageSettings = Game_Event.prototype.setupPageSettings;
Game_Event.prototype.setupPageSettings = function() {
	NYA.EVENT.TRIGGER.Game_Event_setupPageSettings.apply(this, arguments);
	this.triggerRange = null;
	if(this._syncEffectId) {
		$gameTemp.requestRemoveAnimation([this], this._syncEffectId);
		this._syncEffectId = 0;
		this._syncEffectScale = 1;
	}
	const page = this.page();
	if(page.list && page.list.length > 0) {
		const codes = page.list;
		this.buildEventTriggerInfo(codes);
	}
};

NYA.EVENT.TRIGGER.Game_Event_clearPageSettings = Game_Event.prototype.clearPageSettings;
Game_Event.prototype.clearPageSettings = function() {
	NYA.EVENT.TRIGGER.Game_Event_clearPageSettings.apply(this, arguments);
	this.triggerRange = null;
	this._syncEventId = 0;
	if(this._syncEffectId) {
		$gameTemp.requestRemoveAnimation([this], this._syncEffectId);
		this._syncEffectId = 0;
		this._syncEffectScale = 1;
	}
};

NYA.EVENT.TRIGGER.Game_Event_initMembers = Game_Event.prototype.initMembers;
Game_Event.prototype.initMembers = function() {
	NYA.EVENT.TRIGGER.Game_Event_initMembers.apply(this, arguments);
	this.triggerRange = null;
	this._syncEventId = 0;
	this._syncEffectId = 0;
	this._syncEffectScale = 1;
};

Game_Event.prototype.setSyncEffectScaleAdd = function(scale) {
	this._syncEffectScale += scale;
};

Game_Event.prototype.buildEventTriggerInfo = function(codes) {
	for(const data of codes) {
		if(data.code !== 357) {
			continue;
		}
		const para = data.parameters;
		if(para[0] !== "NYA.EVENT.TRIGGER_Adapter") {
			continue;
		}
		const fname = para[1];
		switch(fname) {
			case "range": {
				this.triggerRange = {l:0,t:0,r:0,b:0,tips:"",se:"",hold:0};
				const range = para[3];
				const l = Number.parseFloat(range.l);
				const t = Number.parseFloat(range.t);
				const r = Number.parseFloat(range.r);
				const b = Number.parseFloat(range.b);
				const tips = range.tips;
				const se = range.se;
				const transfer = range.transfer === "true" ? true : false;
				const dir = range.dir === "true";
				
				this.triggerRange.l = l * $gameMap.tileWidth();
				this.triggerRange.t = t * $gameMap.tileHeight();
				this.triggerRange.r = r * $gameMap.tileWidth();
				this.triggerRange.b = b * $gameMap.tileHeight();
				
				this.triggerRange.tips = tips;
				this.triggerRange.se = se;
				this.triggerRange.dir = dir;
				this.triggerRange.hold = 0;
				if(transfer) {
					if(this.x === 0) {
						this.triggerRange.hold = 3;
					} else if(this.x === $gameMap.width() - 1) {
						this.triggerRange.hold = 4;
					} else if(this.y === 0) {
						this.triggerRange.hold = 1;
					} else if(this.y === $gameMap.height() - 1) {
						this.triggerRange.hold = 2;
					}
				}
				break;
			}
			case "stroke": {
				const enable = para[3].enable === "true" ? true : false;
				this.setStrokeEffect(enable);
				break;
			}
			case "sync": {
				const syncEventId = Utils.tryParseInt(para[3].evid);
				this._syncEventId = syncEventId;
				break;
			}
			case "mirror": {
				this.setMirrorLR(true);
				break;
			}
			case "effect": {
				this._syncEffectId = Utils.tryParseInt(para[3].effectId);
				break;
			}
			default: break;
		}
	}
};

Game_Event.prototype.rangeStart = function() {
	AudioManager.playNormalSe(this.triggerRange.se);
	this.start();
	$gameSystem.setGuideCompleted("interact");
};

Game_Player.prototype.checkEventTriggerHere = function() {
};

Game_Player.prototype.checkEventTriggerThere = function() {
};

Game_Player.prototype.triggerTouchAction = function() {
};

Game_CharacterBase.prototype.checkEventTriggerTouchFront = function() {
};

Game_Event.prototype.physicsTriggerTouch = function() {
	if (!$gameMap.isEventRunning()) {
        if (this._trigger === 1) {
            this.start();
        }
    }
};

Game_CharacterBase.prototype.physicsTriggerTouch = function() {
};

Game_Player.prototype.triggerButtonAction = function() {
    return false;
};

NYA.EVENT.TRIGGER.Game_Event_update = Game_Event.prototype.update;
Game_Event.prototype.update = function() {
	NYA.EVENT.TRIGGER.Game_Event_update.apply(this, arguments);
	this.checkPlayerHitEvent(2);
	this.updateEffectSync();
};

Game_Event.prototype.updateEventSync = function() {
	if(this._syncEventId) {
		const target = $gameMap.event(this._syncEventId);
		this.px = this.rx = target.px;
		this.py = this.ry = target.py;
		this.flush();
	}
};

Game_Event.prototype.checkPlayerHitEvent = function(triggerType) {
	if (!$gameMap.isEventRunning()) {
        if(this.triggerRange && this.isPlayerHitEvent(triggerType)) {
			this.rangeStart();
		}
    }
};

// 寻找某触发方式且在范围内的事件
Game_Event.prototype.isPlayerHitEvent = function(triggerType) {
	if ((this._trigger === triggerType || triggerType === -1)) {
		if(this.triggerRange.hold === 1 && $gamePlayer.vy >= 0) {
			return false;
		}
		if(this.triggerRange.hold === 2 && $gamePlayer.vy <= 0) {
			return false;
		}
		return this.isPlayerInTriggerRect();
	}
	return false;
};

Game_Event.prototype.isPlayerInTriggerRect = function() {
	const x = $gamePlayer.px;
	const y = $gamePlayer.py;
	const triggerRange = this.triggerRange;
	return !physicsASM.isRectOutBound(this.px, this.py, this.hitOffsetL() + triggerRange.l, this.hitOffsetT() + triggerRange.t, this.hitOffsetR() + triggerRange.r, this.hitOffsetB() + triggerRange.b
		, x, y, $gamePlayer.hitOffsetL(), $gamePlayer.hitOffsetT(), $gamePlayer.hitOffsetR(), $gamePlayer.hitOffsetB());
};

NYA.EVENT.TRIGGER.Game_Map_update = Game_Map.prototype.update;
Game_Map.prototype.update = function() {
	NYA.EVENT.TRIGGER.Game_Map_update.apply(this, arguments);
	this.checkEventHitPlayer();
	$gameSwitches.update();
	this.updateEventSync();
	AudioManager.updatePlayRandLoopSe();
};

Game_Map.prototype.checkEventHitPlayer = function() {
	const obj = $gamePlayer._impact || $gamePlayer._groundHitObj;
	if(obj && !obj.terrain) {
		obj.physicsTriggerTouch();
	}
};

Utils.isPointInRect = function(x, y, rect) {
	return x < rect.r && x >= rect.l && y < rect.b && y >= rect.t;
};

Game_Event.prototype.lock = function() {
};

Game_Event.prototype.unlock = function() {
};

Game_Player.prototype.updateUpInteract = function() {
	this._isInteractSignClicked = false;
	if(!$gameMap.needSlowerTransform() && this._impact) {
		const impact = this._impact;
		if(impact.type === 3 || impact.type === 4) {
			const ev = this.findPlayerHitEvent(impact.type);
			if(ev) {
				ev.rangeStart();
				return;
			}
		}
	}
	if((!this.isGrounding() && !this._noGroundingInteract) || $gameMessage.isBusy() || $gamePlayer.isOutControl()) {
		this._interactSign = "";
		this._interactSignDown = "";
		return;
	}
	if((Input.isTriggered('up') || (TouchInput.isClicked() && this.isTouchInteract())) && this._interactSign) {
		const ev = this.findPlayerHitEvent(0) || this.findPlayerHitEvent(0, true);
		if(ev) {
			this._isInteractSignClicked = true;
			ev.rangeStart();
		}
	} else if((Input.isTriggered('down') || (TouchInput.isClicked() && this.isTouchInteractDown())) && this._interactSignDown) {
		const ev = this.findPlayerHitEvent(0, true);
		if(ev) {
			this._isInteractSignClicked = true;
			ev.rangeStart();
		}
	} else {
		this.findPlayerHitEventInteractSign();
	}
};

Game_Player.prototype.interactSignX = function() {
	return (-$gameMap.displayX() * $gameMap.tileWidth() + this.px) * $gameMap.scale();
};

Game_Player.prototype.interactSignY = function() {
	return (-$gameMap.displayY() * $gameMap.tileHeight() + this.py - 155) * $gameMap.scale();
};

Game_Player.prototype.interactSignDownX = function() {
	return this.interactSignX();
};

Game_Player.prototype.interactSignDownY = function() {
	return this.interactSignY() + 40;
};

Game_Player.prototype.isInteractSignClicked = function() {
	return this._isInteractSignClicked;
};

Game_Player.prototype.isTouchInteract = function() {
	return this._interactSignDown === "" ? this.isTouchInteractDown() : this.isTouchInteractInternal(this.interactSignX(), this.interactSignY(), 30, 0);
};

Game_Player.prototype.isTouchInteractInternal = function(tx, ty, ot = 0, ob = 0) {
	const sx = TouchInput.x;
	const sy = TouchInput.y;
	const lr = 60;
	const t = 40 + ot;
	const b = 0 + ob;
	return sx <= tx + lr && sx >= tx - lr && sy <= ty + b && sy >= ty - t;
};

Game_Player.prototype.isTouchInteractDown = function() {
	return this.isTouchInteractInternal(this.interactSignDownX(), this.interactSignDownY(), 0, 30);
};

Game_Player.prototype.findPlayerHitEventInteractSign = function() {
	const ev = this.findPlayerHitEvent(0);
	if(ev) {
		this._interactSign = ev.triggerRange.tips;
	} else {
		this._interactSign = "";
	}
	const evdown = this.findPlayerHitEvent(0, true);
	if(evdown) {
		this._interactSignDown = evdown.triggerRange.tips;
	} else {
		this._interactSignDown = "";
	}
	// 优先让玩家使用上来互动
	if(this._interactSign === "" && this._interactSignDown !== "") {
		this._interactSign = this._interactSignDown;
		this._interactSignDown = "";
	}
};

// 寻找【按确定键】可触发的事件
// hold：限定接触地图边界的触发事件
// down：限定事件的交互键类型是否为按下触发的事件
Game_Player.prototype.findPlayerHitEvent = function(hold = 0, down = false) {
	let minDistance = 2100000000;
	let ev = null;
	for(const event of $gameMap.events()) {
		if(event.triggerRange && !!event.triggerRange.dir === down && event.isPlayerHitEvent(0)) {
			const eventHoldType = event.triggerRange.hold || 0;
			if(event.triggerRange.tips && eventHoldType === hold) {
				const distance = $gameMap.distancePixel(this, event);
				if(distance < minDistance) {
					minDistance = distance;
					ev = event;
				}
			}
		}
	}
	return ev;
};

Game_Map.prototype.distancePixel = function(a, b) {
	const px1 = a.px;
	const px2 = b.px;
	const py1 = a.py;
	const py2 = b.py;
	return Math.sqrt(Math.pow(Math.abs(px1 - px2), 2) + Math.pow(Math.abs(py1 - py2), 2));
};

NYA.EVENT.TRIGGER.Game_Player_update = Game_Player.prototype.update;
Game_Player.prototype.update = function(active) {
	NYA.EVENT.TRIGGER.Game_Player_update.apply(this, arguments);
	if(active) {
		this.updateUpInteract();
	}
};

Game_Player.prototype.interactSign = function() {
	return this._interactSign;
};

Game_Player.prototype.interactSignDown = function() {
	return this._interactSignDown;
};

Game_Interpreter.prototype.event = function() {
	return $gameMap.event(this._eventId);
};

NYA.EVENT.TRIGGER.Game_Interpreter_updateWaitMode = Game_Interpreter.prototype.updateWaitMode;
Game_Interpreter.prototype.updateWaitMode = function() {
	let character = null;
    let waiting = false;
    switch (this._waitMode) {
        case "message":
            waiting = $gameMessage.isBusy();
            break;
        case "transfer":
            waiting = $gamePlayer.isTransferring();
            break;
        case "scroll":
            waiting = $gameMap.isScrolling();
            break;
        case "route":
            character = this.character(this._characterId);
            waiting = character && character.isMoveRouteForcing();
            break;
        case "animation":
            character = this.character(this._characterId);
            waiting = character && character.isAnimationPlaying();
            break;
        case "balloon":
            character = this.character(this._characterId);
            waiting = character && character.isBalloonPlaying();
            break;
        case "gather":
            waiting = $gamePlayer.areFollowersGathering();
            break;
        case "action":
            waiting = BattleManager.isActionForced();
            break;
        case "video":
            waiting = Video.isPlaying();
            break;
        case "image":
            waiting = !ImageManager.isReady();
            break;
		case "ai_command":
            waiting = !$gameMap.allEventCommandComplete();
            break;
		case "lily_specMove":
            waiting = !$gameLily.isSpecMoveCommandComplete();
            break;
    }
    if (!waiting) {
        this._waitMode = "";
    }
    return waiting;
};

Game_Switches.prototype.update = function() {
	this._recovers = this._recovers.filter((recover) => {
		if(recover.time > 0) {
			recover.time--;
			return true;
		} else {
			this.setValue(recover.id, false);
			return false;
		}
	});
};

NYA.EVENT.TRIGGER.Game_Switches_clear = Game_Switches.prototype.clear;
Game_Switches.prototype.clear = function() {
    NYA.EVENT.TRIGGER.Game_Switches_clear.apply(this, arguments);
	this._recovers = [];
};

Game_Switches.prototype.setAutoRecover = function(id, time) {
	this._recovers = this._recovers.filter((recover) => {
		return recover.id !== id;
	});
	this._recovers.push({id:id,time:time});
};

Game_Event.prototype.isErased = function() {
	return this._erased;
};

Game_Map.prototype.updateEventSync = function() {
	for(const ev of this.events()) {
		ev.updateEventSync();
	}
};

Game_Map.prototype.needSlowerTransform = function() {
	return false;
};

Game_Event.prototype.updateEffectSync = function() {
	if(this._syncEffectId) {
		this.requestAnimation(this._syncEffectId, {unique:true, physicsPostion:true, z:this.screenZ(), scale:this._syncEffectScale});
	}
};

NYA.UI = {};

ImageManager.loadUI = function(filename) {
	return this.loadBitmap('img/ui/', filename);
};

Sprite.prototype.isBeingTouched = function(smooth = true) {
	if(!this.worldVisible) {
		return false;
	}
    const touchPos = new Point(TouchInput.x, TouchInput.y);
    const localPos = this.worldTransform.applyInverse(touchPos);
    return this.hitTest(localPos.x, localPos.y, smooth);
};

Sprite.prototype.isChildrenBeingTouched = function(smooth = true) {
	return this.children.some((sprite) => {
		return sprite.isBeingTouched(smooth);
	});
};

Sprite.prototype.hitTest = function(x, y, needSmooth = true) {
	const smooth = needSmooth ? Utils.touchUISmooth() : 0;
    const rect = new Rectangle(
        -this.anchor.x * this.hitTestWidth() - smooth,
        -this.anchor.y * this.hitTestHeight() - smooth,
        this.hitTestWidth() + smooth,
        this.hitTestHeight() + smooth
    );
    return rect.contains(x, y);
};

Sprite.prototype.hitTestWidth = function() {
	return this.width;
};

Sprite.prototype.hitTestHeight = function() {
	return this.height;
};

TilingSprite.prototype.isBeingTouched = function() {
    const touchPos = new Point(TouchInput.x, TouchInput.y);
    const localPos = this.worldTransform.applyInverse(touchPos);
    return this.hitTest(localPos.x, localPos.y);
};

TilingSprite.prototype.hitTest = function(x, y) {
	const smooth = Utils.touchUISmooth();
    const rect = new Rectangle(
        -this.anchor.x * this.width - smooth,
        -this.anchor.y * this.height - smooth,
        this.width + smooth,
        this.height + smooth
    );
    return rect.contains(x, y);
};

function Sprite_Progress() {
	this.initialize(...arguments);
}

Sprite_Progress.prototype = Object.create(Sprite.prototype);
Sprite_Progress.prototype.constructor = Sprite_Progress;

Sprite_Progress.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this.progress = 0;
	this._drawingProgress = null;
	this._tilingSpeed = options.tilingSpeed;
	this.createAllSprites(options.lowerNames, options.upperNames, options.progressName, options.tilingName);
	this.createMask();
};

Sprite_Progress.prototype.createAllSprites = function(lowerNames, upperNames, progressName, tilingName) {
	let maxWidth = 0;
	let maxHeight = 0;
	lowerNames.forEach((name) => {
		const bitmap = ImageManager.loadUI(name);
		maxWidth = Math.max(bitmap.width, maxWidth);
		maxHeight = Math.max(bitmap.height, maxHeight);
		this.addChild(new Sprite(bitmap));
	});
	
	const progressBitmap = ImageManager.loadUI(progressName);
	this.progressSprite = new Sprite();
	this._progressContentSprite = new Sprite(progressBitmap);
	this.progressSprite.addChild(this._progressContentSprite);
	if(tilingName) {
		const tilingBitmap = ImageManager.loadUI(tilingName);
		this.tilingProgressSprite = new TilingSprite(tilingBitmap);
		this.progressSprite.addChild(this.tilingProgressSprite);
		this.tilingProgressSprite.move(0, 0, this.progressWidth(), this.progressHeight());
	}
	this.addChild(this.progressSprite);
	
	upperNames.forEach((name) => {
		const bitmap = ImageManager.loadUI(name);
		maxWidth = Math.max(bitmap.width, maxWidth);
		maxHeight = Math.max(bitmap.height, maxHeight);
		this.addChild(new Sprite(bitmap));
	});
	
	this.progressSprite.x = (maxWidth - this.progressWidth()) / 2;
	this.progressSprite.y = (maxHeight - this.progressHeight()) / 2;
};

Sprite_Progress.prototype.progressWidth = function() {
	return this._progressContentSprite.width;
};

Sprite_Progress.prototype.progressHeight = function() {
	return this._progressContentSprite.height;
};

Sprite_Progress.prototype.isBeingTouched = function() {
	return this._progressContentSprite.isBeingTouched();
};

Sprite_Progress.prototype.createMask = function() {
	const texture = PIXI.RenderTexture.create(this.progressWidth(), this.progressHeight());
	this.progressMask = new PIXI.Sprite(texture);
	this.progressSprite.mask = this.progressMask;
	this.progressSprite.addChild(this.progressMask);
	
	const sp = new Sprite(this._progressContentSprite.bitmap);
    const shader = Utils.colorMaskShader(255, 0, 0);
	sp.filters = [shader];
	Graphics.app.renderer.render(sp, texture);
	
	if(this.tilingProgressSprite) {
		this.tilingProgressSprite.mask = new PIXI.Sprite(texture);
		this.progressSprite.addChild(this.tilingProgressSprite.mask);
	}
	
	this.updateMask();
};

Sprite_Progress.prototype.updateMask = function() {
	if(this._drawingProgress !== this.progress) {
		this._drawingProgress = this.progress;
		const progress = this.progress;
		const mask = this.progressMask;
		mask.x = Math.trunc(-this.progressWidth() * (1 - progress)) - 1;
	}
};

Sprite_Progress.prototype.updateTiling = function() {
	if(this.tilingProgressSprite) {
		const tiling = this.tilingProgressSprite;
		tiling.origin.x += this._tilingSpeed;
	}
};

Sprite_Progress.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateTiling();
	this.updateMask();
};

function Sprite_SelectGroup() {
	this.initialize(...arguments);
}

Sprite_SelectGroup.prototype = Object.create(Sprite.prototype);
Sprite_SelectGroup.prototype.constructor = Sprite_SelectGroup;

// commandObjs: {name:{x,y,selected}, ...}
Sprite_SelectGroup.prototype.initialize = function(lowerNames, upperNames, commandObjs) {
	Sprite.prototype.initialize.call(this);
	this._command = commandObjs;
	this._commandSprite = {};
	this._selected = '';
	this._selectType = 'h';
	this._updated = false;
	this._active = false;
	this.createAllSprites(lowerNames, upperNames, commandObjs);
	this.updateSelect();
};

Sprite_SelectGroup.prototype.setSelectedFont = function(bitmap) {
	bitmap.fontSize = 32;
	bitmap.textColor = "#ff9bb7";
	bitmap.outlineWidth = 3;
	bitmap.outlineColor = "#ffffff";
	bitmap.context.shadowBlur = 24;
	bitmap.context.shadowOffsetX = 0;
	bitmap.context.shadowOffsetY = 0;
	bitmap.context.shadowColor = '#ff9bb7';
};

Sprite_SelectGroup.prototype.setUnselectFont = function(bitmap) {
	bitmap.fontSize = 24;
	bitmap.textColor = "#ffffff";
	bitmap.outlineWidth = 0;
};

Sprite_SelectGroup.prototype.createAllSprites = function(lowerNames, upperNames, commandObjs) {
	lowerNames.forEach((name) => {
		const bitmap = ImageManager.loadUI(name);
		const lowerSprite = new Sprite(bitmap);
		lowerSprite.anchor.x = 0.5;
		lowerSprite.x = Graphics.width / 2;
		this.addChild(lowerSprite);
	});
	const bitmap = new Bitmap(1, 1);
	this.setSelectedFont(bitmap);
	let allWidth = 0;
	for(const command of Object.keys(commandObjs)) {
		const width = bitmap.measureTextWidth(TextManager[command]);
		allWidth += width;
		const bitmapText = new Bitmap(width + 54, 80);
		this.setSelectedFont(bitmapText);
		bitmapText.drawCenterText(TextManager[command]);
		const bitmapUnselectText = new Bitmap(bitmapText.width, bitmapText.height);
		this.setUnselectFont(bitmapUnselectText);
		bitmapUnselectText.drawCenterText(TextManager[command]);
		
		this._commandSprite[command] = {};
		const commandSprite = this._commandSprite[command];
		
		commandSprite.unselected = new Sprite(bitmapUnselectText);
		commandSprite.unselected.anchor.set(0.5);
		commandSprite.unselected.y = commandObjs[command].y;
		commandSprite.selected = new Sprite(bitmapText);
		commandSprite.selected.anchor.set(0.5);
		commandSprite.selected.y = commandObjs[command].y;
		this.addChild(commandSprite.unselected, commandSprite.selected);
	}
	bitmap.destroy();
	const margin = (Graphics.width - allWidth) / (Object.keys(commandObjs).length + 1);
	let currentX = margin;
	for(const command of Object.keys(commandObjs)) {
		currentX += (this._commandSprite[command].selected.width / 2 - 27);
		this._commandSprite[command].selected.x = this._commandSprite[command].unselected.x = currentX;
		currentX += (this._commandSprite[command].selected.width / 2 - 27);
		currentX += margin;
	}
	
	upperNames.forEach((name) => {
		const bitmap = ImageManager.loadUI(name);
		this.addChild(new Sprite(bitmap));
	});
};

Sprite_SelectGroup.prototype.onLanguageChange = function() {
	const commandObjs = this._command;
	let allWidth = 0;
	for(const command of Object.keys(commandObjs)) {
		const commandSprite = this._commandSprite[command];
		const width = commandSprite.selected.bitmap.measureTextWidth(TextManager[command]);
		allWidth += width;
		commandSprite.selected.bitmap.resize(width + 54, 80);
		commandSprite.unselected.bitmap.resize(width + 54, 80);
		commandSprite.selected.bitmap.drawCenterText(TextManager[command]);
		commandSprite.unselected.bitmap.drawCenterText(TextManager[command]);
	}
	const margin = (Graphics.width - allWidth) / (Object.keys(commandObjs).length + 1);
	let currentX = margin;
	for(const command of Object.keys(commandObjs)) {
		currentX += (this._commandSprite[command].selected.width / 2 - 27);
		this._commandSprite[command].selected.x = this._commandSprite[command].unselected.x = currentX;
		currentX += (this._commandSprite[command].selected.width / 2 - 27);
		currentX += margin;
	}
};

Sprite_SelectGroup.prototype.updateSelect = function() {
	if(this._updated) {
		return;
	}
	this._updated = true;
	for(const command of Object.keys(this._command)) {
		const commandSprite = this._commandSprite[command];
		if(this._selected === command) {
			commandSprite.unselected.visible = false;
			commandSprite.selected.visible = true;
		} 
		else {
			commandSprite.selected.visible = false;
			commandSprite.unselected.visible = true;
		}
	}
};

Sprite_SelectGroup.prototype.select = function(name) {
	this._selected = name;
	this._updated = false;
};

Sprite_SelectGroup.prototype.selected = function() {
	return this._selected;
};

Sprite_SelectGroup.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active) {
		this.updateInput();
		this.updateTouchInput();
		this.updateSelect();
	}
};

Sprite_SelectGroup.prototype.active = function() {
	this._active = true;
};

Sprite_SelectGroup.prototype.deactive = function() {
	this._active = false;
};

// 'v' or 'h'
Sprite_SelectGroup.prototype.setSelectType = function(type) {
	this._selectType = type;
};

Sprite_SelectGroup.prototype.updateInput = function() {
	if(Input.isUITriggered('ok') && this._command[this._selected] && this._command[this._selected].pressed) {
		SoundManager.playOk();
		this._command[this._selected].pressed();
		return;
	}
	switch(this._selectType) {
		case 'v': this.updateInputInternal(Input.isUITriggered('up'), Input.isUITriggered('down')); break;
		default : this.updateInputInternal(Input.isUITriggered('left'), Input.isUITriggered('right')); break;
	}
};

Sprite_SelectGroup.prototype.updateTouchInput = function() {
	if(TouchInput.isInteract()) {
		for(const command of Object.keys(this._command)) {
			const commandSprite = this._commandSprite[command];
			if(commandSprite.selected.isBeingTouched() || commandSprite.unselected.isBeingTouched()) {
				if(this._selected !== command) {
					this._selected = command;
					this._updated = false;
				}
				if(TouchInput.isReleased()) {
					SoundManager.playOk();
					this._command[command].pressed();
				}
				break;
			}
		}
	}
};

Sprite_SelectGroup.prototype.updateInputInternal = function(l, r) {
	let d = 0;
	d = l ? -1 : d;
	d = r ? 1 : d;
	if(d !== 0) {
		SoundManager.playCursor();
		let idx = 0;
		const keys = Object.keys(this._command);
		for(const command of keys) {
			if(command === this._selected) {
				break;
			}
			idx++;
		}
		if(idx === keys.length) {
			idx = -1;
		}
		let idx2 = idx + d;
		if(idx2 >= keys.length) {
			idx2 = 0;
		}
		if(idx2 < 0) {
			idx2 = keys.length - 1;
		}
		if(idx !== idx2) {
			this._selected = keys[idx2];
			this._updated = false;
		}
	}
};


Utils.colorMaskShader = function(r, g, b) {
	const sr = r / 255;
	const sg = g / 255;
	const sb = b / 255;
	const vsrc = new String("attribute vec2 aVertexPosition;"
	+ "attribute vec2 aTextureCoord;"
	+ "uniform mat3 projectionMatrix;"
	+ "varying vec2 vTextureCoord;"
	+ "void main(void){"
	+ "gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);"
	+ "vTextureCoord = aTextureCoord;}");
    const fsrc = new String("varying vec2 vTextureCoord;"
	+ "uniform sampler2D uSampler;"
	+ "uniform float sr;"
	+ "uniform float sg;"
	+ "uniform float sb;"
	+ "void main(void){"
	+ "vec4 c = texture2D(uSampler, vTextureCoord);"
	+ "c.r = c.a * sr;c.g = c.a * sg;c.b = c.a * sb;gl_FragColor = c;}");
    const shader = new PIXI.Filter(vsrc.toString(), fsrc.toString(), {sr:sr,sg:sg,sb:sb});
	return shader;
};

Utils.colorMaskShaderReverse = function(r, g, b) {
	const sr = r / 255;
	const sg = g / 255;
	const sb = b / 255;
	const vsrc = new String("attribute vec2 aVertexPosition;"
	+ "attribute vec2 aTextureCoord;"
	+ "uniform mat3 projectionMatrix;"
	+ "varying vec2 vTextureCoord;"
	+ "void main(void){"
	+ "gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);"
	+ "vTextureCoord = aTextureCoord;}");
    const fsrc = new String("varying vec2 vTextureCoord;"
	+ "uniform sampler2D uSampler;"
	+ "uniform float sr;"
	+ "uniform float sg;"
	+ "uniform float sb;"
	+ "void main(void){"
	+ "vec4 c = texture2D(uSampler, vTextureCoord);"
	+ "if(c.a <= 0.5) { c.a = 1.0; c.r = sr; c.g = sg;c.b = sb;} else { c.a = 1.0; c.r = 0.0; c.g = 0.0; c.b = 0.0; } gl_FragColor = c;}");
    const shader = new PIXI.Filter(vsrc.toString(), fsrc.toString(), {sr:sr,sg:sg,sb:sb});
	return shader;
};

function AnimationController() {
	this.initialize(...arguments);
}

(() => {
	AnimationController.easeOutQuart = EasingFunction(0.165, 0.84, 0.44, 1);
	AnimationController.easeInQuart = EasingFunction(0.895, 0.03, 0.685, 0.22);
	AnimationController.easeOutExpo = EasingFunction(0.19, 1, 0.22, 1);
	AnimationController.easeInExpo = EasingFunction(0.95, 0.05, 0.795, 0.035);
	AnimationController.easeOutQuad = EasingFunction(0.25, 0.46, 0.45, 0.94);
	AnimationController.easeInQuad = EasingFunction(0.6, -0.28, 0.735, 0.045);
	AnimationController.easeInBack = EasingFunction(0.55, 0.085, 0.68, 0.53);
	AnimationController.easeOutBack = EasingFunction(0.175, 0.885, 0.32, 1.275);
	AnimationController.easeOutBackCat = EasingFunction(0.36, 1.25, 1, 1.78);
	AnimationController.easeOutCubic = EasingFunction(0.33, 1, 0.68, 1);
	AnimationController.linear = function(val) { return val; };
})();

AnimationController.prototype.initialize = function() {
	this._sprite = [];
};

// options:{data:[option1, option2, ...], loop}
// option: {from, to, property, duration, easingType, delay}
// easingType: "linear"/""
AnimationController.prototype.add = function(sprite, options) {
	this.resumeRuntime(sprite, options);
	options.current = 0;
	this.initOption(sprite, options.data[0]);
};

AnimationController.prototype.resumeRuntime = function(sprite, options) {
	if(!sprite._animationControllerOptions) {
		sprite._animationControllerOptions = [];
	}
	if(!this._sprite.includes(sprite)) {
		this._sprite.push(sprite);
	}
	sprite._animationControllerOptions.push(options);
};

AnimationController.prototype.clear = function(sprite) {
	sprite._animationControllerOptions = [];
};

AnimationController.prototype.removeById = function(sprite, id) {
	if(sprite._animationControllerOptions) {
		sprite._animationControllerOptions = sprite._animationControllerOptions.filter((options) => {
			return options.id !== id;
		});
	}
};

AnimationController.prototype.pause = function(sprite) {
	sprite._animationControllerPause = true;
};

AnimationController.prototype.resume = function(sprite) {
	sprite._animationControllerPause = false;
};

AnimationController.prototype.setPause = function(sprite, val) {
	sprite._animationControllerPause = val;
};

AnimationController.prototype.update = function() {
	this._sprite.forEach((sprite) => {
		if(sprite._animationControllerPause) {
			return;
		}
		const allopts = sprite._animationControllerOptions;
		allopts.forEach((options) => { this.updateSprite(sprite, options); });
	});
};

AnimationController.prototype.updateSprite = function(sprite, options) {
	const loop = options.loop;
	let current = options.current;
	if(current === -1) {
		return;
	}
	
	if(this.updateOption(sprite, options.data[current])) {
		current += 1;
		if(loop && current >= options.data.length) {
			current = 0;
		}
		else if(current >= options.data.length) {
			current = -1;
		}
		if(current !== -1) {
			this.initOption(sprite, options.data[current]);
		}
		else {
			if(options.complete) {
				options.complete(sprite);
			}
		}
		options.current = current;
	}
};

AnimationController.prototype.isCompleted = function(sprite) {
	if(!sprite._animationControllerOptions) {
		return true;
	}
	const opts = sprite._animationControllerOptions;
	if(opts.length === 0) { return true; }
	return opts.every((opt) => {
		return opt.current === -1;
	});
};

AnimationController.prototype.initOption = function(sprite, option) {
	if(option.from !== undefined) {
		option.start = option.from;
	}
	else {
		option.start = sprite[option.property];
	}
	option.t = 0;
	option.d = 0;
};

AnimationController.prototype.updateOption = function(sprite, option) {
	const delay = option.delay ? option.delay : 0;
	if(option.d < delay) {
		option.d++;
		return false;
	}
	option.t++;
	const c = this.calcAnimationValue(option);
	sprite[option.property] = c;
	if(option.t >= option.duration) {
		return true;
	}
	return false;
};

AnimationController.prototype.calcAnimationValue = function(option) {
	const t = option.t;
	const type = option.easingType;
	const start = option.start;
	const end = option.to;
	const duration = option.duration;
	return start + (end - start) * this.calcEasing(type, t / duration);
};

AnimationController.prototype.calcEasing = function(type, val) {
	return AnimationController[type](val);
};

function Sprite_Gallery() {
	this.initialize(...arguments);
}

Sprite_Gallery.prototype = Object.create(Sprite.prototype);
Sprite_Gallery.prototype.constructor = Sprite_Gallery;

Sprite_Gallery.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._preventInputForThisFrame = false;
	this.pressCancel = null;
	this.pressOk = null;
	this._moveBaseX = 0;
	this._moveBaseSelectX = 0;
	this._isDragging = false;
	this._cursorName = options.cursorName;
	this._cursorOffset = options.cursorOffset;
	this._lockName = options.lockName;
	this._upperName = options.upperName;
	this._upperOffset = options.upperOffset;
	this._pageMax = options.pageMax;
	this._margin = options.margin;
	this._moveSignName = options.moveSignName;
	this._baseSprite = new Sprite();
	this._animation = new AnimationController();
	this._active = false;
	this._thumbnailRect = options.thumbnailRect;
	this.addChild(this._baseSprite);
	this.createItems();
	this._selectX = this.defaultSelectX();
	this._selectY = this.defaultSelectY();
	this.createCursor();
	this.createUpperItems();
	this.createMoveSign();
	this.createCancelButton();
	this._baseSprite.x = this.showX();
};

Sprite_Gallery.prototype.defaultSelectX = function() {
	return 0;
};

Sprite_Gallery.prototype.defaultSelectY = function() {
	return 0;
};

Sprite_Gallery.prototype.data = function() {
	return Object.keys(ConfigManager._allCg);
};

Sprite_Gallery.prototype.active = function() {
	this._active = true;
	this._preventInputForThisFrame = true;
};

Sprite_Gallery.prototype.deactive = function() {
	this._active = false;
};

Sprite_Gallery.prototype.pageMargin = function() {
	const p = this._pageMax;
	const m = this._margin;
	return (Graphics.width - this.itemWidth() * p.x - m.width * (p.x - 1)) / 2;
};

Sprite_Gallery.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateMoveSign();
	if(this._active && !this._preventInputForThisFrame) {
		this.updateInput();
		this.updateTouchInput();
	}
	this._preventInputForThisFrame = false;
};

Sprite_Gallery.prototype.select = function(x, y) {
	this._selectX = x;
	this._selectY = y;
	this.executeScroll();
};

Sprite_Gallery.prototype.itemWidth = function() {
	const bitmap = ImageManager.loadUI(this._lockName);
	return bitmap.width;
};

Sprite_Gallery.prototype.itemHeight = function() {
	const bitmap = ImageManager.loadUI(this._lockName);
	return bitmap.height;
};

Sprite_Gallery.prototype.pageHeight = function() {
	return this.baseSpriteHeight() + Math.abs(this.cursorHeight() - this.itemHeight());
};

Sprite_Gallery.prototype.pageWidth = function() {
	return Graphics.width;
};

Sprite_Gallery.prototype.baseSpriteHeight = function() {
	const p = this._pageMax;
	const m = this._margin;
	return p.y * this.itemHeight() + (p.y - 1) * m.height;
};

Sprite_Gallery.prototype.itemX = function(x) {
	const p = this._pageMax;
	const pm = this.pageMargin();
	const realX = x % p.x;
	const page = Math.trunc(x / p.x);
	return Graphics.width * page + pm + realX * (this.itemWidth() + this._margin.width);
};

Sprite_Gallery.prototype.itemY = function(y) {
	return y * (this.itemHeight() + this._margin.height);
};

Sprite_Gallery.prototype.createItems = function() {
	let x = 0;
	let y = 0;
	const p = this._pageMax;
	let number = 0;
	for(const item of this.data()) {
		const sprite = new Sprite(ImageManager.loadUI(this._lockName));
		sprite.x = this.itemX(x);
		sprite.y = this.itemY(y);
		this.createItemContents(item, sprite, number);
		if(this._upperName) {
			const upperSprite = new Sprite(ImageManager.loadUI(this._upperName));
			upperSprite.x = this._upperOffset.x;
			upperSprite.y = this._upperOffset.y;
			sprite.addChild(upperSprite);
		}
		this._baseSprite.addChild(sprite);
		y++;
		if(y >= p.y) {
			x++;
			y = 0;
		}
		number++;
	}
};

Sprite_Gallery.prototype.createItemContents = function(item, sprite) {
	const cg = ConfigManager._allCg;
	const arr = cg[item];
	sprite.cgarr = [];
	arr.forEach((one) => {
		if(ConfigManager.isCGUnlock(one)) {
			sprite.cgarr.push(one);
		}
	});
	if(sprite.cgarr.length > 0) {
		if(sprite.thumbnail) {
			sprite.thumbnail.bitmap = ImageManager.loadPicture(sprite.cgarr[0]);
			return;
		}
		sprite.thumbnail = new Sprite(ImageManager.loadPicture(sprite.cgarr[0]));
		const thumbnail = sprite.thumbnail;
		thumbnail.setFrame((thumbnail.width - NYA.BASE_SCREEN_WIDTH) / 2, 0, NYA.BASE_SCREEN_WIDTH, NYA.BASE_SCREEN_HEIGHT);
		const rect = this._thumbnailRect;
		thumbnail.scale.x = thumbnail.scale.y = rect.height / thumbnail.height;
		thumbnail.x = rect.x;
		thumbnail.y = rect.y;
		
		sprite.addChild(sprite.thumbnail);
	}
};

Sprite_Gallery.prototype.createUpperItems = function() {
	let x = 0;
	let y = 0;
	const p = this._pageMax;
	let number = 0;
	for(const item of this.data()) {
		const sprite = new Sprite();
		sprite.x = this.itemX(x);
		sprite.y = this.itemY(y);
		this.createItemUpperContents(item, sprite, number);
		this._baseSprite.addChild(sprite);
		y++;
		if(y >= p.y) {
			x++;
			y = 0;
		}
		number++;
	}
};

Sprite_Gallery.prototype.createItemUpperContents = function(item, sprite, index) {
};

Sprite_Gallery.prototype.refreshItems = function(x, y) {
	const idx = x * this._pageMax.y + y;
	this.refreshIndexItems(idx);
};

Sprite_Gallery.prototype.refreshIndexItems = function(idx) {
	const data = this.data();
	const lower = this._baseSprite.children[idx];
	const upper = this._baseSprite.children[idx + data.length + 1];
	const item = data[idx];
	this.createItemContents(item, lower, idx);
	this.createItemUpperContents(item, upper, idx);
};

Sprite_Gallery.prototype.refreshAllItems = function() {
	let idx = 0;
	for(const item of this.data()) {
		const lower = this._baseSprite.children[idx];
		const upper = this._baseSprite.children[idx + this.data().length + 1];
		this.createItemContents(item, lower, idx);
		this.createItemUpperContents(item, upper, idx);
		idx++;
	}
};

Sprite_Gallery.prototype.refreshSelectedItems = function() {
	this.refreshItems(this._selectX, this._selectY);
};

Sprite_Gallery.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this._cursorSprite.x = this.cursorX();
	this._cursorSprite.y = this.cursorY();
	this._baseSprite.addChild(this._cursorSprite);
};

Sprite_Gallery.prototype.cursorX = function() {
	return this.itemX(this._selectX) - (this.cursorWidth() - this.itemWidth()) / 2 + this._cursorOffset.x;
};

Sprite_Gallery.prototype.cursorY = function() {
	return this.itemY(this._selectY) - (this.cursorHeight() - this.itemHeight()) / 2 + this._cursorOffset.y;
};

Sprite_Gallery.prototype.cursorWidth = function() {
	return this._cursorSprite.width;
};

Sprite_Gallery.prototype.cursorHeight = function() {
	return this._cursorSprite.height;
};

Sprite_Gallery.prototype.executeScroll = function() {
	const options = {data:[
		{to:this.showX(), duration:30, property:'x', easingType:'easeOutExpo'}
	]};
	const controller = this._animation;
	controller.clear(this._baseSprite);
	controller.add(this._baseSprite, options);
	
	const cursorOptionsX = {data:[
		{to:this.cursorX(), duration:20, property:'x', easingType:'easeOutExpo'}
	]};
	
	const cursorOptionsY = {data:[
		{to:this.cursorY(), duration:20, property:'y', easingType:'easeOutExpo'}
	]};
	
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, cursorOptionsX);
	controller.add(this._cursorSprite, cursorOptionsY);
};

Sprite_Gallery.prototype.dragScroll = function() {
	this._baseSprite.x = this._moveBaseX + TouchInput.moveDeltaX;
};

Sprite_Gallery.prototype.endDragScroll = function() {
	const selectX = this._selectX;
	const selectY = this._selectY;
	if(Math.abs(TouchInput.moveDeltaX) > Utils.touchUIDragPageThreshold()) {
		this._selectX += this._pageMax.x * Utils.sign(-TouchInput.moveDeltaX);
	}
	if(!this.checkSelectAvailable(this._selectX, this._selectY)) {
		this._selectX = this._selectX - (this._selectX % this._pageMax.x);
		this._selectY = 0;
		if(!this.checkSelectAvailable(this._selectX, this._selectY)) {
			this._selectX = selectX;
			this._selectY = selectY;
		}
	}
	this.executeScroll();
};

Sprite_Gallery.prototype.showX = function() {
	return -Math.trunc(this._selectX / this._pageMax.x) * Graphics.width;
};

Sprite_Gallery.prototype.updateInput = function() {
	const p = this._pageMax;
	let x = this._selectX;
	let y = this._selectY;
	if(Input.isUITriggered('up')) {
		y--;
	}
	if(Input.isUITriggered('down')) {
		y++;
	}
	if(Input.isUITriggered('left')) {
		if(x % p.x === 0) {
			x-=p.x;
		} else {
			x--;
		}
	}
	if(Input.isUITriggered('right')) {
		if(x % p.x === p.x - 1) {
			x+=p.x;
		} else {
			x++;
		}
	}
	if(x !== this._selectX || y !== this._selectY) {
		SoundManager.playCursor();
		const checkResult = this.checkSelect(x, y);
		if(checkResult) {
			this._selectX = checkResult.x;
			this._selectY = checkResult.y;
			this.executeScroll();
		}
	}
	if(Input.isUITriggered('cancel') && this.pressCancel) {
		SoundManager.playCancel();
		this.pressCancel();
	}
	if(Input.isUITriggered('ok') && this.pressOk) {
		this.pressOk();
	}
};

Sprite_Gallery.prototype.updateTouchInput = function() {
	let x = 0;
	let y = 0;
	const p = this._pageMax;
	if(TouchInput.isClicked()) {
		if(this._cancelSprite.isBeingTouched()) {
			SoundManager.playCancel();
			this.pressCancel();
		} else {
			for(let i = 0; i < this.data().length; i++) {
				const lower = this._baseSprite.children[i];
				if(lower.isBeingTouched()) {
					this._selectX = x;
					this._selectY = y;
					this.executeScroll();
					this.pressOk();
					break;
				}
				y++;
				if(y >= p.y) {
					x++;
					y = 0;
				}
			}
		}
	}
	if(TouchInput.isPressed()) {
		if(this._cancelSprite.isBeingTouched()) {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel_press");
		} else {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
		}
	} else if(TouchInput.isReleased()) {
		this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
	}
	if(TouchInput.isDraged()) {
		if(!this._isDragging) {
			this._isDragging = true;
			this._moveBaseX = this._baseSprite.x;
			this._moveBaseSelectX = this._selectX;
		}
		this.dragScroll();
	} else {
		if(this._isDragging) {
			this._isDragging = false;
			this.endDragScroll();
		}
	}
};

Sprite_Gallery.prototype.updateMoveSign = function() {
	const pageItemNum = this._pageMax.x * this._pageMax.y;
	const page = Math.trunc(this.selectIndex() / pageItemNum);
	if(page === 0) {
		this._moveSignLeft.visible = false;
	} else {
		this._moveSignLeft.visible = true;
	}
	const lastPage = Math.ceil(this.data().length / pageItemNum) - 1;
	if(page === lastPage) {
		this._moveSignRight.visible = false;
	} else {
		this._moveSignRight.visible = true;
	}
};

Sprite_Gallery.prototype.checkSelect = function(x, y) {
	while(x > this._selectX) {
		if(!this.checkSelectAvailable(x, y)) {
			x--;
		}
		else {
			return {x:x,y:y};
		}
	}
	while(y > this._selectY) {
		if(!this.checkSelectAvailable(x, y)) {
			y--;
		}
		else {
			return {x:x,y:y};
		}
	}
	if(this.checkSelectAvailable(x, y)) {
		return {x:x,y:y};
	}
	else {
		return null;
	}
};

Sprite_Gallery.prototype.checkSelectAvailable = function(x, y) {
	if(x < 0 || y < 0) {
		return false;
	}
	const p = this._pageMax;
	const data = this.data();
	const len = data.length;
	const width = Math.trunc(len / p.y);
	const height = len >= p.y ? p.y : len;
	if(x < width && y < height) {
		return true;
	}
	else if(x === width) {
		return y < len % p.y;
	}
};

Sprite_Gallery.prototype.selectedSprite = function() {
	return this._baseSprite.children[this.selectIndex()];
};

Sprite_Gallery.prototype.selectIndex = function() {
	return this._selectX * this._pageMax.y + this._selectY;
};

Sprite_Gallery.prototype.createMoveSign = function() {
	const controller = this._animation;
	this._moveSignLeft = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignLeft.anchor.x = 0.5;
	this._moveSignLeft.anchor.y = 0.5;
	this._moveSignLeft.y = this.baseSpriteHeight() / 2;
	this._moveSignLeft.x = this.pageMargin() / 2;
	this.addChild(this._moveSignLeft);
	
	
	this._moveSignRight = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignRight.anchor.x = 0.5;
	this._moveSignRight.anchor.y = 0.5;
	this._moveSignRight.y = this.baseSpriteHeight() / 2;
	this._moveSignRight.x = this.pageWidth() - this._moveSignLeft.x;
	this._moveSignRight.scale.x = -1;
	this.addChild(this._moveSignRight);
	
	controller.add(this._moveSignLeft, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	controller.add(this._moveSignRight, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
};

Sprite_Gallery.prototype.createCancelButton = function() {
	this._cancelSprite = new Sprite(ImageManager.loadUI("cancel"));
	this._cancelSprite.anchor.set(0.5);
	this._cancelSprite.x = 96;
	this._cancelSprite.y = -48;
	this.addChild(this._cancelSprite);
};

function Sprite_CG() {
	this.initialize(...arguments);
}

Sprite_CG.prototype = Object.create(Sprite.prototype);
Sprite_CG.prototype.constructor = Sprite_CG;

Sprite_CG.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this.pressCancel = null;
	this.visible = false;
	this._active = false;
	this._preventInputForThisFrame = false;
	this._animation = new AnimationController();
	this._baseSprite = new Sprite();
	this._showIndex = 0;
	this._setupDuration = 0;
	this.addChild(this._baseSprite);
};

Sprite_CG.prototype.setup = function(galleryItemSprite, duration) {
	this.visible = true;
	this._showIndex = 0;
	this._setupDuration = duration;
	this._mirror = galleryItemSprite;
	this._baseSprite.removeChildren();
	const arr = galleryItemSprite.cgarr.clone();
	arr.reverse();
	arr.forEach((subcg) => {
		const sprite = new Sprite(ImageManager.loadPicture(subcg));
		sprite.setFrame((sprite.width - NYA.SCREEN_WIDTH) / 2, 0, NYA.SCREEN_WIDTH, NYA.SCREEN_HEIGHT);
		this._baseSprite.addChild(sprite);
	});
	this._baseSprite.scale.x = galleryItemSprite.thumbnail.scale.x;
	this._baseSprite.scale.y = galleryItemSprite.thumbnail.scale.y;
	const p = galleryItemSprite.thumbnail.toGlobal({x:0,y:0});
	this._baseSprite.x = p.x;
	this._baseSprite.y = p.y;
	const controller = this._animation;
	controller.clear(this._baseSprite.scale);
	controller.clear(this._baseSprite);
	controller.add(this._baseSprite.scale, {data:[
		{to:1, duration:duration, property:'x', easingType:'easeOutQuart'}
	]});
	controller.add(this._baseSprite.scale, {data:[
		{to:1, duration:duration, property:'y', easingType:'easeOutQuart'}
	]});
	controller.add(this._baseSprite, {data:[
		{to:0, duration:duration, property:'x', easingType:'easeOutQuart'}
	]});
	controller.add(this._baseSprite, {data:[
		{to:0, duration:duration, property:'y', easingType:'easeOutQuart'}
	], complete:this.onSetupComplete.bind(this)});
};

Sprite_CG.prototype.unsetup = function() {
	this._active = false;
	const controller = this._animation;
	const duration = this._setupDuration;
	const galleryItemSprite = this._mirror;
	controller.clear(this._baseSprite.scale);
	controller.clear(this._baseSprite);
	const dsx = galleryItemSprite.thumbnail.scale.x;
	const dsy = galleryItemSprite.thumbnail.scale.y;
	const p = galleryItemSprite.thumbnail.toGlobal({x:0,y:0});
	const dx = p.x;
	const dy = p.y;
	controller.add(this._baseSprite.scale, {data:[
		{to:dsx, duration:duration, property:'x', easingType:'easeInQuart'}
	]});
	controller.add(this._baseSprite.scale, {data:[
		{to:dsy, duration:duration, property:'y', easingType:'easeInQuart'}
	]});
	controller.add(this._baseSprite, {data:[
		{to:dx, duration:duration, property:'x', easingType:'easeInQuart'}
	]});
	controller.add(this._baseSprite, {data:[
		{to:dy, duration:duration, property:'y', easingType:'easeInQuart'}
	], complete:this.onUnsetupComplete.bind(this)});
};

Sprite_CG.prototype.onUnsetupComplete = function() {
	this._baseSprite.removeChildren();
	this.visible = false;
	if(this.pressCancel) {
		this.pressCancel();
	}
};

Sprite_CG.prototype.onSetupComplete = function() {
	this._active = true;
};

Sprite_CG.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	if(this._active) {
		this.updateInput();
	}
};

Sprite_CG.prototype.updateInput = function() {
	if(Input.isUITriggered('cancel')) {
		SoundManager.playCancel();
		this.unsetup();
	}
	if(Input.isUITriggered('ok') || TouchInput.isTriggered()) {
		if(this._showIndex < this._baseSprite.children.length - 1) {
			const controller = this._animation;
			const index = this._baseSprite.children.length - 1 - this._showIndex;
			controller.clear(this._baseSprite.children[index]);
			controller.add(this._baseSprite.children[index], {data:[{
				property:'alpha', to:0, easingType:'linear', duration:22
			}]});
			this._showIndex++;
		} else {
			this.unsetup();
		}
	}
};

NYA.UI.Bitmap_initialize = Bitmap.prototype.initialize;
Bitmap.prototype.initialize = function(width, height) {
    NYA.UI.Bitmap_initialize.apply(this, arguments);
	this.fontFace = "rmmz-mainfont";
};

function Sprite_SaveLoad() {
	this.initialize(...arguments);
}

Sprite_SaveLoad.prototype = Object.create(Sprite_Gallery.prototype);
Sprite_SaveLoad.prototype.constructor = Sprite_SaveLoad;

Sprite_SaveLoad.prototype.initialize = function(options) {
	this._newestName = options.newestName;
	this._newestOffset = options.newestOffset;
	this._infoOffset = options.infoOffset;
	this._infoMargin = options.infoMargin;
	this._infoLineHeight = options.infoLineHeight;
	this._cursorCatName = options.cursorCatName;
	this._cursorCatOffset = options.cursorCatOffset;
	this._cursorCatQT = options.cursorCatQT;
	this._cursorCatAnimationHeight = options.cursorCatAnimationHeight;
	this._mode = options.mode;
	this._autoLoadCatOptions = options.autoLoadCatOptions;
	
	this._data = null;
	this._dataStart = 1;	// 自动存档是0号档，设置开始索引为1，不显示自动存档
	
	Sprite_Gallery.prototype.initialize.call(this, options);
	this._autoLoadSprite = null;
	this.createAutoLoadSprite();
};

Sprite_SaveLoad.prototype.defaultSelectX = function() {
	const savefileId = DataManager.latestSavefileId();
	if(savefileId !== -1) {
		return Math.trunc((savefileId - this._dataStart) / this._pageMax.y);
	}
	return 0;
};

Sprite_SaveLoad.prototype.defaultSelectY = function() {
	const savefileId = DataManager.latestSavefileId();
	if(savefileId !== -1) {
		return (savefileId - this._dataStart) % this._pageMax.y;
	}
	return 0;
};

Sprite_SaveLoad.prototype.saveFileNumber = function(idx) {
	switch(idx) {
		case 0: return TextManager["STATIC_TEXT_SAVELOAD_AUTO_SAVE"];
		default: return idx.padZero(3);
	}
};

Sprite_SaveLoad.prototype.createItemContents = function(item, sprite, savefileId) {
	
};

Sprite_SaveLoad.prototype.createItemUpperContents = function(item, sprite, savefileId) {
	this.createItemInfoText(item, sprite, savefileId);
	if(!item) { return; }
	const realId = savefileId + this._dataStart;
	if(item.thumbnail) {
		let bitmap = null;
		if(DataManager.thumbnailCache(realId)) {
			bitmap = DataManager.thumbnailCache(realId);
		} else {
			bitmap = Bitmap.load(item.thumbnail);
			DataManager.updateThumbnailCacheInternal(realId, bitmap);
		}
		if(sprite.thumbnail) {
			sprite.thumbnail.bitmap = bitmap;
		} else {
			const thumbnail = new Sprite(bitmap);
			const rect = this._thumbnailRect;
			thumbnail.x = rect.x;
			thumbnail.y = rect.y;
			sprite.thumbnail = thumbnail;
			sprite.addChild(thumbnail);
		}
	}
	const newestText = TextManager[this._newestName];
	const newestBitmap = new Bitmap(66, 28);
	newestBitmap.fontSize = 24;
	newestBitmap.textColor = "#ffffff";
	newestBitmap.outlineWidth = 1;
	newestBitmap.outlineColor = "#da8e8e";
	newestBitmap.drawText(newestText, -2, 2, newestBitmap.width, 22, "right");
	
	newestBitmap.textColor = "#be0a0a";
	newestBitmap.outlineWidth = 0;
	newestBitmap.drawText(newestText, 0, 0, newestBitmap.width, 22, "right");
	if(DataManager.latestSavefileId() === realId && !sprite.newest) {
		const newest = new Sprite(newestBitmap);
		newest.x = this._newestOffset.x;
		newest.y = this._newestOffset.y;
		newest.anchor.x = 1;
		sprite.newest = newest;
		sprite.addChild(newest);
	} else if(sprite.newest) {
		sprite.removeChild(sprite.newest);
		sprite.newest = undefined;
	}
};

Sprite_SaveLoad.prototype.createItemInfoText = function(item, sprite, savefileId) {
	let infoText = null;
	if(sprite.textBitmap) {
		infoText = sprite.textBitmap;
		infoText.clear();
	} else {
		infoText = new Bitmap(this.itemWidth(), this.itemHeight());
		infoText.textColor = "#551717";
		infoText.outlineWidth = 0;
		const spriteText = new Sprite(infoText);
		sprite.addChild(spriteText);
		sprite.textBitmap = infoText;
	}
	if(!item) { 
		infoText.fontSize = 42;
		infoText.drawText(TextManager["STATIC_TEXT_SAVELOAD_NO_DATA"], 0, infoText.height / 2 - infoText.fontSize / 2, infoText.width, infoText.fontSize, 'center');
		
	} else {
		infoText.fontSize = this._infoLineHeight;
		
		const playtime = item.playtime;
		const hp = item.hp;
		const coin = item.coin || 0;
		
		infoText.drawText(' %1:'.format(TextManager["STATIC_TEXT_SAVELOAD_HP"]) + hp, this._infoOffset.x, this._infoOffset.y, infoText.width, this._infoLineHeight, 'left');
		infoText.drawText(' %1:'.format(TextManager["STATIC_TEXT_SAVELOAD_PLAYTIME"]) + playtime, this._infoOffset.x, this._infoOffset.y + this._infoMargin + this._infoLineHeight, infoText.width, this._infoLineHeight, 'left');
		infoText.drawText(' %1:'.format(TextManager["STATIC_TEXT_SAVELOAD_COIN"]) + coin, this._infoOffset.x, this._infoOffset.y + (this._infoMargin + this._infoLineHeight) * 2, infoText.width, this._infoLineHeight, 'left');
		infoText.drawText(' ' + this.saveFileNumber(savefileId + this._dataStart), this._infoOffset.x, this._infoOffset.y + (this._infoMargin + this._infoLineHeight) * 3, infoText.width, this._infoLineHeight, 'left');
	}
};

Sprite_SaveLoad.prototype.clearAllNewest = function() {
	this._baseSprite.children.forEach((sprite) => {
		if(sprite.newest) {
			sprite.removeChild(sprite.newest);
			sprite.newest = undefined;
		}
	});
};

Sprite_SaveLoad.prototype.updateInput = function() {
	Sprite_Gallery.prototype.updateInput.call(this);
	if(this.isAutoLoadEnable() && Input.isUITriggered("bullet") && this.pressOk) {
		this.pressAutoLoad();
	}
};

Sprite_SaveLoad.prototype.pressAutoLoad = function() {
	const x = this._selectX;
	const y = this._selectY;
	this._selectX = 0;
	this._selectY = -1;
	this.pressOk();
	this._selectX = x;
	this._selectY = y;
};

Sprite_SaveLoad.prototype.allWidth = function() {
	const p = this._pageMax;
	return this.pageWidth() * Math.ceil(this.data().length / (p.x * p.y));
};

Sprite_SaveLoad.prototype.data = function() {
	if(!this._data) {
		this._data = [];
		for(let i = this._dataStart; i <= DataManager.maxSavefiles(); i++) {
			this._data.push(DataManager._globalInfo[i]);
		}
	}
	return this._data;
};

Sprite_SaveLoad.prototype.refreshData = function() {
	this._data = null;
};

Sprite_SaveLoad.prototype.createCursor = function() {
	Sprite_Gallery.prototype.createCursor.call(this);
	const catBitmap = ImageManager.loadUI(this._cursorCatName);
	const baseY = this._cursorCatOffset.y + catBitmap.height;
	const qt = this._cursorCatQT;
	this._cursorCatSprite = new Sprite_QT(catBitmap, Object.assign(qt, {
		minY:baseY - this._cursorCatAnimationHeight
		, maxY:baseY + this._cursorCatAnimationHeight
		, x:this._cursorCatOffset.x
		, y:baseY}));
	
	this._cursorSprite.addChild(this._cursorCatSprite);
};

Sprite_SaveLoad.prototype.createAutoLoadSprite = function() {
	if(this.isAutoLoadEnable()) {
		const options = this._autoLoadCatOptions;
		const catLeftPos = options.catLeftPos;
		const backName = options.backName;
		const catName = options.catName;
		const textSize = options.textSize;
		const textColor = options.textColor;
		const autoCatSprite = new Sprite(ImageManager.loadUI(backName));
		autoCatSprite.x = (Graphics.width - autoCatSprite.width) / 2;
		autoCatSprite.y = -autoCatSprite.height;
		const catLeft = new Sprite(ImageManager.loadUI(catName));
		const catRight = new Sprite(ImageManager.loadUI(catName));
		catLeft.anchor.x = catLeft.anchor.y = 0.5;
		catRight.anchor.x = catRight.anchor.y = 0.5;
		catRight.scale.x = -1;
		catLeft.x = catLeftPos.x;
		catLeft.y = catLeftPos.y;
		catRight.x = autoCatSprite.width - catLeftPos.x;
		catRight.y = catLeftPos.y;
		
		this._autoLoadTextBitmap = new Bitmap(autoCatSprite.width, autoCatSprite.height);
		this._autoLoadTextBitmap.textColor = textColor;
		this._autoLoadTextBitmap.fontSize = textSize;
		this._autoLoadTextBitmap.outlineWidth = 0;
		const textSprite = new Sprite(this._autoLoadTextBitmap);
		autoCatSprite.addChild(catLeft, catRight, textSprite);
		this.addChild(autoCatSprite);
		this._autoLoadSprite = autoCatSprite;
		
		this.refreshAutoLoadText();
	}
};

Sprite_SaveLoad.prototype.refreshAutoLoadText = function() {
	this._autoLoadTextBitmap.clear();
	const text = Utils.isMobileDeviceTouchMode() ? TextManager["STATIC_TEXT_TOUCH_AUTO_LOAD"] : TextManager["STATIC_TEXT_PRESS_LOAD_AUTO"].format(ConfigManager.getInputName("bullet"));
	this._autoLoadTextBitmap.drawCenterText(text);
};

Sprite_SaveLoad.prototype.onLanguageChange = function() {
	if(this.isAutoLoadEnable()) {
		this.refreshAutoLoadText();
	}
};

Sprite_SaveLoad.prototype.isAutoLoadEnable = function() {
	return this._mode === "load" && DataManager.savefileInfo(0);
};

Sprite_SaveLoad.prototype.updateTouchInput = function() {
	Sprite_Gallery.prototype.updateTouchInput.call(this);
	if(TouchInput.isClicked() && this.isAutoLoadEnable() && this._autoLoadSprite.isBeingTouched()) {
		this.pressAutoLoad();
	}
};

Sprite_SaveLoad.prototype.touchActive = function() {
};

Sprite_SaveLoad.prototype.touchDeactive = function() {
};

Window_Base.prototype.updatePadding = function() {
	this.padding = 12;
};

Window_Base.prototype.updateTone = function() {
    this.setTone(0, 0, 0);
};

Window_Base.prototype.resetFontSettings = function() {
	this.contents.fontSize = 28;
	this.contents.outlineWidth = 0;
    this.resetTextColor();
};

Window_Base.prototype.resetTextColor = function() {
    this.changeTextColor('#551717');
	this.contents.outlineWidth = 0;
};

Window_Base.prototype.updateBackOpacity = function() {
    this.backOpacity = 255;
};

function Window_Alert() {
	this.initialize(...arguments);
}

Window_Alert.prototype = Object.create(Window_Base.prototype);
Window_Alert.prototype.constructor = Window_Alert;

Window_Alert.prototype.initialize = function(rect, messageKey, options) {
	Window_Base.prototype.initialize.call(this, rect);
	this._preventInputForThisFrame = false;
	this._hasButton = options.hasButton;
	this._buttonText = options.buttonText;
	this._messageKey = "";
	this.createButton();
	if(messageKey) {
		this.setText(messageKey);
	}
};

Window_Alert.prototype.contentExpandY = function() {
	return 0;
};

Window_Alert.prototype.createButton = function() {
	if(this._hasButton) {
		this._buttonSprite = new Sprite_WindowButton(141, this._buttonText);
		const width = this._buttonSprite.allWidth();
		const height = this._buttonSprite.allHeight();
		this._buttonSprite.x = (this.innerWidth - width) / 2;
		this._buttonSprite.y = (this.height - height - this.contents.fontSize) / 3 * 2 + this.contents.fontSize + this.contentExpandY();
		this._contentsSprite.addChild(this._buttonSprite);
	}
};

Window_Alert.prototype.onLanguageChange = function() {
	this._buttonSprite.onLanguageChange();
	this.refreshText();
};

Window_Alert.prototype.refreshText = function() {
	if(this._messageKey) {
		this.setText(this._messageKey);
	}
};

Window_Alert.prototype.setText = function(messageKey) {
	this._messageKey = messageKey;
	const message = TextManager[messageKey];
	this.contents.clear();
	const length = message.length;
	let idx = 0;
	const arr = [];
	let bufferText = "";
	const lineWidth = this.innerWidth * 3 / 4;
	while(idx < length) {
		let width = this.contents.measureTextWidth(bufferText);
		const shouldWaitForSpacingNewLine = Utils.isSpacingNewLineLanguage() && message[idx] !== " ";
		if(width > lineWidth && !shouldWaitForSpacingNewLine) {
			arr.push(bufferText);
			bufferText = "";
			continue;
		}
		bufferText += message[idx];
		idx++;
	}
	if(bufferText !== "") {
		arr.push(bufferText);
	}
	let y = 0;
	const margin = 7;
	const size = this.contents.fontSize;
	if(!this._buttonSprite) {
		y = (this.innerHeight - size) / 2 + size / 2 + margin / 2;
	} else {
		y = (this.innerHeight - size - this._buttonSprite.allHeight()) / 3 + size / 2 + margin / 2;
	}
	
	const allHeight = (size + margin) * arr.length;
	const upper = y - allHeight / 2;
	idx = 0;
	for(const text of arr) {
		this.drawText(text, 0, upper + idx * (size + margin) - this.contentExpandY(), this.innerWidth, 'center');
		idx++
	}
};

Window_Alert.prototype.update = function() {
	Window_Base.prototype.update.call(this);
	if(this.active && !this._preventInputForThisFrame) {
		this.updateInput();
		this.updateTouchInput();
	}
	this._preventInputForThisFrame = false;
};

Window_Alert.prototype.updateInput = function() {
	if(Input.isUITriggered('cancel') && this.pressCancel) {
		SoundManager.playCancel();
		this.pressCancel();
		this.close();
		this.deactivate();
	}
	if(Input.isUITriggered('ok') && this.pressOk) {
		SoundManager.playOk();
		this.pressOk();
		this.close();
		this.deactivate();
	}
};

Window_Alert.prototype.updateTouchInput = function() {
	if(TouchInput.isClicked() && this._buttonSprite.isBeingTouched()) {
		SoundManager.playOk();
		this.pressOk();
		this.close();
		this.deactivate();
	}
};

Window_Alert.prototype.open = function() {
	Window_Base.prototype.open.call(this);
	this._preventInputForThisFrame = true;
};

/**
 * The openness of the window (0 to 255).
 *
 * @type number
 * @name Window#openness
 */
Object.defineProperty(Window.prototype, "openness", {
    get: function() {
        return this._openness;
    },
    set: function(value) {
        if (this._openness !== value) {
            this._openness = value.clamp(0, 255);
            this._container.scale.x = this._container.scale.y = this._openness / 255;
			this._container.x = (this.width / 2) * (1 - this._openness / 255);
            this._container.y = (this.height / 2) * (1 - this._openness / 255);
        }
    },
    configurable: true
});

function Sprite_WindowButton() {
	this.initialize(...arguments);
}

Sprite_WindowButton.prototype = Object.create(Sprite.prototype);
Sprite_WindowButton.prototype.constructor = Sprite_WindowButton;

Sprite_WindowButton.prototype.initialize = function(width, text) {
	Sprite.prototype.initialize.call(this);
	this._buttonWidth = width;
	this._buttonText = text;
	this.createAllParts();
	this._selected = true;
};

Sprite_WindowButton.prototype.createAllParts = function() {
	this.leftSprite = new Sprite(ImageManager.loadUI('button_left_selected'));
	this.rightSprite = new Sprite(ImageManager.loadUI('button_right_selected'));
	this.rightSprite.x = this.leftSprite.width + this._buttonWidth;
	this.cursorSprite = new Sprite(ImageManager.loadUI('button_cursor'));
	this.cursorSprite.anchor.set(0.5);
	const innerBitmap = ImageManager.loadUI('button_inner_selected');
	this.innerSprite = new TilingSprite(ImageManager.loadUI('button_inner_selected'));
	this.innerSprite.move(this.leftSprite.width, 0, this._buttonWidth, innerBitmap.height);
	this.cursorSprite.x = this.leftSprite.width + this._buttonWidth / 2;
	this.cursorSprite.y = this.leftSprite.height / 2 - 3;
	this.textBitmap = new Bitmap(this.allWidth(), this.allHeight());
	
	this.textBitmap.fontSize = 20;
	this.textBitmap.outlineWidth = 0;
	this.textBitmap.textColor = '#551717';
	
	this.textSprite = new Sprite(this.textBitmap);
	this.addChild(this.leftSprite);
	this.addChild(this.rightSprite);
	this.addChild(this.innerSprite);
	this.addChild(this.cursorSprite);
	this.addChild(this.textSprite);
	this.createButtonText();
};

Sprite_WindowButton.prototype.isBeingTouched = function() {
	return this.leftSprite.isBeingTouched() || this.rightSprite.isBeingTouched() || this.innerSprite.isBeingTouched();
};

Sprite_WindowButton.prototype.onLanguageChange = function() {
	this.createButtonText();
};

Sprite_WindowButton.prototype.createButtonText = function() {
	const bitmap = this.textBitmap;
	bitmap.clear();
	bitmap.drawText(TextManager[this._buttonText], 0, (this.allHeight() - bitmap.fontSize) / 2, bitmap.width, bitmap.fontSize, 'center');
};

Sprite_WindowButton.prototype.select = function() {
	this._selected = true;
	this.cursorSprite.visible = true;
	this.updateAllParts();
};

Sprite_WindowButton.prototype.unselect = function() {
	this._selected = false;
	this.cursorSprite.visible = false;
	this.updateAllParts();
};

Sprite_WindowButton.prototype.updateAllParts = function() {
	const prefix = this._selected ? '_selected' : '';
	this.leftSprite.bitmap = ImageManager.loadUI('button_left' + prefix);
	this.rightSprite.bitmap = ImageManager.loadUI('button_right' + prefix);
	this.innerSprite.bitmap = ImageManager.loadUI('button_inner' + prefix);
	this.innerSprite.move(this.leftSprite.width, 0, this._buttonWidth, this.innerSprite.bitmap.height);
};

Sprite_WindowButton.prototype.allWidth = function() {
	return this.leftSprite.width + this.rightSprite.width + this._buttonWidth;
};

Sprite_WindowButton.prototype.allHeight = function() {
	return this.leftSprite.height;
};

Sprite_WindowButton.prototype.selected = function() {
	return this._selected;
};

function Window_Confirm() {
	this.initialize(...arguments);
}

Window_Confirm.prototype = Object.create(Window_Alert.prototype);
Window_Confirm.prototype.constructor = Window_Confirm;

Window_Confirm.prototype.initialize = function(rect, message, options) {
	this._defaultSelected = options.defaultSelected;
	this._canEscape = options.canEscape;
	Window_Alert.prototype.initialize.call(this, rect, message, {});
};

Window_Confirm.prototype.createButton = function() {
	this._buttonSpriteYes = new Sprite_WindowButton(141, "STATIC_TEXT_YES");
	const widthYes = this._buttonSpriteYes.allWidth();
	const height = this._buttonSpriteYes.allHeight();
	
	this._buttonSpriteNo = new Sprite_WindowButton(141, "STATIC_TEXT_NO");
	const widthNo = this._buttonSpriteNo.allWidth();
	
	this._buttonSpriteYes.x = (this.innerWidth - (widthYes + widthNo)) / 3;
	this._buttonSpriteYes.y = (this.height - height - this.contents.fontSize) / 3 * 2 + this.contents.fontSize + this.contentExpandY();
	this._contentsSprite.addChild(this._buttonSpriteYes);
	
	
	this._buttonSpriteNo.x = (this.innerWidth - (widthYes + widthNo)) / 3 * 2 + widthYes;
	this._buttonSpriteNo.y = this._buttonSpriteYes.y;
	this._contentsSprite.addChild(this._buttonSpriteNo);
	
	this.resetDefaultSelect();
	this._buttonSprite = this._buttonSpriteYes;
};

Window_Confirm.prototype.resetDefaultSelect = function() {
	if(this._defaultSelected === 'yes') {
		this.yes();
	} else {
		this.no();
	}
};

Window_Confirm.prototype.onLanguageChange = function() {
	this._buttonSpriteYes.onLanguageChange();
	this._buttonSpriteNo.onLanguageChange();
	this.refreshText();
};

Window_Confirm.prototype.updateInput = function() {
	if(Input.isUITriggered('left') && this._buttonSpriteNo.selected()) {
		SoundManager.playCursor();
		this._buttonSpriteYes.select();
		this._buttonSpriteNo.unselect();
	}
	if(Input.isUITriggered('right') && this._buttonSpriteYes.selected()) {
		SoundManager.playCursor();
		this._buttonSpriteNo.select();
		this._buttonSpriteYes.unselect();
	}
	if(Input.isUITriggered('cancel') && this._canEscape && this.pressCancel) {
		SoundManager.playCancel();
		this.pressCancel();
		this.close();
		this.deactivate();
	}
	if(Input.isUITriggered('ok')) {
		if(this._buttonSpriteYes.selected() && this.pressOk) {
			SoundManager.playOk();
			this.pressOk();
			this.close();
			this.deactivate();
		}
		else if(this._buttonSpriteNo.selected() && this.pressCancel) {
			SoundManager.playOk();
			this.pressCancel();
			this.close();
			this.deactivate();
		}
	}
};

Window_Confirm.prototype.updateTouchInput = function() {
	if(TouchInput.isPressed()) {
		if(this._buttonSpriteYes.isBeingTouched()) {
			this._buttonSpriteYes.select();
			this._buttonSpriteNo.unselect();
		}
		if(this._buttonSpriteNo.isBeingTouched()) {
			this._buttonSpriteNo.select();
			this._buttonSpriteYes.unselect();
		}
	}
	if(TouchInput.isClicked()) {
		if(this._buttonSpriteYes.isBeingTouched()) {
			SoundManager.playOk();
			this.pressOk();
			this.close();
			this.deactivate();
			return;
		}
		if(this._buttonSpriteNo.isBeingTouched()) {
			SoundManager.playOk();
			this.pressCancel();
			this.close();
			this.deactivate();
			return;
		}
	}
};

Window_Confirm.prototype.yes = function() {
	this._buttonSpriteYes.select();
	this._buttonSpriteNo.unselect();
};

Window_Confirm.prototype.no = function() {
	this._buttonSpriteNo.select();
	this._buttonSpriteYes.unselect();
};

function Sprite_Music() {
	this.initialize(...arguments);
}

Sprite_Music.prototype = Object.create(Sprite_Gallery.prototype);
Sprite_Music.prototype.constructor = Sprite_Gallery;

Sprite_Music.prototype.initialize = function(options) {
	this._playIndex = -1;
	this._textOffsetX = options.textOffsetX;
	this._playName = options.playName;
	this._unplayName = options.unplayName;
	this._playButtonOffset = options.playButtonOffset;
	
	this._cursorCatName = options.cursorCatName;
	this._cursorCatOffset = options.cursorCatOffset;
	this._cursorCatQT = options.cursorCatQT;
	this._cursorCatAnimationHeight = options.cursorCatAnimationHeight;
	
	this.createCatSprite();
	Sprite_Gallery.prototype.initialize.call(this, options);
};

Sprite_Music.prototype.createCatSprite = function() {
	const catBitmap = ImageManager.loadUI(this._cursorCatName);
	const baseY = this._cursorCatOffset.y + catBitmap.height;
	const qt = this._cursorCatQT;
	this._catSprite = new Sprite_QT(catBitmap, Object.assign(qt, {
		minY:baseY - this._cursorCatAnimationHeight
		, maxY:baseY + this._cursorCatAnimationHeight
		, x:this._cursorCatOffset.x
		, y:baseY}));
	
	const shader = new PIXI.filters.GlowFilter();
	this._catSprite.filters = [shader];
};

Sprite_Music.prototype.createCursor = function() {
	Sprite_Gallery.prototype.createCursor.call(this);
	this._textMask = new PIXI.Graphics();
	this._textMask.beginFill(0xff0000);
	this._textMask.drawRect(0, 0, this._cursorSprite.width, this._cursorSprite.height);
	this._textMask.endFill();
	this.addChild(this._textMask);
};

Sprite_Music.prototype.data = function() {
	return ConfigManager._allBgm.filter((name) => {		
		return ConfigManager.isBgmUnlock(name);
	}); 
};

Sprite_Music.prototype.createItemContents = function(item, sprite, bgmId) {
	if(!sprite.textBitmap) {
		const textSprite = new Sprite();
		const textBitmap = new Bitmap(this.itemWidth(), this.itemHeight());
		textSprite.bitmap = textBitmap;
		textBitmap.outlineWidth = 0;
		textBitmap.fontSize = 24;
		textBitmap.textColor = '#ffffff';
		sprite.addChild(textSprite);
		sprite.textBitmap = textBitmap;
	} else {
		sprite.textBitmap.clear();
	}
	const bitmap = sprite.textBitmap;
	bitmap.drawText(TextManager[item], this._textOffsetX, (bitmap.height - bitmap.fontSize) / 2, bitmap.width, bitmap.fontSize, 'left');
};

Sprite_Music.prototype.createItemUpperContents = function(item, sprite, bgmId) {
	if(!sprite.upperTextBitmap) {
		const upperTextSprite = new Sprite();
		const upperTextBitmap = new Bitmap(this.itemWidth(), this.itemHeight());
		upperTextSprite.bitmap = upperTextBitmap;
		upperTextBitmap.outlineWidth = 3;
		upperTextBitmap.fontSize = 24;
		upperTextBitmap.textColor = '#ff9bb7';
		upperTextBitmap.outlineColor = '#ffffff';
		upperTextBitmap.context.shadowBlur = 12;
		upperTextBitmap.context.shadowOffsetX = 0;
		upperTextBitmap.context.shadowOffsetY = 0;
		upperTextBitmap.context.shadowColor = '#ff9bb7';
		sprite.addChild(upperTextSprite);
		sprite.upperTextBitmap = upperTextBitmap;
		
		upperTextSprite.mask = this._textMask;
	} else {
		sprite.upperTextBitmap.clear();
	}
	const upperBitmap = sprite.upperTextBitmap;
	upperBitmap.drawText(TextManager[item], this._textOffsetX, (upperBitmap.height - upperBitmap.fontSize) / 2, upperBitmap.width, upperBitmap.fontSize, 'left');
	
	
	if(!sprite.playButton) {
		sprite.playButton = new Sprite();
		sprite.playButton.x = this._playButtonOffset.x;
		sprite.playButton.y = this._playButtonOffset.y;
		sprite.addChild(sprite.playButton);
	}
	if(this._playIndex === bgmId) {
		sprite.playButton.bitmap = ImageManager.loadUI(this._unplayName);
		sprite.addChild(this._catSprite);
	} else {
		sprite.playButton.bitmap = ImageManager.loadUI(this._playName);
	}
};

Sprite_Music.prototype.update = function() {
	Sprite_Gallery.prototype.update.call(this);
	this._textMask.x = this._cursorSprite.x + this._baseSprite.x;
	this._textMask.y = this._cursorSprite.y + this._baseSprite.y;
};

Sprite_Music.prototype.playIndex = function() {
	return this._playIndex;
};

Sprite_Music.prototype.setPlayIndex = function(val) {
	this._playIndex = val;
};

Sprite_Music.prototype.refreshCatSprite = function() {
	const parent = this._catSprite.parent;
	if(parent) { parent.removeChild(this._catSprite); }
	if(this.playIndex() === -1) {return;}
	const sprite = this.playUpperSprite();
	sprite.addChild(this._catSprite);
};

Sprite_Music.prototype.playUpperSprite = function() {
	return this._baseSprite.children[this.playIndex() + this.data().length + 1];
};


Bitmap.prototype._drawTextOutline = function(text, tx, ty, maxWidth) {
	if(this.outlineWidth === 0) { return; }
    const context = this.context;
    context.strokeStyle = this.outlineColor;
    context.lineWidth = this.outlineWidth;
    context.lineJoin = "round";
    context.strokeText(text, tx, ty, maxWidth);
};

function Sprite_QT() {
	this.initialize(...arguments);
}

Sprite_QT.prototype = Object.create(Sprite.prototype);
Sprite_QT.prototype.constructor = Sprite_QT;

Sprite_QT.prototype.initialize = function(bitmap, options) {
	Sprite.prototype.initialize.call(this, bitmap);
	this.anchor.y = 1;
	this._animation = new AnimationController();
	this.x = options.x;
	this.y = options.y;
	this._animation.add(this, {data:[
		{to:options.maxY, duration:options.duration, property:'y', easingType:'easeInQuad'}
		,{to:options.minY, duration:options.duration, property:'y', easingType:'easeOutQuad', delay:Math.round(options.scaleDuration * 4 / 3)}
	],loop:true});
	this._animation.add(this, {data:[
		{to:1.0, duration:options.duration, property:'scaleY', easingType:'linear'}
		,{to:options.minScaleY, duration:options.scaleDuration, property:'scaleY', easingType:'easeOutQuad'}
		,{to:1.0, duration:options.scaleDuration * 2, property:'scaleY', easingType:'easeOutBackCat'}
		,{to:1.0, duration:options.duration - options.scaleDuration * 5 / 3, property:'scaleY', easingType:'linear'}
	],loop:true});
};

Sprite_QT.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
};

Sprite_QT.prototype.pause = function() {
	this._animation.pause();
};

Sprite_QT.prototype.resume = function() {
	this._animation.resume();
};

Object.defineProperty(Sprite_QT.prototype, "scaleY", {
    get: function() {
        return this.scale.y;
    },
    set: function(value) {
        this.scale.y = value;
    },
	configurable: true
});

function Sprite_Option() {
	this.initialize(...arguments);
}

Sprite_Option.prototype = Object.create(Sprite.prototype);
Sprite_Option.prototype.constructor = Sprite_Option;

Sprite_Option.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backgroundName = options.backgroundName;
	this._frameMinY = options.frameMinY;
	this._frameMaxY = options.frameMaxY;
	this._itemsCenterX = options.itemsCenterX;
	this._pageItemXLayout = options.pageItemXLayout;
	this._pageMaxNum = options.pageItemXLayout.length;
	this._cursorName = options.cursorName;
	this._moveSignName = options.moveSignName;
	
	this._active = false;
	this._preventInputForThisFrame = false;
	this._textSize = options.textSize;
	this._singleItemWidth = options.singleItemWidth;
	
	this._pageStartIndex = 0;
	this._selectedItemIndex = 0;
	this._dragStartY = 0;
	this._dragSelectCellOffset = 0;
	this._animation = new AnimationController();
	
	this._pressCancel = null;
	this.createBackground();
	this.createCursor();
	this.createAllItems();
	this.createMoveSign();
	this.createCancelButton();
	this.refreshChildActive();
	this.createWindowLayer();
	this.createAllWindow();
	this.createScreenButtonConfig(options.screenButtonConfig);
	ConfigManager.setDisplayModeErrorHandler(this.onFullScreenError.bind(this));
	if(this._selectedItemIndex !== ConfigManager.reloadSceneReason()) {
		this._selectedItemIndex = ConfigManager.reloadSceneReason();
		ConfigManager.resetReloadSceneReason();
		this.movePageCursor();
		this.refreshChildActive();
	}
};

Sprite_Option.prototype.onFullScreenError = function() {
	this.controlDeactive();
	this.tipsSave("STATIC_TEXT_FULLSCREEN_ERROR", this.controlActive.bind(this));
};

Sprite_Option.prototype.createMoveSign = function() {
	const controller = this._animation;
	this._moveSignUp = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignUp.anchor.x = 0.5;
	this._moveSignUp.anchor.y = 0.5;
	this._moveSignUp.y = this._frameMinY - this._moveSignUp.height;
	this._moveSignUp.x = this.allWidth() / 2;
	this.addChild(this._moveSignUp);
	
	
	this._moveSignDown = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignDown.anchor.x = 0.5;
	this._moveSignDown.anchor.y = 0.5;
	this._moveSignDown.y = this._frameMaxY + this._moveSignUp.height;
	this._moveSignDown.x = this.allWidth() / 2;
	this._moveSignDown.scale.y = -1;
	this.addChild(this._moveSignDown);
	
	controller.add(this._moveSignUp, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	controller.add(this._moveSignDown, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	this.updateMoveSign();
};

Sprite_Option.prototype.createWindowLayer = function() {
	Scene_Base.prototype.createWindowLayer.call(this);
};

Sprite_Option.prototype.createCancelButton = function() {
	this._cancelSprite = new Sprite(ImageManager.loadUI("cancel"));
	this._cancelSprite.anchor.set(0.5);
	this._cancelSprite.x = 64 - Utils.baseHalfWidth();
	this._cancelSprite.y = 64;
	this.addChild(this._cancelSprite);
};

Sprite_Option.prototype.addWindow = function(window) {
    Scene_Base.prototype.addWindow.call(this, window);
};

Sprite_Option.prototype.createAllWindow = function() {
	const confirmWidth = 580;
	const confirmHeight = 250;
	const confirmX = (Graphics.width - confirmWidth) / 2;
	const confirmY = (Graphics.height - confirmHeight) / 2;
	const rect = {x:confirmX,y:confirmY,width:confirmWidth,height:confirmHeight};
	this._tips = new Window_Alert(rect, '', {hasButton:true, buttonText:"STATIC_TEXT_OK"});
	this._tips.visible = false;
	this._tips.deactivate();
	this.addWindow(this._tips);
	
	this._confirm = new Window_Confirm(rect, '', {defaultSelected: 'no', canEscape:true});
	this._confirm.visible = false;
	this._confirm.deactivate();
	this.addWindow(this._confirm);
};

Sprite_Option.prototype.data = function() {
	return ConfigManager.ui();
};

Sprite_Option.prototype.createBackground = function() {
	this._backgroundSprite = new Sprite(ImageManager.loadUI(this._backgroundName));
	this.addChild(this._backgroundSprite);
};

Sprite_Option.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this._cursorSprite.anchor.y = 0.5;
	this._cursorSprite.anchor.x = 0.5;
	this._cursorSprite.x = this.allWidth() / 2;
	this._cursorSprite.y = this.cursorY();
	this.addChild(this._cursorSprite);
};

Sprite_Option.prototype.allWidth = function() {
	return this._backgroundSprite.width;
};

Sprite_Option.prototype.allHeight = function() {
	return this._backgroundSprite.height;
};

Sprite_Option.prototype.pageHeight = function() {
	return this._frameMaxY - this._frameMinY;
};

Sprite_Option.prototype.scrollY = function() {
	return this.pageHeight() / this._pageMaxNum;
};

Sprite_Option.prototype.tipsSave = function(message, callback) {
	this._tips.setText(message);
	this._tips.pressOk = this._tips.pressCancel = callback;
	this._tips.visible = true;
	this._tips.openness = 0;
	this._tips.open();
	this._tips.activate();
};

Sprite_Option.prototype.confirmExit = function(message, okCallback, cancelCallback) {
	this._confirm.setText(message);
	this._confirm.pressOk = okCallback;
	this._confirm.pressCancel = cancelCallback;
	this._confirm.visible = true;
	this._confirm.no();
	this._confirm.openness = 0;
	this._confirm.open();
	this._confirm.activate();
};

Sprite_Option.prototype.createScreenButtonConfig = function(options) {
	this._screenButtonConfig = new Sprite_ScreenButtonConfig(options);
	this._screenButtonConfig.visible = false;
	this._screenButtonConfig.pressOk = this.pressScreenButtonOk.bind(this);
	this._screenButtonConfig.pressCancel = this.pressScreenButtonCancel.bind(this);
	this._screenButtonConfig.x = -Utils.baseHalfWidth();
	this.addChild(this._screenButtonConfig);
};

Sprite_Option.prototype.pressScreenButtonConfigOk = function() {
	this._screenButtonConfig.visible = true;
	this._screenButtonConfig.syncConfig();
	this.deactive();
	for(const item of this._itemsPage.children) {
		item.touchDeactive();
	}
};

Sprite_Option.prototype.pressScreenButtonOk = function() {
	this._screenButtonConfig.visible = false;
	this._screenButtonConfig.applyChange();
	this.active();
	this.refreshChildActive();
};

Sprite_Option.prototype.pressScreenButtonCancel = function() {
	this._screenButtonConfig.visible = false;
	this.active();
	this.refreshChildActive();
};

Sprite_Option.prototype.onLanguageChange = function() {
	this._confirm.onLanguageChange();
	this._tips.onLanguageChange();
	this._screenButtonConfig.onLanguageChange();
	this._itemsPage.children.forEach((child) => {
		child.onLanguageChange();
	});
};

Sprite_Option.prototype.createAllItems = function() {
	this._itemsContainer = new Sprite();
	this._itemsContainer.mask = new PIXI.Graphics();
	const mask = this._itemsContainer.mask;
	mask.beginFill(0xff0000);
	const pageHeight = this.pageHeight();
	mask.drawRect(0, this._frameMinY, Graphics.width, pageHeight);
	mask.endFill();
	this.addChild(mask);
	this._itemsPage = new Sprite();
	this._itemsContainer.addChild(this._itemsPage);
	let cell = 0;
	let currentY = this._frameMinY;
	const baseOption0 = {
		selectedColor:'#ff9bb7'
		, selectedOutlineColor:'#ffffff'
		, selectedOutlineWidth:2
		, textColor:'#ffffff'
		, textSize:this._textSize
		, scrollY:this.scrollY()
	};
	for(const item of this.data()) {
		if(item.pcweb && Utils.isMobileDevice() && typeof AndroidJsObject !== "undefined" || item.pc && Utils.isMobileDevice() || item.mobile && !Utils.isMobileDevice()) {
			continue;
		}
		const baseOption = Object.assign({
			item:item
			, name:item.name
		}, baseOption0);
		switch(item.type) {
			case 'single': {
				const sprite = new Sprite_SingleSelect(Object.assign({
					buttonStartX: this._itemsCenterX - this._singleItemWidth
					, buttonEndX: this._itemsCenterX + this._singleItemWidth
					, buttonTextMargin: 10
					, buttonSelectedName: 'option_single_selected'
					, buttonUnselectedName: 'option_single_unselected'
					, items:item.items
				}, baseOption));
				sprite.callback = function(idx) { item.callback(item.items[idx].para); };
				sprite.y = currentY;
				sprite.x = 0;
				sprite.setSelectedItem(this.findConfigItemIndex(item), false);
				this._itemsPage.addChild(sprite);
				currentY += sprite.cellNum() * this.scrollY();
				if(item.externalChangeHandler) {
					item.externalChangeHandler(function() {
						sprite.setSelectedItem(this.findConfigItemIndex(item), false);
					}.bind(this));
					sprite.setExternalChange(true);
				}
				break;
			}
			case 'progress': {
				const sprite = new Sprite_ProgressSelect(Object.assign({
					progressStartX: 460
					, progressCursorName: 'option_progress_cursor'
					, progressTextMargin: 20
					, cursorOffsetX:22
					, cursorIndentX:-26
					, progress: {
						lowerNames:['preload_bar_lower']
						, upperNames:[]
						, progressName:'preload_bar_content'
						, tilingName:'preload_bar_tiling'
						, tilingSpeed:0
					}
				}, baseOption));
				sprite.callback = item.callback;
				sprite.y = currentY;
				sprite.x = 0;
				sprite.progress = this.readInitVal(item);
				this._itemsPage.addChild(sprite);
				currentY += sprite.cellNum() * this.scrollY();
				break;
			}
			case 'switch' : {
				const sprite = new Sprite_Switch(Object.assign({
					on: this.readInitVal(item)
					, switchButtonName: 'option_switch_cursor'
					, switchPadName: 'option_switch_pad'
					, switchStartX:613
					, switchTextMargin:18
					, onText: item.onText
					, offText: item.offText
				}, baseOption));
				sprite.callback = item.callback;
				sprite.y = currentY;
				sprite.x = 0;
				this._itemsPage.addChild(sprite);
				currentY += sprite.cellNum() * this.scrollY();
				break;
			}
			case 'key' : {
				const sprite = new Sprite_ControlSetting(Object.assign({
					pageMaxNum: 2
					, deactiveParent: this.controlDeactive.bind(this)
					, activeParent: this.controlActive.bind(this)
					, cursorName: 'option_control_cursor'
					, startX: 388
					, itemWidth: 380
					, itemMargin: 32
					, confirmExit: this.confirmExit.bind(this)
					, tipsSave: this.tipsSave.bind(this)
				}, baseOption));
				sprite.callback = item.callback;
				sprite.y = currentY;
				sprite.x = 0;
				this._itemsPage.addChild(sprite);
				currentY += sprite.cellNum() * this.scrollY();
				break;
			}
			case 'screen_button_config': {
				const sprite = new Sprite_ButtonSelect(Object.assign({}, baseOption));
				sprite.pressOk = this.pressScreenButtonConfigOk.bind(this);
				sprite.y = currentY;
				sprite.x = 0;
				this._itemsPage.addChild(sprite);
				currentY += sprite.cellNum() * this.scrollY();
			}
			default: break;
		}
		cell++;
	}
	this.createControlItems(cell, currentY, baseOption0);
	this.addChild(this._itemsContainer);
	this.resetItemNamePosition();
};

Sprite_Option.prototype.controlDeactive = function() {
	this.deactive();
	this._cursorSprite.visible = false;
	this.moveCursorToTop();
};

Sprite_Option.prototype.controlActive = function() {
	this.active();
	this._cursorSprite.visible = true;
};

Sprite_Option.prototype.createControlItems = function(cell, currentY, baseOption0) {
	const sprite = new Sprite_ButtonSelect(Object.assign({
		name: "STATIC_TEXT_RESET_CONFIG"
	}, baseOption0));
	sprite.y = currentY;
	sprite.x = 0;
	sprite.pressOk = this.resetAll.bind(this);
	this._itemsPage.addChild(sprite);
	currentY += sprite.cellNum() * this.scrollY();
	cell++;
	
	this.exitItem = new Sprite_ButtonSelect(Object.assign({
		name: "STATIC_TEXT_EXIT"
	}, baseOption0));
	this.exitItem.y = currentY;
	this.exitItem.x = 0;
	this._itemsPage.addChild(this.exitItem);
};

Sprite_Option.prototype.resetAll = function() {
	ConfigManager.resetAll();
	this._itemsPage.children.forEach((child) => {
		const item = child.item;
		if(child.constructor === Sprite_SingleSelect) {
			child.setSelectedItem(this.findConfigItemIndex(item));
		} else if(child.constructor === Sprite_ProgressSelect) {
			child.progress = this.readInitVal(item);
		} else if(child.constructor === Sprite_Switch) {
			child.on = this.readInitVal(item);
		} else if(child.constructor === Sprite_ControlSetting) {
			child.refreshAllConfig();
		}
	});
};

Object.defineProperty(Sprite_Option.prototype, "pressCancel", {
	get: function() {
        return this._pressCancel;
    },
    set: function(value) {
        this._pressCancel = this.exitItem.pressOk = value;
    },
	configurable: true
});

Sprite_Option.prototype.findConfigItemIndex = function(item) {
	let idx = 0;
	for(const i of item.items) {
		if(i.para === this.readInitVal(item)) {
			return idx;
		}
		idx++;
	}
	return -1;
};

Sprite_Option.prototype.readInitVal = function(item) {
	if(typeof item.init === "function") {
		return item.init();
	} else {
		return ConfigManager[item.init];
	}
};

Sprite_Option.prototype.resetItemNamePosition = function() {
	let idx = 0;
	for(const item of this._itemsPage.children) {
		if(idx <= this._pageStartIndex) {
			item.nameSprite.x = this._pageItemXLayout[0];
		} else if(idx >= this._pageStartIndex + this._pageMaxNum - 1) {
			item.nameSprite.x = this._pageItemXLayout[this._pageMaxNum - 1];
		}
		else {
			item.nameSprite.x = this._pageItemXLayout[idx - this._pageStartIndex];
		}
		idx += item.cellNum();
	}
};

Sprite_Option.prototype.moveItemNamePosition = function() {
	let idx = 0;
	const controller = this._animation;
	for(const item of this._itemsPage.children) {
		let x = 0;
		if(idx <= this._pageStartIndex) {
			x = this._pageItemXLayout[0];
		} else if(idx >= this._pageStartIndex + this._pageMaxNum - 1) {
			x = this._pageItemXLayout[this._pageMaxNum - 1];
		}
		else {
			x = this._pageItemXLayout[idx - this._pageStartIndex];
		}
		controller.clear(item.nameSprite);
		controller.add(item.nameSprite, {data:[
			{to:x, property:'x', easingType:'easeOutQuart', duration:25}
		]});
		idx += item.cellNum();
	}
};

Sprite_Option.prototype.cursorY = function() {
	return this._frameMinY + (this.selectCellNum() - this._pageStartIndex + 0.5) * this.scrollY();
};

Sprite_Option.prototype.selectCellNum = function() {
	let idx = 0;
	for(let i = 0; i < this._selectedItemIndex; i++) {
		idx += this._itemsPage.children[i].cellNum();
	}
	return idx;
};

Sprite_Option.prototype.allCellNum = function() {
	let idx = 0;
	for(let i = 0; i < this._itemsPage.children.length; i++) {
		idx += this._itemsPage.children[i].cellNum();
	}
	return idx;
};

Sprite_Option.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active && !this._preventInputForThisFrame) {
		this.updateInput();
		this.updateTouchInput();
	}
	this._preventInputForThisFrame = false;
	this._animation.update();
};

Sprite_Option.prototype.active = function() {
	this._active = true;
	this._preventInputForThisFrame = true;
	this.refreshChildActive();
};

Sprite_Option.prototype.deactive = function() {
	this._active = false;
	this.refreshChildActive();
};

Sprite_Option.prototype.updateInput = function() {
	if(Input.isUITriggered('up') && this._selectedItemIndex > 0) {
		SoundManager.playCursor();
		this._selectedItemIndex--;
		this.movePageCursor();
		this.refreshChildActive();
	}
	if(Input.isUITriggered('down') && this._selectedItemIndex < this._itemsPage.children.length - 1) {
		SoundManager.playCursor();
		this._selectedItemIndex++;
		this.movePageCursor();
		this.refreshChildActive();
	}
	if(Input.isUITriggered('cancel') && this.pressCancel) {
		SoundManager.playCancel();
		this.pressCancel();
	}
};

Sprite_Option.prototype.updateTouchInput = function() {
	if(TouchInput.isPressed() && TouchInput.moved) {
		if(!this._isDragging) {
			this._dragStartY = this._itemsPage.y;
			this._dragSelectCellOffset = this.selectCellNum() - this._pageStartIndex;
			this._isDragging = true;
		} else {
			this._itemsPage.y = this._dragStartY + TouchInput.moveDeltaY;
		}
	} else {
		if(this._isDragging) {
			this.findDragNearest();
			this.performPageMove();
			this.moveCursor();
			this.refreshChildActive();
			this._isDragging = false;
		} else if(TouchInput.isClicked()) {
			if(this._cancelSprite.isBeingTouched()) {
				SoundManager.playCancel();
				this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
				this.pressCancel();
				return;
			}
			let idx = 0;
			const idxReverse = this._selectedItemIndex;
			for(const sprite of this._itemsPage.children) {
				if(sprite.isBeingTouched()) {
					this._selectedItemIndex = idx;
					break;
				}
				idx++;
			}
			const cellNum = this.selectCellNum();
			if(cellNum >= this.pageMinIndex() && cellNum <= this.pageMaxIndex()) {
				this.moveCursor();
				this.refreshChildActive();
			} else {
				this._selectedItemIndex = idxReverse;
			}
		}
	}
	if(TouchInput.isPressed()) {
		if(this._cancelSprite.isBeingTouched()) {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel_press");
		} else {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
		}
	} else if(TouchInput.isReleased()) {
		this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
	}
};

Sprite_Option.prototype.findDragNearest = function() {
	this._pageStartIndex = Math.round(-this._itemsPage.y / this.scrollY());
	const minIndex = 0;
	const maxIndex = this.allCellNum() - this._pageMaxNum;
	this._pageStartIndex = this._pageStartIndex.clamp(minIndex, maxIndex);
	const selectCellNum = this._pageStartIndex + this._dragSelectCellOffset;
	let minDistance = -1;
	let bestSelectIndex = 0;
	for(let i = 0; i < this._itemsPage.children.length; i++) {
		this._selectedItemIndex = i;
		const currSelectCellNum = this.selectCellNum();
		const distance = Math.abs(currSelectCellNum - selectCellNum);
		if((minDistance === -1 || distance < minDistance) && currSelectCellNum >= this.pageMinIndex() && currSelectCellNum <= this.pageMaxIndex()) {
			minDistance = distance;
			bestSelectIndex = i;
		}
	}
	this._selectedItemIndex = bestSelectIndex;
};

Sprite_Option.prototype.movePageCursor = function() {
	this.checkPageMove();
	this.moveCursor();
};

Sprite_Option.prototype.moveCursor = function() {
	const controller = this._animation;
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, {data:[
		{to:this.cursorY(),easingType:'easeOutQuart', property:'y',duration:25}
	]});
	
	this.updateMoveSign();
};

Sprite_Option.prototype.updateMoveSign = function() {
	if(this._pageStartIndex === 0) {
		this._moveSignUp.visible = false;
	} else {
		this._moveSignUp.visible = true;
	}
	if(this._pageStartIndex >= this.allCellNum() - this._pageMaxNum) {
		this._moveSignDown.visible = false;
	} else {
		this._moveSignDown.visible = true;
	}
};

Sprite_Option.prototype.pageMinIndex = function() {
	return this._pageStartIndex;
};

Sprite_Option.prototype.pageMaxIndex = function() {
	return this.pageMinIndex() + this._pageMaxNum - 1;
};

Sprite_Option.prototype.checkPageMove = function() {
	const minIndex = this.pageMinIndex();
	const maxIndex = this.pageMaxIndex();
	let animated = false;
	const selectCellNum = this.selectCellNum();
	const selectedSprite = this._itemsPage.children[this._selectedItemIndex];
	if(selectCellNum < minIndex) {
		this._pageStartIndex = selectCellNum;
		animated = true;
	}
	else if(selectCellNum > maxIndex) {
		this._pageStartIndex = selectCellNum - this._pageMaxNum + 1;
		animated = true;
	}
	if(animated) {
		this.performPageMove();
	}
};

Sprite_Option.prototype.performPageMove = function() {
	const controller = this._animation;
	controller.clear(this._itemsPage);
	controller.add(this._itemsPage, {data:[
		{to:this.calcPageY(),easingType:'easeOutQuart', property:'y',duration:25}
	]});
};

Sprite_Option.prototype.moveCursorToTop = function() {
	this.topPage();
	this.moveCursor();
};

Sprite_Option.prototype.topPage = function() {
	const controller = this._animation;
	const selectCellNum = this.selectCellNum();
	this._pageStartIndex = selectCellNum;
	controller.clear(this._itemsPage);
	controller.add(this._itemsPage, {data:[
		{to:this.calcPageY(),easingType:'easeOutQuart', property:'y',duration:25}
	]});
};

Sprite_Option.prototype.calcPageY = function() {
	return -this._pageStartIndex * this.scrollY();
};

Sprite_Option.prototype.refreshChildActive = function() {
	let idx = 0;
	let cell = 0;
	for(const item of this._itemsPage.children) {
		if(idx === this._selectedItemIndex && this._active) {
			item.active();
		} else {
			item.deactive();
		}
		if(cell >= this.pageMinIndex() && cell <= this.pageMaxIndex()) {
			item.touchActive();
		} else {
			item.touchDeactive();
		}
		idx++;
		cell += item.cellNum();
	}
};

Sprite_Option.prototype.destroy = function() {
	Sprite.prototype.destroy.apply(this, arguments);
	ConfigManager.clearExternalChangeHandler();
	ConfigManager.setDisplayModeErrorHandler(undefined);
};

function Sprite_OptionBase() {
	this.initialize(...arguments);
}

Sprite_OptionBase.prototype = Object.create(Sprite.prototype);
Sprite_OptionBase.prototype.constructor = Sprite_OptionBase;

Sprite_OptionBase.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._name = options.name;
	this.item = options.item;
	this._selectedColor = options.selectedColor;
	this._selectedOutlineColor = options.selectedOutlineColor;
	this._selectedOutlineWidth = options.selectedOutlineWidth;
	this._textColor = options.textColor;
	this._textSize = options.textSize;
	this._allHeight = options.scrollY;
	this._active = false;
	this._touchActive = false;
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this.createName();
};

Sprite_OptionBase.prototype.cellNum = function() {
	return 1;
};

Sprite_OptionBase.prototype.allWidth = function() {
	return Graphics.width;
};

Sprite_OptionBase.prototype.allHeight = function() {
	return this._allHeight;
};

Sprite_OptionBase.prototype.hitTestWidth = function() {
	return this.allWidth();
};

Sprite_OptionBase.prototype.hitTestHeight = function() {
	return this.allHeight() * this.cellNum();
};

Sprite_OptionBase.prototype.createName = function() {
	this._activeNameBitmap = new Bitmap(this.allWidth(), this.allHeight());
	this._activeNameBitmap.outlineWidth = this._selectedOutlineWidth;
	this._activeNameBitmap.outlineColor = this._selectedOutlineColor;
	this._activeNameBitmap.textColor = this._selectedColor;
	this._deactiveNameBitmap = new Bitmap(this.allWidth(), this.allHeight());
	this._activeNameBitmap.fontSize = this._deactiveNameBitmap.fontSize = this._textSize;
	this._deactiveNameBitmap.outlineWidth = 0;
	this._deactiveNameBitmap.textColor = this._textColor;
	
	this.refreshName();
	
	this.activeSprite = new Sprite(this._activeNameBitmap);
	this.deactiveSprite = new Sprite(this._deactiveNameBitmap);
	
	this.nameSprite = new Sprite();
	
	this.nameSprite.addChild(this.activeSprite);
	this.nameSprite.addChild(this.deactiveSprite);
	this.addChild(this.nameSprite);
	
	this.refreshNameVisible();
};

Sprite_OptionBase.prototype.refreshName = function() {
	const activeY = (this.allHeight() - (this._textSize + this._selectedOutlineWidth * 2)) / 2;
	const deactiveY = (this.allHeight() - this._textSize) / 2;
	const activeX = 0;
	const deactiveX = this._selectedOutlineWidth;
	
	this._activeNameBitmap.clear();
	this._deactiveNameBitmap.clear();
	this._activeNameBitmap.drawText(TextManager[this._name], activeX, activeY, this.allWidth(), this._textSize, 'left');
	this._deactiveNameBitmap.drawText(TextManager[this._name], deactiveX, deactiveY, this.allWidth(), this._textSize, 'left');
};

Sprite_OptionBase.prototype.onLanguageChange = function() {
	this.refreshName();
};

Sprite_OptionBase.prototype.active = function() {
	if(!this._active) {
		this._active = true;
		this.refreshNameVisible();
	}
};

Sprite_OptionBase.prototype.deactive = function() {
	if(this._active) {
		this._active = false;
		this.refreshNameVisible();
	}
};

Sprite_OptionBase.prototype.touchActive = function() {
	this._touchActive = true;
};

Sprite_OptionBase.prototype.touchDeactive = function() {
	this._touchActive = false;
};

Sprite_OptionBase.prototype.refreshNameVisible = function() {
	this.activeSprite.visible = this._active;
	this.deactiveSprite.visible = !this._active;
};

Sprite_OptionBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active) {
		this.updateInput();
	}
	if(this._touchActive) {
		this.updateTouchInput();
	}
};

Sprite_OptionBase.prototype.updateInput = function() {
};

Sprite_OptionBase.prototype.updateTouchInput = function() {
};

function Sprite_SingleSelect() {
	this.initialize(...arguments);
}

Sprite_SingleSelect.prototype = Object.create(Sprite_OptionBase.prototype);
Sprite_SingleSelect.prototype.constructor = Sprite_SingleSelect;

Sprite_SingleSelect.prototype.initialize = function(options) {
	Sprite_OptionBase.prototype.initialize.apply(this, arguments);
	this._items = options.items;
	this._buttonStartX = options.buttonStartX;
	this._buttonEndX = options.buttonEndX;
	this._buttonSelectedName = options.buttonSelectedName;
	this._buttonUnselectedName = options.buttonUnselectedName;
	this._buttonTextMargin = options.buttonTextMargin;
	this._selectedItemIndex = -1;
	this._externalChange = false;
	this.createAllItems();
};

Sprite_SingleSelect.prototype.setExternalChange = function(val) {
	this._externalChange = true;		// 该对象不主动修改自己的selectedItemIndex，只会调用callback让外部修改自己的该对象不主动修改自己的selectedItemIndex
};

Sprite_SingleSelect.prototype.itemHeight = function() {
	const buttonBitmap = ImageManager.loadUI(this._buttonSelectedName);
	return Math.max(buttonBitmap.height, Sprite_OptionBase.prototype.allHeight.call(this));
};

Sprite_SingleSelect.prototype.itemWidth = function() {
	return (this._buttonEndX - this._buttonStartX) / this._items.length;
};

Sprite_SingleSelect.prototype.itemX = function(idx) {
	return this._buttonStartX + idx * this.itemWidth();
};

Sprite_SingleSelect.prototype.itemY = function(idx) {
	return 0;
};
Sprite_SingleSelect.prototype.setSelectedItem = function(idxSelected, isCallback = true) {
	if(this._selectedItemIndex != idxSelected) {
		this._selectedItemIndex = idxSelected;
		let idx = 0;
		for(const sprite of this._baseSprite.children) {
			if(this._selectedItemIndex === idx) {
				sprite.children[1].visible = false;
				sprite.children[0].visible = true;
			} else {
				sprite.children[0].visible = false;
				sprite.children[1].visible = true;
			}
			idx++;
		}
		if(isCallback) { this.callback(idxSelected); }
	}
};

Sprite_SingleSelect.prototype.createAllItems = function() {
	const items = this._items;
	let idx = 0;
	for(const item of items) {
		const bitmap = new Bitmap(this.itemWidth(), this.itemHeight());
		const itemSprite = new Sprite(bitmap);
		const buttonSelected = new Sprite(ImageManager.loadUI(this._buttonSelectedName));
		const buttonUnselected = new Sprite(ImageManager.loadUI(this._buttonUnselectedName));
		if(this._selectedItemIndex === idx) {
			buttonUnselected.visible = false;
		} else {
			buttonSelected.visible = false;
		}
		buttonSelected.y = (bitmap.height - buttonSelected.height) / 2;
		buttonUnselected.y = (bitmap.height - buttonUnselected.height) / 2;
		
		bitmap.outlineWidth = 0;
		bitmap.textColor = this._textColor;
		bitmap.fontSize = this._textSize;
		
		itemSprite.addChild(buttonSelected);
		itemSprite.addChild(buttonUnselected);
		
		itemSprite._buttonSelected = buttonSelected;
		itemSprite._buttonUnselected = buttonUnselected;
		
		itemSprite.x = this.itemX(idx);
		itemSprite.y = this.itemY(idx);
		
		this._baseSprite.addChild(itemSprite);
		idx++;
	}
	this.refreshItemText();
};

Sprite_SingleSelect.prototype.onSelectedChange = function(idx) {
	if(this._externalChange) {
		this.callback(idx);
	} else {
		this.setSelectedItem(idx);
	}
};

Sprite_SingleSelect.prototype.updateInput = function() {
	const idx = this._selectedItemIndex;
	if(Input.isUITriggered('left') && idx > 0) {
		SoundManager.playCursor();
		this.onSelectedChange(idx - 1);
	}
	if(Input.isUITriggered('right') && idx < this._items.length - 1) {
		SoundManager.playCursor();
		this.onSelectedChange(idx + 1);
	}
	if(Input.isUITriggered('ok')) {
		if(idx === this._items.length - 1) {
			SoundManager.playOk();
			this.onSelectedChange(0);
		} else {
			SoundManager.playOk();
			this.onSelectedChange(idx + 1);
		}
	}
};

Sprite_SingleSelect.prototype.updateTouchInput = function() {
	if(TouchInput.isClicked()) {
		let idx = 0;
		for(const sprite of this._baseSprite.children) {
			if(sprite._buttonSelected.isBeingTouched(false) || sprite._buttonUnselected.isBeingTouched(false) || sprite.isBeingTouched(false)) {
				SoundManager.playCursor();
				this.onSelectedChange(idx);
				break;
			}
			idx++;
		}
	}
};

Sprite_SingleSelect.prototype.onLanguageChange = function() {
	Sprite_OptionBase.prototype.onLanguageChange.call(this);
	this.refreshItemText();
};

Sprite_SingleSelect.prototype.refreshItemText = function() {
	const items = this._items;
	let i = 0;
	for(const item of items) {
		const sprite = this._baseSprite.children[i];
		const bitmap = sprite.bitmap;
		bitmap.clear();
		const buttonSelected = sprite._buttonSelected;
		const buttonUnselected = sprite._buttonUnselected;
		const textX = buttonSelected.width + this._buttonTextMargin;
		const textY = (bitmap.height - this._textSize) / 2;
		const text = item.name ? TextManager[item.name] : item.para;
		bitmap.drawText(text, textX, textY, bitmap.width - textX, this._textSize, 'left');
		i++;
	}
};

function Sprite_ProgressSelect() {
	this.initialize(...arguments);
}

Sprite_ProgressSelect.prototype = Object.create(Sprite_OptionBase.prototype);
Sprite_ProgressSelect.prototype.constructor = Sprite_ProgressSelect;

Sprite_ProgressSelect.prototype.initialize = function(options) {
	Sprite_OptionBase.prototype.initialize.apply(this, arguments);
	this._progressStartX = options.progressStartX;
	this._progressCursorName = options.progressCursorName;
	this._progressTextMargin = options.progressTextMargin;
	this._cursorOffsetX = options.cursorOffsetX;
	this._cursorIndentX = options.cursorIndentX;
	this._isDragging = false;
	this.createProgress(options.progress);
	this.createProgressCursor();
	this.createProgressText();
};

Sprite_ProgressSelect.prototype.createProgress = function(options) {
	options.tilingSpeed = 0;
	this._progress = new Sprite_Progress(options);
	this._progress.x = this._progressStartX;
	this._progress.y = (this.allHeight() - this._progress.progressHeight()) / 2 - this._progress.progressSprite.y;
	this._baseSprite.addChild(this._progress);
};

Sprite_ProgressSelect.prototype.createProgressCursor = function() {
	const cursorBitmap = ImageManager.loadUI(this._progressCursorName);
	this._progressCursor = new Sprite(cursorBitmap);
	this._progressCursor.anchor.x = 0.5;
	this._progressCursor.anchor.y = 0.5;
	this._progressCursor.y = this.allHeight() / 2;
	this._baseSprite.addChild(this._progressCursor);
	this.updateProgressCursor();
};

Sprite_ProgressSelect.prototype.delta = function() {
	return 0.05;
};

Sprite_ProgressSelect.prototype.update = function() {
	Sprite_OptionBase.prototype.update.call(this);
	this.updateProgressCursor();
};

Sprite_ProgressSelect.prototype.updateProgressCursor = function() {
	this._progressCursor.x = this._progressStartX + this._cursorOffsetX + this._progress.progress * (this._progress.progressWidth() + this._cursorIndentX);
};

Sprite_ProgressSelect.prototype.updateInput = function() {
	if(Input.isUITriggered('ok')) {
		SoundManager.playCursor();
		if(this.progress === 1) {
			this.progress = 0;
		}			
		else if(this.progress > 1 - this.delta()) {
			this.progress = 1;
		}
		else {
			this.progress += this.delta();
		}
	}
	if(Input.isTriggered('left') || Input.isLongPressed('left') && this.progress > 0) {
		SoundManager.playCursor();
		this.progress = Math.max(0, this.progress - this.delta());
	}
	if(Input.isTriggered('right') || Input.isLongPressed('right') && this.progress < 1) {
		SoundManager.playCursor();
		this.progress = Math.min(1, this.progress + this.delta());
	}
	this.callback(this.progress);
};

Object.defineProperty(Sprite_ProgressSelect.prototype, "progress", {
	get: function() {
        return this._progress.progress;
    },
    set: function(value) {
        this._progress.progress = value;
		this.refreshProgressText();
    },
	configurable: true
});

Sprite_ProgressSelect.prototype.createProgressText = function() {
	this.progressTextBitmap = new Bitmap(this.allWidth(), this.allHeight());
	this.progressTextBitmap.fontSize = this._textSize;
	this.progressTextBitmap.textColor = this._textColor;
	this.progressTextBitmap.outlineWidth = 0;
	const textSprite = new Sprite(this.progressTextBitmap);
	textSprite.x = this._progressStartX + this._progress.progressWidth() + this._progressTextMargin;
	this._baseSprite.addChild(textSprite);
	this.refreshProgressText();
};

Sprite_ProgressSelect.prototype.refreshProgressText = function() {
	this.progressTextBitmap.clear();
	const percent = Math.round(this.progress * 100);
	
	this.progressTextBitmap.drawText(percent.toString() + "%", 0, 0, this.allWidth(), this.allHeight(), 'left');
};

Sprite_ProgressSelect.prototype.updateTouchInput = function() {
	if(TouchInput.isPressed() && this._progress.isBeingTouched()) {
		this._isDragging = true;
	}
	if(!TouchInput.isPressed() && this._isDragging) {
		this._isDragging = false;
		this.refreshProgressText();
	}
	if(this._isDragging) {
		const touchPos = new Point(TouchInput.x, TouchInput.y);
		const localPos = this._progress._progressContentSprite.worldTransform.applyInverse(touchPos);
		const width = this._progress.progressWidth();
		this._progress.progress = (localPos.x / width).clamp(0, 1);
		this.callback(this.progress);
	}
};

function Sprite_Switch() {
	this.initialize(...arguments);
}

Sprite_Switch.prototype = Object.create(Sprite_OptionBase.prototype);
Sprite_Switch.prototype.constructor = Sprite_Switch;

Sprite_Switch.prototype.initialize = function(options) {
	Sprite_OptionBase.prototype.initialize.call(this, options);
	this._onText = options.onText;
	this._offText = options.offText;
	this._switchButtonName = options.switchButtonName;
	this._switchPadName = options.switchPadName;
	this._switchStartX = options.switchStartX;
	this._switchTextMargin = options.switchTextMargin;
	this._on = options.on;
	this._animation = new AnimationController();
	this.createAllItems();
	this._baseSprite.x = this._switchStartX;
};

Sprite_Switch.prototype.createAllItems = function() {
	const textBitmap = new Bitmap(this.allWidth(), this.allHeight());
	textBitmap.fontSize = this._textSize;
	textBitmap.textColor = this._textColor;
	textBitmap.outlineWidth = 0;
	this._textBitmap = textBitmap;
	
	const textSprite = new Sprite(textBitmap);
	this._baseSprite.addChild(textSprite);
	
	const switchPadBitmap = ImageManager.loadUI(this._switchPadName);
	const switchSprite = new Sprite(switchPadBitmap);
	const switchButtonBitmap = ImageManager.loadUI(this._switchButtonName);
	
	const onWidth = this.refreshItemText();
	switchSprite.x = onWidth + this._switchTextMargin;
	switchSprite.y = (this.allHeight() - switchPadBitmap.height) / 2;
	
	this._switchButtonSprite = new Sprite(switchButtonBitmap);
	this._switchButtonSprite.y = (switchPadBitmap.height - switchButtonBitmap.height) / 2;
	switchSprite.addChild(this._switchButtonSprite);
	
	this._onX = 0;
	this._offX = switchPadBitmap.width - switchButtonBitmap.width
	
	this._baseSprite.addChild(switchSprite);
	if(this.on) {
		this._switchButtonSprite.x = this._onX;
	} else {
		this._switchButtonSprite.x = this._offX;
	}
};

Sprite_Switch.prototype.setOnOffText = function(onText, offText) {
	this._onText = onText;
	this._offText = offText;
};

Sprite_Switch.prototype.refreshItemText = function() {
	const textBitmap = this._textBitmap;
	textBitmap.clear();
	const textY = (this.allHeight() - this._textSize) / 2;
	textBitmap.drawText(TextManager[this._onText], 0, textY, this.allWidth(), this._textSize);
	const switchPadBitmap = ImageManager.loadUI(this._switchPadName);
	const onWidth = textBitmap.measureTextWidth(TextManager[this._onText]);
	
	textBitmap.drawText(TextManager[this._offText], onWidth + this._switchTextMargin * 2 + switchPadBitmap.width
	, textY, this.allWidth(), this._textSize);
	
	return onWidth;
};

Sprite_Switch.prototype.onLanguageChange = function() {
	Sprite_OptionBase.prototype.onLanguageChange.call(this);
	this.refreshItemText();
};

Object.defineProperty(Sprite_Switch.prototype, "on", {
	get: function() {
        return this._on;
    },
    set: function(value) {
        this._on = value;
		this.performChange();
    },
	configurable: true
});

Sprite_Switch.prototype.performChange = function() {
	const controller = this._animation;
	controller.clear(this._switchButtonSprite);
	const target = this.on ? this._onX : this._offX;
	controller.add(this._switchButtonSprite, {data:[
		{to:target,property:'x',easingType:'linear',duration:9}
	],loop:false});
};

Sprite_Switch.prototype.update = function() {
	Sprite_OptionBase.prototype.update.call(this);
	this._animation.update();
};

Sprite_Switch.prototype.updateInput = function() {
	if(Input.isUITriggered('ok')) {
		SoundManager.playCursor();
		this.on = !this.on;
		this.callback(this.on);
	}
	if(Input.isUITriggered('left') && !this.on) {
		SoundManager.playCursor();
		this.on = true;
		this.callback(this.on);
	}
	if(Input.isUITriggered('right') && this.on) {
		SoundManager.playCursor();
		this.on = false;
		this.callback(this.on);
	}
};

Sprite_Switch.prototype.updateTouchInput = function() {
	if(TouchInput.isClicked()) {
		if(this._baseSprite.children[1].isBeingTouched(false)) {
			SoundManager.playCursor();
			this.on = !this.on;
			this.callback(this.on);
		}
	}
};

function Sprite_ButtonSelect() {
	this.initialize(...arguments);
}

Sprite_ButtonSelect.prototype = Object.create(Sprite_OptionBase.prototype);
Sprite_ButtonSelect.prototype.constructor = Sprite_ButtonSelect;

Sprite_ButtonSelect.prototype.initialize = function(options) {
	Sprite_OptionBase.prototype.initialize.call(this, options);
	this.pressOk = null;
};

Sprite_ButtonSelect.prototype.updateInput = function() {
	if(Input.isUITriggered('ok') && this.pressOk) {
		SoundManager.playCursor();
		this.pressOk();
	}
};

Sprite_ButtonSelect.prototype.updateTouchInput = function() {
	if(TouchInput.isClicked() && this.isBeingTouched(false)) {
		SoundManager.playCursor();
		this.pressOk();
	}
};

function KeyConfigItem() {
	this.initialize(...arguments);
}

KeyConfigItem.allItems = function() {
	return [
		new KeyConfigItem('up')
		, new KeyConfigItem('down')
		, new KeyConfigItem('left')
		, new KeyConfigItem('right')
		, new KeyConfigItem('ok')
		, new KeyConfigItem('cancel')
		, new KeyConfigItem('bullet')
		, new KeyConfigItem('subattack')
		, new KeyConfigItem('zxc')
		, new KeyConfigItem('menu')
		, new KeyConfigItem('item')
		, new KeyConfigItem('cfish')
		, new KeyConfigItem('save')
		, new KeyConfigItem('nsave')
	];
};

KeyConfigItem.prototype.initialize = function(name) {
	this._name = name;
};

KeyConfigItem.prototype.getDisplayName = function() {
	switch(this._name) {
		case 'ok' : return ConfigManager.attackBindingCancel ? TextManager.STATIC_TEXT_BUTTON_OK : TextManager.STATIC_TEXT_BUTTON_OK_REV;
		case 'cancel': return ConfigManager.attackBindingCancel ? TextManager.STATIC_TEXT_BUTTON_CANCEL : TextManager.STATIC_TEXT_BUTTON_CANCEL_REV;
		case 'up': return TextManager.STATIC_TEXT_BUTTON_UP;
		case 'down': return TextManager.STATIC_TEXT_BUTTON_DOWN;
		case 'left': return TextManager.STATIC_TEXT_BUTTON_LEFT;
		case 'right': return TextManager.STATIC_TEXT_BUTTON_RIGHT;
		case 'bullet': return TextManager.STATIC_TEXT_BUTTON_BULLET;
		case 'zxc': return TextManager.STATIC_TEXT_BUTTON_ZXC;
		case 'menu': return TextManager.STATIC_TEXT_BUTTON_MENU;
		case 'item': return TextManager.STATIC_TEXT_BUTTON_ITEM;
		case 'cfish': return TextManager.STATIC_TEXT_BUTTON_CHANGE_FISH;
		case 'subattack': return TextManager.STATIC_TEXT_BUTTON_SUB_ATTACK;
		case 'save': return TextManager.STATIC_TEXT_BUTTON_SAVE;
		case 'nsave': return TextManager.STATIC_TEXT_BUTTON_NOT_SAVE;
		default: return null;
	}
};

KeyConfigItem.prototype.getKeyCode = function() {
	return ConfigManager._tmpKeyMapper[this._name] !== undefined ? ConfigManager._tmpKeyMapper[this._name] : this.getMapperCode(Input.keyMapper);
};

KeyConfigItem.prototype.getMapperCode = function(mapper) {
	return ConfigManager.getInputNameInternal(this._name, mapper);
};

KeyConfigItem.prototype.getGamepadCode = function() {
	return ConfigManager._tmpGamepadMapper[this._name] !== undefined ? ConfigManager._tmpGamepadMapper[this._name] : this.getMapperCode(Input.gamepadMapper);
};

KeyConfigItem.prototype.setKeyCode = function(code) {
	ConfigManager._tmpKeyMapper[this._name] = code;
};

KeyConfigItem.prototype.setGamepadCode = function(code) {
	ConfigManager._tmpGamepadMapper[this._name] = code;
};

KeyConfigItem.prototype.getCodeName = function() {
	return this.getKeyCodeName() + "/" + this.getGamepadCodeName();
};

KeyConfigItem.prototype.getKeyCodeName = function() {
	const name = keyCode(this.getKeyCode());
	if(name) {
		return name.toUpperCase();
	}
	return '';
};

KeyConfigItem.prototype.getGamepadCodeName = function() {
	const code = this.getGamepadCode();
	return ConfigManager.getGamepadInputName(code);
};

KeyConfigItem.prototype.name = function() {
	return this._name;
};

function Sprite_ControlSetting() {
	this.initialize(...arguments);
}

Sprite_ControlSetting.prototype = Object.create(Sprite_OptionBase.prototype);
Sprite_ControlSetting.prototype.constructor = Sprite_ButtonSelect;

Sprite_ControlSetting.prototype.initialize = function(options) {
	Sprite_OptionBase.prototype.initialize.call(this, options);
	this._pageMaxNum = options.pageMaxNum;
	this._deactiveParent = options.deactiveParent;
	this._activeParent = options.activeParent;
	this._cursorName = options.cursorName;
	this._startX = options.startX;
	this._itemWidth = options.itemWidth;
	this._itemMargin = options.itemMargin;
	this._confirmExit = options.confirmExit;
	this._tipsSave = options.tipsSave;
	
	this._items = KeyConfigItem.allItems();
	this._selectIndex = 0;
	this._innerActive = false;
	this._itemSprite = new Sprite();
	this._currentInputIndex = -1;
	this._currentInputFlash = 0;
	this._mode = Input.getMode();
	this._animation = new AnimationController();
	this.addChild(this._itemSprite);
	this.createCursor();
	this.createAllItems();
};

Sprite_ControlSetting.prototype.itemX = function(x) {
	return this._startX + this._itemWidth * x + this._itemMargin * x;
};

Sprite_ControlSetting.prototype.itemY = function(y) {
	return this.allHeight() * y;
};

Sprite_ControlSetting.prototype.selectX = function() {
	return this._selectIndex % this._pageMaxNum;
};

Sprite_ControlSetting.prototype.selectY = function() {
	return Math.trunc(this._selectIndex / this._pageMaxNum);
};

Sprite_ControlSetting.prototype.createAllItems = function() {
	let x = 0;
	let y = 0;
	let idx = 0;
	for(const item of this._items) {
		const bitmap = new Bitmap(this._itemWidth, this.allHeight());
		const sprite = new Sprite(bitmap);
		bitmap.outlineWidth = 0;
		bitmap.textColor = this._textColor;
		bitmap.fontSize = this._textSize - 6;
		this.createItemContents(item, bitmap, idx);
		sprite.item = item;
		sprite.x = this.itemX(x);
		sprite.y = this.itemY(y);
		this._itemSprite.addChild(sprite);
		x++;
		idx++;
		if(x >= this._pageMaxNum) {
			x = 0;
			y++;
		}
	}
};

Sprite_ControlSetting.prototype.cellNum = function() {
	return Math.ceil(this._items.length / this._pageMaxNum);
};

Sprite_ControlSetting.prototype.cursorWidth = function() {
	return this._cursorSprite.width;
};

Sprite_ControlSetting.prototype.createItemContents = function(item, bitmap, idx) {
	bitmap.clear();
	const y = (bitmap.height - bitmap.fontSize) / 2;
	bitmap.drawText(item.getDisplayName(), 0, y, this.cursorWidth(), bitmap.fontSize, 'center');
	if(item.name() === 'save' || item.name() === 'nsave') {
		return;
	}
	const keyName = this._mode === 'button' ? item.getKeyCodeName() : item.getGamepadCodeName();
	bitmap.drawText(keyName, 0, y, bitmap.width, bitmap.fontSize, 'right');
	if(this._currentInputIndex === idx) {
		if(Math.trunc(this._currentInputFlash / 35) % 2 === 0) {
			bitmap.drawText(this.duplicate("_", keyName), 0, y, bitmap.width, bitmap.fontSize, 'right');
		}
	}
};

Sprite_ControlSetting.prototype.duplicate = function(str, n) {
	let res = "";
	for(let i = 0; i < n.length; i++) {
		res += str;
	}
	return res;
};

Sprite_ControlSetting.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this._cursorSprite.anchor.y = 0.5;
	this._cursorSprite.x = this.cursorX();
	this._cursorSprite.y = this.cursorY();
	this._baseSprite.addChild(this._cursorSprite);
};

Sprite_ControlSetting.prototype.cursorX = function() {
	return this._startX + this.selectX() * (this._itemWidth + this._itemMargin);
};

Sprite_ControlSetting.prototype.cursorY = function() {
	return (this.selectY() + 0.5) * this.allHeight();
};

Sprite_ControlSetting.prototype.selectedSprite = function() {
	return this._itemSprite.children[this._selectIndex];
};

Sprite_ControlSetting.prototype.inputedSprite = function() {
	return this._itemSprite[this._currentInputIndex];
};

Sprite_ControlSetting.prototype.update = function() {
	Sprite_OptionBase.prototype.update.call(this);
	this._animation.update();
	this._cursorSprite.visible = this._innerActive;
	this.updateCursor();
	this.updateKeyConfig();
	this.updateInputMode();
};

Sprite_ControlSetting.prototype.updateInputMode = function() {
	if(this._mode !== Input.getMode()) {
		this._mode = Input.getMode();
		this.refreshAllConfig();
	}
};

Sprite_ControlSetting.prototype.updateInput = function() {
	if(Input.isUITriggered('ok') && !this._innerActive) {
		SoundManager.playOk();
		this._deactiveParent();
		this._innerActive = true;
		this._currentInputIndex = -1;
		ConfigManager.startRecordKeyConfig();
	}
};

Sprite_ControlSetting.prototype.onNotSave = function() {
	if(ConfigManager.isAnyModify()) {
		this._innerActive = false;
		this._confirmExit("STATIC_TEXT_CONTROL_SETTINGS_NOT_SAVE", this.onConfirmOk.bind(this), this.onConfirmCancel.bind(this));
	} else {
		ConfigManager.endRecordKeyConfig();
		this.refreshAllConfig();
		this._activeParent();
		this._innerActive = false;
	}
};

Sprite_ControlSetting.prototype.onSave = function() {
	if(ConfigManager.checkDuplicate()) {
		this._innerActive = false;
		this._tipsSave("STATIC_TEXT_CONTROL_SETTINGS_DUPLICATED", this.onConfirmCancel.bind(this));
	} else {
		ConfigManager.applyRecordKeyConfig();
		this._activeParent();
		this._innerActive = false;
	}
};

Sprite_ControlSetting.prototype.onConfirmOk = function() {
	ConfigManager.endRecordKeyConfig();
	this.refreshAllConfig();
	this._activeParent();
};

Sprite_ControlSetting.prototype.onConfirmCancel = function() {
	this._innerActive = true;
};

Sprite_ControlSetting.prototype.updateCursor = function() {
	if(this._innerActive && this._selectIndex !== -1 && this._currentInputIndex === -1) {
		if(Input.isUITriggered('ok')) {
			SoundManager.playOk();
			const item = this._items[this._selectIndex];
			if(item.name() === 'save') {
				this.onSave();
			} else if(item.name() === 'nsave') {
				this.onNotSave();
			} else {
				this._currentInputIndex = this._selectIndex;
				this._currentInputFlash = 0;
				Input.setLatestGamepadCodeTriggered();
				Input.setLatestButtonCodeTriggered();
			}
		}
		if(Input.isUITriggered('cancel')) {
			SoundManager.playCancel();
			this.onNotSave();
		}
		if(Input.isUITriggered('left')) {
			SoundManager.playCursor();
			this.selectDelta(-1, 0);
		}
		if(Input.isUITriggered('right')) {
			SoundManager.playCursor();
			this.selectDelta(1, 0);
		}
		if(Input.isUITriggered('up')) {
			SoundManager.playCursor();
			this.selectDelta(0, -1);
		}
		if(Input.isUITriggered('down')) {
			SoundManager.playCursor();
			this.selectDelta(0, 1);
		}
	}
};

Sprite_ControlSetting.prototype.selectDelta = function(dx, dy) {
	const x = this.selectX();
	const y = this.selectY();
	const idx = this._selectIndex;
	this._selectIndex += dx;
	this._selectIndex += dy * this._pageMaxNum;
	if(this._selectIndex >= this._items.length || this._selectIndex < 0) {
		this._selectIndex = idx;
		return;
	}
	this.moveCursor();
};

Sprite_ControlSetting.prototype.moveCursor = function() {
	const controller = this._animation;
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, {data:[
		{to:this.cursorY(), property:'y', easingType:'easeOutQuart', duration:12}
	]});
	controller.add(this._cursorSprite, {data:[
		{to:this.cursorX(), property:'x', easingType:'easeOutQuart', duration:12}
	]});
};

Sprite_ControlSetting.prototype.updateKeyConfig = function() {
	if(this._currentInputIndex !== -1) {
		this._currentInputFlash++;
		const item = this._items[this._currentInputIndex];
		const code = Input.latestButtonCodeTriggered();
		if(code !== null) {
			ConfigManager.setKeyboard(code, item.name());
			this._currentInputIndex = -1;
			this.refreshSelectedConfig(item);
			return;
		}
		const padCode = Input.latestGamepadCodeTriggered();
		if(padCode !== null) {
			ConfigManager.setGamepad(padCode, item.name());
			this._currentInputIndex = -1;
			this.refreshSelectedConfig(item);
			return;
		}
		this.refreshSelectedConfig(item);
	}
};

Sprite_ControlSetting.prototype.refreshSelectedConfig = function(item) {
	const sprite = this.selectedSprite();
	this.createItemContents(item, sprite.bitmap, this._selectIndex);
};

Sprite_ControlSetting.prototype.refreshAllConfig = function() {
	for(let idx = 0; idx < this._items.length; idx++) {
		const item = this._items[idx];
		const sprite = this._itemSprite.children[idx];
		this.createItemContents(item, sprite.bitmap, idx);
	}
};

Sprite_ControlSetting.prototype.onLanguageChange = function() {
	Sprite_OptionBase.prototype.onLanguageChange.call(this);
	this.refreshAllConfig();
};


function Sprite_MenuCommand() {
	this.initialize(...arguments);
}

Sprite_MenuCommand.prototype = Object.create(Sprite.prototype);
Sprite_MenuCommand.prototype.constructor = Sprite_MenuCommand;

Sprite_MenuCommand.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._selectedCatName = options.selectedCatName;
	this._unselectedCatName = options.unselectedCatName;
	this._rotation = options.rotation;
	this._itemMargin = options.itemMargin;    // 选项上下间距
	this._textStartX = options.textStartX;   // 文字起始X
	this._textOffsetY = options.textOffsetY;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._selectedColor = options.selectedColor;
	this._selectedTextSize = options.selectedTextSize;
	this._selectedOutlineColor = options.selectedOutlineColor;
	this._selectedOutlineWidth = options.selectedOutlineWidth;
	this._selectedAnimitionHeight = options.selectedAnimitionHeight;
	this._items = options.items;
	this.pressCancel = null;
	
	this._animation = new AnimationController();
	this._selectIndex = 0;
	this.callItemSelected();
	this._active = this._touchActive = true;
	this.createAllItems();
	this.resetPanelPosition();
	//this.createColorShader();
};

Sprite_MenuCommand.prototype.createColorShader = function() {
	this.colorShader = new PIXI.filters.ColorMatrixFilter();
	this.colorShader.brightness(1);
	this.filters = [this.colorShader];
};

Sprite_MenuCommand.prototype.itemHeight = function() {
	return ImageManager.loadUI(this._selectedCatName).height;
};

Sprite_MenuCommand.prototype.createAllItems = function() {
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	let idx = 0;
	for(const item of this._items) {
		this.createItem(idx, item);
		item.panel.commandDeactive = this.deactive.bind(this);				// 触控点击后需要在禁用此对象的键盘焦点
		idx++;
	}
	this.updateCursor();
};

Sprite_MenuCommand.prototype.createItem = function(idx, item) {
	const itemSprite = new Sprite();
	const selected = new Sprite();
	this.createSelectedSprite(item, selected);
	const unselected = new Sprite();
	this.createUnselectedSprite(item, unselected);
	itemSprite.addChild(selected, unselected);
	itemSprite.selected = selected;
	itemSprite.unselected = unselected;
	itemSprite.y = idx * (this.itemHeight() + this._itemMargin);
	this.drawItem(itemSprite, item);
	this._baseSprite.addChild(itemSprite);
};

Sprite_MenuCommand.prototype.drawItem = function(sprite, item) {
	const textBitmap = sprite.selected.textBitmap;
	textBitmap.clear();
	textBitmap.drawText(TextManager[item.name], textBitmap.outlineWidth, (textBitmap.height - (textBitmap.fontSize + textBitmap.outlineWidth * 2)) / 2 + this._textOffsetY
	, textBitmap.width, textBitmap.fontSize, 'left');
	const textBitmap2 = sprite.unselected.textBitmap;
	textBitmap2.clear();
	textBitmap2.drawText(TextManager[item.name], 0, (textBitmap2.height - textBitmap2.fontSize) / 2 + this._textOffsetY, textBitmap2.width, textBitmap2.fontSize, 'left');
};

Sprite_MenuCommand.prototype.createSelectedSprite = function(item, sprite) {
	const bitmap = ImageManager.loadUI(this._selectedCatName);
	const cat = new Sprite(bitmap);
	const ubitmap = ImageManager.loadUI(this._unselectedCatName);
	cat.x = ubitmap.width - bitmap.width;
	cat.y = ubitmap.height - bitmap.height;
	
	const controller = this._animation;
	controller.add(cat, {data:[
		{to:cat.y + this._selectedAnimitionHeight, property:'y', easingType:'linear', duration:75}
		, {to:cat.y, property:'y', easingType:'linear', duration:75}
	], loop:true});
	
	const textBitmap = new Bitmap(120, this.itemHeight());
	textBitmap.fontSize = this._selectedTextSize;
	textBitmap.textColor = this._selectedColor;
	textBitmap.outlineWidth = this._selectedOutlineWidth;
	textBitmap.outlineColor = this._selectedOutlineColor;
	const textSprite = new Sprite(textBitmap);
	textSprite.x = this._textStartX;
	textSprite.rotation = this._rotation;
	sprite.addChild(cat);
	sprite.cat = cat;
	sprite.addChild(textSprite);
	sprite.textBitmap = textBitmap;
};

Sprite_MenuCommand.prototype.createUnselectedSprite = function(item, sprite) {
	const bitmap = ImageManager.loadUI(this._unselectedCatName);
	const cat = new Sprite(bitmap);
	cat.y = (this.itemHeight() - bitmap.height) / 2;
	
	const textBitmap = new Bitmap(120, this.itemHeight());
	textBitmap.fontSize = this._textSize;
	textBitmap.textColor = this._textColor;
	textBitmap.outlineWidth = 0;
	const textSprite = new Sprite(textBitmap);
	textSprite.x = this._textStartX;
	textSprite.rotation = this._rotation;
	sprite.addChild(cat);
	sprite.addChild(textSprite);
	sprite.textBitmap = textBitmap;
};

Sprite_MenuCommand.prototype.refreshItemText = function() {
	let idx = 0;
	for(const item of this._items) {
		const sprite = this._baseSprite.children[idx];
		this.drawItem(sprite, item);
		idx++;
	}
};

Sprite_MenuCommand.prototype.selectedItem = function() {
	return this._items[this._selectIndex];
};

Sprite_MenuCommand.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active) {
		this.updateInput();
	}
	if(this._touchActive) {
		this.updateTouchInput();
	}
	this._animation.update();
};

Sprite_MenuCommand.prototype.active = function() {
	this._active = true;
};

Sprite_MenuCommand.prototype.deactive = function() {
	this._active = false;
};

Sprite_MenuCommand.prototype.touchActive = function() {
	this._touchActive = true;
};

Sprite_MenuCommand.prototype.touchDeactive = function() {
	this._touchActive = false;
};

Sprite_MenuCommand.prototype.updateInput = function() {
	if(Input.isUITriggered('ok')) {
		const item = this.selectedItem();
		if(item && item.panel.selectable()) { 
			SoundManager.playOk();
			item.panel.active();
			this.deactive();
		}
	}
	if(Input.isUITriggered('up')) {
		SoundManager.playCursor();
		this.moveSelected(-1);
	}
	if(Input.isUITriggered('down')) {
		SoundManager.playCursor();
		this.moveSelected(1);
	}
	if((Input.isUITriggered('cancel') || Input.isUITriggered('menu'))  && this.pressCancel) {
		SoundManager.playCancel();
		this.pressCancel();
	}
};

Sprite_MenuCommand.prototype.updateTouchInput = function() {
	if(TouchInput.isMoved() || TouchInput.isClicked()) {
		for(let i = 0; i < this._baseSprite.children.length; i++) {
			const sprite = this._baseSprite.children[i];
			if(sprite.selected.isChildrenBeingTouched() || sprite.unselected.isChildrenBeingTouched()) {
				if(this._selectIndex !== i) {
					SoundManager.playCursor();
					if(!this._active) {
						this._items[this._selectIndex].panel.deactive();
						this._items[this._selectIndex].panel.pressCancel();
					}
					this.moveSelectedDirect(i);
				}
				break;
			}
		}
	}
};

Sprite_MenuCommand.prototype.moveSelected = function(delta) {
	const idx = this._selectIndex + delta;
	if(idx < 0 || idx >= this._items.length) {
		return;
	}
	this.moveSelectedDirect(idx);
};

Sprite_MenuCommand.prototype.moveSelectedDirect = function(idx) {
	this.callItemUnselected();
	this._selectIndex = idx;
	this.callItemSelected();
	this.updateCursor();
};

Sprite_MenuCommand.prototype.callItemSelected = function() {
	const item = this.selectedItem();
	item.panel.visible = true;
	item.panel.touchActive();
	const controller = this._animation;
	controller.clear(item.panel);
	controller.add(item.panel, {data:[
		{to:0, duration:20, easingType:'easeOutQuad', property:'x'}
	]});
};

Sprite_MenuCommand.prototype.callItemUnselected = function() {
	const item = this.selectedItem();
	item.panel.touchDeactive();
	const controller = this._animation;
	controller.clear(item.panel);
	controller.add(item.panel, {data:[
		{to:Graphics.width, duration:20, easingType:'easeOutQuad', property:'x'}
	], complete:item.panel.invisible.bind(item)});
};

Sprite_MenuCommand.prototype.resetPanelPosition = function() {
	for(const item of this._items) {
		item.panel.x = Graphics.width;
	}
	this.callItemSelected();
};

Sprite_MenuCommand.prototype.updateCursor = function() {
	let idx = 0;
	for(const sprite of this._baseSprite.children) {
		const visible = idx === this._selectIndex;
		sprite.selected.visible = visible;
		sprite.unselected.visible = !visible;
		this._animation.setPause(sprite, !visible);
		idx++;
	}
};

Sprite_MenuCommand.prototype.onLanguageChange = function() {
	this.refreshItemText();
};

function Sprite_MenuBase() {
	this.initialize(...arguments);
}

Sprite_MenuBase.prototype = Object.create(Sprite.prototype);
Sprite_MenuBase.prototype.constructor = Sprite_MenuBase;

Sprite_MenuBase.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._active = false;
	this._touchActive = false;
	this.visible = false;
	this._baseRect = options.rect;
	
	this.pressCancel = null;
	this.commandDeactive = null;
	
	this._baseSprite = new Sprite();
	this._animation = new AnimationController();
	this.addChild(this._baseSprite);
};

Sprite_MenuBase.prototype.selectable = function() {
	return false;
};

Sprite_MenuBase.prototype.active = function() {
	this._active = true;
};

Sprite_MenuBase.prototype.deactive = function() {
	this._active = false;
};

Sprite_MenuBase.prototype.touchActive = function() {
	this._touchActive = true;
};

Sprite_MenuBase.prototype.touchDeactive = function() {
	this._touchActive = false;
};

Sprite_MenuBase.prototype.allWidth = function() {
	return this._baseRect.width;
};

Sprite_MenuBase.prototype.onLanguageChange = function() {
};

Sprite_MenuBase.prototype.allHeight = function() {
	return this._baseRect.height;
};

Sprite_MenuBase.prototype.invisible = function() {
	this.visible = false;
};

Sprite_MenuBase.prototype.centerX = function() {
	return this._baseRect.width / 2 + this._baseRect.x;
};

Sprite_MenuBase.prototype.centerY = function() {
	return this._baseRect.height / 2 + this._baseRect.y;
};

Sprite_MenuBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active) {
		this.updateInput();
	}
	if(this._touchActive) {
		this.updateTouchInput();
	}
	this._animation.update();
};

Sprite_MenuBase.prototype.updateInput = function() {
	if(Input.isUITriggered('cancel') && this.pressCancel) {
		SoundManager.playCancel();
		this.deactive();
		this.pressCancel();
	}
};

Sprite_MenuBase.prototype.updateTouchInput = function() {
};

function Sprite_MenuSkill() {
	this.initialize(...arguments);
}

Sprite_MenuSkill.prototype = Object.create(Sprite_MenuBase.prototype);
Sprite_MenuSkill.prototype.constructor = Sprite_MenuSkill;

Sprite_MenuSkill.prototype.initialize = function(options) {
	Sprite_MenuBase.prototype.initialize.call(this, options);
	this._controlOptions = options.controlOptions;
	this._paddingHeight = options.paddingHeight;
	this._paddingWidth = options.paddingWidth;
	this.createAllSkillItems();
};

Sprite_MenuSkill.prototype.createAllSkillItems = function() {
	this.createDefaultSkillItems();
	this.createUnlockedSkillItems();
};

Sprite_MenuSkill.prototype.createDefaultSkillItems = function() {
	const defaultSkill1 = new Sprite_SkillControl(Object.assign(this._controlOptions, {
		step:[{name:"cancel",type:"press"}, {name:"cancel",type:"press"}, {name:"cancel",type:"press"}]  // 'press' or 'hold'
		, sampleImage:[{name:";toru_attack1",index:1},{name:";toru_attack3",index:1}]
	}));
	const defaultSkill2 = new Sprite_SkillControl(Object.assign(this._controlOptions, {
		step:[{name:"down",type:"hold"}, {name:"cancel",type:"press"}]  // 'press' or 'hold'
		, sampleImage:[{name:";toru_down_attack1",index:1}]
		, extButtonToImagePadding:24
	}));
	const defaultSkill3 = new Sprite_SkillControl(Object.assign(this._controlOptions, {
		step:[{name:"up",type:"hold"}, {name:"cancel",type:"press"}]
		, sampleImage:[{name:";toru_up_attack1",index:1}]
		, extButtonToImagePadding:24
	}));
	const defaultSkill4 = new Sprite_SkillControl(Object.assign(this._controlOptions, {
		step:[{name:"bullet",type:"press"}]
		, sampleImage:[{name:";toru_dash",index:1}]
	}));
	const defaultSkill5 = new Sprite_SkillControl(Object.assign(this._controlOptions, {
		step:[{name:"left",type:"press"}, {name:"right",type:"press"}, {name:"bullet",type:"press"}]
		, sampleImage:[{name:";toru_reverse_dash",index:1}]
	}));
	const defaultSkill6 = new Sprite_SkillControl(Object.assign(this._controlOptions, {
		step:[{name:"bullet",type:"press"}, {name:"ok",type:"press"}]
		, sampleImage:[{name:";toru_dash_jump_sample",index:0}]
	}));
	this.addSkillItem(defaultSkill1, defaultSkill2, defaultSkill3, defaultSkill4, defaultSkill5, defaultSkill6);
};

Sprite_MenuSkill.prototype.createUnlockedSkillItems = function() {
	const actor = $gamePlayer.actor();
	const allStonesData = actor._stones.data();
	for(const idstr of Object.keys(allStonesData)) {
		const id = parseInt(idstr);
		const data = allStonesData[idstr];
		if(actor.isStoneUnlock(id) && data.step) {
			for(let i = 0; i < data.step.length; i++) {
				const step = data.step[i];
				const sampleImage = data.sampleImage[i];
				this.addSkillItem(new Sprite_SkillControl(Object.assign(this._controlOptions, {
					step:step
					, sampleImage:sampleImage
				})));
			}
		}
	}
};

Sprite_MenuSkill.prototype.addSkillItem = function() {
	for(const sprite of arguments) {
		const index = this._baseSprite.children.length;
		const y = index % this.pageHeight();
		const x = Math.trunc(index / this.pageHeight());
		this._baseSprite.addChild(sprite);
		sprite.x = this.itemX(x);
		sprite.y = this.itemY(y);
	}
};

Sprite_MenuSkill.prototype.pageWidth = function() {
	return 2;
};

Sprite_MenuSkill.prototype.pageHeight = function() {
	return 6;
};

Sprite_MenuSkill.prototype.itemX = function(x) {
	const width = this.allWidth();
	return Math.trunc(this._paddingWidth + width / this.pageWidth() * x + Graphics.width - width);
};

Sprite_MenuSkill.prototype.itemY = function(y) {
	const height = this.allHeight();
	const itemHeight = (height - this._paddingHeight * 2) / this.pageHeight();
	return Math.trunc(this._paddingHeight + itemHeight * (y + 0.5) + Graphics.height - height);
};

function Sprite_SkillControl() {
	this.initialize(...arguments);
}

Sprite_SkillControl.prototype = Object.create(Sprite.prototype);
Sprite_SkillControl.prototype.constructor = Sprite_SkillControl;

Sprite_SkillControl.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._upArrowName = options.upArrowName;
	this._buttonName = options.buttonName;
	this._plusName = options.plusName;
	this._equalName = options.equalName;
	this._upArrowNameHold = options.upArrowNameHold;
	this._buttonNameHold = options.buttonNameHold;
	this._itemPadding = options.itemPadding;
	this._imagePadding = options.imagePadding;
	this._buttonTextSize = options.buttonTextSize;
	this._buttonTextColor = options.buttonTextColor;
	this._extButtonToImagePadding = options.extButtonToImagePadding | 0;
	this._step = options.step;
	this._sampleImage = options.sampleImage;
	this.createAllItems();
};

Sprite_SkillControl.prototype.maxButtonNum = function() {
	return 3;
};

Sprite_SkillControl.prototype.createAllItems = function() {
	let currentX = 0;
	this._maxHeight = 0;
	const mobile = Utils.isMobileDeviceTouchMode();
	const buttonScale = mobile ? 0.4 : 1;
	const standardButtonWidth = ImageManager.loadUI(this._buttonName).width * buttonScale;
	const standardPlusWidth = ImageManager.loadUI(this._plusName).width;
	for(const step of this._step) {
		const padding = this._itemPadding;
		const name = step.name;
		const type = step.type;
		switch(name) {
			case "up": case "down": case "right": case "left": {
				const bitmapName = type === "press" ? this._upArrowName : this._upArrowNameHold;
				const sprite = new Sprite(ImageManager.loadUI(bitmapName));
				sprite.anchor.y = 0.5;
				const offsetX = (standardButtonWidth - sprite.width) / 2;
				sprite.x = currentX + offsetX;
				switch(name) {
					case "up" : sprite.rotation = 0; break;
					case "down" : sprite.rotation = Math.PI; sprite.x += sprite.width; break;
					case "left" : sprite.rotation = Math.PI * 1.5; sprite.x += sprite.width / 2; sprite.y += (sprite.height / 2 - 3); break;
					case "right" : sprite.rotation = Math.PI * 0.5; sprite.x += sprite.width / 2; sprite.y -= (sprite.height / 2 - 3); break;
				}
				currentX += padding;
				currentX += sprite.width;
				currentX += (offsetX * 2);
				this._maxHeight = Math.max(this._maxHeight, sprite.height);
				this.addChild(sprite);
				break;
			}
			default: {
				const bitmapName = type === "press" ? this._buttonName : this._buttonNameHold;
				const sprite = new Sprite(ImageManager.loadUI(bitmapName));
				sprite.anchor.y = 0.5;
				sprite.x = currentX;
				sprite.scale.set(buttonScale);
				if(!mobile) {
					const buttonText = ConfigManager.getInputName(name);
					const textBitmap = new Bitmap(sprite.width, sprite.height);
					textBitmap.outlineWidth = 0;
					textBitmap.textColor = this._buttonTextColor;
					textBitmap.fontSize = this._buttonTextSize;
					textBitmap.drawCenterText(buttonText);
					const textSprite = new Sprite(textBitmap);
					textSprite.anchor.y = 0.5;
					sprite.addChild(textSprite);
					
				} else {
					const touchSprite = new Sprite(ImageManager.loadUI(this.inputName2Touch(name)));
					touchSprite.anchor.y = 0.5;
					touchSprite.x = (sprite.width - touchSprite.width) / 2;
					sprite.addChild(touchSprite);
				}
				currentX += padding;
				currentX += (sprite.width * buttonScale);
				this._maxHeight = Math.max(this._maxHeight, (sprite.height * buttonScale));
				this.addChild(sprite);
				break;
			}
		}
		if(step !== this._step[this._step.length - 1]) {
			const sprite = new Sprite(ImageManager.loadUI(this._plusName));
			sprite.anchor.y = 0.5;
			sprite.x = currentX;
			currentX += padding;
			currentX += sprite.width;
			this.addChild(sprite);
		}
	}
	currentX = this.maxButtonNum() * (standardButtonWidth + this._itemPadding * 2 + standardPlusWidth) - this._itemPadding - standardPlusWidth;
	
	const sprite = new Sprite(ImageManager.loadUI(this._equalName));
	sprite.anchor.y = 0.5;
	sprite.x = currentX;
	this.addChild(sprite);
	
	currentX += this._itemPadding;
	currentX += sprite.width;
	currentX += this._extButtonToImagePadding;
	
	for(const sample of this._sampleImage) {
		const padding = this._imagePadding;
		const info = ImageFrame.info(sample.name);
		const width = info.width;
		const height = info.height;
		const sprite = new Sprite(ImageManager.loadCharacter(sample.name));
		const frameX = sample.index % width;
		const frameY = Math.trunc(sample.index / width);
		const frameWidth = sprite.width / width;
		const frameHeight = sprite.height / height;
		sprite.setFrame(frameX * frameWidth, frameY * frameHeight, frameWidth, frameHeight);
		sprite.anchor.y = 0.5;
		sprite.x = currentX;
		currentX += padding;
		currentX += frameWidth * sprite.scale.x;
		this._maxHeight = Math.max(this._maxHeight, frameHeight * sprite.scale.y);
		this.addChild(sprite);
	}
	this._maxWidth = currentX - this._imagePadding;
};

Sprite_SkillControl.prototype.inputName2Touch = function(name) {
	switch(name) {
		case "ok": {
			return "jump";
		}
		case "cancel": {
			return "attack";
		}
		default: return name;
	}
};

Sprite_SkillControl.prototype.allHeight = function() {
	return this._maxHeight;
};

Sprite_SkillControl.prototype.allWidth = function() {
	return this._maxWidth;
};


function Sprite_MenuSystem() {
	this.initialize(...arguments);
}

Sprite_MenuSystem.prototype = Object.create(Sprite_MenuBase.prototype);
Sprite_MenuSystem.prototype.constructor = Sprite_MenuSystem;

Sprite_MenuSystem.prototype.initialize = function(options) {
	Sprite_MenuBase.prototype.initialize.call(this, options);
	this._items = options.items;
	this._playTimeTextSize = options.playTimeTextSize;
	this._playTimeTextColor = options.playTimeTextColor;
	this._playTimeMargin = options.playTimeMargin;
	this._playTimeBackName = options.playTimeBackName;
	this._cursorName = options.cursorName;
	this._cursorOffset = options.cursorOffset;
	this._backName = options.backName;
	this._selectedShadowBlur = options.selectedShadowBlur;
	this._selectedShadowColor = options.selectedShadowColor;
	this._selectedColor = options.selectedColor;
	this._selectedSize = options.selectedSize;
	this._selectedOutlineColor = options.selectedOutlineColor;
	this._selectedOutlineWidth = options.selectedOutlineWidth;
	this._unselectedSize = options.unselectedSize;
	this._unselectedColor = options.unselectedColor;
	this._itemMargin = options.itemMargin;
	
	this._selectIndex = 0;
	this.createItemMask();
	this.createLowerItems();
	this.createCursor();
	this.createUpperItems();
	this.refreshItemText();
	this.createPlayTime();
};

Sprite_MenuSystem.prototype.selectable = function() {
	return true;
};

Sprite_MenuSystem.prototype.itemX = function() {
	return this.startX();
};

Sprite_MenuSystem.prototype.itemY = function(idx) {
	return this.startY() + idx * (this.itemHeight() + this._itemMargin);
};

Sprite_MenuSystem.prototype.startX = function() {
	return this.centerX() - this.itemWidth() / 2;
};

Sprite_MenuSystem.prototype.startY = function() {
	return this.centerY() - ((this.itemHeight() + this._itemMargin) * this._items.length - this._itemMargin) / 2;
};

Sprite_MenuSystem.prototype.itemWidth = function() {
	const bitmap = ImageManager.loadUI(this._backName);
	return bitmap.width;
};

Sprite_MenuSystem.prototype.itemHeight = function() {
	const bitmap = ImageManager.loadUI(this._backName);
	return bitmap.height;
};

Sprite_MenuSystem.prototype.cursorX = function() {
	return this.itemX() + this._cursorOffset.x;
};

Sprite_MenuSystem.prototype.cursorY = function() {
	return this.itemY(this._selectIndex) + this._cursorOffset.y;
};

Sprite_MenuSystem.prototype.createItemMask = function() {
	const bitmap = ImageManager.loadUI(this._cursorName);
	const itemMaskRender = new Sprite(ImageManager.loadUI(this._cursorName));
	itemMaskRender.filters = [Utils.colorMaskShader(255, 0, 0)];
	
	const texture = PIXI.RenderTexture.create(bitmap.width, bitmap.height);
	this.itemMask = new PIXI.Sprite(texture);
	Graphics.app.renderer.render(itemMaskRender, texture);
	this.addChild(this.itemMask);
};

Sprite_MenuSystem.prototype.createLowerItems = function() {
	let idx = 0;
	for(const item of this._items) {
		const sprite = new Sprite(ImageManager.loadUI(this._backName));
		sprite.x = this.itemX(idx);
		sprite.y = this.itemY(idx);
		sprite.item = item;
		const textBitmap = new Bitmap(this.itemWidth(), this.itemHeight());
		const textSprite = new Sprite(textBitmap);
		textBitmap.outlineWidth = 0;
		textBitmap.fontSize = this._unselectedSize;
		textBitmap.textColor = this._unselectedColor;
		sprite.addChild(textSprite);
		sprite.textBitmap = textBitmap;
		this._baseSprite.addChild(sprite);
		idx++;
	}
};

Sprite_MenuSystem.prototype.createUpperItems = function() {
	this._upperSprite = new Sprite();
	this.addChild(this._upperSprite);
	let idx = 0;
	for(const item of this._items) {
		const textBitmap = new Bitmap(this.itemWidth(), this.itemHeight());
		const textSprite = new Sprite(textBitmap);
		textBitmap.outlineWidth = this._selectedOutlineWidth;
		textBitmap.outlineColor = this._selectedOutlineColor;
		textBitmap.fontSize = this._selectedSize;
		textBitmap.textColor = this._selectedColor;
		textBitmap.context.shadowBlur = this._selectedShadowBlur;
		textBitmap.context.shadowOffsetX = 0;
		textBitmap.context.shadowOffsetY = 0;
		textBitmap.context.shadowColor = this._selectedShadowColor;
		this._upperSprite.addChild(textSprite);
		textSprite.x = this.itemX();
		textSprite.y = this.itemY(idx);
		idx++;
	}
	this._upperSprite.mask = this.itemMask;
};

Sprite_MenuSystem.prototype.refreshItemText = function() {
	let idx = 0;
	for(const item of this._items) {
		const upper = this._upperSprite.children[idx];
		const normal = this._baseSprite.children[idx];
		normal.textBitmap.clear();
		normal.textBitmap.drawCenterText(TextManager[item.name]);
		upper.bitmap.clear();
		upper.bitmap.drawCenterText(TextManager[item.name]);
		idx++;
	}
};

Sprite_MenuSystem.prototype.createPlayTime = function() {
	this._playTimeSprite = new Sprite(ImageManager.loadUI(this._playTimeBackName));
	this.playTimeBitmap = new Bitmap(this._playTimeSprite.width, this._playTimeSprite.height);
	this.playTimeBitmap.fontSize = this._playTimeTextSize;
	this.playTimeBitmap.textColor = this._playTimeTextColor;
	this.playTimeBitmap.outlineWidth = 0;
	const sprite = new Sprite(this.playTimeBitmap);
	this._playTimeSprite.addChild(sprite);
	this._playTimeSprite.x = this.itemX() + (this.itemWidth() - this._playTimeSprite.width) / 2;
	this._playTimeSprite.y = this.itemY(this._items.length) - this._itemMargin + this._playTimeMargin;
	this.addChild(this._playTimeSprite);
	this.updatePlayTime();
};

Sprite_MenuSystem.prototype.updatePlayTime = function() {
	const bitmap = this.playTimeBitmap;
	bitmap.clear();
	bitmap.drawText(TextManager.STATIC_TEXT_MENU_SYSTEM_PLAY_TIME + $gameSystem.playtimeText(), 0, (bitmap.height - bitmap.fontSize) / 2, bitmap.width, bitmap.fontSize, 'center');
};

Sprite_MenuSystem.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this._cursorSprite.x = this.cursorX();
	this._cursorSprite.y = this.cursorY();
	this.addChild(this._cursorSprite);
};

Sprite_MenuSystem.prototype.update = function() {
	Sprite_MenuBase.prototype.update.call(this);
	this.itemMask.x = this._cursorSprite.x;
	this.itemMask.y = this._cursorSprite.y;
	this.updatePlayTime();
	this._upperSprite.visible = this._cursorSprite.visible = this._active;
};

Sprite_MenuSystem.prototype.updateInput = function() {
	Sprite_MenuBase.prototype.updateInput.call(this);
	if(Input.isUITriggered('ok')) {
		const item = this._items[this._selectIndex];
		if(item && item.callback) {
			SoundManager.playOk();
			item.callback();
		}
	}
	if(Input.isUITriggered('up')) {
		SoundManager.playCursor();
		this.moveCursor(-1);
	}
	if(Input.isUITriggered('down')) {
		SoundManager.playCursor();
		this.moveCursor(1);
	}
};

Sprite_MenuSystem.prototype.updateTouchInput = function() {
	if(TouchInput.isMoved() || TouchInput.isClicked()) {
		for(let i = 0; i < this._baseSprite.children.length; i++) {
			const sprite = this._baseSprite.children[i];
			if(sprite.isBeingTouched()) {
				if(!this._active) {
					this.active();
					this.commandDeactive();
				}
				this.moveCursorDirect(i);
				if(TouchInput.isClicked()) {
					const item = this._items[this._selectIndex];
					SoundManager.playOk();
					item.callback();
				}
				break;
			}
		}
	}
};

Sprite_MenuSystem.prototype.moveCursor = function(delta) {
	const idx = this._selectIndex + delta;
	if(idx < 0 || idx >= this._items.length) {
		return;
	}
	this.moveCursorDirect(idx);
};

Sprite_MenuSystem.prototype.moveCursorDirect = function(idx) {
	this._selectIndex = idx;
	const controller = this._animation;
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, {data:[{
		to:this.cursorY(), property:'y', duration:18, easingType:'easeOutQuart'
	}]});
};

Sprite_MenuSystem.prototype.onLanguageChange = function() {
	Sprite_MenuBase.prototype.onLanguageChange.call(this);
	this.refreshItemText();
};

Bitmap.prototype.drawCenterText = function(text) {
	this.drawAlignText(text, 'center');
};

Bitmap.prototype.drawAlignText = function(text, align) {
	this.drawText(text, 0, (this.height - this.fontSize) / 2, this.width, this.fontSize, align);
};

function Sprite_MapInfo() {
	this.initialize(...arguments);
}

Sprite_MapInfo.prototype = Object.create(Sprite_MenuBase.prototype);
Sprite_MapInfo.prototype.constructor = Sprite_MapInfo;

Sprite_MapInfo.prototype.initialize = function(options) {
	Sprite_MenuBase.prototype.initialize.call(this, options);
	this._mapContentName = options.mapContentName;
	this._mapProgressName = options.mapProgressName;
	this._mapNameBoxName = options.mapNameBoxName;
	this._margin = options.margin;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._nameBoxTextOffset = options.nameBoxTextOffset;
	this._tipsBackName = options.tipsBackName;
	this._tipsTextColor = options.tipsTextColor;
	this._tipsOffsetY = options.tipsOffsetY;
	this._taskSelectOptions = options.taskSelectOptions;
	this._signatureSampleBackName = options.signatureSampleBackName;
	
	this._taskState = "map";
	this._tasks = [];
	this.createMapProgress();
	this.createMapContent();
	this.createSignatureSample();
	this.createMapNameBox();
	this.createControlTips();
	this.createTaskSelect();
	this.createAllTaskWindow();
};

Sprite_MapInfo.prototype.selectable = function() {
	return true;
};

Sprite_MapInfo.prototype.active = function() {
	Sprite_MenuBase.prototype.active.call(this);
	this.activeTaskSelect();
};

Sprite_MapInfo.prototype.deactive = function() {
	Sprite_MenuBase.prototype.deactive.call(this);
	this.deactiveTaskSelect();
};

Sprite_MapInfo.prototype.createMapProgress = function() {
	const bitmap = ImageManager.loadUI(this._mapProgressName);
	const bitmap2 = ImageManager.loadUI(this._mapContentName);
	const x = this.centerX() - bitmap.width / 2;
	const y = this.centerY() - (bitmap.height + this._margin + bitmap2.height) / 2;
	const sprite = new Sprite(bitmap);
	sprite.x = x;
	sprite.y = y;
	const textBitmap = new Bitmap(bitmap.width, bitmap.height);
	textBitmap.fontSize = this._textSize;
	textBitmap.textColor = this._textColor;
	textBitmap.outlineWidth = 0;
	const textSprite = new Sprite(textBitmap);
	this._mapProgressTextBitmap = textBitmap;
	sprite.addChild(textSprite);
	this._baseSprite.addChild(sprite);
	this._progress = sprite;
	this.drawMapProgressText();
};

Sprite_MapInfo.prototype.createControlTips = function() {
	const sprite = new Sprite(ImageManager.loadUI(this._tipsBackName));
	this._content.addChildAt(sprite, 0);
	sprite.x = (this._content.width - sprite.width) / 2;
	sprite.y = this._tipsOffsetY;
	this._tipsBitmap = new Bitmap(sprite.width, sprite.height);
	const textSprite = new Sprite(this._tipsBitmap);
	sprite.addChild(textSprite);
	this._tipsBitmap.fontSize = this._textSize;
	this._tipsBitmap.textColor = this._tipsTextColor;
	this._tipsBitmap.outlineWidth = 0;
	this._tipsSprite = sprite;
	this.refreshTips();
};

Sprite_MapInfo.prototype.refreshTips = function() {
	this._tipsBitmap.clear();
	if(Utils.isMobileDeviceTouchMode()) {
		if(this._taskState === "map") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_TASK_TOUCH"]);
		} else if(this._taskState === "select") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_CANCEL_TASK_TOUCH"]);
		}
	} else {
		if(this._taskState === "map") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_TASK_MODE"].format(ConfigManager.getInputName('ok')));
		} else if(this._taskState === "select") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_CANCEL_TASK_MODE"].format(ConfigManager.getInputName('ok')));
		}
	}
};

Sprite_MapInfo.prototype.createTaskSelect = function() {
	this._taskSelect = new Sprite_PageTaskSelect(this._taskSelectOptions);
	this._content.addChild(this._taskSelect);
	this._taskSelect.pressOk = this.onTaskSelect.bind(this);
	this._taskSelect.x = (this._content.width - this._taskSelect.allWidth()) / 2;
	this._taskSelect.y = this._tipsOffsetY + this._tipsBitmap.height + this._taskSelect._moveSignUp.height + this._taskSelect._moveSignMargin + ((this._content.height - this._tipsBitmap.height - this._tipsOffsetY) - this._taskSelect.allHeight()) / 2;
};

Sprite_MapInfo.prototype.createAllTaskWindow = function() {
	this._regionTaskSprite.removeChildren();
	const tasks = this._tasks;
	const paddingFrame = 12;
	const paddingWindow = 6;
	const maxWidth = this._content.width - paddingFrame * 2;
	for(const taskId of tasks) {
		const page = DataManager.taskPage(taskId);
		const currCell = DataManager.getCurrentThumbnailCell();
		if(!currCell) {
			continue;
		}
		const name = DataManager.taskFullName(taskId);
		const thumbnail = this._thumbnail;
		const pos = thumbnail.evidToCellPosition($dataTask[taskId].ev);
		if(!pos) {
			continue;
		}
		const taskWin = new Window_TaskInBallon(new Rectangle(0, 0, 20, 20));
		taskWin.resetFontSettings();
		const cx = this._content.width / 2;
		const cy = this._content.height / 2 + this.thumbnailShiftY();
		const cw = thumbnail.allWidth() / 2;
		const ch = thumbnail.allHeight() / 2;
		// cx + pos.x - cw是thumbnal内部的x坐标转换为其parent的x坐标
		// cy + pos.y - ch是thumbnal内部的y坐标转换为其parent的y坐标
		const size = taskWin.contents.measureTextWidth(name);
		const windowWidth = taskWin.windowWidth(size);
		const windowHeight = taskWin.windowHeight();
		const sx = cx + pos.x - cw - (windowWidth / 2);
		let sy = 0;
		sy = cy + pos.y - ch - windowHeight - DataManager.thumbnailCellWidth();
		if(this.checkExistingRect(new Rectangle(sx, sy, windowWidth, windowHeight))) {
			sy = cy + pos.y - ch + DataManager.thumbnailCellWidth();
			taskWin.setArrowDir("up");
		}
		const dx = cx + pos.x - cw - sx;
		const dy = cy + pos.y - ch - sy;
		taskWin.x = sx|0;
		taskWin.y = sy|0;
		taskWin.setText(name, dx|0, dy|0);
		this._regionTaskSprite.addChild(taskWin);
		taskWin.open();
	}
};

Sprite_MapInfo.prototype.checkExistingRect = function() {
	return Sprite_Transport.prototype.checkExistingRect.apply(this, arguments);
};

Sprite_MapInfo.prototype.onTaskSelect = function() {
	this.deactive();
	const taskId = this._taskSelect.selectDataId();
	this._tasks = [taskId];
	this.createAllTaskWindow();
	if(this.pressCancel) {
		this.pressCancel();
	}
	return true;
};

Sprite_MapInfo.prototype.deactiveTaskSelect = function() {
	this._taskState = "map";
	this._taskSelect.deactive();
	this._thumbnail.visible = true;
	this._regionTaskSprite.visible = true;
	this.refreshTips();
};

Sprite_MapInfo.prototype.drawMapProgressText = function() {
	const textBitmap = this._mapProgressTextBitmap;
	const exploreItem = DataManager.getExploreItem();
	const exploreMap = DataManager.getThumbnailExplore();
	textBitmap.clear();
	textBitmap.drawCenterText(TextManager.STATIC_TEXT_MAP_INFO_EXPLORE.format(exploreItem.has.padZero(3), exploreItem.all.padZero(3), exploreMap.has.padZero(3), exploreMap.all.padZero(3)));
};

Sprite_MapInfo.prototype.createMapContent = function() {
	const bitmap = ImageManager.loadUI(this._mapContentName);
	const x = this.centerX() - bitmap.width / 2;
	const y = this._progress.y + this._progress.height + this._margin;
	const sprite = new Sprite(bitmap);
	sprite.x = x;
	sprite.y = y;
	const thumbnail = new Sprite_MapThumbnail();
	thumbnail.buildPage();
	thumbnail.x = (bitmap.width - thumbnail.allWidth()) / 2;
	thumbnail.y = (bitmap.height - thumbnail.allHeight()) / 2 + this.thumbnailShiftY();
	thumbnail.setTaskSignatureColor([64, 64, 64, 255]);
	thumbnail.insertTaskSignature();
	sprite.addChild(thumbnail);
	this._baseSprite.addChild(sprite);
	this._content = sprite;
	this._thumbnail = thumbnail;
	this._regionTaskSprite = new Sprite();
	this._content.addChild(this._regionTaskSprite);
};

Sprite_MapInfo.prototype.thumbnailShiftY = function() {
	return 28;
};

Sprite_MapInfo.prototype.createMapNameBox = function() {
	const bitmap = ImageManager.loadUI(this._mapNameBoxName);
	const x = this.centerX() - bitmap.width / 2;
	const y = this._content.y - bitmap.height / 2;
	const sprite = new Sprite(bitmap);
	sprite.x = x;
	sprite.y = y;
	const textBitmap = new Bitmap(bitmap.width, bitmap.height);
	textBitmap.fontSize = this._textSize;
	textBitmap.textColor = this._textColor;
	textBitmap.outlineWidth = 0;
	const textSprite = new Sprite(textBitmap);
	this._mapNameTextBitmap = textBitmap;
	textSprite.x = this._nameBoxTextOffset.x;
	textSprite.y = this._nameBoxTextOffset.y;
	sprite.addChild(textSprite);
	this._baseSprite.addChild(sprite);
	this._nameBox = sprite;
	this.drawMapNameText();
};

Sprite_MapInfo.prototype.drawMapNameText = function() {
	const textBitmap = this._mapNameTextBitmap;
	const cell = DataManager.getCurrentThumbnailCell();
	textBitmap.clear();
	if(cell) {
		const regionId = cell.regionId;
		const name = $dataRegion[regionId].name;
		if(name) {
			textBitmap.drawCenterText(name);
		}
	}
};

Sprite_MapInfo.prototype.activeTaskSelect = function() {
	this._taskState = "select";
	this._taskSelect.active();
	this._thumbnail.visible = false;
	this._regionTaskSprite.visible = false;
	this.refreshTips();
};

Sprite_MapInfo.prototype.onLanguageChange = function() {
	Sprite_MenuBase.prototype.onLanguageChange.call(this);
	this.drawMapProgressText();
	this.drawMapNameText();
	this._taskSelect.onLanguageChange();
	this.refreshTips();
	this._regionTaskSprite.children.forEach((win) => { win.onLanguageChange(); });
	this._sampleSprite.children.forEach((child) => { child.onLanguageChange(); });
};

Sprite_MapInfo.prototype.updateTouchInput = function() {
	if(TouchInput.isClicked() && this._tipsSprite.isBeingTouched()) {
		if(!this._active) {
			SoundManager.playOk();
			this.active();
			this.commandDeactive();
		} else {
			SoundManager.playCancel();
			this.deactive();
			this.pressCancel();
		}
	}
};

Sprite_MapInfo.prototype.createSignatureSample = function() {
	const padding = 12;
	const margin = 12;
	let currentY = 0;
	this._sampleSprite = new Sprite();
	this._baseSprite.addChild(this._sampleSprite);
	
	const myPosSample = new Sprite_SignatureSampleMyPos({backName:this._signatureSampleBackName,textKey:"STATIC_TEXT_SIGNATURE_SAMPLE_MY_POS",padding:padding});
	myPosSample.y = currentY;
	currentY += (myPosSample.allHeight() + margin);
	
	const taskSample = new Sprite_SignatureSampleTask({backName:this._signatureSampleBackName,textKey:"STATIC_TEXT_SIGNATURE_SAMPLE_TASK",padding:padding});
	taskSample.y = currentY;
	currentY += (taskSample.allHeight() + margin);
	
	const transportSample = new Sprite_SignatureSampleLetter({backName:this._signatureSampleBackName,textKey:"STATIC_TEXT_SIGNATURE_SAMPLE_T",padding:padding,letterName:"T"});
	transportSample.y = currentY;
	currentY += (transportSample.allHeight() + margin);
	
	const saveSample = new Sprite_SignatureSampleLetter({backName:this._signatureSampleBackName,textKey:"STATIC_TEXT_SIGNATURE_SAMPLE_S",padding:padding,letterName:"S"});
	saveSample.y = currentY;
	currentY += (saveSample.allHeight() + margin);
	
	const gateSample = new Sprite_SignatureSampleGate({backName:this._signatureSampleBackName,textKey:"STATIC_TEXT_SIGNATURE_SAMPLE_GATE",padding:padding});
	gateSample.y = currentY;
	currentY += (gateSample.allHeight() + margin);
	
	const itemSample = new Sprite_SignatureSampleItem({backName:this._signatureSampleBackName,textKey:"STATIC_TEXT_SIGNATURE_SAMPLE_ITEM",padding:padding});
	itemSample.y = currentY;
	currentY += (itemSample.allHeight() + margin);
	
	this._sampleSprite.y = Math.round(this._content.y + this._content.height - currentY + margin);
	this._sampleSprite.x = Math.round(this._content.x + this._content.width + (Graphics.width - this._content.x - this._content.width - myPosSample.allWidth()) / 2);
	
	this._sampleSprite.addChild(myPosSample, taskSample, transportSample, saveSample, gateSample, itemSample);

};

function Sprite_ItemBase() {
	this.initialize(...arguments);
}

Sprite_ItemBase.prototype = Object.create(Sprite.prototype);
Sprite_ItemBase.prototype.constructor = Sprite_ItemBase;

Sprite_ItemBase.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	
	this._itemMargin = options.itemMargin;
	this._itemPosStart = options.itemPosStart;
	this._descRect = options.descRect;
	this._cursorName = options.cursorName;
	this._backgroundName = options.backgroundName;
	this._cursorOffset = options.cursorOffset;
	this._title = options.title;
	this._titleOutlineWidth = options.titleOutlineWidth;
	this._titleOutlineColor = options.titleOutlineColor;
	this._titleTextSize = options.titleTextSize;
	this._titleTextColor = options.titleTextColor;
	this._titleSelectedTextSize = options.titleSelectedTextSize;
	this._titleSelectedTextColor = options.titleSelectedTextColor;
	this._selectedBackgroundName = options.selectedBackgroundName;
	this._titleCatMargin = options.titleCatMargin;
	this._titleCatName = options.titleCatName;
	this._descTextColor = options.descTextColor;
	this._descTextSize = options.descTextSize;
	
	this._selectIndex = 0;
	this._active = false;
	this._selected = false;
	this.pressCancel = null;
	this.pressOk = null;
	this._animation = new AnimationController();
	this.createBackground();
	this.createCursor();
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this.createAllItems();
	this.createDesc();
	this.createTitle();
};

Sprite_ItemBase.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backgroundName));
	this._selectedBackSprite = new Sprite(ImageManager.loadUI(this._selectedBackgroundName));
	this._selectedBackSprite.anchor.x = this._selectedBackSprite.anchor.y = 0.5;
	this._selectedBackSprite.x = this._backSprite.width / 2;
	this._selectedBackSprite.y = this._backSprite.height / 2;
	this.addChild(this._selectedBackSprite);
	this.addChild(this._backSprite);
};

Sprite_ItemBase.prototype.createTitle = function() {
	const unselectedBitmap = new Bitmap(this._backSprite.width, this._titleTextSize + this._titleOutlineWidth * 2);
	unselectedBitmap.fontSize = this._titleTextSize;
	unselectedBitmap.textColor = this._titleTextColor;
	unselectedBitmap.outlineWidth = this._titleOutlineWidth;
	unselectedBitmap.outlineColor = this._titleOutlineColor;
	const title = TextManager[this._title];
	this._unselectedTitle = new Sprite(unselectedBitmap);
	this._unselectedTitle.anchor.x = 0.5;
	this._unselectedTitle.anchor.y = 1;
	this._unselectedTitle.x = this._backSprite.width / 2;
	this._unselectedTitle.y = this._titleSelectedTextSize / 2;
	this.addChild(this._unselectedTitle);
	
	const selectedBitmap = new Bitmap(this._backSprite.width, this._titleSelectedTextSize + this._titleOutlineWidth * 2);
	selectedBitmap.fontSize = this._titleSelectedTextSize;
	selectedBitmap.textColor = this._titleSelectedTextColor;
	selectedBitmap.outlineWidth = this._titleOutlineWidth;
	selectedBitmap.outlineColor = this._titleOutlineColor;
	this._selectedTitle = new Sprite(selectedBitmap);
	this._selectedTitle.anchor.x = 0.5;
	this._selectedTitle.anchor.y = 1;
	this._selectedTitle.x = this._unselectedTitle.x;
	this._selectedTitle.y = this._unselectedTitle.y;
	this.addChild(this._selectedTitle);
	
	const textWidth = selectedBitmap.measureTextWidth(title);
	const cat1 = new Sprite(ImageManager.loadUI(this._titleCatName));
	const cat2 = new Sprite(ImageManager.loadUI(this._titleCatName));
	cat1.anchor.x = cat2.anchor.x = 0.5;
	cat1.anchor.y = cat2.anchor.y = 0.5;
	cat1.x = this._selectedTitle.x - textWidth / 2 - this._titleCatMargin;
	cat2.x = this._selectedTitle.x + textWidth / 2 + this._titleCatMargin;
	cat1.y = cat2.y = this._selectedTitle.y - cat1.height / 2;
	this.addChild(cat1, cat2);
	
	const controller = this._animation;
	const r = -0.2;
	const duration = 30;
	controller.add(cat1, {data:[
	{property:'rotation', to:r, duration:duration, easingType:'linear'}
	,{property:'rotation', to:0, duration:duration, easingType:'linear'}
	],loop:true});
	cat2.rotation = -r;
	controller.add(cat2, {data:[
	{property:'rotation', to:0, duration:duration, easingType:'linear'}
	,{property:'rotation', to:r, duration:duration, easingType:'linear'}
	],loop:true});
	this._cat1 = cat1;
	this._cat2 = cat2;
	this.refreshTitleText();
	this.updateSelected();
};

Sprite_ItemBase.prototype.onLanguageChange = function() {
	this.refreshTitleText();
	this.updateDesc();
};

Sprite_ItemBase.prototype.refreshTitleText = function() {
	const title = TextManager[this._title];
	this._selectedTitle.bitmap.clear();
	this._selectedTitle.bitmap.drawCenterText(title);
	this._unselectedTitle.bitmap.clear();
	this._unselectedTitle.bitmap.drawCenterText(title);
};

Sprite_ItemBase.prototype.pageWidth = function() {
	return 6;
};

Sprite_ItemBase.prototype.pageHeight = function() {
	return 1;
};

Sprite_ItemBase.prototype.active = function() {
	this._active = true;
	this.updateDesc();
};

Sprite_ItemBase.prototype.deactive = function() {
	this._active = false;
	this.updateDesc();
};

Sprite_ItemBase.prototype.selectX = function() {
	return this._selectIndex % this.pageWidth();
};

Sprite_ItemBase.prototype.selectY = function() {
	return Math.trunc(this._selectIndex / this.pageWidth());
};

Sprite_ItemBase.prototype.cursorX = function() {
	return this._cursorOffset.x + this.itemX();
};

Sprite_ItemBase.prototype.cursorY = function() {
	return this._cursorOffset.y + this.itemY();
};

Sprite_ItemBase.prototype.itemX = function(sx) {
	const x = sx !== undefined ? sx : this.selectX();
	return this.baseItemX(x);
};

Sprite_ItemBase.prototype.itemY = function(sy) {
	const y = sy !== undefined ? sy : this.selectY();
	return this.baseItemY(y);
};

Sprite_ItemBase.prototype.baseItemX = function(x) {
	return this._itemPosStart.x + x * this._itemMargin.width;
};

Sprite_ItemBase.prototype.baseItemY = function(y) {
	return this._itemPosStart.y + y * this._itemMargin.height;
};

Sprite_ItemBase.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this.addChild(this._cursorSprite);
	this._cursorSprite.anchor.x = this._cursorSprite.anchor.y = 0.5;
	this._cursorSprite.x = this.cursorX();
	this._cursorSprite.y = this.cursorY();
	this.updateCursorVisible();
};

Sprite_ItemBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active) {
		this.updateInput();
		this.updateTouchInput();
	}
	this.updateCursorVisible();
	this.updateSelected();
	this._animation.update();
};

Sprite_ItemBase.prototype.isBeingTouched = function() {
	return this._backSprite.isBeingTouched();
};

Sprite_ItemBase.prototype.updateCursorVisible = function() {
	this._cursorSprite.visible = this._active;
};

Sprite_ItemBase.prototype.updateInput = function() {
	const x = this.selectX();
	const y = this.selectY();
	if(Input.isUITriggered('up') && y > 0) {
		SoundManager.playCursor();
		this._selectIndex -= this.pageWidth();
		this.moveCursor();
	}
	if(Input.isUITriggered('left') && x > 0) {
		SoundManager.playCursor();
		this._selectIndex -= 1;
		this.moveCursor();
	}
	if(Input.isUITriggered('down') && y < this.pageHeight() - 1) {
		SoundManager.playCursor();
		this._selectIndex += this.pageWidth();
		this.moveCursor();
	}
	if(Input.isUITriggered('right') && x < this.pageWidth() - 1) {
		SoundManager.playCursor();
		this._selectIndex += 1;
		this.moveCursor();
	}
	if(Input.isUITriggered('cancel') && this.pressCancel) {
		SoundManager.playCancel();
		this.deactive();
		this.pressCancel();
	}
	if(Input.isUITriggered('ok') && this.pressOk) {
		this.pressOk();
	}
};

Sprite_ItemBase.prototype.updateTouchInput = function(noCursorMoveAnimation = false) {
	if(TouchInput.isClicked() || TouchInput.isMoved()) {
		for(let i = 0; i < this._baseSprite.children.length; i++) {
			const sprite = this._baseSprite.children[i];
			if(sprite.constructor === Sprite_ItemIcon && sprite.isBeingTouched()) {
				this._selectIndex = i;
				if(noCursorMoveAnimation) {
					this._cursorSprite.x = this.cursorX();
					this._cursorSprite.y = this.cursorY();
					this.updateDesc();
				} else {
					this.moveCursor();
				}
				if(TouchInput.isClicked() && this.pressOk) {
					this.pressOk();
				}
			}
		}
	}
};

Sprite_ItemBase.prototype.data = function() {
	return [];
};

Sprite_ItemBase.prototype.selected = function() {
	this._selected = true;
};

Sprite_ItemBase.prototype.unselected = function() {
	this._selected = false;
};

Sprite_ItemBase.prototype.updateSelected = function() {
	this._unselectedTitle.visible = !this._selected;
	this._selectedTitle.visible = this._cat1.visible = this._cat2.visible = this._selectedBackSprite.visible = this._selected;
};

Sprite_ItemBase.prototype.selectIndex = function() {
	return this._selectIndex;
};

Sprite_ItemBase.prototype.moveCursor = function() {
	const controller = this._animation;
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, {data:[
		{to:this.cursorX(), duration:14, property:'x', easingType:'easeOutQuart'}]});
	controller.add(this._cursorSprite, {data:[
		{to:this.cursorY(), duration:14, property:'y', easingType:'easeOutQuart'}]});
	this.updateDesc();
};

Sprite_ItemBase.prototype.updateDesc = function() {
	const items = this.data();
	if(items[this._selectIndex] && this._active) {
		this.refreshItemDesc(this.itemDesc(items[this._selectIndex]));
	} else {
		this.refreshItemDesc("");
	}
};

Sprite_ItemBase.prototype.createAllItems = function() {
	let idx = 0;
	for(const item of this.data()) {
		this.createItem(idx, item);
		idx++;
	}
};

Sprite_ItemBase.prototype.createItem = function(idx, item) {
	const categoryName = this.categoryName();
	const sprite = new Sprite_ItemIcon(categoryName, idx);
	sprite.anchor.x = sprite.anchor.y = 0.5;
	const x = idx % this.pageWidth();
	const y = Math.trunc(idx / this.pageWidth());
	sprite.x = this.itemX(x);
	sprite.y = this.itemY(y);
	this._baseSprite.addChild(sprite);
	return sprite;
};

Sprite_ItemBase.prototype.categoryName = function() {
	return '';
};

Sprite_ItemBase.prototype.itemDesc = function(item) {
	return "";
};

Sprite_ItemBase.prototype.createDesc = function() {
	this._descBitmap = new Bitmap(this._descRect.width, this._descRect.height);
	this._descSprite = new Sprite(this._descBitmap);
	this._descBitmap.textColor = this._descTextColor;
	this._descBitmap.fontSize = this._descTextSize;
	this._descBitmap.outlineWidth = 0;
	this._descSprite.x = this._descRect.x;
	this._descSprite.y = this._descRect.y;
	this._baseSprite.addChild(this._descSprite);
	this.updateDesc();
};

Sprite_ItemBase.prototype.refreshItemDesc = function(text) {
	this._descBitmap.clear();
	this._descBitmap.drawCenterTextMutiline(text);
};

Bitmap.prototype.drawCenterTextMutiline = function(text, margin = 4) {
	const maxWidth = this.width;
	let temp = "";
	let line = 1;
	let linearr = [];
	for(let i = 0; i < text.length; i++) {
		temp += text[i];
		const shouldWaitForSpacingNewLine = Utils.isSpacingNewLineLanguage() && text[i] !== " ";
		if(this.measureTextWidth(temp) >= maxWidth && !shouldWaitForSpacingNewLine) {
			line++;
			linearr.push(temp);
			temp = "";
		}
	}
	if(temp !== "") {
		linearr.push(temp);
	}
	const lineHeight = (this.fontSize + margin);
	const allHeight = lineHeight * line - margin;
	const startY = (this.height - allHeight) / 2;
	for(let i = 0; i < linearr.length; i++) {
		this.drawText(linearr[i], 0, startY + i * lineHeight, this.width, this.fontSize, 'center');
	}
};

function Sprite_Item() {
	this.initialize(...arguments);
}

Sprite_Item.prototype = Object.create(Sprite_MenuBase.prototype);
Sprite_Item.prototype.constructor = Sprite_Item;

Sprite_Item.prototype.initialize = function(options) {
	Sprite_MenuBase.prototype.initialize.call(this, options);
	
	this._selectIndex = 0;
	this._items = [];
	this.createAllItems();
	this.updateItemSelect();
};

Sprite_Item.prototype.update = function() {
	Sprite_MenuBase.prototype.update.call(this);
};

Sprite_Item.prototype.updateItemSelect = function() {
	let idx = 0;
	for(const item of this._items) {
		if(idx === this._selectIndex && (this._active || item._active)) {
			item.selected();
		} else {
			item.unselected();
		}
		idx++;
	}
};

Sprite_Item.prototype.updateInput = function() {
	Sprite_MenuBase.prototype.updateInput.apply(this, arguments);
	if(Input.isUITriggered('left')) {
		switch(this._selectIndex) {
			case 1: SoundManager.playCursor(); this._selectIndex = 0; this.updateItemSelect(); break;
			default: break;
		}
	}
	if(Input.isUITriggered('right')) {
		switch(this._selectIndex) {
			case 0: case 2: case 3: SoundManager.playCursor(); this._selectIndex = 1; this.updateItemSelect(); break;
			default: break;
		}
	}
	if(Input.isUITriggered('up')) {
		switch(this._selectIndex) {
			case 3: SoundManager.playCursor(); this._selectIndex = 2; this.updateItemSelect(); break;
			case 2: SoundManager.playCursor(); this._selectIndex = 0; this.updateItemSelect(); break;
			default: break;
		}
	}
	if(Input.isUITriggered('down')) {
		switch(this._selectIndex) {
			case 1: case 2: SoundManager.playCursor(); this._selectIndex += 1; this.updateItemSelect(); break;
			case 0: SoundManager.playCursor(); this._selectIndex = 2; this.updateItemSelect(); break;
			default: break;
		}
	}
	if(Input.isUITriggered('ok')) {
		SoundManager.playOk();
		this._items[this._selectIndex].active();
		this.deactive();
	}
};

Sprite_Item.prototype.updateTouchInput = function() {
	if(TouchInput.isMoved() || TouchInput.isClicked()) {
		let isAnyChildActive = false;
		for(let i = 0; i < this._items.length; i++) {
			if(this._items[i].isBeingTouched() && !isAnyChildActive) {
				this._selectIndex = i;
				if(!this._items[i]._active) {
					this._items[i].active();
					this._items[i].updateTouchInput(true);
				}
				isAnyChildActive = true;
			} else {
				this._items[i].deactive();
			}
		}
		this.deactive();
		if(isAnyChildActive) {
			this.commandDeactive();
		} else {
			this.pressCancel();
		}
	}
};

Sprite_Item.prototype.selectable = function() {
	return true;
};

Sprite_Item.prototype.active = function() {
	Sprite_MenuBase.prototype.active.call(this);
	this.updateItemSelect();
};

Sprite_Item.prototype.deactive = function() {
	Sprite_MenuBase.prototype.deactive.call(this);
	this.updateItemSelect();
};

Sprite_Item.prototype.createAllItems = function() {
	const baseOption = {
		itemPosStart:{x:44,y:44}
		, cursorName:'menu_item_cursor'
		, titleOutlineWidth:5
		, titleOutlineColor:'#ffffff'
		, titleTextSize:24
		, titleTextColor:'#ff9bb7'
		, titleSelectedTextSize:32
		, titleSelectedTextColor:'#551717'
		, titleCatMargin:31
		, titleCatName:'menu_item_cat'
		, descTextSize:18
		, descTextColor:'#551717'
		, cursorOffset:{x:-1,y:2}
	};
	const consumables = new Sprite_Consumables(Object.assign({
		backgroundName:'menu_item_consumables'
		, itemMargin:{width:67,height:60}
		, descRect:{x:35,y:69,width:348,height:96}
		, title:"STATIC_TEXT_MENU_ITEM_CONSUMABLES"
		, selectedBackgroundName:'menu_item_selected_back0'
		
		, itemNumTextSize:16
		, itemNumTextColor:'#551717'
		, itemNumTextOffset:{x:16,y:7}
	}, baseOption));
	consumables.x = 318 + Utils.baseHalfWidth();
	consumables.y = 40;
	
	
	const weapons = new Sprite_Weapons(Object.assign({
		backgroundName:'menu_item_weapons'
		, itemMargin:{width:67,height:60}
		, descRect:{x:39,y:69,width:214,height:96}
		, title:"STATIC_TEXT_MENU_ITEM_WEAPONS"
		, selectedBackgroundName:'menu_item_selected_back1'
		
		, equipCursorName:'menu_item_equip'
		, eqmCursorOffset:{x:-5,y:16}
	}, baseOption));
	weapons.x = 891 + Utils.baseHalfWidth();
	weapons.y = 40;
	
	const stones = new Sprite_Stones(Object.assign({
		backgroundName:'menu_item_stones'
		, itemMargin:{width:67,height:60}
		, descRect:{x:39,y:93,width:470,height:18}
		, title:"STATIC_TEXT_MENU_ITEM_STONES"
		, selectedBackgroundName:'menu_item_selected_back2'
		
		, equipCursorName:'menu_item_equip'
		, eqmCursorOffset:{x:-5,y:16}
	}, baseOption));
	stones.x = 318 + Utils.baseHalfWidth();
	stones.y = 256;
	
	const ornaments = new Sprite_Ornaments(Object.assign({
		backgroundName:'menu_item_ornaments'
		, itemMargin:{width:67,height:60}
		, descRect:{x:39,y:161,width:720,height:48}
		, title:"STATIC_TEXT_MENU_ITEM_ORNAMENTS"
		, selectedBackgroundName:'menu_item_selected_back3'
		
		, equipCursorName:'menu_item_equip'
		, eqmCursorOffset:{x:-5,y:16}
		, remainTipsOffsetY:234
	}, baseOption));
	ornaments.x = 318 + Utils.baseHalfWidth();
	ornaments.y = 435;
	
	consumables.pressCancel = weapons.pressCancel = stones.pressCancel = ornaments.pressCancel = this.onChildCancel.bind(this);
	
	const bell = new Sprite_Bell({textSize:16, textColor:"#551717", iconOffset:{x:-24,y:-4}, textOffset:{x:9,y:0}, unselectName:"bell_back"});
	bell.x = Graphics.width - 100;
	bell.y = Graphics.height - 36;
	
	this._baseSprite.addChild(consumables, weapons, stones, ornaments, bell);
	this._items.push(consumables, weapons, stones, ornaments);
};

Sprite_Item.prototype.onChildCancel = function() {
	this.active();
};

Sprite_Item.prototype.onLanguageChange = function() {
	Sprite_MenuBase.prototype.onLanguageChange.call(this);
	this._items.forEach((sprite) => {
		sprite.onLanguageChange();
	});
};

function Sprite_ItemIcon() {
	this.initialize(...arguments);
}

Sprite_ItemIcon.prototype = Object.create(Sprite.prototype);
Sprite_ItemIcon.prototype.constructor = Sprite_ItemIcon;

Sprite_ItemIcon.prototype.initialize = function(type, idx) {
	const bitmap = type === "bell" ? ImageManager.loadUI("bell") : ImageManager.loadUI('icons');
	bitmap.smooth = false;
	Sprite.prototype.initialize.call(this, bitmap);
	this._type = type;
	this.refreshIdx(idx);
};

Sprite_ItemIcon.prototype.refreshIdx = function(idx) {
	const type = this._type;
	this._idx = idx;
	const w = 32; const h = 32;
	const mx = 12;
	switch(type) {
		case "weapons": this.setFrame(w * idx, 0, w, h); break;
		case "consumables": this.setFrame(w * idx, h, w, h); break;
		case "stones": this.setFrame(w * idx, h * 2, w, h); break;
		case "ornaments": {
			this.setFrame(w * (idx % mx), h * (3 + Math.trunc(idx / mx)), w, h);
			break;
		}
		default: break;
	}
};

Sprite_ItemIcon.prototype.refreshAll = function(type, idx) {
	this._type = type;
	this.refreshIdx(idx);
};

function Sprite_Consumables() {
	this.initialize(...arguments);
}

Sprite_Consumables.prototype = Object.create(Sprite_ItemBase.prototype);
Sprite_Consumables.prototype.constructor = Sprite_Consumables;

Sprite_Consumables.prototype.initialize = function(options) {
	this.createData();
	this._itemNumTextSize = options.itemNumTextSize;
	this._itemNumTextColor = options.itemNumTextColor;
	this._itemNumTextOffset = options.itemNumTextOffset;
	Sprite_ItemBase.prototype.initialize.call(this, options);
	this.pressOk = this.pressItemOk.bind(this);
};

Sprite_Consumables.prototype.createData = function() {
	this._data = [];
	$gamePlayer.actor().foldConsumables(function(k, itemCfg, num) {
		this._data.push([k, itemCfg, num]);
	}.bind(this));
};

Sprite_Consumables.prototype.categoryName = function() {
	return 'consumables';
};

Sprite_Consumables.prototype.itemDesc = function(item) {
	if(item[2] > 0) {
		return item[1].desc;
	}
	return "";
};

Sprite_Consumables.prototype.baseItemX = function(x) {
	let fix = 0;
	switch(x) {
		case 1: case 3: case 5: fix = 1; break;
		default: break;
	}
	return Sprite_ItemBase.prototype.baseItemX.call(this, x) + fix;
};

Sprite_Consumables.prototype.pageWidth = function() {
	return 6;
};

Sprite_Consumables.prototype.pageHeight = function() {
	return 1;
};

Sprite_Consumables.prototype.data = function() {
	return this._data;
};

Sprite_Consumables.prototype.createItem = function(idx, item) {
	const sprite = Sprite_ItemBase.prototype.createItem.apply(this, arguments);
	this.refreshItemInternal(sprite, item);
};

Sprite_Consumables.prototype.refreshItem = function(idx) {
	const sprite = this._baseSprite.children[idx];
	const item = this.data()[idx];
	this.refreshItemInternal(sprite, item);
};

Sprite_Consumables.prototype.refreshItemInternal = function(sprite, item) {
	const num = item[2];
	if(num > 0) {
		if(!sprite.numBitmap) {
			const numBitmap = new Bitmap(200, this._itemNumTextSize);
			numBitmap.fontSize = this._itemNumTextSize;
			numBitmap.textColor = this._itemNumTextColor;
			numBitmap.outlineWidth = 0;
			const numSprite = new Sprite(numBitmap);
			sprite.addChild(numSprite);
			sprite.numBitmap = numBitmap;
			numSprite.x = this._itemNumTextOffset.x;
			numSprite.y = this._itemNumTextOffset.y;
		}
		sprite.numBitmap.clear();
		if(num > 1) {
			sprite.numBitmap.drawText("x" + num, 0, 0, 200, this._itemNumTextSize, 'left');
		}
		sprite.alpha = 1.0;
	} else {
		sprite.alpha = 0;
	}
};

Sprite_Consumables.prototype.pressItemOk = function() {
	const data = this.data()[this.selectIndex()];
	if($gamePlayer.actor().requestUseConsumable(data[0])) {
		SoundManager.playOk();
		SceneManager.pop();
	}
};

function Sprite_Weapons() {
	this.initialize(...arguments);
}

Sprite_Weapons.prototype = Object.create(Sprite_ItemBase.prototype);
Sprite_Weapons.prototype.constructor = Sprite_Weapons;

Sprite_Weapons.prototype.initialize = function(options) {
	this._equipCursorName = options.equipCursorName;
	this._eqmCursorOffset = options.eqmCursorOffset;
	this.createData();
	Sprite_ItemBase.prototype.initialize.call(this, options);
	this.pressOk = this.onEquipChange.bind(this);
};

Sprite_Weapons.prototype.createData = function() {
	this._data = [];
	$gamePlayer.actor().foldWeapons(function(k, itemCfg, unlock) {
		this._data.push([k, itemCfg, unlock]);
	}.bind(this));
};

Sprite_Weapons.prototype.categoryName = function() {
	return "weapons";
};

Sprite_Weapons.prototype.itemDesc = function(item) {
	if(item[2]) {
		return item[1].desc;
	}
	return "";
};

Sprite_Weapons.prototype.baseItemX = function(x) {
	let fix = 0;
	switch(x) {
		case 1: case 3: fix = 1; break;
		default: break;
	}
	return Sprite_ItemBase.prototype.baseItemX.call(this, x) + fix;
};

Sprite_Weapons.prototype.pageWidth = function() {
	return 4;
};

Sprite_Weapons.prototype.pageHeight = function() {
	return 1;
};

Sprite_Weapons.prototype.data = function() {
	return this._data;
};

Sprite_Weapons.prototype.createItem = function(idx, item) {
	const sprite = Sprite_ItemBase.prototype.createItem.apply(this, arguments);
	this.refreshItemInternal(sprite, item);
};

Sprite_Weapons.prototype.refreshItem = function(idx) {
	const sprite = this._baseSprite.children[idx];
	const item = this.data()[idx];
	this.refreshItemInternal(sprite, item);
};

Sprite_Weapons.prototype.refreshItemInternal = function(sprite, item) {
	const unlock = item[2];
	if(!sprite.eqmSprite) {
		const eqmSprite = new Sprite(ImageManager.loadUI(this._equipCursorName));
		sprite.addChild(eqmSprite);
		eqmSprite.x = this._eqmCursorOffset.x;
		eqmSprite.y = this._eqmCursorOffset.y;
		sprite.eqmSprite = eqmSprite;
	}
	if(this.isEquip(item[0])) {
		sprite.eqmSprite.alpha = 1.0;
	} else {
		sprite.eqmSprite.alpha = 0.0;
	}
	if(unlock) {
		sprite.alpha = 1.0;
	} else {
		sprite.alpha = 0.0;
	}
};

Sprite_Weapons.prototype.isEquip = function(itemId) {
	return $gamePlayer.actor().isWeaponEquip(itemId);
};

Sprite_Weapons.prototype.changeEquip = function(idx) {
	const currentEquip = $gamePlayer.actor().currentWeapon();
	if(this.onChange(idx)) {
		SoundManager.playOk();
		this.refreshItem(currentEquip);
	}
};

Sprite_Weapons.prototype.onChange = function(idx) {
	return $gamePlayer.actor().changeWeapon(idx);
};

Sprite_Weapons.prototype.onEquipChange = function() {
	const idx = this._selectIndex;
	const item = this.data()[idx];
	const unlock = item[2];
	if(unlock) {
		this.changeEquip(idx);
		this.refreshItem(idx);
	}
};

function Sprite_Stones() {
	this.initialize(...arguments);
}

Sprite_Stones.prototype = Object.create(Sprite_ItemBase.prototype);
Sprite_Stones.prototype.constructor = Sprite_Stones;

Sprite_Stones.prototype.initialize = function(options) {
	this.createData();
	Sprite_ItemBase.prototype.initialize.call(this, options);
};

Sprite_Stones.prototype.baseItemX = function(x) {
	let fix = 0;
	switch(x) {
		case 1: fix = 1; break;
		case 3: case 5: case 7: fix = -2; break;
		case 4: case 6: fix = -3; break;
		default: break;
	}
	return Sprite_ItemBase.prototype.baseItemX.call(this, x) + fix;
};

Sprite_Stones.prototype.pageWidth = function() {
	return 8;
};

Sprite_Stones.prototype.pageHeight = function() {
	return 1;
};

Sprite_Stones.prototype.categoryName = function() {
	return "stones";
};

Sprite_Stones.prototype.createData = function() {
	this._data = [];
	$gamePlayer.actor().foldStones(function(k, itemCfg, unlock) {
		this._data.push([k, itemCfg, unlock]);
	}.bind(this));
};

Sprite_Stones.prototype.data = function() {
	return this._data;
};

Sprite_Stones.prototype.createItem = function(idx, item) {
	const sprite = Sprite_ItemBase.prototype.createItem.apply(this, arguments);
	this.refreshItemInternal(sprite, item);
};

Sprite_Stones.prototype.refreshItem = function(idx) {
	const sprite = this._baseSprite.children[idx];
	const item = this.data()[idx];
	this.refreshItemInternal(sprite, item);
};

Sprite_Stones.prototype.refreshItemInternal = function(sprite, item) {
	const unlock = item[2];
	if(unlock) {
		sprite.alpha = 1.0;
	} else {
		sprite.alpha = 0.0;
	}
};

Sprite_Stones.prototype.itemDesc = function(item) {
	if(item[2]) {
		return item[1].desc;
	}
	return "";
};

function Sprite_Ornaments() {
	this.initialize(...arguments);
}

Sprite_Ornaments.prototype = Object.create(Sprite_Weapons.prototype);
Sprite_Ornaments.prototype.constructor = Sprite_Ornaments;

Sprite_Ornaments.prototype.initialize = function(options) {
	this._remainTipsOffsetY = options.remainTipsOffsetY;
	Sprite_Weapons.prototype.initialize.call(this, options);
	this.createRemainTips();
};

Sprite_Ornaments.prototype.createRemainTips = function() {
	this._remainBitmap = new Bitmap(this._backSprite.width, this._descTextSize);
	this._remainBitmap.textColor = this._descTextColor;
	this._remainBitmap.fontSize = this._descTextSize;
	this._remainBitmap.outlineWidth = 0;
	const sp = new Sprite(this._remainBitmap);
	this._baseSprite.addChild(sp);
	sp.y = this._remainTipsOffsetY;
	this._remainSprite = sp;
	this._remainSpriteFlashCounter = 0;
	this.refreshRemainTips();
};

Sprite_Ornaments.prototype.update = function() {
	Sprite_Weapons.prototype.update.call(this);
	this.updateRemainTipsFlash();
};

Sprite_Ornaments.prototype.updateRemainTipsFlash = function() {
	if(this._remainSpriteFlashCounter) {
		this._remainSpriteFlashCounter--;
		if(!this._remainSpriteFlashCounter) {
			this._remainSprite.setBlendColor([0,0,0,0]);
		} else {
			const alpha = Math.round((this._remainSpriteFlashCounter & 6) / 6 * 255);
			this._remainSprite.setBlendColor([255,255,255,alpha]);
		}
	}
};

Sprite_Ornaments.prototype.onLanguageChange = function() {
	Sprite_ItemBase.prototype.onLanguageChange.call(this);
	this.refreshRemainTips();
};

Sprite_Ornaments.prototype.refreshRemainTips = function() {
	this._remainBitmap.clear();
	this._remainBitmap.drawCenterText(TextManager.STATIC_TEXT_ITEM_ORNAMENTS_REMAIN.format($gamePlayer.actor().ornamentsRest()));
};

Sprite_Ornaments.prototype.baseItemX = function(x) {
	let fix = -3;
	switch(x) {
		case 0: case 2: case 4: fix += 1; break;
		case 6: case 8: case 10: fix -= 1; break;
		case 11: fix -= 2; break;
		default: break;
	}
	return Sprite_ItemBase.prototype.baseItemX.call(this, x) + fix;
};

Sprite_Ornaments.prototype.pageWidth = function() {
	return 12;
};

Sprite_Ornaments.prototype.pageHeight = function() {
	return 2;
};

Sprite_Ornaments.prototype.categoryName = function() {
	return "ornaments";
};

Sprite_Ornaments.prototype.createData = function() {
	this._data = [];
	$gamePlayer.actor().foldOrnaments(function(k, itemCfg, unlock) {
		this._data.push([k, itemCfg, unlock]);
	}.bind(this));
};

Sprite_Ornaments.prototype.changeEquip = function(idx) {
	if(this.onChange(idx)) {
		SoundManager.playOk();
		this.refreshRemainTips();
	} else {
		this.flashRemainTips();
	}
};

Sprite_Ornaments.prototype.flashRemainTips = function() {
	this._remainSpriteFlashCounter = 30;
	SoundManager.playBuzzer();
};

Sprite_Ornaments.prototype.isEquip = function(idx) {
	return $gamePlayer.actor().isOrnamentEquip(idx);
};

Sprite_Ornaments.prototype.onChange = function(idx) {
	return $gamePlayer.actor().changeOrnament(idx);
};

function Sprite_HPBar() {
	this.initialize(...arguments);
}

Sprite_HPBar.prototype = Object.create(Sprite.prototype);
Sprite_HPBar.prototype.constructor = Sprite_HPBar;

Sprite_HPBar.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._rollInterval = options.rollInterval;
	this._backName = options.backName;
	this._rollName = options.rollName;
	this._progressName = options.progressName;
	this._progressOffset = options.progressOffset;
	this._rollSpeed = options.rollSpeed;
	this._progressSpeed = options.progressSpeed;
	
	this._progress = this.progress();
	this._rollProgress = this._progress;
	this._rollState = 0;
	this._rollReadyCounter = 0;
	this._rollProgressCompare = this._progress;
	this._realState = 0;
	this._realProgressBuffer = this._progress;
	this._orientation = [1, 1];
	this._animation = new AnimationController();
	this.createAllParts();
};

Sprite_HPBar.prototype.sync = function(progress) {
	this.updateProgress(true, progress);
	this._realProgressBuffer = 0;
};

Sprite_HPBar.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_HPBar.prototype.allHeight = function() {
	return this._backSprite.height;
};

Sprite_HPBar.prototype.createAllParts = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
	
	const rollShiftX = this.rollShiftX();
	const rollShiftY = this.rollShiftY();
	
	const roll = new Sprite(ImageManager.loadUI(this._rollName));
	roll.x = this._progressOffset.x + rollShiftX; 
	roll.y = this._progressOffset.y + rollShiftY;
	this.addChild(roll);
	this._rollSprite = roll;
	
	const progress = new Sprite(ImageManager.loadUI(this._progressName));
	progress.x = this._progressOffset.x;
	progress.y = this._progressOffset.y;
	this.addChild(progress);
	this._progressSprite = progress;
	
	this.updateMask();
};

Sprite_HPBar.prototype.rollShiftX = function() {
	return 0;
};

Sprite_HPBar.prototype.rollShiftY = function() {
	return 0;
};

// [0, 0] up -> down for 100 - 0
// [0, 1] up -> down for 0 - 100
// [1, 0] left -> right for 100 - 0
// [1, 1] left -> right for 0 - 100
Sprite_HPBar.prototype.orientation = function() {
	return this._orientation;
};

Sprite_HPBar.prototype.updateMask = function() {
	const h = this.orientation()[0];
	const reverse = this.orientation()[1];
	const rollShiftX = this.rollShiftX();
	const rollShiftY = this.rollShiftY();
	
	const ph = this._progressSprite.bitmap.height;
	const pw = this._progressSprite.bitmap.width;
	const rh = this._rollSprite.bitmap.height;
	const rw = this._rollSprite.bitmap.width;
	const p = this._progress;
	const r = this._rollProgress;
	if(h) {
		const pwp = Math.ceil(pw*p);
		const rwr = Math.ceil(rw*r);
		if(reverse) {
			this._progressSprite.setFrame(0, 0, pwp, ph);
			this._rollSprite.setFrame(0, 0, rwr, rh);
		} else {
			this._progressSprite.setFrame(pw-pwp, 0, pwp, ph); 
			this._rollSprite.setFrame(rw-rwr, 0, rwr, rh);
		}
		this._progressSprite.x = this._progressSprite._frame.x + this._progressOffset.x;
		this._rollSprite.x = this._rollSprite._frame.x + this._progressOffset.x + rollShiftX;
	} else {
		const php = Math.ceil(ph*p);
		const rhr = Math.ceil(rh*r);
		if(reverse) {
			this._progressSprite.setFrame(0, 0, pw, php);
			this._rollSprite.setFrame(0, 0, rw, rhr);
		} else {
			this._progressSprite.setFrame(0, ph-php, pw, php); 
			this._rollSprite.setFrame(0, rh-rhr, rw, rhr);
		}
		this._progressSprite.y = this._progressSprite._frame.y + this._progressOffset.y;
		this._rollSprite.y = this._rollSprite._frame.y + this._progressOffset.y + rollShiftY;
	}
};

Sprite_HPBar.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateProgress();
	this._animation.update();
	this.updateRoll();
	this.updateMask();
};

Sprite_HPBar.prototype.progress = function() {
	return Math.max(0, $gamePlayer.actor().battleObject().hp / $gamePlayer.actor().battleObject().mhp);
};

Sprite_HPBar.prototype.updateRoll = function() {
	switch(this._rollState) {
		case 0: {  // default
			if(this._rollProgress !== this._progress) {
				this._rollReadyCounter = 0;
				this._rollState = 1;
				this._rollProgressCompare = this._progress;
			}	
			break;
		}
		case 1: {  // roll pending
			if(this._rollProgress < this._progress) {
				this._rollProgress = this._progress;
				this._rollState = 0;
			}
			if(this._rollProgressCompare > this._progress) {
				this._rollProgressCompare = this._progress;
				this._rollReadyCounter = 0;
			}
			if(this._rollReadyCounter < this._rollInterval && this._progress !== 0) {
				this._rollReadyCounter++;
			} else {
				this._rollState = 2;
			}
			break;
		}
		case 2: {  // perform roll
			const sign = Utils.sign(this._progress - this._rollProgress);
			const speed = this._rollSpeed * sign;
			this._rollProgress += speed;
			if(Utils.sign(this._progress - this._rollProgress) !== sign) {
				this._rollProgress = this._progress;
				this._rollState = 0;
			}
			break;
		}
	}
};

Sprite_HPBar.prototype.smoothProgress = function() {
	return this._progress;
};

Sprite_HPBar.prototype.updateProgress = function(sync = false, progress) {
	const realProgress = progress ? progress : this.progress();
	if(this._realProgressBuffer !== realProgress && this._realState === 1) {
		this._realState = 0;
	}
	if(this._progress !== realProgress && this._realState === 0) {
		if(sync) {
			this._progress = this._rollProgress = realProgress;
		} else {
			const controller = this._animation;
			controller.removeById(this, "progress");
			controller.add(this, {id: "progress", data:[{
				to:realProgress, property:'_progress', easingType:'easeOutQuart', duration:25
			}]});
		}
		this._realState = 1;
		this._realProgressBuffer = realProgress;
	}
};

function Sprite_SPBar() {
	this.initialize(...arguments);
}

Sprite_SPBar.prototype = Object.create(Sprite.prototype);
Sprite_SPBar.prototype.constructor = Sprite_SPBar;

Sprite_SPBar.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._progressName = options.progressName;
	this._progressOffset = options.progressOffset;
	this._progressSpeed = options.progressSpeed;
	
	this._progress = this.progress();
	this._realState = 0;
	this._realProgressBuffer = this._progress;
	this._orientation = [1, 1];
	this._animation = new AnimationController();
	this.createAllParts();
};

Sprite_SPBar.prototype.createAllParts = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
	
	const progress = new Sprite(ImageManager.loadUI(this._progressName));
	progress.x = this._progressOffset.x;
	progress.y = this._progressOffset.y;
	this.addChild(progress);
	
	this._progressSprite = progress;
	
	this.updateMask();
};

// [0, 0] up -> down for 100 - 0
// [0, 1] up -> down for 0 - 100
// [1, 0] left -> right for 100 - 0
// [1, 1] left -> right for 0 - 100
Sprite_SPBar.prototype.orientation = function() {
	return this._orientation;
};

Sprite_SPBar.prototype.updateMask = function() {
	const h = this.orientation()[0];
	const reverse = this.orientation()[1];
	
	const ph = this._progressSprite.bitmap.height;
	const pw = this._progressSprite.bitmap.width;
	const p = this._progress;
	if(h) {
		const pwp = pw*p;
		if(reverse) {
			this._progressSprite.setFrame(0, 0, pwp, ph);
		} else {
			this._progressSprite.setFrame(pw-pwp, 0, pwp, ph); 
		}
		this._progressSprite.x = this._progressSprite._frame.x + this._progressOffset.x;
	} else {
		const php = ph*p;
		if(reverse) {
			this._progressSprite.setFrame(0, 0, pw, php);
		} else {
			this._progressSprite.setFrame(0, ph-php, pw, php); 
		}
		this._progressSprite.y = this._progressSprite._frame.y + this._progressOffset.y;
	}
};

Sprite_SPBar.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateProgress();
	this._animation.update();
	this.updateMask();
};

Sprite_SPBar.prototype.progress = function() {
	return $gamePlayer.actor().battleObject().sp / $gamePlayer.actor().battleObject().msp;
};

Sprite_SPBar.prototype.updateProgress = function() {
	const realProgress = this.progress();
	if(this._realProgressBuffer !== realProgress && this._realState === 1) {
		this._realState = 0;
	}
	if(this._progress !== realProgress && this._realState === 0) {
		const controller = this._animation;
		controller.removeById(this, "progress");
		controller.add(this, {id:"progress", data:[{
			to:realProgress, property:'_progress', easingType:'easeOutQuart', duration:25
		}]});
		this._realState = 1;
		this._realProgressBuffer = realProgress;
		if(realProgress >= 1) {
			this.startMaxEffect();
		} else {
			this.endMaxEffect();
		}
	}
};

Sprite_SPBar.prototype.startMaxEffect = function() {
};

Sprite_SPBar.prototype.endMaxEffect = function() {
};

function Sprite_ZPBar() {
	this.initialize(...arguments);
}

Sprite_ZPBar.prototype = Object.create(Sprite_SPBar.prototype);
Sprite_ZPBar.prototype.constructor = Sprite_ZPBar;

Sprite_ZPBar.prototype.initialize = function(options) {
	Sprite_SPBar.prototype.initialize.call(this, options);
};

Sprite_ZPBar.prototype.progress = function() {
	return $gamePlayer.actor().battleObject().zp / $gamePlayer.actor().battleObject().mzp;
};

Sprite_ZPBar.prototype.orientation = function() {
	return [1, 1];
};

Sprite_ZPBar.prototype.createAllParts = function() {
	Sprite_SPBar.prototype.createAllParts.call(this);
	this.createMaxEffect();
};

Sprite_ZPBar.prototype.update = function() {
	Sprite_SPBar.prototype.update.call(this);
	this.updateMaxEffect();
};

Sprite_ZPBar.prototype.createMaxEffect = function() {
	this._maxEffect = new Sprite_KeyFrameAnimationEx("zxc_effect", 4, "img/ui/", 24, 8);
	this._maxEffect.x = -16;
	this._maxEffect.y = -8;
	this.addChild(this._maxEffect);
	this.updateMaxEffect();
};

Sprite_ZPBar.prototype.updateMaxEffect = function() {
	const visible = $gamePlayer.isZPEnoughForZXC();
	if(this._maxEffect.visible !== visible) {
		this._maxEffect.visible = visible;
		if(visible) {
			AudioManager.playNormalSe("zxc_max");
			this._maxEffect.start();
		} else {
			this._maxEffect.stop();
		}
	}
};

function Sprite_BarFace() {
	this.initialize(...arguments);
}

Sprite_BarFace.prototype = Object.create(Sprite.prototype);
Sprite_BarFace.prototype.constructor = Sprite_BarFace;

Sprite_BarFace.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._faceName = options.faceName;
	this._dangerFaceName = options.dangerFaceName;
	this._faceOffset = options.faceOffset;
	
	this._isHpDanger = false;
	this._animation = new AnimationController();
	this.createAllParts();
	this.x = options.x;
	this.y = options.y;
};

Sprite_BarFace.prototype.createAllParts = function() {
	this.createBackground();
	this.createFace();
};

Sprite_BarFace.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_BarFace.prototype.createFace = function() {
	this._faceSprite = new Sprite(ImageManager.loadUI(this._faceName));
	this._dangerFaceSprite = new Sprite(ImageManager.loadUI(this._dangerFaceName));
	this._faceSprite.anchor.x = this._faceSprite.anchor.y = this._dangerFaceSprite.anchor.x = this._dangerFaceSprite.anchor.y = 0.5;
	this._faceSprite.x = this._dangerFaceSprite.x = this._faceOffset.x;
	this._faceSprite.y = this._dangerFaceSprite.y = this._faceOffset.y;
	
	this.addChild(this._faceSprite, this._dangerFaceSprite);
	
	const threshold = this.isHpUnderThreshold();
	if(threshold) {
		this._isHpDanger = true;
		this._faceSprite.alpha = 0;
	} else {
		this._isHpDanger = false;
		this._dangerFaceSprite.alpha = 0;
	}
};

Sprite_BarFace.prototype.setFaceName = function(normal, danger) {
	this._faceSprite.bitmap = ImageManager.loadUI(normal);
	this._dangerFaceSprite.bitmap = ImageManager.loadUI(danger);
};

Sprite_BarFace.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	const threshold = this.isHpUnderThreshold();
	if(threshold && !this._isHpDanger) {
		this.changeToDangerFace();
	} else if(!threshold && this._isHpDanger) {
		this.changeToNormalFace();
	}
};

Sprite_BarFace.prototype.isHpUnderThreshold = function() {
	const hp = $gamePlayer.battleObject().hp;
	const mhp = $gamePlayer.battleObject().mhp;
	const threshold = hp / mhp < this.dangerHpThreshold();
	return threshold;
};

Sprite_BarFace.prototype.changeToDangerFace = function() {
	this._isHpDanger = true;
	this.swapSpriteAlpha(this._dangerFaceSprite, this._faceSprite);
};

Sprite_BarFace.prototype.changeToNormalFace = function() {
	this._isHpDanger = false;
	this.swapSpriteAlpha(this._faceSprite, this._dangerFaceSprite);
};

Sprite_BarFace.prototype.swapSpriteAlpha = function(sprite1, sprite2) {
	const controller = this._animation;
	controller.clear(sprite1);
	controller.clear(sprite2);
	controller.add(sprite1, {data:[{
		to:1, property:'alpha', easingType:'linear', duration:25
	}]});
	controller.add(sprite2, {data:[{
		to:0, property:'alpha', easingType:'linear', duration:25
	}]});
};

Sprite_BarFace.prototype.dangerHpThreshold = function() {
	return 0.2;
};

function Sprite_PlayerBar() {
	this.initialize(...arguments);
}

Sprite_PlayerBar.prototype = Object.create(Sprite.prototype);
Sprite_PlayerBar.prototype.constructor = Sprite_PlayerBar;

Sprite_PlayerBar.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
};

Sprite_PlayerBar.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._options = options;
	this._hpNum = undefined;
	this.createBackground();
	this.createSp();
	this.createZp();
	this.createHp();
	this.createFace();
	this.createHPNumber();
	this.createBuff();
	this.createCoin();
};

Sprite_PlayerBar.prototype.createBackground = function() {
	const background = new Sprite(ImageManager.loadUI(this._options.backName));
	background.x = this._options.backOffset.x;
	background.y = this._options.backOffset.y;
	this.addChild(background);
};

Sprite_PlayerBar.prototype.createHp = function() {
	const opt = this._options.hp;
	this.hpBar = new Sprite_HPBar(opt);
	this.hpBar.x = opt.x;
	this.hpBar.y = opt.y;
	this.addChild(this.hpBar);
};

Sprite_PlayerBar.prototype.createSp = function() {
	const opt = this._options.sp;
	this.spBar = new Sprite_SPBar(opt);
	this.spBar.x = opt.x;
	this.spBar.y = opt.y;
	this.addChild(this.spBar);
};

Sprite_PlayerBar.prototype.createZp = function() {
	const opt = this._options.zp;
	this.zpBar = new Sprite_ZPBar(opt);
	this.zpBar.x = opt.x;
	this.zpBar.y = opt.y;
	this.addChild(this.zpBar);
};

Sprite_PlayerBar.prototype.createFace = function() {
	const opt = this._options.face;
	const sprite = new Sprite_BarFace(opt);
	this.addChild(sprite);
	this.face = sprite;
};

Sprite_PlayerBar.prototype.createHPNumber = function() {
	this.hpNumberBitmap = new Bitmap(240, this._options.hpNumberTextSize + this._options.hpNumberTextOutlineWidth * 2);
	const gradient = this.hpNumberBitmap.context.createLinearGradient(120,0,120,this.hpNumberBitmap.height);
	gradient.addColorStop(0, this._options.hpNumberTextColorStart);
	gradient.addColorStop(1, this._options.hpNumberTextColorStop);
	this.hpNumberBitmap.textColor = gradient;
	this.hpNumberBitmap.fontSize = this._options.hpNumberTextSize;
	this.hpNumberBitmap.outlineColor = this._options.hpNumberTextOutlineColor;
	this.hpNumberBitmap.outlineWidth = this._options.hpNumberTextOutlineWidth;
	const sprite = new Sprite(this.hpNumberBitmap);
	sprite.x = this._options.hpNumberOffset.x;
	sprite.y = this._options.hpNumberOffset.y;
	this.addChild(sprite);
	this.updateHpNumber();
};

Sprite_PlayerBar.prototype.createCoin = function() {
	this._coinBar = new Sprite_Coin({
		backName:'map_coin_back'
		,textColor:'#551717'
		,textSize:16
		,textOffset:{x:11,y:1}
	});
	this.addChild(this._coinBar);
	this._coinBar.x = 386;
	this._coinBar.y = 38;
};

Sprite_PlayerBar.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateHpNumber();
};

Sprite_PlayerBar.prototype.updateHpNumber = function() {
	const hp = Math.round(this.hpBar.smoothProgress() * $gamePlayer.actor().battleObject().mhp);
	if(hp !== this._hpNum) {
		this.hpNumberBitmap.clear();
		this.hpNumberBitmap.drawText(hp.toString(), this._options.hpNumberTextOutlineWidth, this._options.hpNumberTextOutlineWidth, 240, this._options.hpNumberTextSize, 'left');
		this._hpNum = hp;
	}
};

Sprite_PlayerBar.prototype.updateStatus = function() {
};

Sprite_PlayerBar.prototype.createBuff = function() {
	const opt = this._options.buff;
	const buffGroup = new Sprite_BuffIconGroup({character:$gamePlayer, iconBackName:opt.iconBackName, layoutDirection:"up"});
	buffGroup.x = opt.x;
	buffGroup.y = opt.y;
	this.addChild(buffGroup);
};

function Sprite_Coin() {
	this.initialize(...arguments);
}

Sprite_Coin.prototype = Object.create(Sprite.prototype);
Sprite_Coin.prototype.constructor = Sprite_Coin;

Sprite_Coin.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._textColor = options.textColor;
	this._textSize = options.textSize;
	this._textOffset = options.textOffset;
	this._coin = this.coin();
	this._realState = 0;
	this._realCoinBuffer = 0;
	this._drawCoin = undefined;
	
	this._animation = new AnimationController();
	this.createBackground();
	this.createCoinNumber();
};

Sprite_Coin.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_Coin.prototype.coin = function() {
	return $gamePlayer.actor().coin();
};

Sprite_Coin.prototype.createCoinNumber = function() {
	this._coinNumBitmap = new Bitmap(this._backSprite.width, this._backSprite.height);
	this._coinNumBitmap.textColor = this._textColor;
	this._coinNumBitmap.outlineWidth = 0;
	this._coinNumBitmap.fontSize = this._textSize;
	const sprite = new Sprite(this._coinNumBitmap);
	this.addChild(sprite);
	sprite.x = this._textOffset.x;
	sprite.y = this._textOffset.y;
	this.updateText();
};

Sprite_Coin.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateCoin();
	this.updateText();
	this._animation.update();
};

Sprite_Coin.prototype.updateCoin = function() {
	const realCoin = this.coin();
	if(this._realCoinBuffer !== realCoin && this._realState === 1) {
		this._realState = 0;
	}
	if(this._coin !== realCoin && this._realState === 0) {
		const controller = this._animation;
		controller.clear(this);
		controller.add(this, {data:[{
			to:realCoin, property:'_coin', easingType:'easeOutQuart', duration:90
		}]});
		this._realState = 1;
		this._realCoinBuffer = realCoin;
	}
};

Sprite_Coin.prototype.updateText = function() {
	if(this._coin !== this._drawCoin) {
		this.updateTextInternal();
		this._drawCoin = this._coin;
	}
};

Sprite_Coin.prototype.updateTextInternal = function() {
	const str = "" + Math.round(this._coin);
	this._coinNumBitmap.clear();
	this._coinNumBitmap.drawCenterText(str);
};

ImageManager.loadArtwork = function(filename) {
	return this.loadBitmap('img/artwork/', filename);
};

function Sprite_Artwork() {
	this.initialize(...arguments);
}

Sprite_Artwork.prototype = Object.create(Sprite.prototype);
Sprite_Artwork.prototype.constructor = Sprite_Artwork;

Sprite_Artwork.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this._animation = new AnimationController();
	this.createAllPos();
};

Sprite_Artwork.prototype.start = function() {
	this.visible = true;
	this.fadeOutPerformed = false;
};

Sprite_Artwork.prototype.terminate = function() {
	this.visible = false;
	this.children.forEach((sp) => {sp.bitmap = null;});
	this.clearPosInfo();
};

Sprite_Artwork.prototype.clearPosInfo = function() {
	this.posInfo = [{},{},{},{}];
};

Sprite_Artwork.prototype.pos = function() {
	return [Math.round(0.19 * Graphics.width), Math.round(0.38 * Graphics.width), Math.round(0.62 * Graphics.width), Math.round(0.81 * Graphics.width)];
};

Sprite_Artwork.prototype.canStart = function() {
	return this._messageWindow && this._messageWindow.isOpen();
};

Sprite_Artwork.prototype.canTerminate = function() {
	return this.isAllAnimationCompleted() && this.readyForTerminate(128);
};

Sprite_Artwork.prototype.readyForTerminate = function(openness) {
	return this._messageWindow && !$gameMessage.isBusy() && ((this._messageWindow.isClosing() && this._messageWindow.openness < openness) || this._messageWindow.isClosed());
};

Sprite_Artwork.prototype.isAllAnimationCompleted = function() {
	return this.children.every((sprite) => {
		return this._animation.isCompleted(sprite);
	});
};

Sprite_Artwork.prototype.setMessageWindow = function(win) {
	this._messageWindow = win;
};

Sprite_Artwork.prototype.createAllPos = function() {
	const pos = this.pos();
	for(let i = 0; i < pos.length; i++) {
		const sprite = new Sprite();
		this.applyDefaultTransform(i, sprite);
		this.addChild(sprite);
	}
	this.clearPosInfo();
};

Sprite_Artwork.prototype.applyDefaultTransform = function(pos, sprite) {
	const posArr = this.pos();
	sprite.anchor.y = 1;
	sprite.anchor.x = 0.5;
	sprite.x = posArr[pos];
	sprite.y = Graphics.height;
};

Sprite_Artwork.prototype.update = function() {
	this._animation.update();
	Sprite.prototype.update.call(this);
	if(this.canTerminate() && this.visible) {
		this.terminate();
	} else if(this.readyForTerminate(210) && !this.fadeOutPerformed) {
		this.fadeOutPerformed = true;
		this.fadeOutAll();
	}
	if(this.canStart() && !this.visible) {
		this.start();
	}
	if(this.visible) {
		try {
			this.updateArtwork();
		} catch (err) {
			console.warn("xlsx story parsing error!");
			console.warn(err);
		}
	}
};

Sprite_Artwork.prototype.updateArtwork = function() {
	if(this.updateArtworkInternal()) {
		this.executeExtraOptions($gameMessage.extraOpt());
	}
};

Sprite_Artwork.prototype.updateArtworkInternal = function() {
	const artwork = $gameMessage.artwork();
	const speakerId = $gameMessage.speakerId();
	if(speakerId === 0) {
		return false;
	}
	const live2d = $gameMessage.live2d();
	const artworkPos = $gameMessage.artworkPos();
	const cache = this.posInfo[artworkPos];
	if(cache.artwork !== artwork || cache.live2d !== live2d || cache.speakerId !== speakerId) {
		if(artwork === "") {
			this.requestFadeOut(artworkPos);
		} else {
			const target = this.children[artworkPos];
			const name = DataManager.actorAliasName(speakerId);
			if(!live2d) {
				if(target.constructor === Sprite) {
					target.bitmap = ImageManager.loadArtwork(name + '/' + artwork);
				} else {
					this.removeChild(target);
					const sprite = new Sprite();
					this.applyDefaultTransform(artworkPos, sprite);
					sprite.bitmap = ImageManager.loadArtwork(name + '/' + artwork);
					this.addChildAt(sprite, artworkPos);
				}
			} else {
				if(target.constructor === Sprite || target._name !== name) {
					this.removeChild(target);
					const sprite = new Sprite_Live2D(name);
					sprite.playMotion(artwork);
					this.applyDefaultTransform(artworkPos, sprite);
					this.live2dTransformFix(name, sprite);
					this.addChildAt(sprite, artworkPos);
				} else {
					target.playMotion(artwork);
				}
			}
			if(cache.artwork === undefined || cache.artwork === "") {
				this.requestFadeIn(artworkPos);
			}
		}
		cache.artwork = artwork;
		cache.live2d = live2d;
		cache.speakerId = speakerId;
	}
	return true;
};

Sprite_Artwork.prototype.executeExtraOptions = function(opts) {
	let opt = opts.pop();
	while(opt) {
		const name = opt.name;
		const para = opt.para;
		switch(name) {
			case "add": {
				$gameMessage.setSpeakerId(parseInt(para[0]));
				$gameMessage.setArtwork(para[1], parseInt(para[2]), !!parseInt(para[3]));
				this.updateArtworkInternal();
				break;
			}
			case "del": {
				this.requestFadeOut(parseInt(para[0]));
				break;
			}
			case "swap": {
				this.requestSwap(parseInt(para[0]), parseInt(para[1]));
				break;
			}
			default: break;
		}
		opt = opts.pop();
	}
};

Sprite_Artwork.prototype.requestFadeIn = function(artworkPos) {
	const posArr = this.pos();
	const sprite = this.children[artworkPos];
	const controller = this._animation;
	let from = posArr[artworkPos];
	let to = from;
	const moveDelta = this.fadeMoveDelta();
	switch(artworkPos) {
		case 0: case 1: from -= moveDelta; break;
		case 2: case 3: from += moveDelta; break;
		default: break;
	}
	controller.clear(sprite);
	controller.add(sprite, {data:[{
		property:'x', from:from, to:to, easingType:'easeOutQuart', duration:14
	}]});
	sprite.x = from;
	controller.add(sprite, {data:[{
		property:'alpha', from:0, to:1, easingType:'easeOutQuart', duration:14
	}]});
	sprite.alpha = 0;
};

Sprite_Artwork.prototype.fadeOutAll = function() {
	let pos = 0;
	for(const cache of this.posInfo) {
		if(cache.artwork) {
			this.requestFadeOut(pos);
		}
		pos++;
	}
};

Sprite_Artwork.prototype.requestFadeOut = function(artworkPos) {
	const posArr = this.pos();
	const sprite = this.children[artworkPos];
	const controller = this._animation;
	let to = posArr[artworkPos];
	const moveDelta = this.fadeMoveDelta();
	switch(artworkPos) {
		case 0: case 1: to -= moveDelta; break;
		case 2: case 3: to += moveDelta; break;
		default: break;
	}
	controller.clear(sprite);
	controller.add(sprite, {data:[{
		property:'x', to:to, easingType:'easeOutQuart', duration:14
	}]});
	controller.add(sprite, {data:[{
		property:'alpha', to:0, easingType:'easeOutQuart', duration:14
	}]});
	
};

Sprite_Artwork.prototype.fadeMoveDelta = function() {
	return 50;
};

Sprite_Artwork.prototype.requestSwap = function(artworkPos1, artworkPos2) {
	const sprite1 = this.children[artworkPos1];
	const sprite2 = this.children[artworkPos2];
	this.swapChildren(sprite1, sprite2);
	const cache1 = this.posInfo[artworkPos1];
	const cache2 = this.posInfo[artworkPos2];
	this.posInfo[artworkPos2] = cache1;
	this.posInfo[artworkPos1] = cache2;
	
	const currPos = $gameMessage.artworkPos();
	if(currPos === artworkPos1) {
		$gameMessage.setArtworkPos(artworkPos2);
	} else if(currPos === artworkPos2) {
		$gameMessage.setArtworkPos(artworkPos1);
	}
	
	const posArr = this.pos();
	const controller = this._animation;
	const to1 = posArr[artworkPos1];
	const to2 = posArr[artworkPos2];
	
	controller.clear(sprite1);
	controller.add(sprite1, {data:[{
		property:'x', to:to2, easingType:'easeOutQuart', duration:14
	}]});
	controller.add(sprite1, {data:[{
		property:'alpha', to:1, easingType:'easeOutQuart', duration:14
	}]});
	
	controller.clear(sprite2);
	controller.add(sprite2, {data:[{
		property:'x', to:to1, easingType:'easeOutQuart', duration:14
	}]});
	controller.add(sprite2, {data:[{
		property:'alpha', to:1, easingType:'easeOutQuart', duration:14
	}]});
};

Sprite_Artwork.prototype.live2dTransformFix = function(name, sprite) {
	switch(name) {
		case "Nyarutoru": {
			sprite.scale.x = sprite.scale.y = 0.225;
			sprite.y -= 160;
			break;
		}
		default: break;
	}
};

function Sprite_NotificationBar() {
	this.initialize(...arguments);
}

Sprite_NotificationBar.prototype = Object.create(Sprite.prototype);
Sprite_NotificationBar.prototype.constructor = Sprite_NotificationBar;

Sprite_NotificationBar.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._mainTextOffset = options.mainTextOffset;
	this._subTextOffset = options.subTextOffset;
	this._mainTextSize = options.mainTextSize;
	this._subTextSize = options.subTextSize;
	this._mainTextColor = options.mainTextColor;
	this._subTextColor = options.subTextColor;
	this._runDuration = options.runDuration;
	this._runningMaxShowingTime = options.runningMaxShowingTime;
	this._align = options.align;
	this.y = options.y;
	this.x = Graphics.width;
	this._running = false;
	this._runningShowingTime = -1;
	this._animation = new AnimationController();
	this.createBackground();
	this.createText();
	this.visible = false;
};

Sprite_NotificationBar.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_NotificationBar.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_NotificationBar.prototype.allHeight = function() {
	return this._backSprite.height;
};

Sprite_NotificationBar.prototype.createText = function() {
	const width = this.allWidth();
	this._mainTextBitmap = new Bitmap(width, this._mainTextSize);
	this._mainTextSprite = new Sprite(this._mainTextBitmap);
	this._mainTextSprite.x = this._mainTextOffset.x;
	this._mainTextSprite.y = this._mainTextOffset.y;
	this._mainTextBitmap.textColor = this._mainTextColor;
	this._mainTextBitmap.fontSize = this._mainTextSize;
	this._mainTextBitmap.outlineWidth = 0;
	
	this._subTextBitmap = new Bitmap(width, this._subTextSize);
	this._subTextSprite = new Sprite(this._subTextBitmap);
	this._subTextSprite.x = this._subTextOffset.x;
	this._subTextSprite.y = this._subTextOffset.y;
	this._subTextBitmap.textColor = this._subTextColor;
	this._subTextBitmap.fontSize = this._subTextSize;
	this._subTextBitmap.outlineWidth = 0;
	
	this.addChild(this._mainTextSprite, this._subTextSprite);
};

Sprite_NotificationBar.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateShowingTime();
};

Sprite_NotificationBar.prototype.run = function() {
	const controller = this._animation;
	controller.clear(this);
	this._running = true;
	this._runningShowingTime = -1;
	this.visible = true;
	controller.add(this, {data:[{
		to:Graphics.width - this.allWidth(), property:'x', duration:this._runDuration, easingType:'easeOutQuart'
	}], complete:this.onRunningEnd.bind(this)});
};

Sprite_NotificationBar.prototype.onRunningEnd = function() {
	this._runningShowingTime = 0;
};

Sprite_NotificationBar.prototype.onRunningComplete = function() {
	this._running = false;
	this.visible = false;
};

Sprite_NotificationBar.prototype.updateShowingTime = function() {
	if(this._runningShowingTime !== -1) {
		this._runningShowingTime++;
		if(this._runningShowingTime > this._runningMaxShowingTime) {
			const controller = this._animation;
			controller.add(this, {data:[{
				to:Graphics.width, property:'x', duration:this._runDuration, easingType:'easeOutQuart'
			}], complete:this.onRunningComplete.bind(this)});
			this._runningShowingTime = -1;
		}
	}
};

Sprite_NotificationBar.prototype.isRunning = function() {
	return this._running;
};

Sprite_NotificationBar.prototype.terminateRunning = function() {
	if(this.isRunning()) {
		this._running = false;
		this._runningShowingTime = -1;
		this.x = Graphics.width;
		this.visible = false;
	}
};

Sprite_NotificationBar.prototype.setText = function(mainText, subText = "") {
	this._mainTextBitmap.clear();
	this._mainTextBitmap.drawAlignText(mainText, this._align);
	this._subTextBitmap.clear();
	this._subTextBitmap.drawAlignText(subText, this._align);
};

function Sprite_EnemyHpBar() {
	this.initialize(...arguments);
}

Sprite_EnemyHpBar.prototype = Object.create(Sprite_HPBar.prototype);
Sprite_EnemyHpBar.prototype.constructor = Sprite_EnemyHpBar;

Sprite_EnemyHpBar.prototype.initialize = function(options) {
	Sprite_HPBar.prototype.initialize.apply(this, arguments);
	this._showX = options.showX;
	this.y = this._showY = options.showY;
	this._hiddenDuration = options.hiddenDuration;
	
	this.hideWaitingCounter = 0;
	this._hidden = true;
	this._cachedHotEvent = null;
};

Sprite_EnemyHpBar.prototype.progress = function() {
	const hotEvent = $gameMap.hotEvent();
	if(hotEvent && hotEvent.battleObject()) {
		const obj = hotEvent.battleObject();
		return Math.max(0, obj._hp / obj.mhp);
	}
	return 0;
};

Sprite_EnemyHpBar.prototype.orientation = function() {
	return [1, 0];
};

Sprite_EnemyHpBar.prototype.update = function() {
	this.updateHotEventChange();
	Sprite_HPBar.prototype.update.call(this);
	this.updatePosition();
};

Sprite_EnemyHpBar.prototype.updateHotEventChange = function() {
	const hotEvent = $gameMap.hotEvent();
	if(hotEvent && this._cachedHotEvent !== hotEvent) {
		this._cachedHotEvent = hotEvent;
		const opt = $gameMap.hotEventOpt();
		this.sync(opt.initHp / hotEvent.battleObject().mhp);
	}
};

Sprite_EnemyHpBar.prototype.updatePosition = function() {
	if($gameMessage.isBusy() || $gameMap.isEventRunning() || this.isBarShelterPlayer()) {
		if(this.hideWaitingCounter >= 3) {
			this.updateHidden(true);
		} else {
			this.hideWaitingCounter++;
		}
	} else {
		if(this.progress() === 0) {
			if(this.hideWaitingCounter >= 135) {
				this.updateHidden(true);
			} else {
				this.hideWaitingCounter++;
			}
		} else {
			this.hideWaitingCounter = 0;
			this.updateHidden(false);
		}
	}
};

Sprite_EnemyHpBar.prototype.updateHidden = function(newVal) {
	if(this._hidden !== newVal) {
		this._hidden = newVal;
		const controller = this._animation;
		controller.removeById(this, "hidden");
		if(this._hidden) {
			controller.add(this, {id:"hidden", data:[{
				to:this.hiddenX(),duration:this._hiddenDuration,easingType:'easeOutQuart',property:'x'
			}]});
		} else {
			controller.add(this, {id:"hidden", data:[{
				to:this._showX,duration:this._hiddenDuration,easingType:'easeOutQuart',property:'x'
			}]});
		}
	}
};

Sprite_EnemyHpBar.prototype.hiddenX = function() {
	return Graphics.width;
};

Sprite_EnemyHpBar.prototype.rollShiftX = function() {
	return 0;
};

Sprite_EnemyHpBar.prototype.rollShiftY = function() {
	return 0;
};

Sprite_EnemyHpBar.prototype.isBarShelterPlayer = function() {
	const barX = this._showX;
	const barY = 0;
	const sx = -$gameMap.displayX() * $gameMap.tileWidth() + $gamePlayer.px;
	const sy = -$gameMap.displayY() * $gameMap.tileHeight() + $gamePlayer.py;
	const hl = $gamePlayer.hitOffsetL();
	const ht = $gamePlayer.hitOffsetT();
	const hr = $gamePlayer.hitOffsetR();
	const hb = $gamePlayer.hitOffsetB();
	const width = 504;
	const height = 108;
	return !physicsASM.isRectOutBound(sx, sy, hl, ht, hr, hb, barX, barY, 0, 0, width, height);
};

function Sprite_DamageDigitGroup() {
	this.initialize(...arguments);
}

Sprite_DamageDigitGroup.prototype = Object.create(Sprite.prototype);
Sprite_DamageDigitGroup.prototype.constructor = Sprite_DamageDigitGroup;

Sprite_DamageDigitGroup.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this._interactSprite = new Sprite(ImageManager.loadUI('interact'));
	this._interactDownSprite = new Sprite(ImageManager.loadUI('interact_down'));
	this._interactSprite.anchor.x = this._interactDownSprite.anchor.x = 0.5;
	this._interactSprite.anchor.y = this._interactDownSprite.anchor.y = 1;
	this._interactText = "";
	this._interactDownText = "";
	this._interactAlphaDir = false;
	this._baseSprite = new Sprite();
	
	this.addChild(this._interactSprite, this._interactDownSprite);
	this.addChild(this._baseSprite);
	this.createTextSprite();
};

Sprite_DamageDigitGroup.prototype.createTextSprite = function() {
	const width = 58;
	this._interactTextBitmap = new Bitmap(width, this._interactSprite.height);
	this._interactTextSprite = new Sprite(this._interactTextBitmap);
	this._interactSprite.addChild(this._interactTextSprite);
	this._interactTextSprite.x = (this._interactSprite.width - width) * 0.5;
	this._interactTextSprite.anchor.x = 0.5;
	this._interactTextSprite.anchor.y = 1;
	this._interactTextBitmap.outlineWidth = 0;
	this._interactTextBitmap.textColor = "#551717";
	this._interactTextBitmap.fontSize = 18;
	
	this._interactDownTextBitmap = new Bitmap(width, this._interactDownSprite.height);
	this._interactDownTextSprite = new Sprite(this._interactDownTextBitmap);
	this._interactDownSprite.addChild(this._interactDownTextSprite);
	this._interactDownTextSprite.x = (this._interactDownSprite.width - width) * 0.5;
	this._interactDownTextSprite.anchor.x = 0.5;
	this._interactDownTextSprite.anchor.y = 1;
	this._interactDownTextBitmap.outlineWidth = 0;
	this._interactDownTextBitmap.textColor = "#551717";
	this._interactDownTextBitmap.fontSize = 18;
};

Sprite_DamageDigitGroup.prototype.updateInteractText = function() {
	this._interactTextBitmap.clear();
	this._interactTextBitmap.drawCenterText(TextManager[this._interactText]);
};

Sprite_DamageDigitGroup.prototype.updateInteractDownText = function() {
	this._interactDownTextBitmap.clear();
	this._interactDownTextBitmap.drawCenterText(TextManager[this._interactDownText]);
};

Sprite_DamageDigitGroup.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateDigits();
	this.updateInteractSign();
};

Sprite_DamageDigitGroup.prototype.updateInteractSign = function() {
	if($gamePlayer.interactSign()) {
		if(this._interactText !== $gamePlayer.interactSign()) {
			this._interactText = $gamePlayer.interactSign();
			this.updateInteractText();
		}
		this._interactSprite.visible = true;
	}
	else {
		this._interactSprite.visible = false;
	}
	if($gamePlayer.interactSignDown()) {
		if(this._interactDownText !== $gamePlayer.interactSignDown()) {
			this._interactDownText = $gamePlayer.interactSignDown();
			this.updateInteractDownText();
		}
		this._interactDownSprite.visible = true;
	}
	else {
		this._interactDownSprite.visible = false;
	}
	if(this._interactSprite.visible || this._interactDownSprite.visible) {
		this.updateInteractSignAlpha();
	}
	this.updateInteractSignPos();
};

Sprite_DamageDigitGroup.prototype.updateInteractSignPos = function() {
	if(this._interactSprite.visible && this._interactDownSprite.visible) {
		this._interactSprite.x = $gamePlayer.interactSignX();
		this._interactSprite.y = $gamePlayer.interactSignY();
		this._interactDownSprite.x = $gamePlayer.interactSignDownX();
		this._interactDownSprite.y = $gamePlayer.interactSignDownY();
	} else {
		this._interactDownSprite.x = this._interactSprite.x = $gamePlayer.interactSignDownX();
		this._interactDownSprite.y = this._interactSprite.y = $gamePlayer.interactSignDownY();
	}
};

Sprite_DamageDigitGroup.prototype.interactSignFadeSpeed = function() {
	return 0.012;
};

Sprite_DamageDigitGroup.prototype.updateInteractSignAlpha = function() {
	const speed = this.interactSignFadeSpeed();
	if(this._interactAlphaDir) {
		this._interactSprite.alpha += speed;
		if(this._interactSprite.alpha >= 1) {
			this._interactSprite.alpha = 1;
			this._interactAlphaDir = !this._interactAlphaDir;
		}
	} else {
		this._interactSprite.alpha -= speed;
		if(this._interactSprite.alpha <= 0.5) {
			this._interactSprite.alpha = 0.5;
			this._interactAlphaDir = !this._interactAlphaDir;
		}
	}
	this._interactDownSprite.alpha = this._interactSprite.alpha;
};

Sprite_DamageDigitGroup.prototype.updateDigits = function() {
	const digits = $gameMap.damageDigit();
	for(const digit of digits) {
		if(!this.isDigitInChild(digit)) {
			const digitSprite = new Sprite_DamageDigit(digit);
			digitSprite.anchor.x = 0.5;
			digitSprite.anchor.y = 0.5;
			this._baseSprite.addChild(digitSprite);
		}
	}
};

Sprite_DamageDigitGroup.prototype.isDigitInChild = function(digit) {
	return this._baseSprite.children.some((child) => {
		return child._digit === digit;
	});
};

function Sprite_DamageDigit() {
	this.initialize(...arguments);
}

Sprite_DamageDigit.prototype = Object.create(Sprite.prototype);
Sprite_DamageDigit.prototype.constructor = Sprite_DamageDigit;

Sprite_DamageDigit.prototype.initialize = function(digit) {
	Sprite.prototype.initialize.apply(this);
	this._digit = digit;
	this.createDigit();
	this.updatePosition();
};

Sprite_DamageDigit.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateVisible();
	this.updateAlpha();
	this.updatePosition();
	this.updateScale();
};

Sprite_DamageDigit.prototype.updateVisible = function() {
	const digits = $gameMap.damageDigit();
	if(!digits.includes(this._digit)) {
		this.parent.removeChild(this);
	}
};

Sprite_DamageDigit.prototype.alphaStartTime = function() {
	return 0.66;
};

Sprite_DamageDigit.prototype.updateAlpha = function() {
	const time = this._digit.time;
	const maxTime = $gameMap.maxDigitTime();
	const rate = time / maxTime;
	if(rate > this.alphaStartTime()) {
		this.alpha = 1 - (rate - this.alphaStartTime()) / (1 - this.alphaStartTime());
	} else {
		this.alpha = 1;
	}
};

Sprite_DamageDigit.prototype.updatePosition = function() {
	this.x = Math.round((this._digit.x + $gameMap.tileWidth() * (this._digit.dx - $gameMap.displayX())) * $gameMap.scale());
	this.y = Math.round((this._digit.y + $gameMap.tileHeight() * (this._digit.dy - $gameMap.displayY())) * $gameMap.scale());
};

Sprite_DamageDigit.prototype.updateScale = function() {
	if(this._digit.type === "enemy" || this._digit.damage < 0) {
		this.scale.x = this.scale.y = Math.max(1, 1 + ($gameMap.digitFloatTime() - this._digit.time) * 3 / $gameMap.digitFloatTime());
	}
};

Sprite_DamageDigit.prototype.createDigit = function() {
	let name = "";
	if(this._digit.damage < 0) {
		name = "map_digit_recover";
	} else {
		switch(this._digit.type) {
			case "player": name = "map_digit_player_damage"; break;
			case "enemy": name = "map_digit_enemy_damage"; break;
			default: break;
		}
	}
	const bitmap = ImageManager.loadUI(name);
	const oneWidth = bitmap.width / 10;
	const width = oneWidth * this._digit.damage.toString().length;
	const height = bitmap.height;
	const startX = width / 2;
	const startY = height / 2;
	const str = this._digit.damage.toString();
	let indent = 0;
	for(let i = 0; i < str.length; i++) {
		const c = str[i];
		const digit = parseInt(c);
		if(digit === 1) {
			indent -= Math.trunc(oneWidth / 6);
		}
		const sp = new Sprite_Digit(name, parseInt(c));
		sp.x = -startX + oneWidth * i + indent;
		sp.y = -startY;
		if(digit === 1) {
			indent -= Math.trunc(oneWidth / 6);
		}
		this.addChild(sp);
	}
};

function Sprite_Digit() {
	this.initialize(...arguments);
}

Sprite_Digit.prototype = Object.create(Sprite.prototype);
Sprite_Digit.prototype.constructor = Sprite_Digit;

Sprite_Digit.prototype.initialize = function(name, num) {
	const bitmap = ImageManager.loadUI(name);
	bitmap.smooth = false;
	Sprite.prototype.initialize.call(this, bitmap);
	const width = bitmap.width / 10;
	if(num === 0) {
		this.setFrame(width * 9, 0, width, bitmap.height);
	} else {
		this.setFrame(width * (num - 1), 0, width, bitmap.height);
	}
};

function Sprite_SmallMap() {
	this.initialize(...arguments);
}

Sprite_SmallMap.prototype = Object.create(Sprite.prototype);
Sprite_SmallMap.prototype.constructor = Sprite_SmallMap;

Sprite_SmallMap.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._padding = options.padding;
	this._backName = options.backName;
	this._hiddenDuration = options.hiddenDuration;
	this._baseSprite = new Sprite();
	this.createBackground();
	this.createThumbnail();
	this._showX = Graphics.width - this._padding - this._backSprite.width;
	if(Utils.isNoPopupBarScene() && !$gameMap.bossEvent()) {
		this.x = this._showX;
	} else {
		this.x = Graphics.width;
	}
	this.y = this._padding;
	this._cell = undefined;
	this._hidden = true;
	this._hideWaitingCounter = 0;
	this.addChild(this._baseSprite);
	this._animation = new AnimationController();
	const actor = $gamePlayer.actor();
	this._taskUpdateChecker = actor.tasks().clone();
	this._taskGuideSprite = null;
	this._taskGuideFloatingSpeed = 0;
	if(this.shouldDisplayTaskGuide()) {
		this.createTaskGuide();
	}
};

Sprite_SmallMap.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
	const offset = DataManager.thumbnailCellWidth() / 2 + DataManager.thumbnailMargin() / 2;
	this._baseSprite.x = Math.trunc(this._backSprite.width / 2 - offset);
	this._baseSprite.y = Math.trunc(this._backSprite.height / 2 - offset);
};

Sprite_SmallMap.prototype.createThumbnail = function() {
	this._thumbnail = new Sprite_MapThumbnail();
	const width = Math.trunc(this._backSprite.width / (2 * (DataManager.thumbnailCellWidth() + DataManager.thumbnailMargin())));
	const height = Math.trunc(this._backSprite.height / (2 * (DataManager.thumbnailCellWidth() + DataManager.thumbnailMargin())));
	this._pageWidth = width;
	this._pageHeight = height;
	this._thumbnail.buildPage(true, width, height);
	this._thumbnail.insertTaskSignature();
	this._baseSprite.addChild(this._thumbnail);
};

Sprite_SmallMap.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updatePosition();
	this.updateVisible();
	this.updateNewTask();
	this.updateTaskGuideFloating();
	this._animation.update();
};

Sprite_SmallMap.prototype.updateNewTask = function() {
	const actor = $gamePlayer.actor();
	if(!this._taskUpdateChecker.equals(actor.tasks())) {
		this._thumbnail.clearTaskSignature();
		this._thumbnail.insertTaskSignature();
		this._taskUpdateChecker = actor.tasks().clone();
	}
};

Sprite_SmallMap.prototype.updatePosition = function() {
	const cell = DataManager.getCurrentThumbnailCell();
	if(this._cell !== cell) {
		this._cell = cell;
		$gameSystem.moveThumbnail();
		this._thumbnail.setCurrentCell(cell);
		this._thumbnail.buildPage(true, this._pageWidth, this._pageHeight);
		this._thumbnail.insertTaskSignature();
	}
};

Sprite_SmallMap.prototype.updateVisible = function() {
	if($gameMessage.isBusy() || $gameMap.isEventRunning() || $gameMap.bossEvent() || this.isShelterPlayer()) {
		this._hideWaitingCounter++;
		if(this._hideWaitingCounter >= 3) {
			this.updateHidden(true);
		}
	} else {
		this.updateHidden(false);
		this._hideWaitingCounter = 0;
	}
};

Sprite_SmallMap.prototype.isShelterPlayer = function() {
	const sx = -$gameMap.displayX() * $gameMap.tileWidth() + $gamePlayer.px;
	const sy = -$gameMap.displayY() * $gameMap.tileHeight() + $gamePlayer.py;
	const hl = $gamePlayer.hitOffsetL();
	const ht = $gamePlayer.hitOffsetT();
	const hr = $gamePlayer.hitOffsetR();
	const hb = $gamePlayer.hitOffsetB();
	return !physicsASM.isRectOutBound(sx, sy, hl, ht, hr, hb, this._showX, this._padding, 0, 0, this._backSprite.width, this._backSprite.height);
};

Sprite_SmallMap.prototype.updateHidden = function(newVal) {
	if(this._hidden !== newVal) {
		this._hidden = newVal;
		const controller = this._animation;
		controller.removeById(this, "hidden");
		if(this._hidden) {
			controller.add(this, {id:"hidden", data:[{
				to:Graphics.width,duration:this._hiddenDuration,easingType:'easeOutQuart',property:'x'
			}]});
		} else {
			controller.add(this, {id:"hidden", data:[{
				to:this._showX,duration:this._hiddenDuration,easingType:'easeOutQuart',property:'x'
			}]});
		}
	}
};

Sprite_SmallMap.prototype.shouldDisplayTaskGuide = function() {
	return !$gameSwitches.value(3) && $gameMap.mapId() === 5;
};

Sprite_SmallMap.prototype.createTaskGuide = function() {
	this._taskGuideSprite = new Sprite();
	this._baseSprite.addChild(this._taskGuideSprite);
	const textSprite = new Sprite_PadText({
		text:TextManager.STATIC_TEXT_TASK_GUIDE
		, edgeName:"task_guide_pad_edge"
		, innerName:"task_guide_pad_inner"
		, textSize:24
		, textColor:"#551717"
	});
	textSprite.y = 136;
	const arrowSprite = new Sprite(ImageManager.loadUI("task_guide_arrow"));
	arrowSprite.anchor.set(0.5);
	arrowSprite.y = 70;
	this._taskGuideSprite.addChild(textSprite, arrowSprite);
	this._taskGuideFloatingSpeed = this.guideFloatingSpeed();
	this.updateTaskGuidePosition();
};

Sprite_SmallMap.prototype.updateTaskGuideFloating = function() {
	if(this._taskGuideSprite) {
		this.updateTaskGuidePosition();
		const distance = this.guideFloatingDistance();
		if(this._taskGuideSprite.y < distance && this._taskGuideFloatingSpeed > 0 || this._taskGuideSprite.y > -distance && this._taskGuideFloatingSpeed < 0) {
			this._taskGuideSprite.y += this._taskGuideFloatingSpeed;
		} else {
			this._taskGuideFloatingSpeed = -this._taskGuideFloatingSpeed;
		}
	}
};

Sprite_SmallMap.prototype.updateTaskGuidePosition = function() {
	const sprite = this._thumbnail.firstTaskSignatureSprite();
	if(sprite) {
		this._taskGuideSprite.x = sprite.x;
	}
};

Sprite_SmallMap.prototype.guideFloatingSpeed = function() {
	return 0.2;
};

Sprite_SmallMap.prototype.guideFloatingDistance = function() {
	return 10;
};

function Sprite_Transport() {
	this.initialize(...arguments);
}

Sprite_Transport.prototype = Object.create(Sprite.prototype);
Sprite_Transport.prototype.constructor = Sprite_Transport;

Sprite_Transport.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._regionTitleBackName = options.regionTitleBackName;
	this._regionTitleOffset = options.regionTitleOffset;
	this._regionTitleTextOffset = options.regionTitleTextOffset;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._regionImagePadding = options.regionImagePadding;  // 区域预览与选择窗口部分的间隔
	this._regionCommandOffset = options.regionCommandOffset;
	this._regionCommandBackName = options.regionCommandBackName;
	this._regionMapBackName = options.regionMapBackName;
	this._commandMaskPadding = options.commandMaskPadding;
	this._cursorOffset = options.cursorOffset;
	this._lockOffset = options.lockOffset;
	this._moveSignMargin = options.moveSignMargin;
	this._moveSignName = options.moveSignName;
	this._taskSelectOptions = options.taskSelectOptions;
	
	this._commandBackName = options.commandBackName;
	this._commandLockName = options.commandLockName;
	this._commandCursorName = options.commandCursorName;
	
	this._tipsBackName = options.tipsBackName;
	this._tipsTextColor = options.tipsTextColor;
	
	this._pageIndex = 0;
	this._selectIndex = 0;
	this._isDragging = false;
	this._dragStartY = 0;
	this._dragSelectPageOffset = 0;
	this.pressOk = null;
	this.pressCancel = null;
	this._tasks = [];
	this._animation = new AnimationController();
	this._taskState = "map";   // or "select"
	this.createRegionName();
	this.createRegionCommand();
	this.createRegionMapThumbnail();
	this.createControlTips();  // press X to task select mode
	this.createTaskSelect();
	this.createCancelButton();
	this.changeRegionThumbnail(this.selectRegion());
};

Sprite_Transport.prototype.createRegionName = function() {
	this._regionNameSprite = new Sprite(ImageManager.loadUI(this._regionTitleBackName));
	this._regionNameSprite.x = this._regionTitleOffset.x;
	this._regionNameSprite.y = this._regionTitleOffset.y;
	this.addChild(this._regionNameSprite);
	this.createRegionSelectText();
};

Sprite_Transport.prototype.createRegionSelectText = function() {
	const text = TextManager['STATIC_TEXT_TRANSPORT_TITLE'];
	const bitmap = new Bitmap(this._regionNameSprite.width, this._regionNameSprite.height);
	this.initBitmapText(bitmap);
	bitmap.drawCenterText(text);
	const sprite = new Sprite(bitmap);
	this._regionNameSprite.addChild(sprite);
	sprite.x = this._regionTitleTextOffset.x;
	sprite.y = this._regionTitleTextOffset.y;
	this._regionTextBitmap = bitmap;
};

Sprite_Transport.prototype.initBitmapText = function(bitmap) {
	bitmap.outlineWidth = 0;
	bitmap.fontSize = this._textSize;
	bitmap.textColor = this._textColor;
};

Sprite_Transport.prototype.createRegionCommand = function() {
	this._commandBackSprite = new Sprite(ImageManager.loadUI(this._regionCommandBackName));
	this._commandBackSprite.x = this._regionCommandOffset.x;
	this._commandBackSprite.y = this._regionCommandOffset.y;
	this.addChild(this._commandBackSprite);
	this.createCommandData();
	this.createCommandMoveSign();
};

Sprite_Transport.prototype.createRegionMapThumbnail = function() {
	this._regionThumbnailSprite = new Sprite(ImageManager.loadUI(this._regionMapBackName));
	this._regionThumbnailSprite.x = this._regionCommandOffset.x + this._regionImagePadding + this._commandBackSprite.width;
	this._regionThumbnailSprite.y = this._commandBackSprite.y;
	this.addChild(this._regionThumbnailSprite);
	this._regionThumbnail = new Sprite_MapThumbnail();
	this._regionThumbnailSprite.addChild(this._regionThumbnail);
	this._regionTaskSprite = new Sprite();
	this._regionThumbnailSprite.addChild(this._regionTaskSprite);
};

Sprite_Transport.prototype.createControlTips = function() {
	const sprite = new Sprite(ImageManager.loadUI(this._tipsBackName));
	this._regionThumbnailSprite.addChild(sprite);
	sprite.x = (this._regionThumbnailSprite.width - sprite.width) / 2;
	this._tipsBitmap = new Bitmap(sprite.width, sprite.height);
	const textSprite = new Sprite(this._tipsBitmap);
	sprite.addChild(textSprite);
	this._tipsBitmap.fontSize = this._textSize;
	this._tipsBitmap.textColor = this._tipsTextColor;
	this._tipsBitmap.outlineWidth = 0;
	this._tipsSprite = sprite;
	this.refreshTips();
};

Sprite_Transport.prototype.createTaskSelect = function() {
	this._taskSelect = new Sprite_TaskSelect(this._taskSelectOptions);
	this._regionThumbnailSprite.addChild(this._taskSelect);
	this._taskSelect.pressOk = this.onTaskSelect.bind(this);
	this._taskSelect.pressCancel = this.deactiveTaskSelect.bind(this);
	this._taskSelect.x = (this._regionThumbnailSprite.width - this._taskSelect.allWidth()) / 2;
	this._taskSelect.y = this._tipsBitmap.height + this._taskSelect._moveSignUp.height + this._taskSelect._moveSignMargin + ((this._regionThumbnailSprite.height - this._tipsBitmap.height) - this._taskSelect.allHeight()) / 2;
};

Sprite_Transport.prototype.onTaskSelect = function() {
	this.deactiveTaskSelect();
	const taskId = this._taskSelect.selectDataId();
	this._tasks = [taskId];
	const regionId = DataManager.taskRegion(taskId);
	this.updateSelectIndex(regionId - 1);
	this.createAllTaskWindow();
	return true;
};

Sprite_Transport.prototype.refreshTips = function() {
	this._tipsBitmap.clear();
	if(Utils.isMobileDevice()) {
		if(this._taskState === "map") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_TASK_TOUCH"]);
		} else if(this._taskState === "select") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_CANCEL_TASK_TOUCH"]);
		}
	} else {
		if(this._taskState === "map") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_TASK_MODE"].format(ConfigManager.getInputName(this.taskControlInput())));
		} else if(this._taskState === "select") {
			this._tipsBitmap.drawCenterText(TextManager["STATIC_TEXT_TRANSPORT_CANCEL_TASK_MODE"].format(ConfigManager.getInputName('ok')));
		}
	}
};

Sprite_Transport.prototype.taskControlInput = function() {
	return 'bullet';
};

Sprite_Transport.prototype.changeRegionThumbnail = function(regionId) {
	const thumbnail = this._regionThumbnail;
	const cell = $dataRegion[regionId].transportCell;
	if(cell) {
		thumbnail.setCurrentCell(cell);
		thumbnail.buildPage(false, 0, 0, cell.page);
		thumbnail.insertTaskSignature();
		thumbnail.x = (this._regionThumbnailSprite.width - thumbnail.allWidth()) / 2;
		thumbnail.y = (this._regionThumbnailSprite.height - thumbnail.allHeight()) / 2;
		thumbnail.x = thumbnail.x | 0;
		thumbnail.y = thumbnail.y | 0;
	} else {
		thumbnail.clear();
	}
	this._regionTaskSprite.removeChildren();
};

Sprite_Transport.prototype.createAllTaskWindow = function() {
	this._regionTaskSprite.removeChildren();
	const tasks = this._tasks;
	const paddingFrame = 12;
	const paddingWindow = 6;
	const maxWidth = this._regionThumbnailSprite.width - paddingFrame * 2;
	for(const taskId of tasks) {
		const page = DataManager.taskPage(taskId);
		if(!$dataRegion[this.selectRegion()].transportCell || page !== $dataRegion[this.selectRegion()].transportCell.page) {
			continue;
		}
		const name = DataManager.taskFullName(taskId);
		const thumbnail = this._regionThumbnail;
		const pos = thumbnail.evidToCellPosition($dataTask[taskId].ev);
		if(!pos) {
			continue;
		}
		const taskWin = new Window_TaskInBallon(new Rectangle(0, 0, 20, 20));
		taskWin.resetFontSettings();
		const cx = this._regionThumbnailSprite.width / 2;
		const cy = this._regionThumbnailSprite.height / 2;
		const cw = thumbnail.allWidth() / 2;
		const ch = thumbnail.allHeight() / 2;
		// cx + pos.x - cw是thumbnal内部的x坐标转换为其parent的x坐标
		// cy + pos.y - ch是thumbnal内部的y坐标转换为其parent的y坐标
		const size = taskWin.contents.measureTextWidth(name);
		const windowWidth = taskWin.windowWidth(size);
		const windowHeight = taskWin.windowHeight();
		const sx = cx + pos.x - cw - (windowWidth / 2);
		let sy = 0;
		sy = cy + pos.y - ch - windowHeight - DataManager.thumbnailCellWidth();
		if(this.checkExistingRect(new Rectangle(sx, sy, windowWidth, windowHeight))) {
			sy = cy + pos.y - ch + DataManager.thumbnailCellWidth();
			taskWin.setArrowDir("up");
		}
		const dx = cx + pos.x - cw - sx;
		const dy = cy + pos.y - ch - sy;
		taskWin.x = sx|0;
		taskWin.y = sy|0;
		taskWin.setText(name, dx|0, dy|0);
		this._regionTaskSprite.addChild(taskWin);
		taskWin.open();
	}
};

Sprite_Transport.prototype.checkExistingRect = function(rect) {
	return !this._regionTaskSprite.children.every((win) => {
		return physicsASM.isRectOutBound(win.x, win.y, 0, 0, win.width, win.height, rect.x, rect.y, 0, 0, rect.width, rect.height);
	});
};

Sprite_Transport.prototype.createCommandData = function() {
	this._commandContentSprite = new Sprite();
	this._commandSpriteLower = new Sprite();
	const mask = new PIXI.Graphics();
	mask.beginFill(0xff0000);
	mask.drawRect(this._commandMaskPadding, this._commandMaskPadding, this._commandBackSprite.width - this._commandMaskPadding * 2, this._commandBackSprite.height - this._commandMaskPadding * 2);
	mask.endFill();
	this._commandSpriteLower.mask = mask;
	this._commandSpriteUpper = new Sprite();
	this._commandSpriteUpper.mask = mask;
	this._commandBackSprite.addChild(mask);
	this._commandContentSprite.addChild(this._commandSpriteLower);
	this.createCursor(mask);
	this._commandContentSprite.addChild(this._commandSpriteUpper);
	this._commandBackSprite.addChild(this._commandContentSprite);
	let i = 0;
	for(const regionId in $dataRegion) {
		const sprite = new Sprite_TransportCommand({
			commandBackName:this._commandBackName
			,commandLockName:this._commandLockName
			,lockOffset:this._lockOffset
			,pageNum:this.pageNum()
			,pageWidth:this._commandBackSprite.width
			,pageHeight:this._commandBackSprite.height
			,i:i
			,regionId:parseInt(regionId)
			,bitmapSetter:this.initBitmapText.bind(this)
		});
		this._commandSpriteLower.addChild(sprite);
		this._commandSpriteUpper.addChild(sprite.textSprite());
		i++;
	}
	this._commandContentSprite.y = this.pageY();
	this.resetCursorPos();
};

Sprite_Transport.prototype.createCursor = function(mask) {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._commandCursorName));
	this._commandContentSprite.addChild(this._cursorSprite);
	this._cursorSprite.mask = mask;
};

Sprite_Transport.prototype.createCancelButton = function() {
	this._cancelSprite = new Sprite(ImageManager.loadUI("cancel"));
	this._cancelSprite.anchor.set(0.5);
	this._cancelSprite.x = 320;
	this._cancelSprite.y = 56;
	this.addChild(this._cancelSprite);
};

Sprite_Transport.prototype.updateCancelButton = function() {
	if(TouchInput.isClicked() && this._cancelSprite.isBeingTouched()) {
		SoundManager.playCancel();
		this.pressCancel();
	}
	if(TouchInput.isPressed()) {
		if(this._cancelSprite.isBeingTouched()) {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel_press");
		} else {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
		}
	} else if(TouchInput.isReleased()) {
		this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
	}
};

Sprite_Transport.prototype.resetCursorPos = function() {
	this._cursorSprite.x = this.cursorX();
	this._cursorSprite.y = this.cursorY();
};

Sprite_Transport.prototype.cursorX = function() {
	return this._cursorOffset.x + this._commandSpriteLower.children[this._selectIndex].x;
};

Sprite_Transport.prototype.cursorY = function() {
	return this._cursorOffset.y + this._commandSpriteLower.children[this._selectIndex].y;
};

Sprite_Transport.prototype.pageY = function() {
	const targetSprite = this._commandSpriteLower.children[this._pageIndex];
	return -targetSprite.y + targetSprite.x;
};

Sprite_Transport.prototype.onLanguageChange = function() {
	this._commandSprite.children.forEach((sp) => {
		sp.onLanguageChange();
	});
	const text = TextManager['STATIC_TEXT_TRANSPORT_TITLE'];
	this._regionTextBitmap.clear();
	this._regionTextBitmap.drawCenterText(text);
	this.refreshTips();
	this._taskSelect.onLanguageChange();
	this._regionTaskSprite.children.forEach((win) => { win.onLanguageChange(); });
};

Sprite_Transport.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	if(this._taskState === "map") {
		this.updateInput();
	}
	this.updateMoveSign();
	this.updateCancelButton();
	this.updateTouchInput();
};

Sprite_Transport.prototype.updateSelectIndex = function(idx) {
	if(this._selectIndex !== idx) {
		const page = this.updateSelect(idx);
		if(this._pageIndex !== page) {
			this.updatePage(page);
		}
	}
};

Sprite_Transport.prototype.updateInput = function() {
	if(Input.isUITriggered("up") || Input.isRepeated("up")) {
		SoundManager.playCursor();
		this.updateSelectIndex(this.upRegion());
	}
	if(Input.isUITriggered("down") || Input.isRepeated("down")) {
		SoundManager.playCursor();
		this.updateSelectIndex(this.downRegion());
	}
	if(Input.isUITriggered("ok") && this.pressOk) {
		if(this.pressOk()) {
			SoundManager.playOk();
		} else {
			SoundManager.playBuzzer();
		}
	}
	if(Input.isUITriggered("cancel") && this.pressCancel) {
		SoundManager.playCancel();
		this.pressCancel();
	}
	if(Input.isUITriggered(this.taskControlInput())) {
		SoundManager.playCursor();
		this.activeTaskSelect();
	}
};

Sprite_Transport.prototype.updateTouchInput = function() {
	if(TouchInput.isClicked()) {
		if(this._tipsSprite.isBeingTouched()) {
			if(this._taskState === "map") {
				SoundManager.playCursor();
				this.activeTaskSelect();
			} else if(this._taskState === "select") {
				SoundManager.playCancel();
				this.deactiveTaskSelect();
			}
			return;
		}
		for(let i = 0; i < this._commandSpriteLower.children.length; i++) {
			const sprite = this._commandSpriteLower.children[i];
			if(sprite.isBeingTouched()) {
				if(this._selectIndex !== i) {
					SoundManager.playCursor();
					this.updateSelectIndex(i);
				} else {
					if(this.pressOk()) {
						SoundManager.playOk();
					} else {
						SoundManager.playBuzzer();
					}
				}
				break;
			}
		}
	}
	if(TouchInput.isDraged()) {
		if(!this._isDragging) {
			this._isDragging = true;
			this._dragStartY = this._commandContentSprite.y;
		}
		this._commandContentSprite.y = this._dragStartY + TouchInput.moveDeltaY;
	} else {
		if(this._isDragging) {
			this._isDragging = false;
			this.endDragScroll();
		}
	}
};

Sprite_Transport.prototype.endDragScroll = function() {
	let minDistance = -1;
	let bestIdx = 0;
	for(let i = 0; i < this._commandSpriteLower.children.length; i++) {
		const y = this._commandSpriteLower.children[i].y;
		const distance = Math.abs(-this._commandContentSprite.y - y);
		if(minDistance === -1 || distance < minDistance) {
			minDistance = distance;
			bestIdx = i;
		}
	}
	const pageIndex = bestIdx.clamp(0, Math.max(0, Object.keys($dataRegion).length - this.pageNum()));
	this.updatePage(pageIndex);
};

Sprite_Transport.prototype.activeTaskSelect = function() {
	this._taskState = "select";
	this._taskSelect.active();
	this._regionThumbnail.visible = false;
	this._regionTaskSprite.visible = false;
	this.refreshTips();
};

Sprite_Transport.prototype.deactiveTaskSelect = function() {
	this._taskState = "map";
	this._taskSelect.deactive();
	this._regionThumbnail.visible = true;
	this._regionTaskSprite.visible = true;
	this.refreshTips();
};

Sprite_Transport.prototype.upRegion = function() {
	if(this._selectIndex === 0) {
		return Object.keys($dataRegion).length - 1;
	} else {
		return this._selectIndex - 1;
	}
};

Sprite_Transport.prototype.downRegion = function() {
	if(this._selectIndex === Object.keys($dataRegion).length - 1) {
		return 0;
	} else {
		return this._selectIndex + 1;
	}
};

Sprite_Transport.prototype.updateSelect = function(idx) {
	this._selectIndex = idx;
	const x = this.cursorX();
	const y = this.cursorY();
	const controller = this._animation;
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, {data:[
		{property:'y', easingType:'easeOutQuart', duration:18, to:y}
	]});
	controller.add(this._cursorSprite, {data:[
		{property:'x', easingType:'easeOutQuart', duration:18, to:x}
	]});
	this.changeRegionThumbnail(this.selectRegion());
	return this.calcPage();
};

Sprite_Transport.prototype.selectRegion = function() {
	return this._selectIndex + 1;
};

Sprite_Transport.prototype.calcPage = function() {
	if(this._selectIndex >= this._pageIndex + this.pageNum()) {
		return this._selectIndex - this.pageNum() + 1;
	} else if(this._selectIndex < this._pageIndex) {
		return this._selectIndex;
	}
	return this._pageIndex;
};

Sprite_Transport.prototype.updatePage = function(page) {
	this._pageIndex = page;
	const y = this.pageY();
	const controller = this._animation;
	controller.clear(this._commandContentSprite);
	controller.add(this._commandContentSprite, {data:[
		{property:'y', easingType:'easeOutQuart', duration:18, to:y}
	]});
};

Sprite_Transport.prototype.updateMoveSign = function() {
	const pageMin = 0;
	const pageMax = Object.keys($dataRegion).length - this.pageNum();
	if(this._pageIndex <= pageMin) {
		this._moveSignUp.visible = false;
	} else {
		this._moveSignUp.visible = true;
	}
	if(this._pageIndex >= pageMax) {
		this._moveSignDown.visible = false;
	} else {
		this._moveSignDown.visible = true;
	}
};

Sprite_Transport.prototype.createCommandMoveSign = function() {
	const controller = this._animation;
	this._moveSignUp = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignUp.anchor.x = 0.5;
	this._moveSignUp.anchor.y = 0.5;
	this._moveSignUp.y = this._regionCommandOffset.y - this._moveSignMargin;
	this._moveSignUp.x = this._regionCommandOffset.x + this._commandBackSprite.width / 2;
	this.addChild(this._moveSignUp);
	
	
	this._moveSignDown = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignDown.anchor.x = 0.5;
	this._moveSignDown.anchor.y = 0.5;
	this._moveSignDown.y = this._regionCommandOffset.y + this._commandBackSprite.height + this._moveSignMargin;
	this._moveSignDown.x = this._moveSignUp.x;
	this._moveSignDown.scale.y = -1;
	this.addChild(this._moveSignDown);
	
	controller.add(this._moveSignUp, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	controller.add(this._moveSignDown, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	this.updateMoveSign();
};

Sprite_Transport.prototype.pageNum = function() {
	return 4;
};

function Sprite_TransportCommand() {
	this.initialize(...arguments);
}

Sprite_TransportCommand.prototype = Object.create(Sprite.prototype);
Sprite_TransportCommand.prototype.constructor = Sprite_TransportCommand;

Sprite_TransportCommand.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._commandBackName = options.commandBackName;
	this._commandLockName = options.commandLockName;
	this._bitmapSetter = options.bitmapSetter;
	this._lockOffset = options.lockOffset;
	this._pageNum = options.pageNum;
	this._pageWidth = options.pageWidth;
	this._pageHeight = options.pageHeight;
	
	this.index = options.i;
	this.regionId = options.regionId;
	
	this.createBackground();
	this.createRegionNameText();
	this.createLock();
	this.calcPosition();
};

Sprite_TransportCommand.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._commandBackName));
	this.addChild(this._backSprite);
};

Sprite_TransportCommand.prototype.isBeingTouched = function() {
	return this._backSprite.isBeingTouched();
};

Sprite_TransportCommand.prototype.createRegionNameText = function() {
	const bitmap = new Bitmap(this._backSprite.width, this._backSprite.height);
	this._bitmapSetter(bitmap);
	this._textSprite = new Sprite(bitmap);
	bitmap.drawCenterText($dataRegion[this.regionId].name);
	if(!$gameSystem.isRegionUnlock(this.regionId)) {
		this._textSprite.visible = this._backSprite.visible = false;
	}
};

Sprite_TransportCommand.prototype.createLock = function() {
	this._lockSprite = new Sprite(ImageManager.loadUI(this._commandLockName));
	this._lockSprite.x = this._lockOffset.x;
	this._lockSprite.y = this._lockOffset.y;
	this.addChild(this._lockSprite);
	if($gameSystem.isRegionUnlock(this.regionId)) {
		this._lockSprite.visible = false;
	}
};

Sprite_TransportCommand.prototype.onLanguageChange = function() {
	const bitmap = this._textSprite.bitmap;
	bitmap.clear();
	bitmap.drawCenterText($dataRegion[this.regionId].name);
};

Sprite_TransportCommand.prototype.textSprite = function() {
	return this._textSprite;
};

Sprite_TransportCommand.prototype.calcPosition = function() {
	this.x = ((this._pageWidth - this._backSprite.width) / 2) | 0;
	const itemPadding = ((this._pageHeight - this.x * 2 - this._pageNum * this._backSprite.height) / (this._pageNum - 1)) | 0;
	this.y = this.x + this.index * (itemPadding + this._backSprite.height);
	this._textSprite.x = this.x;
	this._textSprite.y = this.y;
};

function Window_TaskInBallon() {
	this.initialize(...arguments);
}

Window_TaskInBallon.prototype = Object.create(Window_Base.prototype);
Window_TaskInBallon.prototype.constructor = Window_TaskInBallon;

Window_TaskInBallon.prototype.initialize = function() {
	Window_Base.prototype.initialize.apply(this, arguments);
	this._arrow = new PIXI.Graphics();
	this._container.addChild(this._arrow);
	this._arrowDir = "down";
	this._alphaAnimationDir = 1;
	this._alphaFilter = new PIXI.filters.AlphaFilter(0.7);
	this.filters = [this._alphaFilter];
};

Window_TaskInBallon.prototype.setArrowDir = function(dir) {
	this._arrowDir = "up";
};

Window_TaskInBallon.prototype.setText = function(name, x, y) {
	this.refreshRect(name);
	this.createContents();
	this.contents.drawCenterText(name);
	this.refreshArrow(x, y);
};

Window_TaskInBallon.prototype.refreshRect = function(name) {
	const size = this.contents.measureTextWidth(name);
	this.move(this.x, this.y, this.windowWidth(size), this.windowHeight());
};

Window_TaskInBallon.prototype.windowWidth = function(size) {
	return size + this.padding * 2;
};

Window_TaskInBallon.prototype.windowHeight = function() {
	return this.contents.fontSize + this.padding * 2;
};

Window_TaskInBallon.prototype.resetFontSettings = function() {
    this.contents.fontFace = $gameSystem.mainFontFace();
    this.contents.fontSize = 18;
	this.contents.textColor = '#551717';
	this.contents.outlineWidth = 0;
};

Window_TaskInBallon.prototype.refreshArrow = function(dx, dy) {
	let y = 0;
	switch(this._arrowDir) {
		case "up": y = -this.arrowShiftY(); break;
		case "down": y = this.height + this.arrowShiftY(); break;
		default: break;
	}
	const p1 = new PIXI.Point(((this.width - this.arrowWidth()) / 2) | 0, y);
	const p2 = new PIXI.Point(((this.width + this.arrowWidth()) / 2) | 0, y);
	const p3 = new PIXI.Point(dx, dy);
	this._arrow.clear();
	this._arrow.beginFill(0xfff4d6);
	this._arrow.drawPolygon([p1, p2, p3]);
	this._arrow.endFill();
	this._arrow.lineStyle(2, 0xfec1d2);
	this._arrow.drawPolygon([p1, p3]);
	this._arrow.drawPolygon([p2, p3]);
	
	//this._arrow.drawPolygon([p1, p2, p3]);
};

Window_TaskInBallon.prototype.arrowShiftY = function() {
	return -2;
};

Window_TaskInBallon.prototype.arrowWidth = function() {
	return 24;
};

Window_TaskInBallon.prototype.update = function() {
	Window_Base.prototype.update.call(this);
	this.updateAlphaChange();
};

Window_TaskInBallon.prototype.updateAlphaChange = function() {
	if(this._alphaFilter.alpha >= 1 && this._alphaAnimationDir === 1) {
		this._alphaAnimationDir = -1;
	} else if(this._alphaFilter.alpha <= 0.8 && this._alphaAnimationDir === -1) {
		this._alphaAnimationDir = 1;
	}
	this._alphaFilter.alpha += this._alphaAnimationDir * 0.001;
};

Window_TaskInBallon.prototype.onLanguageChange = function() {
	// ... TODO
};

function Sprite_HPSmallBar() {
	this.initialize(...arguments);
}

Sprite_HPSmallBar.prototype = Object.create(Sprite.prototype);
Sprite_HPSmallBar.prototype.constructor = Sprite_HPSmallBar;

Sprite_HPSmallBar.prototype.initialize = function(options, character) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._progressName = options.progressName;
	this._letterName = options.letterName;
	this._progressOffset = options.progressOffset;
	this._offset = options.offset;
	this._letterOffset = options.letterOffset;
	
	this._progress = 1;
	this.visible = false;
	this._visibleTime = 0;
	this._lackEffect = false;
	this._lackEffectCounter = 0;
	this._character = character;
	this._hp = this.data();
	this.z = 7;
	this.createBackground();
	this.createProgress();
	this.createHpLetter();
};

Sprite_HPSmallBar.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this._backSprite.anchor.x = 0.5;
	this._backSprite.anchor.y = 1;
	this.addChild(this._backSprite);
};

Sprite_HPSmallBar.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_HPSmallBar.prototype.allHeight = function() {
	return this._backSprite.height;
};

Sprite_HPSmallBar.prototype.createProgress = function() {
	this._progressSprite = new Sprite(ImageManager.loadUI(this._progressName));
	this._progressSprite.anchor.y = 1;
	this._progressSprite.x = this._progressOffset.x;
	this._progressSprite.y = this._progressOffset.y;
	this._progressWidth = this._progressSprite.width;
	this.addChild(this._progressSprite);
};

Sprite_HPSmallBar.prototype.createHpLetter = function() {
	this._letterSprite = new Sprite(ImageManager.loadUI(this._letterName));
	this._letterSprite.anchor.x = 0.5;
	this._letterSprite.anchor.y = 1;
	this._letterSprite.x = this._letterOffset.x;
	this._letterSprite.y = this._letterOffset.y;
	this.addChild(this._letterSprite);
};

Object.defineProperty(Sprite_HPSmallBar.prototype, "progress", {
	get: function() {
        return this._progress;
    },
    set: function(value) {
        if (this._progress !== value) {
            this._progress = value.clamp(0, 1);
			this._progressSprite.width = Math.ceil(this._progressWidth * value);
			this.startVisible();
        }
    },
    configurable: true
});

Sprite_HPSmallBar.prototype.startVisible = function() {
	this._visibleTime = this.visibleTime();
};

Sprite_HPSmallBar.prototype.visibleTime = function() {
	return 240;
};

Sprite_HPSmallBar.prototype.visibleFadeTime = function() {
	return 30;
};

Sprite_HPSmallBar.prototype.updateProgress = function() {
	const character = this._character;
	if(character.isRemove()) {
		this.parent.removeChild(this);
		return;
	}
	if(character.isDeath()) {
		this._visibleTime = 0;
		return;
	}
	this.x = -$gameMap.displayX() * $gameMap.tileWidth() + character.px + this._offset.x;
	this.y = -$gameMap.displayY() * $gameMap.tileHeight() + character.py - character.hitOffsetT() + this.screenOffsetY() + this._offset.y;
	const value = this.data();
	if(this._hp !== value && value !== undefined) {
		this.progress = value;
		this._hp = value;
	}
};

Sprite_HPSmallBar.prototype.screenOffsetY = function() {
	return -24;
};

Sprite_HPSmallBar.prototype.data = function() {
	const character = this._character;
	const obj = character.battleObject();
	if(obj) { return obj.hp / obj.mhp; }
	return undefined;
};

Sprite_HPSmallBar.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateVisible();
	this.updateProgress();
	this.updateLackEffect();
};

Sprite_HPSmallBar.prototype.updateLackEffect = function() {
	if(this.isLackEffect()) {
		this._lackEffect = true;
	} else {
		this._lackEffect = false;
	}
	this.performLackEffect();
};

Sprite_HPSmallBar.prototype.isLackEffect = function() {
	if(this._character.constructor === Game_Player) {
		return this._hp <= 0.2;
	}
	return false;
};

Sprite_HPSmallBar.prototype.performLackEffect = function() {
	if(this._lackEffect) {
		const speed = this.lackEffectSpeed();
		const num = (this._lackEffectCounter % (speed * 2));
		if(num > speed) {
			const color = (speed * 2 - num) / speed * 255;
			this._letterSprite.setBlendColor([color,0,0,color]);
		} else {
			const color = num / speed * 255;
			this._letterSprite.setBlendColor([color,0,0,color]);
		}
		this._lackEffectCounter++;
	} else {
		this._letterSprite.setBlendColor([0,0,0,0]);
		this._lackEffectCounter = 0;
	}
};

Sprite_HPSmallBar.prototype.lackEffectSpeed = function() {
	return 4;
};

Sprite_HPSmallBar.prototype.updateVisible = function() {
	if(this._visibleTime > 0) {
		this.visible = true;
		if(this._visibleTime > this.visibleFadeTime()) {
			this.alpha = 1;
		} else {
			this.alpha = this._visibleTime / this.visibleFadeTime();
		}
		this._visibleTime--;
	} else {
		this.visible = false;
	}
};

function Sprite_SPSmallBar() {
	this.initialize(...arguments);
}

Sprite_SPSmallBar.prototype = Object.create(Sprite_HPSmallBar.prototype);
Sprite_SPSmallBar.prototype.constructor = Sprite_HPSmallBar;

Sprite_SPSmallBar.prototype.initialize = function(options) {
	Sprite_HPSmallBar.prototype.initialize.apply(this, arguments);
	this._lackEffectTime = 0;
};

Sprite_SPSmallBar.prototype.lackEffectTime = function() {
	return 24;
};

Sprite_SPSmallBar.prototype.isLackEffect = function() {
	const character = this._character;
	const effect = character.pollSpLackEffect();
	if(effect) {
		this._lackEffectTime = this.lackEffectTime();
	}
	if(this._lackEffectTime > 0) {
		this._lackEffectTime--;
		return true;
	}
	return false;
};

Sprite_SPSmallBar.prototype.data = function() {
	const character = this._character;
	const obj = character.battleObject();
	if(obj) { return obj.sp / obj.msp; }
	return undefined;
};

NYA.UI.Spriteset_Map_createCharacter = Spriteset_Map.prototype.createCharacter;
Spriteset_Map.prototype.createCharacter = function(character) {
	NYA.UI.Spriteset_Map_createCharacter.apply(this, arguments);
	this.createSpSmallBar(character);
	this.createHpSmallBar(character);
	this.createSpecProgress(character);
	this.createFloatMessageWindow(character);
};

Spriteset_Map.prototype.createHpSmallBar = function(character) {
	const options = character.hpSmallBarName();
	if(!character.isNoHpSmallBar() && options && character.battleObject() && !character.battleObject().unlimitHp) {
		const optionsSp = character.spSmallBarName();
		if(!optionsSp) {
			const hpBar = new Sprite_HPSmallBar(options, character);
			this._tilemap.addChild(hpBar);
		} else {
			const height = ImageManager.loadUI(optionsSp.backName).height;
			const hpBar = new Sprite_HPSmallBar(Object.assign(options, {offset:{x:0,y:-height}}), character);
			this._tilemap.addChild(hpBar);
		}
	}
};

Spriteset_Map.prototype.createSpSmallBar = function(character) {
	const options = character.spSmallBarName();
	if(options && character.battleObject()) {
		const spBar = new Sprite_SPSmallBar(options, character);
		this._tilemap.addChild(spBar);
	}
};

Spriteset_Map.prototype.createSpecProgress = function(character) {
	if(character.battleObject() && character.battleObject().hasSpecProgress) {
		const specProgress = new Sprite_SmallSpecProgress({
			backName:'spec_progress_small_back'
			,progressName:'spec_progress_small'
			,progressOffset:{x:9,y:9}
			,progressSpeed:1
		}, character);
		this._tilemap.addChild(specProgress);
	}
};

Game_CharacterBase.prototype.hpSmallBarName = function() {
	return null;
};

Game_CharacterBase.prototype.spSmallBarName = function() {
	return null;
};

Game_Event.prototype.hpSmallBarName = function() {
	return {
		backName:'map_hp_small_enemy'
		,progressName:'map_hp_small_enemy_progress'
		,letterName:'map_hp_small_enemy_letter'
		,letterOffset:{x:0,y:0}
		,progressOffset:{x:-36,y:-5}
		,offset:{x:0,y:0}
	}
};

Game_Player.prototype.hpSmallBarName = function() {
	return {
		backName:'map_hp_small'
		,progressName:'map_hp_small_progress'
		,letterName:'map_hp_small_letter'
		,letterOffset:{x:0,y:0}
		,progressOffset:{x:-36,y:-5}
		,offset:{x:0,y:0}
	}
};

Game_Player.prototype.spSmallBarName = function() {
	return {
		backName:'map_sp_small'
		,progressName:'map_sp_small_progress'
		,letterName:'map_sp_small_letter'
		,letterOffset:{x:0,y:0}
		,progressOffset:{x:-36,y:-5}
		,offset:{x:0,y:0}
	}
};

function Window_FloatMessage() {
	this.initialize(...arguments);
}

Window_FloatMessage.prototype = Object.create(Window_Base.prototype);
Window_FloatMessage.prototype.constructor = Window_FloatMessage;

Window_FloatMessage.prototype.initialize = function() {
	Window_Base.prototype.initialize.apply(this, arguments);
	this._message = "";
	this._closeAfterShow = 0;
	this._textState = null;
	this.openness = 0;
	this.z = 6;
	this.createCharacterArrow();
};

Window_FloatMessage.prototype.createCharacterArrow = function() {
	const arrow = new PIXI.Graphics();
	arrow.beginFill(0xfff4d6);
	const p1 = new PIXI.Point(-10, 0);
	const p2 = new PIXI.Point(10, 0);
	const p3 = new PIXI.Point(0, 16);
	arrow.drawPolygon([
		p1, p2, p3
	]);
	arrow.endFill();
	arrow.lineStyle(2, 0xfec1d2);
	arrow.drawPolygon([p1, p3]);
	arrow.drawPolygon([p2, p3]);
	this._container.addChild(arrow);
	this._characterArrow = arrow;
};

Window_FloatMessage.prototype.updateCharacterArrow = function() {
	this._characterArrow.x = this.width / 2;
	this._characterArrow.y = this.height - 2;
};

Window_FloatMessage.prototype.closeAfterShow = function() {
	return 150;
};

Window_FloatMessage.prototype.setCharacter = function(character) {
	this._character = character;
};

Window_FloatMessage.prototype.update = function() {
	Window_Base.prototype.update.apply(this, arguments);
	this.updatePosition();
	this.checkNewMessage();
	this.updateMessage();
	this.updateCloseAfterShow();
	this.updateVisible();
};

Window_FloatMessage.prototype.updatePosition = function() {
	this.x = -$gameMap.displayX() * $gameMap.tileWidth() - Math.round((this.width + this._character.hitOffsetL() - this._character.hitOffsetR()) / 2) + this._character.px;
	this.y = -$gameMap.displayY() * $gameMap.tileHeight() - this.height + this._character.hitOffsetB() - this._character.hitOffsetT() + this._character.py - this.floatMessageShiftY();
};

Window_FloatMessage.prototype.maxLineWidth = function() {
	return 288;
};

Spriteset_Map.prototype.createFloatMessageWindow = function(character) {
	if(character.battleObject() && character.enableFloatMessage()) {
		const cache = Window_FloatMessage.getCache(character);
		if(!cache) {
			const msgwin = new Window_FloatMessage(new Rectangle(0, 0, 50, 50));
			msgwin.setCharacter(character);
			this._tilemap.addChild(msgwin);
		} else {
			this._tilemap.addChild(cache);
		}
	}
};

Window_FloatMessage.prototype.floatMessageShiftY = function() {
	return 36;
};

Window_FloatMessage.prototype.start = function(msg) {
	this._message = msg;
	this.contents.clear();
	this.open();
	this.startMessage();
};

Window_FloatMessage.prototype.startMessage = function() {
	this._textState = this.createTextState(this._message, 0, 0, 0);
	this._textInterval = 0;
	this._closeAfterShow = 0;
	const output = this.textSizeEx(this._message);
	this.move(0, 0, output.width + this._padding * 2, output.height + this._padding * 2);
	this.contents.resize(output.width, output.height);
	this.updatePosition();
	this.updateCharacterArrow();
};

Window_FloatMessage.prototype.checkNewMessage = function() {
	const character = this._character;
	if(!this._character.isDeath() && !this._message) {
		const text = this._character.floatMessage();
		if(text) {
			this.start(text);
		}
	}
};

Window_FloatMessage.prototype.updateMessage = function() {
    const textState = this._textState;
    if (textState && this._textInterval <= 0) {
        if(!this.isEndOfText(textState)) {
			this.processCharacter(textState);
			this.flushTextState(textState);
			this._textInterval = 3;
		} else {
			this.onEndOfText();
		}
    } else {
		this._textInterval--;
	}
};

Window_FloatMessage.prototype.resetFontSettings = function() {
    this.contents.fontFace = $gameSystem.mainFontFace();
    this.contents.fontSize = 18;
	this.contents.textColor = '#551717';
	this.contents.outlineWidth = 0;
};

Window_FloatMessage.prototype.isEndOfText = function(textState) {
    return textState.index >= textState.text.length;
};

Window_FloatMessage.prototype.onEndOfText = function() {
	if(this._closeAfterShow === 0) {
		this._closeAfterShow = 1;
	}
};

Window_FloatMessage.prototype.updateCloseAfterShow = function() {
	if(this._closeAfterShow > 0 && !this.isClosing() && !this.isClosed()) {
		this._closeAfterShow++;
		if(this._closeAfterShow > this.closeAfterShow()) {
			this._message = "";
			if(!this.checkNextMessage()) {
				this.close();
			}
			this._closeAfterShow = 0;
		}
	}
	if(this._character.isDeath() && !this.isClosing() && !this.isClosed()) {
		this.close();
	}
	if(this._character.isRemove()) {
		this.parent.removeChild(this);
	}
};

Window_FloatMessage.prototype.checkNextMessage = function() {
	if(!this._character.isDeath()) {
		const text = this._character.nextFloatMessage();
		if(text) {
			this.start(text);
			return true;
		}
	}
	return false;
};

Window_FloatMessage.prototype.updateVisible = function() {
	if(this.isClosed()) {
		this.visible = false;
	} else {
		this.visible = true;
	}
};

Window_FloatMessage.prototype.flushTextState = function(textState) {
	Window_Base.prototype.flushTextState.apply(this, arguments);
	if(textState.x > this.maxLineWidth() && !this.shouldWaitForSpacingNewLine(textState)) {
		textState.y += textState.height;
		textState.x = 0;
	}
};

Window_FloatMessage.prototype.shouldWaitForSpacingNewLine = function(textState) {
	return Utils.isSpacingNewLineLanguage() && textState.text[textState.index] !== " ";
};

Window_FloatMessage.prototype.processAllText = function(textState) {
    while (textState.index < textState.text.length) {
        this.processCharacter(textState);
		this.flushTextState(textState);
    }
};

Window_FloatMessage.prototype.destroy = function() {
	if(!this.isClosed()) {
		Window_FloatMessage.insertToCachePool(this);
	} else {
		Window_Base.prototype.destroy.apply(this, arguments);
	}
};

Window_FloatMessage._cachePool = [];

Window_FloatMessage.insertToCachePool = function(win) {
	if(!this._cachePool.includes(win)) {
		this._cachePool.push(win);
	}
};

Window_FloatMessage.getCache = function(character) {
	for(const win of this._cachePool) {
		if(win._character === character) {
			return win;
		}
	}
	return undefined;
};

Window_FloatMessage.clearCache = function() {
	for(const win of this._cachePool) {
		if(!win.parent) {
			win.destroy();
		}
	}
	this._cachePool = [];
};

function Sprite_SplashIcon() {
	this.initialize(...arguments);
}

Sprite_SplashIcon.prototype = Object.create(Sprite.prototype);
Sprite_SplashIcon.prototype.constructor = Sprite_SplashIcon;

Sprite_SplashIcon.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._nyaEngineIconName = options.nyaEngineIconName;
	this._baseEngineIconOffset = options.baseEngineIconOffset;
	
	this._animation = new AnimationController();
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this.createBackground();
	this.createEngineIcon();
};

Sprite_SplashIcon.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
};

Sprite_SplashIcon.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this._baseSprite.addChild(this._backSprite);
};

Sprite_SplashIcon.prototype.createEngineIcon = function() {
	this._nyaEngineSprite = new Sprite(ImageManager.loadUI(this._nyaEngineIconName));
	this._nyaEngineSprite.x = this._baseEngineIconOffset.x;
	this._nyaEngineSprite.y = this._baseEngineIconOffset.y;
	this._baseSprite.addChild(this._nyaEngineSprite);
};

function Sprite_GameoverBox() {
	this.initialize(...arguments);
}

Sprite_GameoverBox.prototype = Object.create(Sprite.prototype);
Sprite_GameoverBox.prototype.constructor = Sprite_GameoverBox;

Sprite_GameoverBox.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._buttonSelectedName = options.buttonSelectedName;
	this._buttonUnselectedName = options.buttonUnselectedName;
	this._buttonMargin = options.buttonMargin;
	this._textSizeSelected = options.textSizeSelected;
	this._textSizeUnselected = options.textSizeUnselected;
	this._textColor = options.textColor;
	this._titleOffsetY = options.titleOffsetY;
	
	this._selected = "up";
	this._titleText = "";
	this._active = false;
	this.pressOk = null;
	this.createBackground();
	this.createButton();
};

Sprite_GameoverBox.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_GameoverBox.prototype.createButton = function() {
	this._buttonUpSelected = new Sprite_TextInner(ImageManager.loadUI(this._buttonSelectedName));
	this._buttonUpUnselected = new Sprite_TextInner(ImageManager.loadUI(this._buttonUnselectedName));
	this._buttonDownSelected = new Sprite_TextInner(ImageManager.loadUI(this._buttonSelectedName));
	this._buttonDownUnselected = new Sprite_TextInner(ImageManager.loadUI(this._buttonUnselectedName));
	this._buttonUpSelected.anchor.x = this._buttonUpSelected.anchor.y = 0.5;
	this._buttonUpUnselected.anchor.x = this._buttonUpUnselected.anchor.y = 0.5;
	this._buttonDownSelected.anchor.x = this._buttonDownSelected.anchor.y = 0.5;
	this._buttonDownUnselected.anchor.x = this._buttonDownUnselected.anchor.y = 0.5;
	this._buttonUpSelected.setTextStyle(this._textSizeSelected, this._textColor);
	this._buttonUpUnselected.setTextStyle(this._textSizeUnselected, this._textColor);
	this._buttonDownSelected.setTextStyle(this._textSizeSelected, this._textColor);
	this._buttonDownUnselected.setTextStyle(this._textSizeUnselected, this._textColor);
	const offset = 58;
	this._buttonUpSelected.x = this._buttonUpUnselected.x = this._backSprite.width / 2;
	this._buttonUpSelected.y = this._buttonUpUnselected.y = (this._backSprite.height - this._buttonUpSelected.height - this._buttonMargin) / 2 + offset;
	this._buttonDownSelected.x = this._buttonDownUnselected.x = this._backSprite.width / 2;
	this._buttonDownSelected.y = this._buttonDownUnselected.y = (this._backSprite.height + this._buttonUpSelected.height + this._buttonMargin) / 2 + offset;
	this.addChild(this._buttonUpSelected, this._buttonUpUnselected, this._buttonDownSelected, this._buttonDownUnselected);
	this.createTitleSprite();
	this.updateSelect();
};

Sprite_GameoverBox.prototype.createTitleSprite = function() {
	this._titleBitmap = new Bitmap(this._backSprite.width, this._textSizeSelected);
	this._titleSprite = new Sprite(this._titleBitmap);
	this._titleSprite.y = this._titleOffsetY;
	this._titleBitmap.fontSize = this._textSizeSelected;
	this._titleBitmap.textColor = this._textColor;
	this._titleBitmap.outlineWidth = 0;
	this.addChild(this._titleSprite);
};

Sprite_GameoverBox.prototype.setTitle = function(text) {
	this._titleBitmap.clear();
	this._titleBitmap.drawCenterText(TextManager[text]);
	this._titleText = text;
};

Sprite_GameoverBox.prototype.setButtonName = function(leftText, rightText) {
	this._buttonUpSelected.setText(leftText);
	this._buttonUpUnselected.setText(leftText);
	this._buttonDownSelected.setText(rightText);
	this._buttonDownUnselected.setText(rightText);
};

Sprite_GameoverBox.prototype.updateSelect = function() {
	switch(this._selected) {
		case "up": {
			this._buttonUpSelected.visible = true;
			this._buttonUpUnselected.visible = false;
			this._buttonDownSelected.visible = false;
			this._buttonDownUnselected.visible = true;
			break;
		}
		case "down": {
			this._buttonUpSelected.visible = false;
			this._buttonUpUnselected.visible = true;
			this._buttonDownSelected.visible = true;
			this._buttonDownUnselected.visible = false;
			break;
		}
		default: break;
	}
};

Sprite_GameoverBox.prototype.active = function() {
	this._active = true;
};

Sprite_GameoverBox.prototype.deactive = function() {
	this._active = false;
};

Sprite_GameoverBox.prototype.selectedButton = function() {
	return this._selected;
};

Sprite_GameoverBox.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._active) {
		this.updateInput();
		this.updateTouchInput();
	}
};

Sprite_GameoverBox.prototype.updateInput = function() {
	if(Input.isUITriggered("up") && this._selected === "down") {
		SoundManager.playCursor();
		this._selected = "up";
		this.updateSelect();
	}
	if(Input.isUITriggered("down") && this._selected === "up") {
		SoundManager.playCursor();
		this._selected = "down";
		this.updateSelect();
	}
	if(Input.isUITriggered("ok") && this.pressOk) {
		SoundManager.playOk();
		this.pressOk();
	}
};

Sprite_GameoverBox.prototype.updateTouchInput = function() {
	if(TouchInput.isMoved() || TouchInput.isClicked()) {
		if(this._buttonUpSelected.isBeingTouched() || this._buttonUpUnselected.isBeingTouched()) {
			if(this._selected !== "up") {
				this._selected = "up";
				this.updateSelect();
			}
		} else if(this._buttonDownSelected.isBeingTouched() || this._buttonDownUnselected.isBeingTouched()) {
			if(this._selected !== "down") {
				this._selected = "down";
				this.updateSelect();
			}
		} else {
			return;
		}
		if(TouchInput.isClicked()) {
			SoundManager.playOk();
			this.pressOk();
		}
	}
};

Sprite_GameoverBox.prototype.onLanguageChange = function() {
	this._buttonUpSelected.onLanguageChange();
	this._buttonUpUnselected.onLanguageChange();
	this._buttonDownSelected.onLanguageChange();
	this._buttonDownUnselected.onLanguageChange();
	this.setTitle(this._titleText);
};

function Sprite_TextInner() {
	this.initialize(...arguments);
}

Sprite_TextInner.prototype = Object.create(Sprite.prototype);
Sprite_TextInner.prototype.constructor = Sprite_TextInner;

Sprite_TextInner.prototype.initialize = function() {
	Sprite.prototype.initialize.apply(this, arguments);
	this.createText();
};

Sprite_TextInner.prototype.createText = function() {
	this._textBitmap = new Bitmap(this.width, this.height);
	this._innerText = new Sprite(this._textBitmap);
	this._text = "";
	this.addChild(this._innerText);
};

Sprite_TextInner.prototype.setTextStyle = function(textSize, textColor) {
	this._textBitmap.fontSize = textSize;
	this._textBitmap.textColor = textColor;
	this._textBitmap.outlineWidth = 0;
	this._innerText.x = -this.width * this.anchor.x;
	this._innerText.y = -this.height * this.anchor.y;
};

Sprite_TextInner.prototype.setText = function(text) {
	this._textBitmap.clear();
	this._textBitmap.drawCenterText(TextManager[text]);
	this._text = text;
};

Sprite_TextInner.prototype.onLanguageChange = function() {
	this.setText(this._text);
};

function Sprite_SelectBase() {
	this.initialize(...arguments);
}

Sprite_SelectBase.prototype = Object.create(Sprite.prototype);
Sprite_SelectBase.prototype.constructor = Sprite_SelectBase;

Sprite_SelectBase.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._pageNum = options.pageNum;
	this._moveSignName = options.moveSignName;
	this._itemName = options.itemName;
	this._cursorName = options.cursorName;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._itemMargin = options.itemMargin;
	this._textStartX = options.textStartX;
	this._noTaskTipsTextColor = options.noTaskTipsTextColor;
	this._moveSignMargin = options.moveSignMargin;

	this._active = false;
	this._preventInputForThisFrame = false;
	this.pressOk = null;
	this.pressCancel = null;
	this._selectIndex = 0;
	this._pageIndex = 0;
	this._dragStartY = 0;
	this._isDragging = false;
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this._itemSprite = new Sprite();
	this._baseSprite.addChild(this._itemSprite);
	this.createCursor();
	this._disabledSprite = new Sprite();
	this._baseSprite.addChild(this._disabledSprite);
	this._upperSprite = new Sprite();
	this._baseSprite.addChild(this._upperSprite);
	this._animation = new AnimationController();
	
	this.createAllItems();
	this.createMoveSign();
	this.createItemMask();
};

Sprite_SelectBase.prototype.active = function() {
	this._active = true;
	this._preventInputForThisFrame = true;
};

Sprite_SelectBase.prototype.deactive = function() {
	this._active = false;
};

Sprite_SelectBase.prototype.createItemMask = function() {
	const mask = new PIXI.Graphics();
	mask.beginFill(0xff0000);
	mask.drawRect(0, 0, this.allItemWidth(), this.allItemHeight());
	mask.endFill();
	this._baseSprite.mask = mask;
	this.addChild(mask);
	this.syncPage();
};

// * overwrite it!
Sprite_SelectBase.prototype.data = function() {
	return [];
};

Sprite_SelectBase.prototype.createAllItems = function() {
	let idx = 0;
	for(const dataId of this.data()) {
		this.createItem(idx, dataId);
		idx++;
	}
	if(idx === 0) {
		this._cursorSprite.visible = false;
		this.createNoItemTips();
	}
};

// * overwrite it!
Sprite_SelectBase.prototype.isItemEnabled = function(dataId) {
	return true;
};

Sprite_SelectBase.prototype.createItem = function(idx, dataId) {
	const x = this.itemX(idx);
	const y = this.itemY(idx);
	const enabled = this.isItemEnabled(dataId);
	const sprite = new Sprite(ImageManager.loadUI(this._itemName));
	this._itemSprite.addChild(sprite);
	sprite.x = x;
	sprite.y = y;
	const bitmap = new Bitmap(sprite.width - this._textStartX, sprite.height);
	bitmap.fontSize = this._textSize;
	bitmap.textColor = this._textColor;
	bitmap.outlineWidth = 0;
	const textSprite = new Sprite(bitmap);
	textSprite.dataId = dataId;
	textSprite.x = x + this._textStartX;
	textSprite.y = y;
	
	const sprite2 = new Sprite(ImageManager.loadUI(this._itemName));
	sprite2.setBlendColor([128,128,128,255]);
	sprite2.alpha = 0.5;
	sprite2.x = sprite.x;
	sprite2.y = sprite.y;
	this._disabledSprite.addChild(sprite2);
	
	if(!enabled) {
		sprite.setBlendColor([128,128,128,255]);
		textSprite.setBlendColor(this.disabledTextBlendColor());
	} else {
		sprite2.visible = false;
	}
	this._upperSprite.addChild(textSprite);
	this.refreshItemText(dataId, bitmap);
};

Sprite_SelectBase.prototype.refreshItemText = function(dataId, bitmap) {
	// * overwrite it!
};

Sprite_SelectBase.prototype.disabledTextBlendColor = function() {
	return [255,255,255,255];
};

Sprite_SelectBase.prototype.refreshSelectedItemEnable = function() {
	const index = this._selectIndex;
	const dataId = this.selectDataId();
	const enabled = this.isItemEnabled(dataId);
	const sprite = this._itemSprite.children[index];
	const textSprite = this._upperSprite.children[index];
	const sprite2 = this._disabledSprite.children[index];
	if(!enabled) {
		sprite.setBlendColor([128,128,128,255]);
		textSprite.setBlendColor(this.disabledTextBlendColor());
		sprite2.visible = true;
	} else {
		sprite.setBlendColor([0,0,0,0]);
		textSprite.setBlendColor([0,0,0,0]);
		sprite2.visible = false;
	}
};

Sprite_SelectBase.prototype.itemX = function(idx) {
	return 0;
};

Sprite_SelectBase.prototype.itemY = function(idx) {
	return idx * (ImageManager.loadUI(this._itemName).height + this._itemMargin);
};

Sprite_SelectBase.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this._baseSprite.addChild(this._cursorSprite);
	this.syncCursor();
};

Sprite_SelectBase.prototype.syncCursor = function() {
	this._cursorSprite.x = this.cursorX();
	this._cursorSprite.y = this.cursorY();
};

Sprite_SelectBase.prototype.syncPage = function() {
	this._baseSprite.x = this.pageX();
	this._baseSprite.y = this.pageY();
};

Sprite_SelectBase.prototype.cursorX = function() {
	return this.itemX(this._selectIndex);
};

Sprite_SelectBase.prototype.cursorY = function() {
	return this.itemY(this._selectIndex);
};

Sprite_SelectBase.prototype.pageX = function() {
	return -this.itemX(this._pageIndex);
};

Sprite_SelectBase.prototype.pageY = function() {
	return -this.itemY(this._pageIndex);
};

Sprite_SelectBase.prototype.noItemTips = function() {
	return "";
};

Sprite_SelectBase.prototype.createNoItemTips = function() {
	const bitmap = new Bitmap(this.allItemWidth(), this._textSize);
	bitmap.textColor = this._noTaskTipsTextColor;
	bitmap.fontSize = this._textSize;
	bitmap.outlineWidth = 0;
	bitmap.drawCenterText(this.noItemTips());
	const tips = new Sprite(bitmap);
	tips.x = this.allItemWidth() / 2;
	tips.y = this.allItemHeight() / 2;
	tips.anchor.x = tips.anchor.y = 0.5;
	this._baseSprite.addChild(tips);
	this._tipsSprite = tips;
};

Sprite_SelectBase.prototype.refreshSelectedItemText = function() {
	const sprite = this._upperSprite.children[this._selectIndex];
	this.refreshItemText(sprite.dataId, sprite.bitmap);
};

Sprite_SelectBase.prototype.onLanguageChange = function() {
	for(const sprite of this._upperSprite.children) {
		this.refreshItemText(sprite.dataId, sprite.bitmap);
	}
	if(this._tipsSprite) {
		this._tipsSprite.bitmap.clear();
		this._tipsSprite.bitmap.drawCenterText(this.noItemTips());
	}
};

Sprite_SelectBase.prototype.createMoveSign = function() {
	const controller = this._animation;
	this._moveSignUp = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignUp.anchor.x = 0.5;
	this._moveSignUp.anchor.y = 0.5;
	this._moveSignUp.y = -this._moveSignMargin - this._moveSignUp.height / 2;
	this._moveSignUp.x = this.allItemWidth() / 2;
	this.addChild(this._moveSignUp);
	
	
	this._moveSignDown = new Sprite(ImageManager.loadUI(this._moveSignName));
	this._moveSignDown.anchor.x = 0.5;
	this._moveSignDown.anchor.y = 0.5;
	this._moveSignDown.y = this.allItemHeight() + this._moveSignMargin + this._moveSignDown.height / 2;
	this._moveSignDown.x = this.allItemWidth() / 2;
	this._moveSignDown.scale.y = -1;
	this.addChild(this._moveSignDown);
	
	controller.add(this._moveSignUp, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	controller.add(this._moveSignDown, {data:[{to:0, easingType:'linear', duration:50, property:'alpha'},{to:1, easingType:'linear', duration:50, property:'alpha'}], loop:true});
	this.updateMoveSign();
};

Sprite_SelectBase.prototype.allItemWidth = function() {
	return ImageManager.loadUI(this._itemName).width;
};

Sprite_SelectBase.prototype.allItemHeight = function() {
	const height = ImageManager.loadUI(this._itemName).height;
	const margin = this._itemMargin;
	return this._pageNum * height + (this._pageNum - 1) * margin;
};

Sprite_SelectBase.prototype.allWidth = function() {
	return this.allItemWidth();
};

Sprite_SelectBase.prototype.allHeight = function() {
	return this.allItemHeight() + this._moveSignDown.height + this._moveSignUp.height + this._moveSignMargin * 2;
};

Sprite_SelectBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.visible = this._active;
	if(this._active && !this._preventInputForThisFrame) {
		this.updateInput();
		this.updateTouchInput();
	}
	this._preventInputForThisFrame = false;
};

Sprite_SelectBase.prototype.itemNum = function() {
	return this._upperSprite.children.length;
};

Sprite_SelectBase.prototype.updateInput = function() {
	if(this._cursorSprite.visible) {
		if(Input.isUITriggered("up")) {
			SoundManager.playCursor();
			if(this._selectIndex === 0) {
				this._selectIndex = this.itemNum() - 1;
			} else {
				this._selectIndex--;
			}
			this.calcPage();
			this.updateCursor();
			this.updatePage();
		} else if(Input.isUITriggered("down")) {
			SoundManager.playCursor();
			if(this._selectIndex === this.itemNum() - 1) {
				this._selectIndex = 0;
			} else {
				this._selectIndex++;
			}
			this.calcPage();
			this.updateCursor();
			this.updatePage();
		} else if(this.pressOk && Input.isUITriggered("ok")) {
			const dataId = this.selectDataId();
			const enabled = this.isItemEnabled(dataId);
			if(enabled) {
				if(this.pressOk()) {
					SoundManager.playOk();
				} else {
					SoundManager.playBuzzer();
				}
			} else {
				this.pressDisabledItem();
				SoundManager.playBuzzer();
			}
		}
	}
	if(this.pressCancel && Input.isUITriggered("cancel")) {
		SoundManager.playCancel();
		this.pressCancel();
	}
};

Sprite_SelectBase.prototype.shouldUseTouchConfirm = function() {
	return false;
};

Sprite_SelectBase.prototype.shouldMoveCursorAfterDrag = function() {
	return true;
};

Sprite_SelectBase.prototype.updateTouchInput = function() {
	if((TouchInput.isClicked() || TouchInput.isReleased()) && !TouchInput.moved) {
		for(let i = 0; i < this._itemSprite.children.length; i++) {
			const sprite = this._itemSprite.children[i];
			if(i >= this._pageIndex && i < this._pageIndex + this._pageNum && sprite.isBeingTouched()) {
				if(this.shouldUseTouchConfirm() && this._selectIndex !== i) {
					this._selectIndex = i;
					SoundManager.playCursor();
					this.updateCursor();
				} else {
					this._selectIndex = i;
					this.updateCursor();
					if(TouchInput.isClicked()) {
						if(this.pressOk()) {
							SoundManager.playOk();
						} else {
							SoundManager.playBuzzer();
						}
					}
				}
				break;
			}
		}
	}
	if(TouchInput.isDraged()) {
		if(!this._isDragging) {
			this._isDragging = true;
			this._dragStartY = this._baseSprite.y;
			this._dragSelectPageOffset = this._selectIndex - this._pageIndex;
		}
		this._baseSprite.y = this._dragStartY + TouchInput.moveDeltaY;
	} else {
		if(this._isDragging) {
			this._isDragging = false;
			this.endDragScroll();
		}
	}
};

Sprite_SelectBase.prototype.endDragScroll = function() {
	let minDistance = -1;
	let bestIdx = 0;
	for(let i = 0; i < this._itemSprite.children.length; i++) {
		const y = this.itemY(i);
		const distance = Math.abs(-this._baseSprite.y - y);
		if(minDistance === -1 || distance < minDistance) {
			minDistance = distance;
			bestIdx = i;
		}
	}
	this._pageIndex = bestIdx;
	this._pageIndex = this._pageIndex.clamp(0, Math.max(0, this.itemNum() - this._pageNum));
	if(this.shouldMoveCursorAfterDrag()) {
		this._selectIndex = this._pageIndex + this._dragSelectPageOffset;
		this.updateCursor();
	}
	this.updatePage();
};

Sprite_SelectBase.prototype.updateCursor = function() {
	const x = this.cursorX();
	const y = this.cursorY();
	const controller = this._animation;
	controller.clear(this._cursorSprite);
	controller.add(this._cursorSprite, {data:[
		{to:x, property:"x", easingType:'easeOutQuart', duration:25}
	]});
	controller.add(this._cursorSprite, {data:[
		{to:y, property:"y", easingType:'easeOutQuart', duration:25}
	]});
};

Sprite_SelectBase.prototype.updatePage = function() {
	const x = this.pageX();
	const y = this.pageY();
	const controller = this._animation;
	controller.clear(this._baseSprite);
	controller.add(this._baseSprite, {data:[
		{to:x, property:"x", easingType:'easeOutQuart', duration:25}
	]});
	controller.add(this._baseSprite, {data:[
		{to:y, property:"y", easingType:'easeOutQuart', duration:25}
	]});
	this.updateMoveSign();
};


Sprite_SelectBase.prototype.calcPage = function() {
	const pageNum = this._pageNum;
	if(this._pageIndex > this._selectIndex) {
		this._pageIndex = this._selectIndex;
	} else if(this._pageIndex <= this._selectIndex - pageNum) {
		this._pageIndex = this._selectIndex - pageNum + 1;
	}
};

Sprite_SelectBase.prototype.selectDataId = function() {
	return this._upperSprite.children[this._selectIndex].dataId;
};

Sprite_SelectBase.prototype.updateMoveSign = function() {
	if(this._pageIndex === 0) {
		this._moveSignUp.visible = false;
	} else {
		this._moveSignUp.visible = true;
	}
	if(this._pageIndex >= this.itemNum() - this._pageNum) {
		this._moveSignDown.visible = false;
	} else {
		this._moveSignDown.visible = true;
	}
};

Sprite_SelectBase.prototype.pressDisabledItem = function() {
	const textSprite = this._upperSprite.children[this._selectIndex];
	const controller = this._animation;
	textSprite.bitmap.clear();
	textSprite.bitmap.drawAlignText(this.disableItemText(), "left");
	controller.clear(textSprite);
	controller.add(textSprite, {data:[{
		to:0, property:'alpha', easingType:'linear', duration:35, delay:135
	}], complete:this.onTextSpriteDisableTipsComplete.bind(this)});
};

Sprite_SelectBase.prototype.onTextSpriteDisableTipsComplete = function(textSprite) {
	const controller = this._animation;
	controller.clear(textSprite);
	this.refreshItemText(textSprite.dataId, textSprite.bitmap);
	controller.add(textSprite, {data:[{
		to:1, property:'alpha', easingType:'linear', duration:35
	}]});
};

Sprite_SelectBase.prototype.disableItemText = function() {
	return "";
};

function Sprite_TaskSelect() {
	this.initialize(...arguments);
}

Sprite_TaskSelect.prototype = Object.create(Sprite_SelectBase.prototype);
Sprite_TaskSelect.prototype.constructor = Sprite_TaskSelect;

Sprite_TaskSelect.prototype.initialize = function(options) {
	this._mainTaskColor = options.mainTaskColor;
	Sprite_SelectBase.prototype.initialize.apply(this, arguments);
};

Sprite_TaskSelect.prototype.data = function() {
	return $gamePlayer.actor().tasks();
};

Sprite_TaskSelect.prototype.noItemTips = function() {
	return TextManager["STATIC_TEXT_NO_MORE_TASK"];
};

Sprite_TaskSelect.prototype.isItemEnabled = function(dataId) {
	return this.taskPageId() === 0 || DataManager.taskPage(dataId) === this.taskPageId();
};

Sprite_TaskSelect.prototype.taskPageId = function() {
	return 0;
};

Sprite_TaskSelect.prototype.refreshItemText = function(dataId, bitmap) {
	bitmap.clear();
	const typeStr = DataManager.taskTypeStr($dataTask[dataId].type);
	const title = $dataTask[dataId].title;
	const maxProgress = $dataTask[dataId].maxProgress;
	let suffix = "";
	if(maxProgress) {
		const progressStr = "(%1/%2)";
		suffix = progressStr.format($gamePlayer.actor().getTaskProgress(dataId), maxProgress);
	}
	if($dataTask[dataId].type === 0) {
		bitmap.textColor = this._mainTaskColor;
	}
	const y = (bitmap.height - bitmap.fontSize) / 2;
	bitmap.drawText(typeStr, 0, y, bitmap.width, bitmap.fontSize, "left");
	const x = bitmap.measureTextWidth(typeStr);
	bitmap.textColor = this._textColor;
	bitmap.drawText(title + suffix, x + 8, y, bitmap.width, bitmap.fontSize, "left");
};

Sprite_TaskSelect.prototype.disableItemText = function() {
	return TextManager['STATIC_TEXT_TASK_PAGE_NOT_MATCH'];
};

function Sprite_PageTaskSelect() {
	this.initialize(...arguments);
}

Sprite_PageTaskSelect.prototype = Object.create(Sprite_TaskSelect.prototype);
Sprite_PageTaskSelect.prototype.constructor = Sprite_PageTaskSelect;

Sprite_PageTaskSelect.prototype.initialize = function() {
	Sprite_TaskSelect.prototype.initialize.apply(this, arguments);
};

function Sprite_ShopSelect() {
	this.initialize(...arguments);
}

Sprite_ShopSelect.prototype = Object.create(Sprite_SelectBase.prototype);
Sprite_ShopSelect.prototype.constructor = Sprite_ShopSelect;

Sprite_ShopSelect.prototype.initialize = function(options) {
	this._nameX = options.nameX;
	this._priceX = options.priceX;
	this._hasNumX = options.hasNumX;
	this._iconX = options.iconX;
	this._itemMaskOffsetWidth = options.itemMaskOffsetWidth;
	Sprite_SelectBase.prototype.initialize.apply(this, arguments);
	this.onCursorMove = null;
	this.pressDisable = null;
};

Sprite_ShopSelect.prototype.isItemEnabled = function(item) {
	return item.itemNum > 0;
};

Sprite_ShopSelect.prototype.update = function() {
	Sprite_SelectBase.prototype.update.call(this);
	this.visible = true;
};

Sprite_ShopSelect.prototype.data = function() {
	return $gamePlayer.actor().shopData();
};

Sprite_ShopSelect.prototype.refreshItemText = function(item, bitmap) {
	bitmap.clear();
	const name = item.name ? item.name : "";
	const price = (NYA.DEMO ? item.demoPrice : item.price) || 4000;
	const hasNum = item.type === "consumables" ? item.hasNum.toString() : "";
	const maxWidth = 320;
	const y = (bitmap.height - this._textSize) / 2;
	bitmap.drawText(name, this._nameX, y, maxWidth, this._textSize, "left");
	bitmap.drawText(price, this._priceX, y, 70, this._textSize, "center");
	bitmap.drawText(hasNum, this._hasNumX, y, maxWidth, this._textSize, "left");
};

Sprite_ShopSelect.prototype.createItem = function(idx, item) {
	Sprite_SelectBase.prototype.createItem.apply(this, arguments);
	const sprite = this._upperSprite.children[idx];
	const icon = new Sprite_ItemIcon(item.type, item.idx);
	icon.anchor.x = icon.anchor.y = 0.5;
	icon.x = this._iconX;
	icon.y = sprite.height / 2;
	sprite.addChild(icon);
};

Sprite_ShopSelect.prototype.pressDisabledItem = function() {
	if(this.pressDisable) {
		this.pressDisable();
	}
};

Sprite_ShopSelect.prototype.updateCursor = function() {
	Sprite_SelectBase.prototype.updateCursor.call(this);
	if(this.onCursorMove) {
		this.onCursorMove();
	}
};

Sprite_ShopSelect.prototype.startFadeInEffect = function() {
	const controller = this._animation;
	let delay = 0;
	this._cursorSprite.x = -this._cursorSprite.width;
	controller.add(this._cursorSprite, {data:[
		{to:this.cursorX(), easingType:"easeOutQuart", duration:20, property:'x'}
	]});
	for(const sprite of this._itemSprite.children) {
		const to = sprite.x;
		sprite.x = -sprite.width;
		controller.add(sprite, {data:[
			{to:to, easingType:"easeOutQuart", duration:20, property:'x', delay:delay}
		]});
		delay++;
	}
	delay = 0;
	for(const sprite of this._upperSprite.children) {
		const to = sprite.x;
		sprite.x = -sprite.width;
		controller.add(sprite, {data:[
			{to:to, easingType:"easeOutQuart", duration:20, property:'x', delay:delay}
		]});
		delay++;
	}
};

Sprite_ShopSelect.prototype.createItemMask = function() {
	const mask = new PIXI.Graphics();
	mask.beginFill(0xff0000);
	mask.drawRect(-this._itemMaskOffsetWidth, 0, this.allItemWidth() + this._itemMaskOffsetWidth, this.allItemHeight() + this._itemMargin * 2);
	mask.endFill();
	this._baseSprite.mask = mask;
	this.addChild(mask);
	this.syncPage();
};

Sprite_ShopSelect.prototype.disabledTextBlendColor = function() {
	return [0,0,0,0];
};

Sprite_ShopSelect.prototype.shouldUseTouchConfirm = function() {
	return true;
};

Sprite_ShopSelect.prototype.shouldMoveCursorAfterDrag = function() {
	return false;
};

function Sprite_ShopInfoBar() {
	this.initialize(...arguments);
}

Sprite_ShopInfoBar.prototype = Object.create(Sprite.prototype);
Sprite_ShopInfoBar.prototype.constructor = Sprite_ShopInfoBar;

Sprite_ShopInfoBar.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._nameX = options.nameX;
	this._priceX = options.priceX;
	this._hasNumX = options.hasNumX;
	this._backName = options.backName;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._textOffsetY = options.textOffsetY;
	this.createBackground();
	this.createTextSprite();
};

Sprite_ShopInfoBar.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_ShopInfoBar.prototype.createTextSprite = function() {
	const bitmap = new Bitmap(this._backSprite.width, this._backSprite.height);
	this._textSprite = new Sprite(bitmap);
	this.addChild(this._textSprite);
	bitmap.fontSize = this._textSize;
	bitmap.textColor = this._textColor;
	bitmap.outlineWidth = 0;
	this._textBitmap = bitmap;
	this.createAllText();
};

Sprite_ShopInfoBar.prototype.createAllText = function() {
	const bitmap = this._textBitmap;
	bitmap.clear();
	const maxWidth = 320;
	const y = (bitmap.height - this._textSize) / 2 + this._textOffsetY;
	bitmap.drawText(TextManager['STATIC_TEXT_SHOP_ITEM_NAME'], this._nameX, y, maxWidth, this._textSize, "left");
	bitmap.drawText(TextManager['STATIC_TEXT_SHOP_ITEM_PRICE'], this._priceX, y, maxWidth, this._textSize, "left");
	bitmap.drawText(TextManager['STATIC_TEXT_SHOP_ITEM_HAS_NUM'], this._hasNumX, y, maxWidth, this._textSize, "left");
};

Sprite_ShopInfoBar.prototype.onLanguageChange = function() {
	this.createAllText();
};

function Sprite_TextBalloon() {
	this.initialize(...arguments);
}

Sprite_TextBalloon.prototype = Object.create(Sprite.prototype);
Sprite_TextBalloon.prototype.constructor = Sprite_TextBalloon;

Sprite_TextBalloon.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._textPadding = options.textPadding;
	this._linePadding = options.linePadding;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	
	this._textDrawCounter = 0;
	this._textX = 0;
	this._textY = 0;
	this._textDrawIndex = 0;
	this._currentText = "";
	this.createBackground();
	this.createTextContent();
};

Sprite_TextBalloon.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_TextBalloon.prototype.createTextContent = function() {
	const indent = 100;			// 英文非空格不换行导致的文字溢出问题
	const bitmap = new Bitmap(this._backSprite.width - this._textPadding * 2 + 100, this._backSprite.height - this._textPadding * 2);
	bitmap.fontSize = this._textSize;
	bitmap.textColor = this._textColor;
	bitmap.outlineWidth = 0;
	this._textSprite = new Sprite(bitmap);
	this._textSprite.x = this._textSprite.y = this._textPadding;
	this.addChild(this._textSprite);
	this._textBitmap = bitmap;
};

Sprite_TextBalloon.prototype.setText = function(text) {
	this._textBitmap.clear();
	this._textDrawCounter = 0;
	this._currentText = text;
	this._textDrawIndex = 0;
	this._textX = 0;
	this._textY = 0;
};

Sprite_TextBalloon.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this._currentText !== "") {
		this.updateText();
	}
};

Sprite_TextBalloon.prototype.textSpeed = function() {
	return 0;
};

Sprite_TextBalloon.prototype.currentText = function() {
	return this._currentText;
};

Sprite_TextBalloon.prototype.updateText = function() {
	if(this._textDrawCounter >= this.textSpeed()) {
		this._textDrawCounter = 0;
		this.processText();
	} else {
		this._textDrawCounter++;
	}
};

Sprite_TextBalloon.prototype.processText = function() {
	if(this._textDrawIndex >= this._currentText.length) {
		this._currentText = "";
		return;
	}
	const ch = this._currentText[this._textDrawIndex];
	const shouldIgnoreSpace = Utils.isSpacingNewLineLanguage();
	const width = this._textBitmap.measureTextWidth(ch);
	const maxWidth = this._backSprite.width - this._textPadding * 2;
	if(this._textX + width > maxWidth && !(shouldIgnoreSpace && ch !== " ")) {
		this._textY += (this._textSize + this._linePadding);
		this._textX = 0;
	}
	
	this._textBitmap.drawText(ch, this._textX, this._textY, 400, this._textSize, "left");
	this._textX += width;
	this._textDrawIndex++;
};

function Sprite_SoftGuide() {
	this.initialize(...arguments);
}

Sprite_SoftGuide.prototype = Object.create(Sprite.prototype);
Sprite_SoftGuide.prototype.constructor = Sprite_SoftGuide;

Sprite_SoftGuide.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._catLeftPos = options.catLeftPos;
	this._backName = options.backName;
	this._catName = options.catName;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this.menuCallback = options.menuCallback;
	
	this._animation = new AnimationController();
	this._text = "";
	this.y = Graphics.height;
	this.visible = false;
	this.isClosing = false;
	this.createBackground();
	this.createCatSprite();
	this.createTextSprite();
};

Sprite_SoftGuide.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.x = (Graphics.width - this._backSprite.width) / 2;
	this.addChild(this._backSprite);
};

Sprite_SoftGuide.prototype.createCatSprite = function() {
	this._catLeft = new Sprite(ImageManager.loadUI(this._catName));
	this._catRight = new Sprite(ImageManager.loadUI(this._catName));
	this._catLeft.anchor.x = this._catLeft.anchor.y = this._catRight.anchor.x = this._catRight.anchor.y = 0.5;
	this._catRight.scale.x = -1;
	this.addChild(this._catLeft, this._catRight);
	this._catLeft.x = this._catLeftPos.x;
	this._catLeft.y = this._catLeftPos.y;
	this._catRight.x = this._backSprite.width - this._catLeft.x;
	this._catRight.y = this._catLeft.y;
	
	const controller = this._animation;
	controller.add(this._catLeft, {data:[
		{to:-0.3, property:'rotation', duration:35, easingType:'linear'}
		, {to:0.3, property:'rotation', duration:35, easingType:'linear'}
	], loop:true});
	controller.add(this._catRight, {data:[
		{to:0.3, property:'rotation', duration:35, easingType:'linear'}
		, {to:-0.3, property:'rotation', duration:35, easingType:'linear'}
	], loop:true});
};

Sprite_SoftGuide.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateGuide();
};

Sprite_SoftGuide.prototype.updateGuide = function() {
	if(!this.visible) {
		const guide = $gameSystem.softGuide();
		if(guide.isClosing) {
			this.onCloseComplete();
		} else if(guide.message) {
			this.setText(guide.message);
			this.open();
		}
	} else if(!this.isClosing) {
		const guide = $gameSystem.softGuide();
		if(guide.isClosing) {
			this.close();
		}
	}
};

Sprite_SoftGuide.prototype.createTextSprite = function() {
	this._textBitmap = new Bitmap(this._backSprite.width, this._backSprite.height);
	this._textBitmap.fontSize = this._textSize;
	this._textBitmap.textColor = this._textColor;
	this._textBitmap.outlineWidth = 0;
	this._textSprite = new Sprite(this._textBitmap);
	this.addChild(this._textSprite);
};

// 字符串里的#xxx#字符会被转义成按钮图案，例：按#cancel#攻击
Sprite_SoftGuide.prototype.setText = function(text) {
	this._textBitmap.clear();
	this._text = text;
	const width = this._backSprite.width;
	let textWidth = 0;
	let isButton = false;
	let buttonBuffer = "";
	let textBuffer = "";
	const buttons = [];
	this._textSprite.removeChildren();
	let noPressTriggered = false;
	if(text[0] === "~") {
		text = text.substr(1);
		noPressTriggered = true;		// 指示该引导并不是按键触发，而是代码里触发完成
	}
	for(const ch of text) {
		if(ch === "#" || ch === "@") {			// ch === "@"代表触发时使用isUITriggered，z键实际按enter键也可完成
			isButton = !isButton;
			if(!isButton) {		// 移动端会自动转化按钮图案，上转化为interact键，cancel转化为attack触控按钮，ok转化为jump触控按钮，menu转化为menu触控按钮
				let button = null;
				if(Utils.isMobileDeviceTouchMode()) {
					switch(buttonBuffer) {
						case "up": {
							button = new Sprite_GuideInteractButton();
							break;
						}
						case "left": case "right": case "down": {
							button = new Sprite_GuideButton(buttonBuffer);
							break;
						}
						case "bullet": case "zxc": {
							button = new Sprite_GuideScreenButton(buttonBuffer);
							break;
						}
						case "ok": {
							button = new Sprite_GuideScreenButton("jump");
							break;
						}
						case "cancel": {
							button = new Sprite_GuideScreenButton("attack");
							break;
						}
						case "menu": {
							button = new Sprite_GuideMenuButton();
							button.menuCallback = this.menuCallback;
							break;
						}
					}
				} else { 
					button = new Sprite_GuideButton(buttonBuffer, ch === "@");
				}
				if(!noPressTriggered) {
					button.pressButton = this.onPressButton.bind(this);
				}
				textWidth += button.allWidth();
				button.setTextBuffer(textBuffer);
				buttons.push(button);
				buttonBuffer = "";
				textBuffer = "";
			}
		} else {
			if(isButton) {
				buttonBuffer += ch;
			} else {
				textBuffer += ch;
				const oneWidth = this._textBitmap.measureTextWidth(ch);
				textWidth += oneWidth;
			}
		}
	}
	let x = ((this._backSprite.width - textWidth) / 2) | 0;
	const textY = (this._backSprite.height - this._textSize) / 2;
	for(const button of buttons) {
		const oneBuffer = button.getTextBuffer();
		const oneWidth = this._textBitmap.measureTextWidth(oneBuffer);
		this._textBitmap.drawText(oneBuffer, x, textY, 500, this._textSize, "left");
		x += oneWidth;
		this._textSprite.addChild(button);
		button.x = x;
		button.y = this._backSprite.height / 2;
		x += button.allWidth();
	}
	this._textBitmap.drawText(textBuffer, x, textY, 500, this._textSize, "left");
};

Sprite_SoftGuide.prototype.onPressButton = function() {
	if(this.visible && !this.isClosing) {
		$gameSystem.setGuideCompleted();
	}
};

Sprite_SoftGuide.prototype.open = function() {
	this.visible = true;
	this.isClosing = false;
	const controller = this._animation;
	controller.clear(this);
	controller.add(this, {data:[{
		easingType:'easeOutQuad', to:Graphics.height - 100, property:'y', duration:22
	}]});
	AudioManager.playNormalSe("guide");
};

Sprite_SoftGuide.prototype.close = function() {
	this.isClosing = true;
	const controller = this._animation;
	controller.clear(this);
	controller.add(this, {data:[{
		easingType:'easeOutQuad', to:Graphics.height, property:'y', duration:22
	}], complete:this.onCloseComplete.bind(this)});
};

Sprite_SoftGuide.prototype.onCloseComplete = function() {
	this.visible = false;
	$gameSystem.clearSoftGuide();
};

function Sprite_GuideButtonBase() {
	this.initialize(...arguments);
}

Sprite_GuideButtonBase.prototype = Object.create(Sprite.prototype);
Sprite_GuideButtonBase.prototype.constructor = Sprite_GuideButtonBase;

Sprite_GuideButtonBase.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this.pressButton = null;
	this.anchor.y = 0.5;
	this._textBuffer = "";
};

Sprite_GuideButtonBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateButtonPressed();
};

Sprite_GuideButtonBase.prototype.updateButtonPressed = function() {
	if(this.checkButtonPressed() && this.pressButton) {
		this.pressButton();
	}
};

Sprite_GuideButtonBase.prototype.checkButtonPressed = function() {
	return false;
};

Sprite_GuideButtonBase.prototype.setTextBuffer = function(text) {
	this._textBuffer = text;
};

Sprite_GuideButtonBase.prototype.getTextBuffer = function() {
	return this._textBuffer;
};

Sprite_GuideButtonBase.prototype.allWidth = function() {
	return this.width;
};

function Sprite_GuideButton() {
	this.initialize(...arguments);
}

Sprite_GuideButton.prototype = Object.create(Sprite_GuideButtonBase.prototype);
Sprite_GuideButton.prototype.constructor = Sprite_GuideButton;

Sprite_GuideButton.prototype.initialize = function(buttonName, uiTriggered = false) {
	Sprite_GuideButtonBase.prototype.initialize.call(this);
	this.bitmap = ImageManager.loadUI("guide_button_back");
	this.createText(buttonName);
	this._buttonName = buttonName;
	this._uiTriggered = uiTriggered;
};

Sprite_GuideButton.prototype.createText = function(buttonName) {
	const bitmap = new Bitmap(this.width, this.height);
	bitmap.fontSize = 24;
	bitmap.textColor = "#ff9bb7";
	bitmap.outlineColor = "#ffffff";
	bitmap.outlineWidth = 4;
	bitmap.drawCenterText(ConfigManager.getInputName(buttonName));
	this._textSprite = new Sprite(bitmap);
	this._textSprite.y = -10;
	this._textSprite.anchor.y = 0.5;
	this.addChild(this._textSprite);
};

Sprite_GuideButton.prototype.checkButtonPressed = function() {
	if(this._uiTriggered) {
		return Input.isUITriggered(this._buttonName);
	} else {
		return Input.isPressed(this._buttonName) || Input.isTriggered(this._buttonName);
	}
};

function Sprite_GuideMenuButton() {
	this.initialize(...arguments);
}

Sprite_GuideMenuButton.prototype = Object.create(Sprite_GuideButtonBase.prototype);
Sprite_GuideMenuButton.prototype.constructor = Sprite_GuideMenuButton;

Sprite_GuideMenuButton.prototype.initialize = function(menuCallback) {
	Sprite_GuideButtonBase.prototype.initialize.call(this);
	this.menuCallback = menuCallback;
	this.createAllItems();
};

Sprite_GuideMenuButton.prototype.createAllItems = function() {
	this.bitmap = ImageManager.loadUI("menu_unpressed");
	this._menuButtonTextSprite = new Sprite(new Bitmap(this.width, this.height));
	this._menuButtonTextSprite.anchor.y = 0.5;
	this._menuButtonTextSprite.x = 16;
	this.addChild(this._menuButtonTextSprite);
	const bitmap = this._menuButtonTextSprite.bitmap;
	bitmap.fontSize = 20;
	bitmap.textColor = "#551717";
	bitmap.outlineWidth = 0;
	bitmap.drawCenterText(TextManager.STATIC_TEXT_MENU);
};

Sprite_GuideMenuButton.prototype.checkButtonPressed = function() {
	return this.menuCallback();
};

function Sprite_GuideInteractButton() {
	this.initialize(...arguments);
}

Sprite_GuideInteractButton.prototype = Object.create(Sprite_GuideButtonBase.prototype);
Sprite_GuideInteractButton.prototype.constructor = Sprite_GuideInteractButton;

Sprite_GuideInteractButton.prototype.initialize = function() {
	Sprite_GuideButtonBase.prototype.initialize.call(this);
	this.createAllItems();
};

Sprite_GuideInteractButton.prototype.createAllItems = function() {
	this.bitmap = ImageManager.loadUI('interact');
	const width = 58;
	this._interactTextBitmap = new Bitmap(width, this.height);
	this._interactTextSprite = new Sprite(this._interactTextBitmap);
	this.addChild(this._interactTextSprite);
	this._interactTextSprite.x = this.width - width;
	this._interactTextSprite.anchor.y = 0.5;
	this._interactTextBitmap.outlineWidth = 0;
	this._interactTextBitmap.textColor = "#551717";
	this._interactTextBitmap.fontSize = 18;
	this._interactTextBitmap.drawCenterText("TALK");
};

Sprite_GuideInteractButton.prototype.checkButtonPressed = function() {
	return $gamePlayer.isInteractSignClicked();
};


Utils.isNoPopupBarScene = function() {
	const scenes = [Scene_Menu, Scene_Save, Scene_Shop, Scene_Transport, Scene_HardGuide, Scene_ItemObtain];
	return scenes.some((scene) => {
		return SceneManager.isPreviousScene(scene);
	});
};

function Sprite_HardGuide() {
	this.initialize(...arguments);
}

Sprite_HardGuide.prototype = Object.create(Sprite.prototype);
Sprite_HardGuide.prototype.constructor = Sprite_HardGuide;

Sprite_HardGuide.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._continueCatName = options.continueCatName;
	this._continueTextPadding = options.continueTextPadding;
	this._continueTextSize = options.continueTextSize;
	this._continueTextColor = options.continueTextColor;
	this._continueTextOutlineColor = options.continueTextOutlineColor;
	this._continueTextOutlineWidth = options.continueTextOutlineWidth;
	this._continueOffsetY = options.continueOffsetY;
	
	this._animation = new AnimationController();
	this.pressOk = null;
	this._continueVisibleCounter = 0;
	this.createBackground();
	this._contentsSprite = new Sprite(ImageManager.loadUI($gameSystem.hardGuide() + "_" + $dataLanguage));
	this._contentsSprite.x = -this._backSprite.width / 2;
	this._contentsSprite.y = -this._backSprite.height / 2;
	this._contentsSprite.alpha = 0;
	this.addChild(this._contentsSprite);
	this.createPressAnyContinue();
	this.startFadeInAnimation();
};

Sprite_HardGuide.prototype.startFadeInAnimation = function() {
	const controller = this._animation;
	this.backScale = 0;
	controller.add(this, {data:[{
		to:1, property:"backScale", easingType:'easeOutQuart', duration:12
	}], complete:this.startContentFadeIn.bind(this)});
};

Sprite_HardGuide.prototype.startContentFadeIn = function() {
	const controller = this._animation;
	controller.add(this._contentsSprite, {data:[{
		to:1, property:"alpha", easingType:'linear', duration:12
	}]});
};

Object.defineProperty(Sprite_HardGuide.prototype, "backScale", {
	get: function() {
		return this._backSprite.scale.x;
	},
	set: function(val) {
		this._backSprite.scale.x = this._backSprite.scale.y = val;
	},
	configurable: true
});

Sprite_HardGuide.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this._backSprite.anchor.x = this._backSprite.anchor.y = 0.5;
	this.addChild(this._backSprite);
};

Sprite_HardGuide.prototype.continueVisibleTime = function() {
	return 60;
};

Sprite_HardGuide.prototype.createPressAnyContinue = function() {
	this._continueTextBitmap = new Bitmap(this._backSprite.width, this._continueTextSize + this._continueTextOutlineWidth * 2);
	this._continueTextBitmap.outlineColor = this._continueTextOutlineColor;
	this._continueTextBitmap.outlineWidth = this._continueTextOutlineWidth;
	this._continueTextBitmap.textColor = this._continueTextColor;
	this._continueTextBitmap.fontSize = this._continueTextSize;
	this._continueSprite = new Sprite(this._continueTextBitmap);
	this._continueCatLeft = new Sprite(ImageManager.loadUI(this._continueCatName));
	this._continueCatRight = new Sprite(ImageManager.loadUI(this._continueCatName));
	this._continueCatLeft.anchor.x = this._continueCatLeft.anchor.y = this._continueCatRight.anchor.x = this._continueCatRight.anchor.y = 0.5;
	this._continueCatLeft.y = this._continueCatRight.y = this._continueSprite.height / 2;
	this._continueCatRight.scale.x = -1;
	this._continueSprite.addChild(this._continueCatLeft, this._continueCatRight);
	this._contentsSprite.addChild(this._continueSprite);
	this._continueSprite.y = this._continueOffsetY;
	this._continueSprite.visible = false;
	this.refreshContinueText();
	this.createContinueAnimation();
};

Sprite_HardGuide.prototype.refreshContinueText = function() {
	const text = TextManager.STATIC_TEXT_PRESS_ANY_CONTINUE;
	const textWidth = this._continueTextBitmap.measureTextWidth(text);
	
	this._continueCatLeft.x = (this._continueSprite.width - textWidth) / 2 - this._continueTextPadding;
	this._continueCatRight.x = this._continueSprite.width - this._continueCatLeft.x;
	this._continueTextBitmap.clear();
	this._continueTextBitmap.drawCenterText(text);
};

Sprite_HardGuide.prototype.onLanguageChange = function() {
	this.refreshContinueText();
};

Sprite_HardGuide.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateContinueSpriteVisible();
	this.updateInput();
};

Sprite_HardGuide.prototype.updateInput = function() {
	if(this._continueSprite.visible) {
		if(Input.isAnyTriggered() && this.pressOk) {
			SoundManager.playCancel();
			this.pressOk();
		}
	}
};

Sprite_HardGuide.prototype.updateContinueSpriteVisible = function() {
	if(!this._continueSprite.visible) {
		this._continueSprite.visible = (this._continueVisibleCounter > this.continueVisibleTime());
		this._continueVisibleCounter++;
	}	
};

Sprite_HardGuide.prototype.createContinueAnimation = function() {
	const controller = this._animation;
	const r = 0.4;
	const duration = 60;
	controller.add(this._continueCatLeft, {data:[{
		to:r, duration:duration, property:'rotation', easingType:'linear'
	}
	,{
		to:-r, duration:duration, property:'rotation', easingType:'linear'
	}],loop:true});
	controller.add(this._continueCatRight, {data:[{
		to:-r, duration:duration, property:'rotation', easingType:'linear'
	}
	,{
		to:r, duration:duration, property:'rotation', easingType:'linear'
	}],loop:true});
};

function Sprite_BuffIcon() {
	this.initialize(...arguments);
}

Sprite_BuffIcon.prototype = Object.create(Sprite.prototype);
Sprite_BuffIcon.prototype.constructor = Sprite_BuffIcon;

Sprite_BuffIcon.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._buff = options.buff;
	this._backName = options.backName;
	this._removed = false;
	this._layoutDirection = options.layoutDirection;
	this.onRemove = null;
	this._animation = new AnimationController();
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this.createBackground();
	this.createTimeSprite();
	this.createIcon();
	this.updateTime();
	this._isUnlimitBuffInStart = this.isUnlimitTimeBuff();
};

Sprite_BuffIcon.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this._baseSprite.addChild(this._backSprite);
	const bitmap = ImageManager.loadUI("buff_icons");
	this._backSprite.x = ((bitmap.width / this.buffTypeNum()) - this._backSprite.width) / 2;
	this._backSprite.y = this._layoutDirection === "up" ? (-this._backSprite.height - 2) : (bitmap.height + 2 - this._backSprite.height);
};

Sprite_BuffIcon.prototype.isUnlimitTimeBuff = function() {
	return this._buff.time >= 1000000 || this._buff.maxTime <= 2;		// maxTime <= 2一般是特定条件满足后每一帧持续附加的buff，而不是随时间消失
};

Sprite_BuffIcon.prototype.createTimeSprite = function() {
	this._timeBitmap = new Bitmap(this._backSprite.width, this._backSprite.height);
	this._timeBitmap.outlineWidth = 0;
	this._timeBitmap.fontSize = 12;
	this._timeBitmap.textColor = "#8e350f";
	this._time = new Sprite(this._timeBitmap);
	this._time.x = this._backSprite.x;
	this._time.y = this._backSprite.y;
	this._baseSprite.addChild(this._time);
};

Sprite_BuffIcon.prototype.createIcon = function() {
	const iconIdx = this.buffIcon();
	const bitmap = ImageManager.loadUI("buff_icons");
	this._iconSprite = new Sprite(bitmap);
	this._iconSprite.y = this._layoutDirection === "up" ? 0 : -this._backSprite.height;
	this._baseSprite.addChild(this._iconSprite);
	const width = bitmap.width / this.buffTypeNum();
	const height = bitmap.height;
	this._iconSprite.setFrame(iconIdx * width, 0, width, height);
};

Sprite_BuffIcon.prototype.buffTypeNum = function() {
	return 16;
};

Sprite_BuffIcon.prototype.buffIcon = function() {
	switch(this._buff.name) {
		case "invincible": case "unvisible_invincible": case "useless_invincible": {
			return 0;
		}
		case "hp_resume": case "hp_resume_very_easy": {
			return 12;
		}
		case "hp_drop": {
			return 11;
		}
		case "sp_resume": {
			return 10;
		}
		case "sp_drop": {
			return 9;
		}
		case "zp_resume": {
			return 8;
		}
		case "hp_lock": {
			return 13;
		} 
		case "atk_up": {
			return 3;
		}
		case "atk_down": {
			return 4;
		}
		case "def_up": {
			return 1;
		}
		case "def_down": {
			return 2;
		}
		case "jump_down": {
			return 5;
		}
		case "mov_up": {
			return 6;
		}
		case "mov_down": {
			return 7;
		}
		case "skill_force_immue": {
			return 14;
		}
		case "anti_stagger": {
			return 15;
		}
	}
};

Sprite_BuffIcon.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_BuffIcon.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateTime();
	if(this._buff.time <= 60 && !this._removed && !this._isUnlimitBuffInStart) {
		this._removed = true;
		this._animation.add(this._baseSprite, {data:[
			{to:0, property:"alpha", duration:61, easingType:"linear"}
		], complete:this.completeRemoveFade.bind(this)});
	} else if(this._buff.time <= 0 && !this._removed && this._isUnlimitBuffInStart) {
		this._removed = true;
		this.completeRemoveFade();
	}
};

Sprite_BuffIcon.prototype.completeRemoveFade = function() {
	this.onRemove(this);
};

Sprite_BuffIcon.prototype.updateTime = function() {
	if(!this.isUnlimitTimeBuff()) {	
		this._timeBitmap.clear();
		this._timeBitmap.drawCenterText(Math.min(999, Math.ceil(this._buff.time / 60)).padZero(3));
		this._backSprite.visible = true;
	} else {
		this._backSprite.visible = false;
	}
};

function Sprite_BuffIconGroup() {
	this.initialize(...arguments);
}

Sprite_BuffIconGroup.prototype = Object.create(Sprite.prototype);
Sprite_BuffIconGroup.prototype.constructor = Sprite_BuffIconGroup;

Sprite_BuffIconGroup.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._character = options.character;
	this._layoutDirection = options.layoutDirection;
	this._iconBackName = options.iconBackName;
	this._animation = new AnimationController();
	this.updateBuff();
};

Sprite_BuffIconGroup.prototype.setCharacter = function(character) {
	this._character = character;
	this.removeChildren();
};

Sprite_BuffIconGroup.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateBuff();
};

Sprite_BuffIconGroup.prototype.updateBuff = function() {
	if(!this._character) {
		return;
	}
	const obj = this._character.battleObject();
	if(obj) {
		for(const buff of obj.allBuff()) {
			if(!this.children.some((child) => { return child._buff === buff; })) {
				const sprite = new Sprite_BuffIcon({
					buff:buff
					, backName: this._iconBackName
					, layoutDirection: this._layoutDirection
				});
				sprite.x = this.itemX(this.children.length);
				sprite.onRemove = this.onIconRemove.bind(this);
				this.addChild(sprite);
			}
		}
	}
};

Sprite_BuffIconGroup.prototype.itemX = function(idx) {
	return 27 * idx;
};

Sprite_BuffIconGroup.prototype.onIconRemove = function(sprite) {
	const idx = this.getChildIndex(sprite);
	this.removeChild(sprite);
	const controller = this._animation;
	for(let i = idx; i < this.children.length; i++) {
		const child = this.children[i];
		controller.clear(child);
		controller.add(child, {data:[
			{to:this.itemX(i), property:"x", duration:20, easingType:"linear"}
		]});
	}
};

function Sprite_ZXCArtwork() {
	this.initialize(...arguments);
}

Sprite_ZXCArtwork.prototype = Object.create(Sprite.prototype);
Sprite_ZXCArtwork.prototype.constructor = Sprite_ZXCArtwork;

Sprite_ZXCArtwork.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this._animation = new AnimationController();
	this.anchor.x = this.anchor.y = 0.5;
};

Sprite_ZXCArtwork.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateArtwork();
};

Sprite_ZXCArtwork.prototype.updateArtwork = function() {
	const artwork = $gameTemp.zxcArtwork();
	if(artwork.name) {
		if(!this.bitmap) {
			this.bitmap = ImageManager.loadArtwork(artwork.name);
		}
		this.visible = true;
		if(!artwork.init) {
			artwork.init = true;
			artwork.width = this.width;
			artwork.height = this.height;
			$gameTemp.startZXCArtwork();
		}
		$gameTemp.updateZXCArtwork();
		this.x = artwork.x;
		this.y = artwork.y;
	} else {
		this.visible = false;
		this.bitmap = undefined;
	}
};

function Sprite_BossHpBar() {
	this.initialize(...arguments);
}

Sprite_BossHpBar.prototype = Object.create(Sprite_EnemyHpBar.prototype);
Sprite_BossHpBar.prototype.constructor = Sprite_BossHpBar;

Sprite_BossHpBar.prototype.initialize = function(options) {
	Sprite_EnemyHpBar.prototype.initialize.apply(this, arguments);
	this.createFace(options);
	this.createBuff(options);
	this.createScoreStar(options);
	if($gameMap.bossEvent()) {
		this.x = this._showX;
	} else {
		this.x = this.hiddenX();
	}
	this._backSprite.x = options.backOffset.x;
	this._backSprite.y = options.backOffset.y;
};

Sprite_BossHpBar.prototype.progress = function() {
	const hotEvent = $gameMap.bossEvent();
	if(hotEvent && hotEvent.battleObject()) {
		const obj = hotEvent.battleObject();
		return Math.max(0, obj._hp / obj.mhp);
	}
	return 0;
};

Sprite_BossHpBar.prototype.orientation = function() {
	return [1, 1];
};

Sprite_BossHpBar.prototype.updateHotEventChange = function() {
	const hotEvent = $gameMap.bossEvent();
	if(hotEvent && this._cachedHotEvent !== hotEvent) {
		this._cachedHotEvent = hotEvent;
		this.refreshBossFace();
		this._buffGroup.setCharacter(hotEvent);
	}
};

Sprite_BossHpBar.prototype.createFace = function(options) {
	this._face = new Sprite_BarFace(options.face);
	this.addChild(this._face);
};

Sprite_BossHpBar.prototype.createBuff = function(options) {
	const opt = options.buff;
	this._buffGroup = new Sprite_BuffIconGroup({iconBackName:opt.iconBackName,layoutDirection:"down"});
	this._buffGroup.x = opt.x;
	this._buffGroup.y = opt.y;
	this.addChild(this._buffGroup);
};

Sprite_BossHpBar.prototype.createScoreStar = function(options) {
	const opt = options.scoreStar;
	this._scoreStar = new Sprite_BossScoreStar();
	this._scoreStar.scale.set(0.6);
	this._scoreStar.x = opt.x;
	this._scoreStar.y = opt.y;
	this._starNum = 0;
	this.refreshStar();
	this.addChild(this._scoreStar);
};

Sprite_BossHpBar.prototype.refreshStar = function() {
	const hotEvent = $gameMap.bossEvent();
	if(hotEvent) {
		const star = $gamePlayer.generateBossScore();
		if(this._starNum !== star) {
			this._scoreStar.refreshStar("left");
		}
	}
};

Sprite_BossHpBar.prototype.refreshBossFace = function() {
	const obj = $gameMap.bossEvent().battleObject();
	const faceName = obj.faceName || "";
	const dangerFaceName = obj.dangerFaceName || faceName;
	this._face.setFaceName(faceName, dangerFaceName);
};

Sprite_BossHpBar.prototype.hiddenX = function() {
	return Graphics.width - this._face.x;
};

Sprite_BossHpBar.prototype.update = function() {
	Sprite_EnemyHpBar.prototype.update.call(this);
	this.refreshStar();
};

function Sprite_ItemObtain() {
	this.initialize(...arguments);
}

Sprite_ItemObtain.prototype = Object.create(Sprite.prototype);
Sprite_ItemObtain.prototype.constructor = Sprite_ItemObtain;

Sprite_ItemObtain.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._data = $gameSystem.lastObtainItem();
	this._catName = options.catName;
	this._lightName = options.lightName;
	this._auraName = options.auraName;
	this._textAreaName = options.textAreaName;
	this._catRotation = options.catRotation;
	this._catScrollSpeed = options.catScrollSpeed;
	this._catPosArr = options.catPosArr;
	this._lightRotationSpeed = options.lightRotationSpeed;
	this._textAreaY = options.textAreaY;
	this._nameTextSize = options.nameTextSize;
	this._descTextSize = options.descTextSize;
	this._textColor = options.textColor;
	this._nameTextPadEdge = options.nameTextPadEdge;
	this._nameTextPadInner = options.nameTextPadInner;
	this._artworkYMin = options.artworkYMin;
	this._artworkYMax = options.artworkYMax;
	this._artworkXSpeedMin = options.artworkXSpeedMin;
	this._artworkXSpeedMax = options.artworkXSpeedMax;
	this._artworkJumpIntervalMin = options.artworkJumpIntervalMin;
	this._artworkJumpIntervalMax = options.artworkJumpIntervalMax;
	this._artworkJumpStrengthMin = options.artworkJumpStrengthMin;
	this._artworkJumpStrengthMax = options.artworkJumpStrengthMax;
	this._artworkJumpGravity = options.artworkJumpGravity;
	
	this.createCatScroll();
	this.createLightRotate();
	this.createAuraRotate();
	this.createTextArea();
	this.createItemIcon();
	this.createArtwork();
	
	this._animation = new AnimationController();
	this.active = false;
	this.pressOk = null;
	this.startFadeIn();
};

Sprite_ItemObtain.prototype.createCatScroll = function() {
	const bitmap = ImageManager.loadUI(this._catName);
	this._catSprite = new Sprite();
	this.addChild(this._catSprite);
	for(const pos of this._catPosArr) {
		const cat = new TilingSprite(bitmap);
		cat.rotation = this._catRotation;
		cat.move(pos.x, pos.y, bitmap.width, bitmap.height);
		cat.anchor.x = cat.anchor.y = 0.5;
		this._catSprite.addChild(cat);
	}
};

Sprite_ItemObtain.prototype.createLightRotate = function() {
	this._lightRotateSprite = new Sprite(ImageManager.loadUI(this._lightName));
	this.addChild(this._lightRotateSprite);
	this._lightRotateSprite.x = Graphics.width / 2;
	this._lightRotateSprite.y = Graphics.height / 2;
	this._lightRotateSprite.anchor.set(0.5);
};

Sprite_ItemObtain.prototype.createAuraRotate = function() {
	this._auraRotateSprite = new Sprite(ImageManager.loadUI(this._auraName));
	this.addChild(this._auraRotateSprite);
	this._auraRotateSprite.x = Graphics.width / 2;
	this._auraRotateSprite.y = Graphics.height / 2;
	this._auraRotateSprite.anchor.set(0.5);
};

Sprite_ItemObtain.prototype.createTextArea = function() {
	this._textAreaSprite = new Sprite(ImageManager.loadUI(this._textAreaName));
	this.addChild(this._textAreaSprite);
	const width = this._textAreaSprite.width;
	this._textAreaSprite.x = (Graphics.width - width) / 2;
	this._textAreaSprite.y = this._textAreaY;
	
	const bitmapDesc = new Bitmap(width, this._textAreaSprite.height / 2);
	bitmapDesc.textColor = this._textColor;
	bitmapDesc.fontSize = this._descTextSize;
	bitmapDesc.outlineWidth = 0;
	
	this._mainTextSprite = new Sprite_PadText({
		text:""
		, edgeName:this._nameTextPadEdge
		, innerName:this._nameTextPadInner
		, textSize:this._nameTextSize
		, textColor:this._textColor
	});
	this._mainTextSprite.x = this._textAreaSprite.width / 2;
	this._subTextSprite = new Sprite(bitmapDesc);
	this._textAreaSprite.addChild(this._mainTextSprite, this._subTextSprite);
	this._subTextSprite.y = this._subTextSprite.height / 2;
	this.createText();
};

Sprite_ItemObtain.prototype.createText = function() {
	const bitmapDesc = this._subTextSprite.bitmap;
	bitmapDesc.clear();
	const itemData = this.itemData();
	const name = itemData.name;
	const desc = itemData.desc;
	this._mainTextSprite.setText(name);
	bitmapDesc.drawCenterText(desc);
};

Sprite_ItemObtain.prototype.itemData = function() {
	return $gamePlayer.actor().itemData(this._data);
};

Sprite_ItemObtain.prototype.createArtwork = function() {
	this._artwork = new Sprite_KeyFrameAnimation('obtain_item_artwork', 2, 'img/ui/', 12);
	this._artwork.anchor.set(0.5);
	if($gamePlayer.isSquash()) {
		this._artwork.scale.y = 0.5;
	}
	this.addChild(this._artwork);
	this.initArtwork();
};

Sprite_ItemObtain.prototype.initArtwork = function() {
	const bitmap = ImageManager.loadUI("obtain_item_artwork1");
	if(this._artwork.x < Graphics.width / 2) {
		this._artwork.x = -bitmap.width;
		this._artwork.scale.x = -1;
	} else {
		this._artwork.x = Graphics.width + bitmap.width;
		this._artwork.scale.x = 1;
	}
	this._artwork.y = this.randArtworkY();
	this._artworkGround = this._artwork.y;
	this._artworkXSpeed = this.randArtworkSpeed();
	this._initDelayCounter = 0;
	this._jumpIntervalCounter = 0;
	this._randJumpInterval = 0;
	this._artworkYSpeed = 0;
};

Sprite_ItemObtain.prototype.checkNeedInitArtwork = function() {
	if((this._artwork.x < -this._artwork.width && this._artwork.scale.x === 1) || (this._artwork.x > Graphics.width + this._artwork.width && this._artwork.scale.x === -1)) {
		this._initDelayCounter++;
	}
	if(this._initDelayCounter > this.initDelay()) {
		this.initArtwork();
	}
};

Sprite_ItemObtain.prototype.initDelay = function() {
	return 50;
};

Sprite_ItemObtain.prototype.randArtworkY = function() {
	return Utils.randomInt(this._artworkYMin, this._artworkYMax);
};

Sprite_ItemObtain.prototype.randArtworkSpeed = function() {
	return Utils.randomInt(this._artworkXSpeedMin, this._artworkXSpeedMax);
};

Sprite_ItemObtain.prototype.randJumpStrength = function() {
	return Utils.randomInt(this._artworkJumpStrengthMin, this._artworkJumpStrengthMax);
};

Sprite_ItemObtain.prototype.randJumpInterval = function() {
	return Utils.randomInt(this._artworkJumpIntervalMin, this._artworkJumpIntervalMax);
};

Sprite_ItemObtain.prototype.createItemIcon = function() {
	this._itemIcon = new Sprite_ItemIcon(this._data.type, this._data.idx);
	this._itemIcon.anchor.set(0.5);
	this.addChild(this._itemIcon);
	this._itemIcon.scale.x = this._itemIcon.scale.y = 2;
	this._itemIcon.x = this._lightRotateSprite.x;
	this._itemIcon.y = this._lightRotateSprite.y;
};

Sprite_ItemObtain.prototype.onLanguageChange = function() {
	this.createText();
};

Sprite_ItemObtain.prototype.updateCatScroll = function() {
	let reverse = false;
	for(const child of this._catSprite.children) {
		if(reverse) {
			child.origin.x += this._catScrollSpeed;
		} else {
			child.origin.x -= this._catScrollSpeed;
		}
		reverse = !reverse;
	}
};

Sprite_ItemObtain.prototype.updateLightScroll = function() {
	this._lightRotateSprite.rotation += this._lightRotationSpeed;
};

Sprite_ItemObtain.prototype.updateAuraScroll = function() {
	this._auraRotateSprite.rotation -= this._lightRotationSpeed;
};

Sprite_ItemObtain.prototype.updateArtwork = function() {
	if(this._artwork.y < this._artworkGround) {
		this._artworkYSpeed += this._artworkJumpGravity;
	} else {
		this._artwork.y = this._artworkGround;
		if(!this._randJumpInterval) {
			this._randJumpInterval = this.randJumpInterval();
		}
		this._jumpIntervalCounter++;
		if(this._jumpIntervalCounter > this._randJumpInterval) {
			this._artworkYSpeed = -this.randJumpStrength();
			this._jumpIntervalCounter = 0;
			this._randJumpInterval = 0;
		}
	}
	this._artwork.x += (this._artworkXSpeed * (-this._artwork.scale.x));
	this._artwork.y += this._artworkYSpeed;
	this.checkNeedInitArtwork();
};

Sprite_ItemObtain.prototype.fadeInCatScroll = function() {
	const controller = this._animation;
	for(const child of this._catSprite.children) {
		const targetX = child.x;
		const targetY = child.y;
		if(targetX < Graphics.width / 2) {
			child.x = -child.bitmap.height;
		} else {
			child.x = Graphics.width + child.bitmap.height;
		}
		
		if(targetY < Graphics.height / 2) {
			child.y = -child.bitmap.height;
		} else {
			child.y = Graphics.height + child.bitmap.height;
		}
		
		controller.add(child, {
			data:[{property:'x',duration:25,easingType:'easeOutQuart',to:targetX}]
		});
		controller.add(child, {
			data:[{property:'y',duration:25,easingType:'easeOutQuart',to:targetY}]
		});
	}
};

Sprite_ItemObtain.prototype.fadeInLight = function() {
	const targetY = this._lightRotateSprite.y;
	this._lightRotateSprite.y = -this._lightRotateSprite.height / 2;
	const controller = this._animation;
	controller.add(this._lightRotateSprite, {data:[{
		to:targetY, property:'y', easingType:'linear', duration:45
	}], complete:this.onLightFadeInStep1.bind(this)});
};

Sprite_ItemObtain.prototype.onLightFadeInStep1 = function() {
	this.active = true;
};

Sprite_ItemObtain.prototype.fadeInItemIcon = function() {
	const targetY = this._itemIcon.y;
	this._itemIcon.y = -this._lightRotateSprite.height / 2;
	const controller = this._animation;
	controller.add(this._itemIcon, {data:[{
		to:targetY, property:'y', easingType:'linear', duration:45
	}]});
};

Sprite_ItemObtain.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateCatScroll();
	this.updateLightScroll();
	this.updateAuraScroll();
	this.updateArtwork();
	if(this.active) {
		this.updateInput();
	}
};

Sprite_ItemObtain.prototype.startFadeIn = function() {
	this.fadeInCatScroll();
	this.fadeInLight();
	this.fadeInItemIcon();
};

Sprite_ItemObtain.prototype.updateInput = function() {
	if(Input.isAnyTriggered() && this.pressOk) {
		this.pressOk();
		SoundManager.playCancel();
	}
};

function Sprite_MapMovingCursor() {
	this.initialize(...arguments);
}

Sprite_MapMovingCursor.prototype = Object.create(Sprite.prototype);
Sprite_MapMovingCursor.prototype.constructor = Sprite_MapMovingCursor;

Sprite_MapMovingCursor.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._cursorName = options.cursorName;
	this._cursorMargin = options.cursorMargin;
	this.createBackground();
	this.createCursor();
	this.updateVisible();
	this.updateCursor();
};

Sprite_MapMovingCursor.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
	this._backSprite.anchor.set(0.5);
};

Sprite_MapMovingCursor.prototype.createCursor = function() {
	this._cursorSprite = new Sprite(ImageManager.loadUI(this._cursorName));
	this.addChild(this._cursorSprite);
	this._cursorSprite.anchor.set(0.5);
};

Sprite_MapMovingCursor.prototype.updateVisible = function() {
	if($gameMap.movingCursorProgress()) {
		this.visible = true;
	} else {
		this.visible = false;
	}
};

Sprite_MapMovingCursor.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateVisible();
	this.updateCursor();
};

Sprite_MapMovingCursor.prototype.updateCursor = function() {
	if(this.visible) {
		const progress = $gameMap.movingCursorProgress() - 1;
		const min = -this._backSprite.width / 2 + this._cursorMargin;
		const max = -min;
		this._cursorSprite.x = min + (max - min) * progress / 1000;
	}
};

function Sprite_SpecProgress() {
	this.initialize(...arguments);
}

Sprite_SpecProgress.prototype = Object.create(Sprite_SPBar.prototype);
Sprite_SpecProgress.prototype.constructor = Sprite_SpecProgress;

Sprite_SpecProgress.prototype.initialize = function() {
	Sprite_SPBar.prototype.initialize.apply(this, arguments);
	this.updateVisible(true);
	this.swapChildren(this._backSprite, this._progressSprite);
	this._isFadeOutAnimating = false;
	this._progressFilter = new ColorFilter();
	this._progressFilter.setBlendColor([128,0,128,255]);
	this._progressSprite.filters = [this._progressFilter];
	this._progressFilter.enabled = false;
};

Sprite_SpecProgress.prototype.update = function() {
	Sprite_SPBar.prototype.update.call(this);
	this.updateVisible();
	this.updateProgressType();
};

Sprite_SpecProgress.prototype.updateVisible = function(noFade = false) {
	const visible = this.visibleData();
	if(this.visible !== visible && !this._isFadeOutAnimating) {
		if(!noFade) {
			if(visible) {
				this.visible = visible;
				this.requestFadeIn();
			} else {
				this.requestFadeOut();
			}
		} else {
			this.visible = visible;
		}
	}
};

Sprite_SpecProgress.prototype.updateProgressType = function() {
	if(this.visible) {
		if($gameMap.specProgressType() === 0 && this._progressFilter.enabled) {
			this._progressFilter.enabled = false;
		} else if($gameMap.specProgressType() === 1 && !this._progressFilter.enabled) {
			this._progressFilter.enabled = true;
		}
	}
};

Sprite_SpecProgress.prototype.progress = function() {
	return $gameMap.specProgress();
};

Sprite_SpecProgress.prototype.visibleData = function() {
	return $gameMap.specProgressVisible();
};

Sprite_SpecProgress.prototype.requestFadeIn = function() {
	this.alpha = 0;
	const controller = this._animation;
	controller.removeById(this, "fade");
	controller.add(this, {id:"fade", data:[
		{to:1, duration:20, property:'alpha', easingType:'linear'}
	]});
};

Sprite_SpecProgress.prototype.requestFadeOut = function() {
	const controller = this._animation;
	controller.removeById(this, "fade");
	controller.add(this, {id:"fade", data:[
		{to:0, duration:20, property:'alpha', easingType:'linear'}
	], complete:this.onFadeOutComplete.bind(this)});
	this._isFadeOutAnimating = true;
};

Sprite_SpecProgress.prototype.onFadeOutComplete = function() {
	this.visible = false;
	this._isFadeOutAnimating = false;
};

Sprite_SpecProgress.prototype.orientation = function() {
	return [1, 1]
};

Sprite_SpecProgress.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_SpecProgress.prototype.allHeight = function() {
	return this._backSprite.height;
};

Sprite_SpecProgress.prototype.updateProgress = function() {
	if(this.visibleData()) {
		Sprite_SPBar.prototype.updateProgress.call(this);
	}
};

Sprite_SpecProgress.prototype.updateMask = function() {
	if(this.visibleData() || this._isFadeOutAnimating) {
		Sprite_SPBar.prototype.updateMask.call(this);
	}
};

// boss头顶的机制条
function Sprite_SmallSpecProgress() {
	this.initialize(...arguments);
}

Sprite_SmallSpecProgress.prototype = Object.create(Sprite_SpecProgress.prototype);
Sprite_SmallSpecProgress.prototype.constructor = Sprite_SmallSpecProgress;

Sprite_SmallSpecProgress.prototype.initialize = function(options, character) {
	this._character = character;
	Sprite_SpecProgress.prototype.initialize.call(this, options);
	this.z = 7;
};

Sprite_SmallSpecProgress.prototype.visibleData = function() {
	return this._character.specProgressVisible() && !this._character.isDeath();
};

Sprite_SmallSpecProgress.prototype.updateProgressType = function() {
};

Sprite_SmallSpecProgress.prototype.progress = function() {
	return this._character.specProgress();
};

Sprite_SmallSpecProgress.prototype.update = function() {
	Sprite_SpecProgress.prototype.update.call(this);
	this.updatePosition();
};

Sprite_SmallSpecProgress.prototype.updatePosition = function() {
	this.x = -$gameMap.tileWidth() * $gameMap.displayX() + this._character.px - this.allWidth() / 2;
	this.y = -$gameMap.tileHeight() * $gameMap.displayY() + this._character.py - this.allHeight() / 2 - this._character.hitOffsetT() - 48;
};

function Sprite_BossScore() {
	this.initialize(...arguments);
}

Sprite_BossScore.prototype = Object.create(Sprite.prototype);
Sprite_BossScore.prototype.constructor = Sprite_BossScore;

Sprite_BossScore.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._animation = new AnimationController();
	this._starBottomPadding = options.starBottomPadding;
	this.createBackground();
	this.createScoreStar();
	this.x = -this.allWidth();
	this.visible = false;
};

Sprite_BossScore.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
};

Sprite_BossScore.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_BossScore.prototype.allHeight = function() {
	return this._backSprite.height;
};

Sprite_BossScore.prototype.createScoreStar = function() {
	this._scoreStar = new Sprite_BossScoreStar();
	this.addChild(this._scoreStar);
	this._scoreStar.y = this.allHeight() - this._starBottomPadding;
	this._scoreStar.x = (this.allWidth() / 2) | 0;
};

Sprite_BossScore.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	if($gameMap.pollBossScorePopUp()) {
		this.requestPopUp();
	}
};

Sprite_BossScore.prototype.requestPopUp = function() {
	const controller = this._animation;
	controller.clear(this);
	this.visible = true;
	controller.add(this, {data:[
		{to:0,property:"x",duration:25,easingType:"easeOutQuart"}
		, {to:-this.allWidth(),property:"x",duration:25,easingType:"easeOutQuart", delay:140}
	], complete:this.onPopUpComplete.bind(this)});
	this._scoreStar.refreshStar();
	
};

Sprite_BossScore.prototype.onPopUpComplete = function() {
	this.visible = false;
};

function Sprite_BossScoreStar() {
	this.initialize(...arguments);
}

Sprite_BossScoreStar.prototype = Object.create(Sprite.prototype);
Sprite_BossScoreStar.prototype.constructor = Sprite_BossScoreStar;

Sprite_BossScoreStar.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
};

Sprite_BossScoreStar.prototype.refreshStar = function(align = "center") {
	const star = $gamePlayer.generateBossScore();
	const margin = 10;
	const bitmap = ImageManager.loadUI("boss_score_star");
	const oneWidth = bitmap.width + margin;
	const allWidth = oneWidth * star - margin;
	const startX = align === "center" ? ((-allWidth / 2) | 0) : 0;
	this.removeChildren();
	for(let i = 0; i < star; i++) {
		const sprite = new Sprite(bitmap);
		sprite.anchor.y = 1;
		sprite.x = startX + i * oneWidth;
		this.addChild(sprite);
	}
};

function Sprite_MenuBook() {
	this.initialize(...arguments);
}

Sprite_MenuBook.prototype = Object.create(Sprite_MenuBase.prototype);
Sprite_MenuBook.prototype.constructor = Sprite_MenuBook;

Sprite_MenuBook.prototype.initialize = function(options) {
	Sprite_MenuBase.prototype.initialize.apply(this, arguments);
	this._commandMargin = options.commandMargin;
	this._commandShiftY = options.commandShiftY;
	this._commandSelectShiftY = options.commandSelectShiftY;
	this._commandName = options.commandName;
	this._commandSelectName = options.commandSelectName;
	this._backName = options.backName;
	this._commandTextSize = options.commandTextSize;
	this._commandTextColor = options.commandTextColor;
	this._moveSignName = options.moveSignName;
	this.createCommandData();
	this.createBackground();
	this.createPanel();
	this._selectIndex = -1;				// 分两个选择索引，选项卡选择和面板选择，因为当选项卡全部变成未选择时，面板依然会有一个在选择状态
	this._panelSelectIndex = 0;
	this.updateSelect();
};

Sprite_MenuBook.prototype.selectable = function() {
	return true;
};

Sprite_MenuBook.prototype.onLanguageChange = function() {
	Sprite_MenuBase.prototype.onLanguageChange.call(this);
	this._commandSprite.children.forEach((sprite) => {
		sprite.onLanguageChange();
	});
	this._panelSprite.children.forEach((sprite) => {
		sprite.onLanguageChange();
	});
};

Sprite_MenuBook.prototype.createCommandData = function() {
	this._commandSprite = new Sprite();
	const bitmap1 = ImageManager.loadUI(this._commandName);
	const bitmap2 = ImageManager.loadUI(this._backName);
	this._commandSprite.x = (this.allWidth() - bitmap2.width) / 2 + this._baseRect.x;
	this._commandSprite.y = (this.allHeight() - bitmap1.height - bitmap2.height + this._commandShiftY) / 2 + this._baseRect.y;
	this._baseSprite.addChild(this._commandSprite);
	const shiftY = this._commandSelectShiftY - this._commandShiftY;
	const command1 = new Sprite_MenuBookCommand({
		selectName:this._commandSelectName
		,unselectName:this._commandName
		,desc:"STATIC_TEXT_BOOK_BOSS_SCORE"
		,shiftY:0
		,selectShiftY:shiftY
		,textSize:this._commandTextSize
		,textColor:this._commandTextColor
	});
	command1.x = this._commandMargin;
	const command2 = new Sprite_MenuBookCommand({
		selectName:this._commandSelectName
		,unselectName:this._commandName
		,desc:"STATIC_TEXT_BOOK_BUFF"
		,shiftY:0
		,selectShiftY:shiftY
		,textSize:this._commandTextSize
		,textColor:this._commandTextColor
	});
	command2.x = this._commandMargin * 2 + bitmap1.width;
	const command3 = new Sprite_MenuBookCommand({
		selectName:this._commandSelectName
		,unselectName:this._commandName
		,desc:"STATIC_TEXT_BOOK_MAP_INFO"
		,shiftY:0
		,selectShiftY:shiftY
		,textSize:this._commandTextSize
		,textColor:this._commandTextColor
	});
	command3.x = this._commandMargin * 3 + bitmap1.width * 2;
	this._commandSprite.addChild(command1, command2, command3);
};

Sprite_MenuBook.prototype.createBackground = function() {
	const bitmap1 = ImageManager.loadUI(this._commandName);
	const bitmap2 = ImageManager.loadUI(this._backName);
	this._backSprite = new Sprite(bitmap2);
	this._backSprite.x = (this.allWidth() - bitmap2.width) / 2 + this._baseRect.x;
	this._backSprite.y = (this.allHeight() + bitmap1.height - bitmap2.height - this._commandShiftY) / 2 + this._baseRect.y;
	this._baseSprite.addChild(this._backSprite);
};

Sprite_MenuBook.prototype.createPanel = function() {
	this._panelSprite = new Sprite();
	this._baseSprite.addChild(this._panelSprite);
	this._panelSprite.x = this._backSprite.x;
	this._panelSprite.y = this._backSprite.y;
	const bitmap2 = ImageManager.loadUI(this._backName);
	const baseOptions = {
		width:bitmap2.width
		,height:bitmap2.height
		,moveSignName:this._moveSignName
	};
	const panel1 = new Sprite_MenuBookScore(baseOptions);
	const panel2 = new Sprite_MenuBookBuff(baseOptions);
	const panel3 = new Sprite_MenuBookMap(baseOptions);
	this._panelSprite.addChild(panel1, panel2, panel3);
};

Sprite_MenuBook.prototype.updateInput = function() {
	Sprite_MenuBase.prototype.updateInput.call(this);
	let delta = 0;
	if(Input.isUITriggered("left")) {
		delta = -1;
	}
	if(Input.isUITriggered("right")) {
		delta = 1;
	}
	if(delta !== 0) {
		this._selectIndex += delta;
		const max = this._commandSprite.children.length;
		if(this._selectIndex >= max) {
			this._selectIndex = 0;
		} else if(this._selectIndex < 0) {
			this._selectIndex = max - 1;
		}
		this._panelSelectIndex = this._selectIndex;
		this.updateSelect();
		SoundManager.playCursor();
	}
};

Sprite_MenuBook.prototype.updateTouchInput = function() {
	if(TouchInput.isMoved() || TouchInput.isClicked()) {
		for(let i = 0; i < this._commandSprite.children.length; i++) {
			const sprite = this._commandSprite.children[i];
			if(sprite.isBeingTouched()) {
				if(this._panelSelectIndex !== i) {
					this._panelSelectIndex = this._selectIndex = i;
					this.updateSelect();
				}
				if(!this._active) {
					this.active();
					this.commandDeactive();
				}
				if(TouchInput.isClicked()) {
					SoundManager.playCursor();
				}
				break;
			}
		}
	}
};

Sprite_MenuBook.prototype.updateSelect = function() {
	this.updatePanelVisible();
	this.updateCommandActive();
};

// 因为失去焦点后，this._selectIndex会变成-1
// 但即使没有选项卡被选中，仍然要显示一个panel，初始是第一个panel，后续为失去焦点后最后显示的panel
Sprite_MenuBook.prototype.updatePanelVisible = function() {
	for(let i = 0; i < this._panelSprite.children.length; i++) {
		if(i === this._panelSelectIndex) {
			this._panelSprite.children[i].visible = true;
		} else {
			this._panelSprite.children[i].visible = false;
		}
	}
};

// 虽然panel的显示是上面的函数决定，但是，panel显示出来不一定获得操作焦点，选项卡的选择才决定操作焦点
Sprite_MenuBook.prototype.updateCommandActive = function() {
	for(let i = 0; i < this._commandSprite.children.length; i++) {
		if(i === this._selectIndex) {
			this._commandSprite.children[i].select();
			this._panelSprite.children[i].active();
		} else {
			this._commandSprite.children[i].unselect();
			this._panelSprite.children[i].deactive();
		}
	}
};

Sprite_MenuBook.prototype.active = function() {
	Sprite_MenuBase.prototype.active.call(this);
	this._selectIndex = this._panelSelectIndex;
	this.updateSelect();
};

Sprite_MenuBook.prototype.deactive = function() {
	Sprite_MenuBase.prototype.deactive.call(this);
	this._selectIndex = -1;
	this.updateSelect();
};

function Sprite_MenuBookCommand() {
	this.initialize(...arguments);
}

Sprite_MenuBookCommand.prototype = Object.create(Sprite.prototype);
Sprite_MenuBookCommand.prototype.constructor = Sprite_MenuBookCommand;

Sprite_MenuBookCommand.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._selectName = options.selectName;
	this._unselectName = options.unselectName;
	this._desc = options.desc;
	this._shiftY = options.shiftY;
	this._selectShiftY = options.selectShiftY;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this.createSelectedSprite();
	this.createUnselectedSprite();
	this.createText();
	this.unselect();
};

Sprite_MenuBookCommand.prototype.onLanguageChange = function() {
	this.refreshText();
};

Sprite_MenuBookCommand.prototype.select = function() {
	this._selectSprite.visible = true;
	this._unselectSprite.visible = false;
	this._textSprite.y = this._selectShiftY;
};

Sprite_MenuBookCommand.prototype.unselect = function() {
	this._selectSprite.visible = false;
	this._unselectSprite.visible = true;
	this._textSprite.y = this._shiftY;
};

Sprite_MenuBookCommand.prototype.isBeingTouched = function() {
	return this._selectSprite.isBeingTouched() || this._unselectSprite.isBeingTouched();
};

Sprite_MenuBookCommand.prototype.createSelectedSprite = function() {
	this._selectSprite = new Sprite(ImageManager.loadUI(this._selectName));
	this.addChild(this._selectSprite);
	this._selectSprite.y = this._selectShiftY;
};

Sprite_MenuBookCommand.prototype.createUnselectedSprite = function() {
	this._unselectSprite = new Sprite(ImageManager.loadUI(this._unselectName));
	this.addChild(this._unselectSprite);
	this._unselectSprite.y = this._shiftY;
};

Sprite_MenuBookCommand.prototype.createText = function() {
	this._textBitmap = new Bitmap(this._unselectSprite.width, this._unselectSprite.height);
	this._textBitmap.outlineWidth = 0;
	this._textBitmap.textColor = this._textColor;
	this._textBitmap.fontSize = this._textSize;
	this._textSprite = new Sprite(this._textBitmap);
	this.addChild(this._textSprite);
	this.refreshText();
};

Sprite_MenuBookCommand.prototype.refreshText = function() {
	this._textBitmap.clear();
	this._textBitmap.drawCenterText(TextManager[this._desc]);
};

function Sprite_MenuBookPanelBase() {
	this.initialize(...arguments);
}

Sprite_MenuBookPanelBase.prototype = Object.create(Sprite.prototype);
Sprite_MenuBookPanelBase.prototype.constructor = Sprite_MenuBookPanelBase;

Sprite_MenuBookPanelBase.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._panelWidth = options.width;
	this._panelHeight = options.height;
	this._moveSignName = options.moveSignName;
	this._baseSprite = new Sprite();
	this.addChild(this._baseSprite);
	this._animation = new AnimationController();
	this.createScrollMask();
	this.createMoveSign();
};

Sprite_MenuBookPanelBase.prototype.createScrollMask = function() {
	if(this.supportScoll()) {
		this._scrollMask = new PIXI.Graphics();
		this.addChild(this._scrollMask);
		this._scrollMask.clear();
		this._scrollMask.beginFill(0xff0000);
		this._scrollMask.drawRect(0, 0, this._panelWidth, this._panelHeight);
		this._scrollMask.endFill();
		this._baseSprite.mask = this._scrollMask;
	} else {
		this._scrollMask = null;
	}
};

Sprite_MenuBookPanelBase.prototype.onLanguageChange = function() {
};

Sprite_MenuBookPanelBase.prototype.centerX = function() {
	return this._panelWidth / 2;
};

Sprite_MenuBookPanelBase.prototype.centerY = function() {
	return this._panelHeight / 2;
};

Sprite_MenuBookPanelBase.prototype.active = function() {
	this._active = true;
};

Sprite_MenuBookPanelBase.prototype.deactive = function() {
	this._active = false;
};

// 是否支持上下滚动
Sprite_MenuBookPanelBase.prototype.supportScoll = function() {
	return false;
};

// overwrite
Sprite_MenuBookPanelBase.prototype.scrollDelta = function() {
	return 0;
};

Sprite_MenuBookPanelBase.prototype.maxScroll = function() {
	return 0;
};

Sprite_MenuBookPanelBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	if(this._active && this.supportScoll()) {
		this.updateInput();
		this.updateMoveSign();
	}
};

Sprite_MenuBookPanelBase.prototype.updateInput = function() {
	if(Input.isUITriggered("up") && this._baseSprite.y > 0) {
		const y = Math.max(0, this._baseSprite.y - this.scrollDelta());
		SoundManager.playCursor();
		const controller = this._animation;
		controller.clear(this._baseSprite);
		controller.add(this._baseSprite, {data:[
			{to:y,property:"y",duration:16,easingType:"easeOutQuart"}
		]});
	}
	else if(Input.isUITriggered("down") && this._baseSprite.y < this.maxScroll()) {
		const y = Math.min(this.maxScroll(), this._baseSprite.y + this.scrollDelta());
		SoundManager.playCursor();
		const controller = this._animation;
		controller.clear(this._baseSprite);
		controller.add(this._baseSprite, {data:[
			{to:y,property:"y",duration:16,easingType:"easeOutQuart"}
		]});
	}
};

Sprite_MenuBookPanelBase.prototype.createMoveSign = function() {
	if(this.supportScoll()) {
		this._moveSignUp = new Sprite(ImageManager.loadUI(this._moveSignName));
		this._moveSignDown = new Sprite(ImageManager.loadUI(this._moveSignName));
		this._moveSignUp.anchor.set(0.5);
		this._moveSignDown.anchor.set(0.5);
		this._moveSignDown.scale.y = -1;
		this.addChild(this._moveSignDown, this._moveSignUp);
		this._moveSignUp.x = this._moveSignDown.x = this.centerX();
		this._moveSignUp.y = this._moveSignUp.height / 2;
		this._moveSignDown.y = this._panelHeight - this._moveSignDown.height / 2;
		const controller = this._animation;
		controller.add(this._moveSignUp, {data:[{
			to:0.5, property:"alpha", duration:45, easingType:"linear"
		},{
			to:1, property:"alpha", duration:45, easingType:"linear"
		}], loop:true});
		controller.add(this._moveSignDown, {data:[{
			to:0.5, property:"alpha", duration:45, easingType:"linear"
		},{
			to:1, property:"alpha", duration:45, easingType:"linear"
		}], loop:true});
	} else {
		this._moveSignUp = null;
		this._moveSignDown = null;
	}
};

Sprite_MenuBookPanelBase.prototype.updateMoveSign = function() {
	this._moveSignUp.visible = this._baseSprite.x > 0;
	this._moveSignDown.visible = this._baseSprite.x < this.maxScroll();
};

function Sprite_MenuBookScore() {
	this.initialize(...arguments);
}

Sprite_MenuBookScore.prototype = Object.create(Sprite_MenuBookPanelBase.prototype);
Sprite_MenuBookScore.prototype.constructor = Sprite_MenuBookScore;

Sprite_MenuBookScore.prototype.initialize = function() {
	Sprite_MenuBookPanelBase.prototype.initialize.apply(this, arguments);
	this.createAllItems();
};

Sprite_MenuBookScore.prototype.createAllItems = function() {
	const allBattleObject = Game_BattleObject.template();
	let i = 0;
	for(const idstr of Object.keys(allBattleObject)) {
		const id = parseInt(idstr);
		const obj = allBattleObject[id];
		if(obj.isBoss) {
			const score = ConfigManager.bossScore(id);
			let child = null;
			if(score) {
				child = new Sprite_MenuBookBossScoreStar(id);
			} else {
				child = new Sprite_MenuBookBossScoreStar(0);
			}
			child.x = this.itemX(i);
			child.y = this.itemY(i);
			this._baseSprite.addChild(child);
			i++;
		}
	}
};

Sprite_MenuBookScore.prototype.itemNumPerRow = function() {
	return 2;
};

Sprite_MenuBookScore.prototype.itemNumPerColumn = function() {
	return 7;
};

Sprite_MenuBookScore.prototype.itemPadding = function() {
	return 32;
};

Sprite_MenuBookScore.prototype.itemX = function(index) {
	const cellWidth = (this._panelWidth - this.itemPadding() * 2) / this.itemNumPerRow();
	const x = index % this.itemNumPerRow();
	return this.itemPadding() + x * cellWidth + cellWidth / 2;
};

Sprite_MenuBookScore.prototype.itemY = function(index) {
	const cellHeight = (this._panelHeight - this.itemPadding() * 2) / this.itemNumPerColumn();
	const y = Math.trunc(index / this.itemNumPerRow());
	return this.itemPadding() + y * cellHeight + cellHeight / 2;
};

function Sprite_MenuBookBossScoreStar() {
	this.initialize(...arguments);
}

Sprite_MenuBookBossScoreStar.prototype = Object.create(Sprite.prototype);
Sprite_MenuBookBossScoreStar.prototype.constructor = Sprite_MenuBookBossScoreStar;

// 布局从左到右，待机动画+特异性标识extraSignature+评分星数
Sprite_MenuBookBossScoreStar.prototype.initialize = function(battleObjectId) {
	Sprite.prototype.initialize.call(this);
	this._battleObjectId = battleObjectId;
	this._frameWidth = 1;
	this._frameHeight = 1;
	this._frameSpeed = 1;
	this.createAllItems();
	this.updateCharacterFrame();
};

Sprite_MenuBookBossScoreStar.prototype.extraSignature = function(battleObjectId) {
	switch(battleObjectId) {
		case 35: return ";lily_bomb";
		case 87: return ";lily_bomb_water";
		default: return null;
	}
};

Sprite_MenuBookBossScoreStar.prototype.maxStarNum = function() {
	return 5;
};

Sprite_MenuBookBossScoreStar.prototype.itemMargin = function() {
	return 10;
};

Sprite_MenuBookBossScoreStar.prototype.createAllItems = function() {
	let bitmap = null;
	this._characterWidth = 0;
	this._characterHeight = 0;
	if(this._battleObjectId !== 0) {
		const template = Game_BattleObject.template();
		const name = template[this._battleObjectId].standingImage;
		const f = ImageFrame.info(name);
		bitmap = ImageManager.loadCharacter(name);
		this._characterWidth = bitmap.width / f.width;
		this._characterHeight = bitmap.height / f.height;
		this._frameWidth = f.width;
		this._frameHeight = f.height;
		this._frameSpeed = f.frameSpeed;
	} else {
		bitmap = ImageManager.loadUI("menu_boss_score_unknow");
		this._characterWidth = bitmap.width;
		this._characterHeight = bitmap.height;
	}
	const signatureWidth = 32;
	const starBitmap = ImageManager.loadUI("menu_boss_score_star");
	const darkStarBitmap = ImageManager.loadUI("menu_boss_score_star_dark");
	const scaleCharacter = 1;
	const scaleStar = 0.8;
	const allWidth = this._characterWidth * scaleCharacter + signatureWidth + starBitmap.width * this.maxStarNum() + this.itemMargin();
	this._characterSprite = new Sprite(bitmap);
	this._characterSprite.x = -allWidth / 2;
	this._characterSprite.anchor.y = 0.5;
	this._characterSprite.scale.set(scaleCharacter);
	this.addChild(this._characterSprite);
	const extraSignature = this.extraSignature(this._battleObjectId);
	if(extraSignature) {
		const extSprite = new Sprite(ImageManager.loadCharacter(extraSignature));
		this.addChild(extSprite);
		extSprite.x = this._characterSprite.x + this._characterWidth * scaleCharacter + 10;
		extSprite.y = -bitmap.height / 2;
	}
	const star = this._battleObjectId ? ConfigManager.bossScore(this._battleObjectId) : 0;
	for(let i = 0; i < this.maxStarNum(); i++) {
		let starSprite = null;
		if(i < star) {
			starSprite = new Sprite(starBitmap);
		} else {
			starSprite = new Sprite(darkStarBitmap);
		}
		this.addChild(starSprite);
		starSprite.anchor.y = 0.5;
		starSprite.scale.set(scaleStar);
		starSprite.x = this._characterSprite.x + this._characterWidth * scaleCharacter + signatureWidth + i * starBitmap.width + this.itemMargin();
	}
};

Sprite_MenuBookBossScoreStar.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateCharacterFrame();
};

Sprite_MenuBookBossScoreStar.prototype.updateCharacterFrame = function() {
	const i = Graphics.frameCount % this._frameSpeed;
	if(i === 0) {
		const frame = Math.trunc(Graphics.frameCount / this._frameSpeed);
		const frameNum = this._frameWidth * this._frameHeight;
		const c = frame % frameNum;
		const x = c % this._frameWidth;
		const y = Math.trunc(c / this._frameWidth);
		this._characterSprite.setFrame(x * this._characterWidth, y * this._characterHeight, this._characterWidth, this._characterHeight);
	}
};

function Sprite_MenuBookBuff() {
	this.initialize(...arguments);
}

Sprite_MenuBookBuff.prototype = Object.create(Sprite_MenuBookScore.prototype);
Sprite_MenuBookBuff.prototype.constructor = Sprite_MenuBookBuff;

Sprite_MenuBookBuff.prototype.initialize = function() {
	Sprite_MenuBookScore.prototype.initialize.apply(this, arguments);
};

Sprite_MenuBookBuff.prototype.createAllItems = function() {
	const allBuffNum = Sprite_BuffIcon.prototype.buffTypeNum.call(this);
	const bitmap = ImageManager.loadUI("buff_icons");
	const textWidth = 270;
	const iconFrame = 48;
	const itemWidth = textWidth + iconFrame;
	const textSize = 18;
	for(let buffId = 0; buffId < allBuffNum; buffId++) {
		const iconSprite = new Sprite(bitmap);
		this._baseSprite.addChild(iconSprite);
		const width = bitmap.width / allBuffNum;
		const height = bitmap.height;
		iconSprite.setFrame(buffId * width, 0, width, height);
		const itemCenterX = this.itemX(buffId);
		const itemCenterY = this.itemY(buffId);
		iconSprite.anchor.set(0.5);
		iconSprite.x = itemCenterX - itemWidth / 2 + iconFrame / 2;
		iconSprite.y = itemCenterY;
		
		const textBitmap = new Bitmap(textWidth, textSize);
		textBitmap.fontSize = textSize;
		textBitmap.textColor = "#551717";
		textBitmap.outlineWidth = 0;
		const textSprite = new Sprite(textBitmap);
		this._baseSprite.addChild(textSprite);
		textSprite.x = iconSprite.x + iconFrame + 24;
		textSprite.y = itemCenterY;
		textSprite.anchor.y = 0.5;
	}
	this.refreshText();
};

Sprite_MenuBookBuff.prototype.itemNumPerRow = function() {
	return 2;
};

Sprite_MenuBookBuff.prototype.itemNumPerColumn = function() {
	return 8;
};

Sprite_MenuBookBuff.prototype.onLanguageChange = function() {
	Sprite_MenuBookScore.prototype.onLanguageChange.call(this);
	this.refreshText();
};

Sprite_MenuBookBuff.prototype.refreshText = function() {
	const allBuffNum = Sprite_BuffIcon.prototype.buffTypeNum.call(this);
	const prefix = "STATIC_TEXT_BUFF_DESC";
	for(let buffId = 0; buffId < allBuffNum; buffId++) {
		const textBitmap = this._baseSprite.children[buffId * 2 + 1].bitmap;
		textBitmap.clear();
		textBitmap.drawAlignText(TextManager[prefix + buffId], "left");
	}
};

function Sprite_MenuBookMap() {
	this.initialize(...arguments);
}

Sprite_MenuBookMap.prototype = Object.create(Sprite_MenuBookScore.prototype);
Sprite_MenuBookMap.prototype.constructor = Sprite_MenuBookMap;

Sprite_MenuBookMap.prototype.initialize = function() {
	Sprite_MenuBookScore.prototype.initialize.apply(this, arguments);
};

Sprite_MenuBookMap.prototype.itemNumPerRow = function() {
	return 2;
};

Sprite_MenuBookMap.prototype.itemNumPerColumn = function() {
	return 7;
};

Sprite_MenuBookMap.prototype.createAllItems = function() {
	let i = 0;
	const regionNameWidth = 120;
	const regionNameTextSize = 24;
	const progressNameWidth = 48;
	const margin = 8;	// 左右间距
	const padding = 12;		// 上下间距
	const progressNameTextSize = 12;
	const progressBitmap = ImageManager.loadUI("menu_map_status_progress_back");
	const progressWidth = progressBitmap.width;
	const allWidth = regionNameWidth + progressNameWidth + progressWidth + margin * 2;
	
	this._progressItemTextBitmap = new Bitmap(progressNameWidth, progressNameTextSize + padding);
	this._progressMapTextBitmap = new Bitmap(progressNameWidth, progressNameTextSize + padding);
	
	this._progressItemTextBitmap.fontSize = this._progressMapTextBitmap.fontSize = progressNameTextSize;
	this._progressItemTextBitmap.textColor = this._progressMapTextBitmap.textColor = "#551717";
	this._progressItemTextBitmap.outlineWidth = this._progressMapTextBitmap.outlineWidth = 0;
	
	const progressOptions = {
		lowerNames:[]
		, upperNames:["menu_map_status_progress_back"]
		, progressName:"menu_map_status_progress"
	};
	
	for(const regionId of $gameSystem.achieveUnlockRegion()) {
		const centerX = this.itemX(i);
		const centerY = this.itemY(i);
		const regionNameBitmap = new Bitmap(regionNameWidth, regionNameTextSize + 4);
		regionNameBitmap.textColor = "#ff9bb7";
		regionNameBitmap.fontSize = regionNameTextSize;
		regionNameBitmap.outlineWidth = 2;
		regionNameBitmap.outlineColor = "#ffffff";
		const regionNameSprite = new Sprite(regionNameBitmap);
		regionNameSprite.anchor.y = 0.5;
		regionNameSprite.x = centerX - allWidth / 2;
		regionNameSprite.y = centerY;
		this._baseSprite.addChild(regionNameSprite);
		
		const itemTextSprite = new Sprite(this._progressItemTextBitmap);
		const mapTextSprite = new Sprite(this._progressMapTextBitmap);
		
		itemTextSprite.anchor.y = 1;
		mapTextSprite.anchor.y = 0;
		
		itemTextSprite.y = mapTextSprite.y = centerY;
		itemTextSprite.x = mapTextSprite.x = regionNameSprite.x + regionNameWidth + margin;
		
		this._baseSprite.addChild(itemTextSprite, mapTextSprite);
		
		const itemProgressSprite = new Sprite_Progress(progressOptions);
		
		const mapProgressSprite = new Sprite_Progress(progressOptions);
		
		const exploreItem = DataManager.getRegionExploreItem(regionId);
		const exploreMap = DataManager.getRegionThumbnailExplore(regionId);
		itemProgressSprite.progress = exploreItem.all === 0 ? 1 : exploreItem.has / exploreItem.all;
		mapProgressSprite.progress = exploreMap.all === 0 ? 1 : exploreMap.has / exploreMap.all;
		itemProgressSprite.x = mapProgressSprite.x = regionNameSprite.x + regionNameWidth + progressNameWidth + margin * 2;
		itemProgressSprite.y = centerY - itemProgressSprite.progressHeight() - padding;
		mapProgressSprite.y = centerY + 2;
		
		this._baseSprite.addChild(itemProgressSprite, mapProgressSprite);
		
		
		i++;
	}
	this.refreshText();
};

Sprite_MenuBookMap.prototype.onLanguageChange = function() {
	Sprite_MenuBookScore.prototype.onLanguageChange.call(this);
	this.refreshText();
};

Sprite_MenuBookMap.prototype.refreshText = function() {
	let i = 0;
	this._progressItemTextBitmap.clear();
	this._progressMapTextBitmap.clear();
	this._progressItemTextBitmap.drawCenterText(TextManager.STATIC_TEXT_MENU_BOOK_ITEM);
	this._progressMapTextBitmap.drawCenterText(TextManager.STATIC_TEXT_MENU_BOOK_MAP);
	for(const regionId of $gameSystem.achieveUnlockRegion()) {
		const regionTextBitmap = this._baseSprite.children[i * 5].bitmap;
		regionTextBitmap.clear();
		regionTextBitmap.drawCenterText($dataRegion[regionId].name);
		i++;
	}
};

Sprite_MenuBookMap.prototype.itemPadding = function() {
	return 18;
};

function Sprite_SplashScreen() {
	this.initialize(...arguments);
}

Sprite_SplashScreen.prototype = Object.create(Sprite.prototype);
Sprite_SplashScreen.prototype.constructor = Sprite_SplashScreen;

Sprite_SplashScreen.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	const hour = new Date().getHours();
	this._isNight = hour >= 18 || hour < 6;
	this.createBackground();
	this.createEdge();
	this.createIcon();
};

Sprite_SplashScreen.prototype.createBackground = function() {
	const graphic = new PIXI.Graphics();
	graphic.beginFill(this._isNight ? 0 : 0xffffff);
	graphic.drawRect(0, 0, Graphics.width, Graphics.height);
	graphic.endFill();
	this.addChild(graphic);
};

Sprite_SplashScreen.prototype.createEdge = function() {
	const edgeLT = new Sprite(ImageManager.loadUI("splash_edge_lt"));
	const edgeRT = new Sprite(ImageManager.loadUI("splash_edge_rt"));
	const edgeLB = new Sprite(ImageManager.loadUI("splash_edge_lb"));
	const edgeRB = new Sprite(ImageManager.loadUI("splash_edge_rb"));
	const edgeT = new Sprite(ImageManager.loadUI("splash_edge_t"));
	const edgeB = new Sprite(ImageManager.loadUI("splash_edge_b"));
	edgeRT.anchor.x = 1;
	edgeRT.x = Graphics.width;
	edgeLB.anchor.y = 1;
	edgeLB.y = Graphics.height;
	edgeRB.anchor.set(1);
	edgeRB.x = Graphics.width;
	edgeRB.y = Graphics.height;
	edgeT.anchor.x = 0.5;
	edgeT.x = Graphics.width / 2;
	edgeB.anchor.x = 0.5;
	edgeB.anchor.y = 1;
	edgeB.x = Graphics.width / 2;
	edgeB.y = Graphics.height;
	this._edgeSprite = new Sprite();
	if(this._isNight) {
		const f = new PIXI.filters.ColorMatrixFilter();
		f.negative();
		this._edgeSprite.filters = [f];
	}
	this._edgeSprite.addChild(edgeLT, edgeRT, edgeLB, edgeRB, edgeT, edgeB);
	this.addChild(this._edgeSprite);
};

Sprite_SplashScreen.prototype.iconTextSize = function() {
	return 32;
};

Sprite_SplashScreen.prototype.createIcon = function() {
	const iconWhiteCat = new Sprite(ImageManager.loadUI("white_cat"));
	const iconCatTail = new Sprite(ImageManager.loadUI("cat_tail"));
	iconWhiteCat.anchor.set(0.5);
	iconCatTail.anchor.set(0.5);
	const padding = 0;
	const colNum = Utils.isLegalMode() ? 3 : 2;
	iconWhiteCat.y = iconCatTail.y = Graphics.height / 2 - this.iconTextSize();
	iconWhiteCat.x = padding + (colNum - 1) * (Graphics.width - padding * colNum) / (colNum + 1);
	iconCatTail.x = padding + colNum * (Graphics.width - padding * colNum) / (colNum + 1);
	
	const textWhiteCatBitmap = new Bitmap(400, this.iconTextSize());
	const textCatTailBitmap = new Bitmap(400, this.iconTextSize());
	textWhiteCatBitmap.outlineWidth = textCatTailBitmap.outlineWidth = 0;
	textWhiteCatBitmap.fontSize = textCatTailBitmap.fontSize = this.iconTextSize();
	textWhiteCatBitmap.textColor = textCatTailBitmap.textColor = this._isNight ? "#ffffff" : "#000000";
	textWhiteCatBitmap.drawCenterText("@赤瞳大白猫");
	textCatTailBitmap.drawCenterText("@猫尾巴制作组");
	const textWhiteCat = new Sprite(textWhiteCatBitmap);
	const textCatTail = new Sprite(textCatTailBitmap);
	textWhiteCat.anchor.set(0.5);
	textCatTail.anchor.set(0.5);
	textWhiteCat.x = iconWhiteCat.x;
	textWhiteCat.y = iconWhiteCat.y + iconWhiteCat.height / 2 + 1.5 * this.iconTextSize();
	textCatTail.x = iconCatTail.x;
	textCatTail.y = textWhiteCat.y;
	this.addChild(iconWhiteCat, iconCatTail, textWhiteCat, textCatTail);
	
	if(Utils.isLegalMode()) {
		const logo4399Sprite = new Sprite(ImageManager.loadUI(this._isNight ? "4399Logon" : "4399Logo"));
		logo4399Sprite.x = padding + (colNum - 2) * (Graphics.width - padding * colNum) / (colNum + 1);
		logo4399Sprite.y = Graphics.height / 2;
		logo4399Sprite.anchor.set(0.5);
		this.addChild(logo4399Sprite);
	}
};

function Sprite_TouchUI() {
	this.initialize(...arguments);
}

Sprite_TouchUI.prototype = Object.create(Sprite.prototype);
Sprite_TouchUI.prototype.constructor = Sprite_TouchUI;

Sprite_TouchUI.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._textOffsetX = options.textOffsetX;
	this._menuButtonOffset = options.menuButtonOffset;
	this._isMenuCalled = false;
	this.createAllItems();
};

Sprite_TouchUI.prototype.createAllItems = function() {
	for(const info of ConfigManager.screenButtons) {
		const name = info.name;
		const x = info.x;
		const y = info.y;
		let sprite = null;
		if(name === "zxc") {
			sprite = new Sprite_ScreenButtonZXC(name);
		} else if(name === "joystick") {
			sprite = new Sprite_ScreenButtonJoyStick(name);
		} else if(name === "consumable") {
			sprite = new Sprite_ScreenButtonConsumable(name);
		} else {
			sprite = new Sprite_ScreenButtonBase(name);
		}
		sprite.x = x;
		sprite.y = y;
		this.addChild(sprite);
	}
	this.createMenuButton();
};

Sprite_TouchUI.prototype.createMenuButton = function() {
	this._menuButton = new Sprite(ImageManager.loadUI("menu_unpressed"));
	this._menuButtonTextSprite = new Sprite(new Bitmap(this._menuButton.width, this._menuButton.height));
	this._menuButtonTextSprite.x = this._textOffsetX + this._menuButton.width / 2;
	this._menuButtonTextSprite.anchor.x = 0.5;
	this._menuButton.addChild(this._menuButtonTextSprite);
	this._menuButton.x = this._menuButtonOffset.x;
	this._menuButton.y = this._menuButtonOffset.y;
	this.addChild(this._menuButton);
	const bitmap = this._menuButtonTextSprite.bitmap;
	bitmap.fontSize = this._textSize;
	bitmap.textColor = this._textColor;
	bitmap.outlineWidth = 0;
	this.refreshMenuButtonText();
};

Sprite_TouchUI.prototype.refreshMenuButtonText = function() {
	const bitmap = this._menuButtonTextSprite.bitmap;
	bitmap.clear();
	bitmap.drawCenterText(TextManager.STATIC_TEXT_MENU);
};

Sprite_TouchUI.prototype.onLanguageChange = function() {
	this.refreshMenuButtonText();
};

Sprite_TouchUI.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateMenuButton();
};

Sprite_TouchUI.prototype.updateMenuButton = function() {
	if(this.visible && TouchInput.isClicked() && this._menuButton.isBeingTouched()) {
		this._isMenuCalled = true;
	} else {
		this._isMenuCalled = false;
	}
	if(TouchInput.isPressed()) {
		if(this._menuButton.isBeingTouched()) {
			this.pressMenuButton();
		} else {
			this.releaseMenuButton();
		}
	} else if(TouchInput.isReleased()) {
		this.releaseMenuButton();
	}
};

Sprite_TouchUI.prototype.pressMenuButton = function() {
	this._menuButton.bitmap = ImageManager.loadUI("menu_pressed");
};

Sprite_TouchUI.prototype.releaseMenuButton = function() {
	this._menuButton.bitmap = ImageManager.loadUI("menu_unpressed");
};

Sprite_TouchUI.prototype.isMenuCalled = function() {
	return this._isMenuCalled;
};

function Sprite_ScreenButtonBase() {
	this.initialize(...arguments);
}

Sprite_ScreenButtonBase.prototype = Object.create(Sprite.prototype);
Sprite_ScreenButtonBase.prototype.constructor = Sprite_ScreenButtonBase;

Sprite_ScreenButtonBase.prototype.initialize = function(buttonName) {
	Sprite.prototype.initialize.call(this);
	this._buttonName = buttonName;
	this.createAllItems();
	this.initButtonScale();
	this.updatePressed();
};

Sprite_ScreenButtonBase.prototype.createAllItems = function() {
	this._pressedSprite = new Sprite();
	const pressed = new Sprite(ImageManager.loadUI(this.pressedName()));
	pressed.anchor.set(0.5);
	this._pressedSprite.addChild(pressed);
	
	this._unpressedSprite = new Sprite();
	const unpressed = new Sprite(ImageManager.loadUI(this.unpressedName()));
	unpressed.anchor.set(0.5);
	this._unpressedSprite.addChild(unpressed);
	
	this._unpressedSprite.alpha = 0.5;
	this._iconSprite = new Sprite(ImageManager.loadUI(this._buttonName));
	this._iconSprite.anchor.set(0.5);
	this._baseSprite = new Sprite();
	this._baseSprite.addChild(this._pressedSprite, this._unpressedSprite, this._iconSprite);
	this.addChild(this._baseSprite);
};

Sprite_ScreenButtonBase.prototype.initButtonScale = function() {
	for(const buttonInfo of ConfigManager.screenButtons) {
		if(buttonInfo.name === this._buttonName) {
			this._baseSprite.scale.set((buttonInfo.scale || 1));
			break;
		}
	}
};

Sprite_ScreenButtonBase.prototype.pressedName = function() {
	return "screen_button_pressed";
};

Sprite_ScreenButtonBase.prototype.unpressedName = function() {
	return "screen_button_unpressed";
};

Sprite_ScreenButtonBase.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updatePressed();
};

Sprite_ScreenButtonBase.prototype.updatePressed = function() {
	this.doPress(TouchInput.isScreenButtonPressed(this._buttonName));
};

Sprite_ScreenButtonBase.prototype.doPress = function(val) {
	this._pressedSprite.visible = val;
	this._unpressedSprite.visible = !val;
};

function Sprite_ScreenButtonJoyStick() {
	this.initialize(...arguments);
}

Sprite_ScreenButtonJoyStick.prototype = Object.create(Sprite_ScreenButtonBase.prototype);
Sprite_ScreenButtonJoyStick.prototype.constructor = Sprite_ScreenButtonJoyStick;

Sprite_ScreenButtonJoyStick.prototype.initialize = function() {
	Sprite_ScreenButtonBase.prototype.initialize.apply(this, arguments);
	this.initJoystickFixedPosition();
};

Sprite_ScreenButtonJoyStick.prototype.initJoystickFixedPosition = function() {
	if($gamePlayer.isInteractSignClicked()) {
		for(const buttonInfo of ConfigManager.screenButtons) {
			if(buttonInfo.name === this._buttonName) {
				this.x = buttonInfo.x;
				this.y = buttonInfo.y;
				break;
			}
		}
	}
};

Sprite_ScreenButtonJoyStick.prototype.pressedName = function() {
	return "joystick_pressed";
};

Sprite_ScreenButtonJoyStick.prototype.unpressedName = function() {
	return "joystick_unpressed";
};

Sprite_ScreenButtonJoyStick.prototype.updatePressed = function() {
	const touch = TouchInput.getJoystickButtonPressed();
	this.doPress(!!touch);
	this.updateCursor(touch);
};

Sprite_ScreenButtonJoyStick.prototype.updateCursor = function(touch) {
	if(touch && !$gamePlayer.isInteractSignClicked()) {
		if(!ConfigManager.isFixedJoystick) {
			this.x = TouchInput._joystickPressX;
			this.y = TouchInput._joystickPressY;
		}
		const tx = this.x;
		const ty = this.y;
		const sx = touch.x;
		const sy = touch.y;
		const maxRadius = this._unpressedSprite.children[0].width / 2;
		const distanceRate = Math.sqrt(Math.pow(sx - tx, 2) + Math.pow(sy - ty, 2)) / maxRadius;
		if(distanceRate > 1) {
			this._iconSprite.x = (sx - tx) / distanceRate;
			this._iconSprite.y = (sy - ty) / distanceRate;
		} else {
			this._iconSprite.x = (sx - tx) * distanceRate;
			this._iconSprite.y = (sy - ty) * distanceRate;
		}
		this.alpha = 1;
	} else {
		this._iconSprite.x = this._iconSprite.y = 0;
		this.alpha = 0;
	}
};

function Sprite_ScreenButtonZXC() {
	this.initialize(...arguments);
}

Sprite_ScreenButtonZXC.prototype = Object.create(Sprite_ScreenButtonBase.prototype);
Sprite_ScreenButtonZXC.prototype.constructor = Sprite_ScreenButtonZXC;

Sprite_ScreenButtonZXC.prototype.initialize = function() {
	Sprite_ScreenButtonBase.prototype.initialize.apply(this, arguments);
};

Sprite_ScreenButtonZXC.prototype.createAllItems = function() {
	Sprite_ScreenButtonBase.prototype.createAllItems.call(this);
	this.initEnergyItems();
};

Sprite_ScreenButtonZXC.prototype.initEnergyItems = function() {
	const pressed = new Sprite(ImageManager.loadUI("screen_button_pressed2"));
	const unpressed = new Sprite(ImageManager.loadUI("screen_button_unpressed2"));
	pressed.anchor.set(0.5);
	unpressed.anchor.set(0.5);
	this._pressedSprite.addChild(pressed);
	this._unpressedSprite.addChild(unpressed);
	
	this._progressSprite = new Sprite(ImageManager.loadUI("screen_button_progress"));
	this._progressSprite.x = -this._progressSprite.bitmap.width / 2;
	this._progressSprite.y = -this._progressSprite.bitmap.height / 2;
	this._energySprite = new Sprite();
	const childNum = 2;
	for(let i = 0; i < childNum; i++) {
		const child = new Sprite(ImageManager.loadUI("screen_button_energy"));
		this._energySprite.addChild(child);
		child.anchor.set(0.5);
		child.rotation = Math.PI * 2 * i / childNum;
		child.blendMode = PIXI.BLEND_MODES.ADD;
	}
	this._baseSprite.addChild(this._progressSprite, this._energySprite);
	this.updateEnergy();
};

Sprite_ScreenButtonZXC.prototype.update = function() {
	Sprite_ScreenButtonBase.prototype.update.call(this);
	this.updateEnergy();
};

Sprite_ScreenButtonZXC.prototype.updateEnergy = function() {
	const battleObject = $gamePlayer.battleObject();
	const progress = (1 - battleObject.zp / battleObject.mzp);
	this._progressSprite.height = Math.round(this._progressSprite.bitmap.height * progress);
	if($gamePlayer.isZPEnoughForZXC()) {
		if(!this._energySprite.visible) {
			this._energySprite.visible = true;
		} 
		this.updateEnergyEffect();
	} else if(this._energySprite.visible) {
		this._energySprite.visible = false;
	}
	
	this._pressedSprite.children[0].visible = this._unpressedSprite.children[0].visible = !this._energySprite.visible;
	this._pressedSprite.children[1].visible = this._unpressedSprite.children[1].visible = this._energySprite.visible;
};

Sprite_ScreenButtonZXC.prototype.updateEnergyEffect = function() {
	for(const child of this._energySprite.children) {
		child.rotation += 0.06;
	}
};

Sprite_ScreenButtonZXC.prototype.doPress = function(val) {
	Sprite_ScreenButtonBase.prototype.doPress.apply(this, arguments);
	this._progressSprite.visible = !val;
	this._energySprite.alpha = val ? 1 : 0.5;
};

function Sprite_ScreenButtonConsumable() {
	this.initialize(...arguments);
}

Sprite_ScreenButtonConsumable.prototype = Object.create(Sprite_ScreenButtonBase.prototype);
Sprite_ScreenButtonConsumable.prototype.constructor = Sprite_ScreenButtonConsumable;

Sprite_ScreenButtonConsumable.prototype.update = function() {
	Sprite_ScreenButtonBase.prototype.update.call(this);
	this.updateHasConsumable();
};

Sprite_ScreenButtonConsumable.prototype.updateHasConsumable = function() {
	if($gamePlayer.actor().hasAnyConsumable()) {
		this._baseSprite.alpha = 1;
	} else {
		this._baseSprite.alpha = 0.35;
	}
};

function Sprite_ScreenButtonForConfig() {
	this.initialize(...arguments);
}

Sprite_ScreenButtonForConfig.prototype = Object.create(Sprite_ScreenButtonBase.prototype);
Sprite_ScreenButtonForConfig.prototype.constructor = Sprite_ScreenButtonForConfig;

Sprite_ScreenButtonForConfig.prototype.initialize = function() {
	Sprite_ScreenButtonBase.prototype.initialize.apply(this, arguments);
	this._isDragging = false;
	this._isScaling = false;
	this._dragStartX = 0;
	this._dragStartY = 0;
	this._rad = 0;
	this._scaleStartRadius = 0;
	this._scaleTouchStartRadius = 0;
	this.checkCollision = null;
};

Sprite_ScreenButtonForConfig.prototype.updatePressed = function() {
};

Sprite_ScreenButtonForConfig.prototype.updateDrag = function() {
	if(TouchInput.isDoublePressed()) {
		this._isDragging = false;
		if(!this._isScaling && TouchInput.isFirstPressedInCirCle(this.x, this.y, this._rad)) {
			this._isScaling = true;
			this._scaleStartRadius = this._rad;
			this._scaleTouchStartRadius = TouchInput.doublePressedDistance();
		} else if(this._isScaling) {
			const fallbackRadius = this._rad;
			this._rad = TouchInput.doublePressedDistance() - this._scaleTouchStartRadius + this._scaleStartRadius;
			if(this.checkCollision()) {
				this._rad = fallbackRadius;
			} else {
				this.refreshRadius();
			}
		}
	} else {
		this._isScaling = false;
		if(TouchInput.isPressed()) {
			const pressed = this._pressedSprite.children[0].isBeingTouched() || this._unpressedSprite.children[0].isBeingTouched();
			this.doPress(pressed);
		} else if(TouchInput.isReleased()) {
			this.doPress(false);
		}
		if(this._pressedSprite.visible && TouchInput.isTriggered() && !this._isDragging) {
			this._dragStartX = this.x;
			this._dragStartY = this.y;
			this._isDragging = true;
		} else if(TouchInput.isPressed() && this._isDragging) {
			const fallBackX = this.x;
			const fallBackY = this.y;
			this.x = this._dragStartX + TouchInput.moveDeltaX;
			this.y = this._dragStartY + TouchInput.moveDeltaY;
			if(this.checkCollision()) {
				this.x = fallBackX;
				this.y = fallBackY;
			}
		} else {
			this._isDragging = false;
		}
	}
};

Sprite_ScreenButtonForConfig.prototype.syncConfig = function() {
	for(const info of ConfigManager.screenButtons) {
		if(info.name === this._buttonName) {
			this.x = info.x;
			this.y = info.y;
			this._rad = info.rad;
			this.refreshRadius();
			break;
		}
	}
};

Sprite_ScreenButtonForConfig.prototype.applyChange = function() {
	for(const info of ConfigManager.screenButtons) {
		if(info.name === this._buttonName) {
			info.x = this.x;
			info.y = this.y;
			info.rad = this._rad;
			break;
		}
	}
};

Sprite_ScreenButtonForConfig.prototype.createAllItems = function() {
	this._radiusGraphics = new PIXI.Graphics();
	this._radiusGraphics.alpha = 0.4;
	this.addChild(this._radiusGraphics);
	Sprite_ScreenButtonBase.prototype.createAllItems.call(this);
	this._unpressedSprite.alpha = 1;
};

Sprite_ScreenButtonForConfig.prototype.setRadius = function(radius) {
	this._rad = radius;
	this.refreshRadius();
};

Sprite_ScreenButtonForConfig.prototype.refreshRadius = function() {
	this._radiusGraphics.clear();
	this._radiusGraphics.beginFill(0xffffff);
	this._radiusGraphics.drawCircle(0, 0, this._rad);
	this._radiusGraphics.endFill();
};

function Sprite_ScreenButtonConfig() {
	this.initialize(...arguments);
}

Sprite_ScreenButtonConfig.prototype = Object.create(Sprite.prototype);
Sprite_ScreenButtonConfig.prototype.constructor = Sprite_ScreenButtonConfig;

Sprite_ScreenButtonConfig.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._limitStartY = options.limitStartY;
	this._backName = options.backName;
	this._limitTipsBackName = options.limitTipsBackName;
	this._textColor = options.textColor;
	this._textSize = options.textSize;
	this._buttonSelectedName = options.buttonSelectedName;
	this._buttonUnselectedName = options.buttonUnselectedName;
	this._buttonOffset = options.buttonOffset;
	this._buttonPadding = options.buttonPadding;
	this._cancelButtonOffset = options.cancelButtonOffset;
	this.pressOk = null;
	this.pressCancel = null;
	this.createBackground();
	this.createLimitAreaTips();
	this.createButtons();
	this.createCancelButton();
	this.createScreenButtons();
};

Sprite_ScreenButtonConfig.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
	this._backSprite.anchor.set(0.5);
	this._backSprite.x = Graphics.width / 2;
	this._backSprite.y = Graphics.height / 2;
};

Sprite_ScreenButtonConfig.prototype.createLimitAreaTips = function() {
	const textSprite = new Sprite();
	this._tipsSprite = new Sprite(ImageManager.loadUI(this._limitTipsBackName));
	this._tipsSprite.addChild(textSprite);
	this.addChild(this._tipsSprite);
	textSprite.anchor.y = this._tipsSprite.anchor.y = 1;
	textSprite.anchor.x = this._tipsSprite.anchor.x = 0.5;
	
	this._tipsSprite.x = Graphics.width / 2;
	this._tipsSprite.y = this._limitStartY;
	this._tipsBitmap = new Bitmap(this._tipsSprite.width, this._tipsSprite.height);
	textSprite.bitmap = this._tipsBitmap;
	this._tipsBitmap.textColor = this._textColor;
	this._tipsBitmap.fontSize = this._textSize;
	this._tipsBitmap.outlineWidth = 0;
	this.refreshTipsText();
};

Sprite_ScreenButtonConfig.prototype.refreshTipsText = function() {
	this._tipsBitmap.clear();
	this._tipsBitmap.drawCenterText(TextManager.STATIC_TEXT_SCREEN_BUTTON_LIMIT_TIPS);
};

Sprite_ScreenButtonConfig.prototype.onLanguageChange = function() {
	this.refreshTipsText();
	this.refreshButtonText();
};

Sprite_ScreenButtonConfig.prototype.createButtons = function() {
	this._okButton = new Sprite_SimpleButton({
		selectName:this._buttonSelectedName
		, unselectName:this._buttonUnselectedName
		, textSize:this._textSize
		, textColor:this._textColor
		, textKey:"STATIC_TEXT_APPLY"
	});
	this._resetButton = new Sprite_SimpleButton({
		selectName:this._buttonSelectedName
		, unselectName:this._buttonUnselectedName
		, textSize:this._textSize
		, textColor:this._textColor
		, textKey:"STATIC_TEXT_RESET"
	});
	this._okButton.x = this._buttonOffset.x;
	this._okButton.y = this._buttonOffset.y;
	this._resetButton.x = this._buttonOffset.x;
	this._resetButton.y = this._buttonOffset.y + this._okButton.allHeight() + this._buttonPadding;
	this.addChild(this._okButton, this._resetButton);
};

Sprite_ScreenButtonConfig.prototype.refreshButtonText = function() {
	this._okButton.refreshText();
	this._resetButton.refreshText();
};

Sprite_ScreenButtonConfig.prototype.createCancelButton = function() {
	this._cancelSprite = new Sprite(ImageManager.loadUI("cancel"));
	this._cancelSprite.x = this._cancelButtonOffset.x;
	this._cancelSprite.y = this._cancelButtonOffset.y;
	this._cancelSprite.anchor.set(0.5);
	this.addChild(this._cancelSprite);
};

Sprite_ScreenButtonConfig.prototype.createScreenButtons = function() {
	this._screenButtonSprite = new Sprite();
	this.addChild(this._screenButtonSprite);
	for(const info of ConfigManager.screenButtons) {
		const name = info.name;
		const x = info.x;
		const y = info.y;
		const sprite = new Sprite_ScreenButtonForConfig(name);
		sprite.x = x;
		sprite.y = y;
		sprite.checkCollision = this.checkCollision.bind(this);
		sprite.setRadius(info.rad);
		this._screenButtonSprite.addChild(sprite);
	}
};

Sprite_ScreenButtonConfig.prototype.update = function() {
	Sprite.prototype.update.call(this);
	if(this.visible) {
		this.updateCancelButton();
		this.updateButtons();
		this.updateScreenButtons();
	}
};

Sprite_ScreenButtonConfig.prototype.updateCancelButton = function() {
	if(TouchInput.isClicked() && this._cancelSprite.isBeingTouched()) {
		SoundManager.playCancel();
		this.pressCancel();
	}
	if(TouchInput.isPressed()) {
		if(this._cancelSprite.isBeingTouched()) {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel_press");
		} else {
			this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
		}
	} else if(TouchInput.isReleased()) {
		this._cancelSprite.bitmap = ImageManager.loadUI("cancel");
	}
};

Sprite_ScreenButtonConfig.prototype.updateButtons = function() {
	if(TouchInput.isClicked() || TouchInput.isMoved()) {
		if(this._okButton.isBeingTouched()) {
			this._okButton.select(true);
			this._resetButton.select(false);
			if(TouchInput.isClicked()) {
				SoundManager.playOk();
				this.pressOk();
			}
			return;
		}
		if(this._resetButton.isBeingTouched()) {
			this._okButton.select(false);
			this._resetButton.select(true);
			if(TouchInput.isClicked()) {
				SoundManager.playOk();
				ConfigManager.resetScreenButtons();
				this.syncConfig();
			}
			return;
		}
	}
};

Sprite_ScreenButtonConfig.prototype.updateScreenButtons = function() {
	for(const child of this._screenButtonSprite.children) {
		child.updateDrag();
	}
};

// 贴图中的位置输出到配置位置
Sprite_ScreenButtonConfig.prototype.applyChange = function() {
	for(const child of this._screenButtonSprite.children) {
		child.applyChange();
	}
};

// 配置中的位置输出到贴图位置
Sprite_ScreenButtonConfig.prototype.syncConfig = function() {
	for(const child of this._screenButtonSprite.children) {
		child.syncConfig();
	}
};

// 检查5个按键是否发生碰撞
Sprite_ScreenButtonConfig.prototype.checkCollision = function() {
	for(let i = 0; i < this._screenButtonSprite.children.length; i++) {
		const sprite1 = this._screenButtonSprite.children[i];
		const x1 = sprite1.x;
		const y1 = sprite1.y;
		const r1 = sprite1._rad;
		for(let j = i + 1; j < this._screenButtonSprite.children.length; j++) {
			const sprite2 = this._screenButtonSprite.children[j];
			const x2 = sprite2.x;
			const y2 = sprite2.y;
			const r2 = sprite2._rad;
			if(this.checkCircleCollision(x1, y1, r1, x2, y2, r2)) {
				return true;
			}
		}
	}
	return false;
};

Sprite_ScreenButtonConfig.prototype.checkCircleCollision = function(x1, y1, r1, x2, y2, r2) {
	return $gameMap.pixelDistance(x1, y1, x2, y2) <= (r1 + r2);
};

function Sprite_SimpleButton() {
	this.initialize(...arguments);
}

Sprite_SimpleButton.prototype = Object.create(Sprite.prototype);
Sprite_SimpleButton.prototype.constructor = Sprite_SimpleButton;

Sprite_SimpleButton.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._selectName = options.selectName;
	this._unselectName = options.unselectName;
	this._textKey = options.textKey;
	this._textColor = options.textColor;
	this._textSize = options.textSize;
	this.createAllItems();
	this.select(false);
};

Sprite_SimpleButton.prototype.createAllItems = function() {
	this.selected = new Sprite(ImageManager.loadUI(this._selectName));
	this.unselected = new Sprite(ImageManager.loadUI(this._unselectName));
	this.textSprite = new Sprite(new Bitmap(this.selected.width, this.selected.height));
	this.selected.anchor.set(0.5);
	this.unselected.anchor.set(0.5);
	this.textSprite.anchor.set(0.5);
	this.addChild(this.selected, this.unselected, this.textSprite);
	
	const bitmap = this.textSprite.bitmap;
	bitmap.textColor = this._textColor;
	bitmap.fontSize = this._textSize;
	bitmap.outlineWidth = 0;
	this.refreshText();
};

Sprite_SimpleButton.prototype.refreshText = function() {
	const bitmap = this.textSprite.bitmap;
	bitmap.clear();
	bitmap.drawCenterText(TextManager[this._textKey]);
};

Sprite_SimpleButton.prototype.isBeingTouched = function() {
	return this.selected.isBeingTouched() || this.unselected.isBeingTouched();
};

Sprite_SimpleButton.prototype.select = function(val) {
	this.selected.visible = val;
	this.unselected.visible = !val;
};

Sprite_SimpleButton.prototype.allHeight = function() {
	return this.selected.height;
};

function Sprite_GuideScreenButton() {
	this.initialize(...arguments);
}

Sprite_GuideScreenButton.prototype = Object.create(Sprite_GuideButtonBase.prototype);
Sprite_GuideScreenButton.prototype.constructor = Sprite_GuideScreenButton;

Sprite_GuideScreenButton.prototype.initialize = function(buttonName) {
	Sprite_GuideButtonBase.prototype.initialize.call(this);
	this._buttonName = buttonName;
	this.createAllItems();
};

Sprite_GuideScreenButton.prototype.createAllItems = function() {
	this.bitmap = ImageManager.loadUI(this.pressedName());
	this._iconSprite = new Sprite(ImageManager.loadUI(this._buttonName));
	this._iconSprite.anchor.y = 0.5;
	this._iconSprite.x = (this.width - this._iconSprite.width) / 2;
	this.scale.set(0.5);
	this.addChild(this._iconSprite);
};

Sprite_GuideScreenButton.prototype.pressedName = Sprite_ScreenButtonBase.prototype.pressedName;

Sprite_GuideScreenButton.prototype.checkButtonPressed = function() {
	return TouchInput.isScreenButtonTriggered(this._buttonName);
};

Sprite_GuideScreenButton.prototype.allWidth = function() {
	return this.width * this.scale.x;
};


function Sprite_WeaponChanging() {
	this.initialize(...arguments);
}

Sprite_WeaponChanging.prototype = Object.create(Sprite.prototype);
Sprite_WeaponChanging.prototype.constructor = Sprite_WeaponChanging;

Sprite_WeaponChanging.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this._currentWeapon = $gamePlayer.actor().currentWeapon();
	this.alpha = 0;
	this._animation = new AnimationController();
	this.createBackground();
	this.createIcon();
};

Sprite_WeaponChanging.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI("map_player_status_back"));
	this.addChild(this._backSprite);
	this._backSprite.anchor.set(0.5);
};

Sprite_WeaponChanging.prototype.createIcon = function() {
	this._iconSprite = new Sprite_ItemIcon("weapons", this._currentWeapon);
	this.addChild(this._iconSprite);
	this._iconSprite.anchor.set(0.5);
};

Sprite_WeaponChanging.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._animation.update();
	this.updateChange();
	if(this.alpha > 0) {
		this.updatePosition();
	}
};

Sprite_WeaponChanging.prototype.updateChange = function() {
	if($gamePlayer.pollWeaponChange()) {
		this._currentWeapon = $gamePlayer.actor().currentWeapon();
		this.startAlphaAnimation();
		this._iconSprite.refreshIdx(this._currentWeapon);
	}
};

Sprite_WeaponChanging.prototype.startAlphaAnimation = function() {
	this.alpha = 1;
	const controller = this._animation;
	controller.clear(this);
	controller.add(this, {data:[{
		to:0, property:'alpha', duration:60, easingType:"linear", delay:100
	}]});
};

Sprite_WeaponChanging.prototype.updatePosition = function() {
	this.x = -$gameMap.displayX() * $gameMap.tileWidth() + $gamePlayer.px;
	this.y = -$gameMap.displayY() * $gameMap.tileHeight() + $gamePlayer.py + this._backSprite.height / 2 + 12;
};


function Sprite_AutoSave() {
	this.initialize(...arguments);
}

Sprite_AutoSave.prototype = Object.create(Sprite.prototype);
Sprite_AutoSave.prototype.constructor = Sprite_AutoSave;

Sprite_AutoSave.prototype.initialize = function() {
	Sprite.prototype.initialize.call(this);
	this._animation = new AnimationController();
	this.createBackground();
	this.createCat();
	this.createSaveText();
	this.alpha = 0;
	this.showNextFrame = false;
};

Sprite_AutoSave.prototype.createBackground = function() {
	this._background = new Sprite_KeyFrameAnimation("autosave_back", 4, "img/ui/", 10);
	this._background.anchor.set(0.5);
	this._background.scale.set(0.3);
	this._background.y = -32;
	this._background.adjustAnchor();
	this.addChild(this._background);
};

Sprite_AutoSave.prototype.createCat = function() {
	this._cat = new Sprite(ImageManager.loadUI("autosave_cat"));
	this._animation.add(this._cat, {data:[{
		from:0, to:Math.PI*2, property:'rotation', duration:30, easingType:"linear"
	}], loop:true});
	this._cat.anchor.set(0.5);
	this.addChild(this._cat);
};

Sprite_AutoSave.prototype.createSaveText = function() {
	this._saveText = new Sprite(ImageManager.loadUI("autosave_text"));
	this.addChild(this._saveText);
	this._saveText.anchor.set(0.5);
	this._saveText.y = 64;
};

Sprite_AutoSave.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.checkPopup();
	if(this.alpha > 0) {
		this._animation.update();
	}
};

Sprite_AutoSave.prototype.checkPopup = function() {
	if(this.showNextFrame) {
		this.showNextFrame = false;
		this.alpha = 1;
		const controller = this._animation;
		controller.clear(this);
		controller.add(this, {data:[{
			to:0, property:"alpha", easingType:"linear", duration:24, delay:55
		}]});
	}
	if(DataManager.pollAutoSaveRequest()) {
		this.showNextFrame = true;
	}
};

function Sprite_SkipStory() {
	this.initialize(...arguments);
}

Sprite_SkipStory.prototype = Object.create(Sprite.prototype);
Sprite_SkipStory.prototype.constructor = Sprite_SkipStory;

Sprite_SkipStory.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._buttonName = options.buttonName;
	this._buttonOffset = options.buttonOffset;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._signName = options.signName;
	this._buttonDownName = options.buttonDownName;
	this._buttonTextOffsetY = options.buttonTextOffsetY;
	this._hideHeight = options.hideHeight;
	this._signOffset = options.signOffset;
	this._inputMode = "";
	this._show = false;
	this._animation = new AnimationController();
	this.createButton();
	this.createSkipSign();
	this.updateButtonName();
	this.updateVisible();
};

Sprite_SkipStory.prototype.createButton = function() {
	this._button = new Sprite(ImageManager.loadUI(this._buttonName));
	this._buttonNameBitmap = new Bitmap(this._button.width, this._button.height);
	this._buttonNameBitmap.textColor = this._textColor;
	this._buttonNameBitmap.fontSize = this._textSize;
	this._buttonNameBitmap.outlineWidth = 0;
	this._textSprite = new Sprite(this._buttonNameBitmap);
	this._textSprite.y = this._buttonTextOffsetY + this._button.height / 2;
	this._textSprite.x = this._button.width / 2;
	this._textSprite.anchor.set(0.5);
	this._button.addChild(this._textSprite);
	this.addChild(this._button);
	this._button.x = this._buttonOffset.x;
	this._button.y = this._buttonOffset.y;
};

Sprite_SkipStory.prototype.createSkipSign = function() {
	this._skipSign = new Sprite(ImageManager.loadUI(this._signName));
	this.addChild(this._skipSign);
	this.y = -this._hideHeight;
	this._skipSign.x = this._signOffset.x;
	this._skipSign.y = this._signOffset.y;
};

Sprite_SkipStory.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this.updateVisible();
	this.updateButtonName();
	this._animation.update();
};

Sprite_SkipStory.prototype.updateVisible = function() {
	const visible = $gameMessage.canUseSkipMode();
	this.updateTouchInput(visible);
	if(this._show !== visible) {
		this._show = visible;
		const controller = this._animation;
		controller.clear(this);
		if(visible) {
			controller.add(this, {data:[{
				to:0, property:"y", easingType:"easeOutQuart", duration:12
			}]});
		} else {
			controller.add(this, {data:[{
				to:-53, property:"y", easingType:"easeOutQuart", duration:18
			}]});
		}
	}
};

Sprite_SkipStory.prototype.updateButtonName = function() {
	if(this._inputMode !== Input.mode()) {
		this._buttonNameBitmap.clear();
		this._buttonNameBitmap.drawCenterText(ConfigManager.getInputName("menu"));
		if(Utils.isMobileDeviceTouchMode()) {
			this._skipSign.visible = false;
			this._textSprite.bitmap = ImageManager.loadUI(this._signName);
		} else {
			this._skipSign.visible = true;
			this._textSprite.bitmap = this._buttonNameBitmap;
		}		
		this._inputMode = Input.mode();
	}
};

Sprite_SkipStory.prototype.updateTouchInput = function(canUse) {
	if(canUse) {
		if(TouchInput.isPressed() && this._button.isBeingTouched()) {
			this._button.bitmap = ImageManager.loadUI(this._buttonDownName);
			this._textSprite.y = this._buttonTextOffsetY + this._button.height / 2 + 4;
		} else if(TouchInput.isReleased()) {
			if(this._button.isBeingTouched()) {
				$gameMessage.updateSkipMode(true);
			}
			this._textSprite.y = this._buttonTextOffsetY + this._button.height / 2;
			this._button.bitmap = ImageManager.loadUI(this._buttonName);
		}
	}
};

function Sprite_Bell() {
	this.initialize(...arguments);
}

Sprite_Bell.prototype = Object.create(Sprite.prototype);
Sprite_Bell.prototype.constructor = Sprite_Bell;

Sprite_Bell.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._unselectName = options.unselectName;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	this._textOffset = options.textOffset;
	this._iconOffset = options.iconOffset;
	this.createBackground();
	this.createIcon();
	this.createText();
};

Sprite_Bell.prototype.unselect = function() {
	this._background.bitmap = ImageManager.loadUI(this._unselectName);
};

Sprite_Bell.prototype.createBackground = function() {
	this._background = new Sprite(ImageManager.loadUI(this._unselectName));
	this._background.anchor.y = 0.5;
	this.addChild(this._background);
};

Sprite_Bell.prototype.createIcon = function() {
	this._icon = new Sprite_ItemIcon("bell", 0);
	this._icon.anchor.y = 0.5;
	this._icon.x = this._iconOffset.x;
	this._icon.y = this._iconOffset.y;
	this.addChild(this._icon);
};

Sprite_Bell.prototype.createText = function() {
	this._textBitmap = new Bitmap(this._background.width, this._background.height);
	this._textBitmap.fontSize = this._textSize;
	this._textBitmap.textColor = this._textColor;
	this._textBitmap.outlineWidth = 0;
	this._textSprite = new Sprite(this._textBitmap);
	this._textSprite.anchor.y = 0.5;
	this._textSprite.x = this._textOffset.x;
	this._textSprite.y = this._textOffset.y;
	this.addChild(this._textSprite);
	
	this._textBitmap.drawCenterText($gamePlayer.actor().bellNum());
};


function Window_ShopConfirm() {
	this.initialize(...arguments);
}

Window_ShopConfirm.prototype = Object.create(Window_Confirm.prototype);
Window_ShopConfirm.prototype.constructor = Window_ShopConfirm;

Window_ShopConfirm.prototype.initialize = function(item) {
	const width = 582;
	const height = 350;
	Window_Confirm.prototype.initialize.call(this, {x:(Graphics.width - width) / 2,y:(Graphics.height - height) / 2,width:width,height:height}, "STATIC_TEXT_SHOP_CONFIRM", {defaultSelected:"yes", canEscape:true});
	this._item = item;
	this._purchaseNum = 0;
	this.createItemInfo();
};

Window_ShopConfirm.prototype.contentExpandY = function() {
	return 32;
};

Window_ShopConfirm.prototype.createItemInfo = function() {
	const background = new Sprite(ImageManager.loadUI("shop_confirm_item_back"));
	background.anchor.set(0.5);
	background.x = this.innerWidth / 2;
	background.y = this.innerHeight / 2;
	const itemBack = new Sprite(ImageManager.loadUI("shop_confirm_icon_back"));
	itemBack.anchor.y = 0.5;
	itemBack.y = background.y;
	itemBack.x = (this.innerWidth - background.width) / 2 + 6;
	this.itemIcon = new Sprite_ItemIcon(this._item.type, this._item.idx);
	this.itemIcon.anchor.set(0.5);
	this.itemIcon.x = itemBack.width / 2;
	itemBack.addChild(this.itemIcon);
	this._contentsSprite.addChild(background, itemBack);
	
	this.subButton = new Sprite();
	this.subButton.y = background.y;
	this.subButton.x = 300;
	this.subButton.selectSprite = new Sprite(ImageManager.loadUI("shop_confirm_select"));
	this.subButton.selectSprite.anchor.y = 0.5;
	this.subButton.unselectSprite = new Sprite(ImageManager.loadUI("shop_confirm_unselect"));
	this.subButton.unselectSprite.anchor.y = 0.5;
	const signSub = new Sprite(ImageManager.loadUI("shop_confirm_sub"));
	signSub.anchor.set(0.5);
	signSub.x = this.subButton.selectSprite.width / 2;
	this.subButton.addChild(this.subButton.selectSprite, this.subButton.unselectSprite, signSub);	// TODO 减号图案
	this.subButton.selectSprite.visible = false;
	
	this.addButton = new Sprite();
	this.addButton.y = this.subButton.y;
	this.addButton.x = 462;
	this.addButton.selectSprite = new Sprite(ImageManager.loadUI("shop_confirm_select"));
	this.addButton.selectSprite.anchor.y = 0.5;
	this.addButton.unselectSprite = new Sprite(ImageManager.loadUI("shop_confirm_unselect"));
	this.addButton.unselectSprite.anchor.y = 0.5;
	const signAdd = new Sprite(ImageManager.loadUI("shop_confirm_add"));
	signAdd.anchor.set(0.5);
	signAdd.x = this.addButton.selectSprite.width / 2;
	this.addButton.addChild(this.addButton.selectSprite, this.addButton.unselectSprite, signAdd);	// TODO 加号图案
	this.addButton.unselectSprite.visible = false;
		
	this._contentsSprite.addChild(this.subButton, this.addButton);
	
	this.textBitmap = new Bitmap(234, background.height);
	const textSprite = new Sprite(this.textBitmap);
	textSprite.anchor.set(0.5);
	textSprite.x = background.x - 80;
	textSprite.y = background.y;
	
	this.numberBitmap = new Bitmap(66, background.height);
	const numberSprite = new Sprite(this.numberBitmap);
	numberSprite.anchor.set(0.5);
	numberSprite.x = background.x + 134;
	numberSprite.y = background.y;
	
	this.textBitmap.textColor = this.numberBitmap.textColor = "#551717";
	this.textBitmap.outlineWidth = this.numberBitmap.outlineWidth = 0;
	this.textBitmap.fontSize = this.numberBitmap.fontSize = 18;
	
	this._contentsSprite.addChild(numberSprite, textSprite);
	
	this.resetItemData();
};

Window_ShopConfirm.prototype.resetItemData = function(data) {
	const newData = data || this._item;
	this._item = newData;
	this._purchaseNum = 1;
	this.updateItemName();
	this.updateItemNum();
	this.resetDefaultSelect();
	this.itemIcon.refreshAll(newData.type, newData.idx);
};

Window_ShopConfirm.prototype.updateItemName = function() {
	const itemData = $gamePlayer.actor().itemData(this._item);
	this.textBitmap.clear();
	this.textBitmap.drawCenterText(itemData.name);
};

Window_ShopConfirm.prototype.updateItemNum = function() {
	this.numberBitmap.clear();
	this.numberBitmap.drawCenterText(this._purchaseNum);
};

Window_ShopConfirm.prototype.onLanguageChange = function() {
	Window_Confirm.prototype.onLanguageChange.call(this);
	this.updateItemName();
};

Window_ShopConfirm.prototype.updateInput = function() {
	Window_Confirm.prototype.updateInput.call(this);
	if(Input.isUITriggered("up")) {
		SoundManager.playCursor();
		this.addItemNum(1);
		this.selectAdd();
	} else if(Input.isUITriggered("down")) {
		SoundManager.playCursor();
		this.addItemNum(-1);
		this.selectSub();
	}
};

Window_ShopConfirm.prototype.addItemNum = function(n) {
	const maxNum = this._item.itemNum;
	const minNum = 1;
	const old = this._purchaseNum;
	this._purchaseNum += n;
	this._purchaseNum = this._purchaseNum.clamp(1, maxNum);
	if(this._purchaseNum !== old) {
		this.updateItemNum();
	}
};

Window_ShopConfirm.prototype.selectAdd = function(reverse = false) {
	this.addButton.selectSprite.visible = this.subButton.unselectSprite.visible = !reverse;
	this.subButton.selectSprite.visible = this.addButton.unselectSprite.visible = !!reverse;
};

Window_ShopConfirm.prototype.selectSub = function() {
	this.selectAdd(true);
};

Window_ShopConfirm.prototype.purchaseNum = function() {
	return this._purchaseNum;
};

Window_ShopConfirm.prototype.updateTouchInput = function() {
	Window_Confirm.prototype.updateTouchInput.call(this);
	if(TouchInput.isPressed()) {
		if(this.addButton.selectSprite.isBeingTouched() || this.addButton.unselectSprite.isBeingTouched()) {
			this.selectAdd();
		}
		if(this.subButton.selectSprite.isBeingTouched() || this.subButton.unselectSprite.isBeingTouched()) {
			this.selectSub();
		}
	}
	if(TouchInput.isClicked()) {
		if(this.addButton.selectSprite.isBeingTouched() || this.addButton.unselectSprite.isBeingTouched()) {
			SoundManager.playCursor();
			this.addItemNum(1);
		}
		if(this.subButton.selectSprite.isBeingTouched() || this.subButton.unselectSprite.isBeingTouched()) {
			SoundManager.playCursor();
			this.addItemNum(-1);
		}
	}
};

function Sprite_SignatureSampleBase() {
	this.initialize(...arguments);
}

Sprite_SignatureSampleBase.prototype = Object.create(Sprite.prototype);
Sprite_SignatureSampleBase.prototype.constructor = Sprite_SignatureSampleBase;

Sprite_SignatureSampleBase.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._backName = options.backName;
	this._textKey = options.textKey;
	this._padding = options.padding;
	this.initExtOptions(options);
	this.createBackground();
	this.createSignature();
	this.createText();
};

Sprite_SignatureSampleBase.prototype.initExtOptions = function(options) {
};

Sprite_SignatureSampleBase.prototype.createBackground = function() {
	this._backSprite = new Sprite(ImageManager.loadUI(this._backName));
	this.addChild(this._backSprite);
	
	const color = DataManager.regionColor(DataManager.regionId());
	const cellWidth = DataManager.thumbnailCellWidth();
	const innerCellWidth = DataManager.thumbnailInnerCellWidth();
	const graphics = new PIXI.Graphics();
	const upperColor = Utils.upperColor(color, 2);
	const innerMargin = (cellWidth - innerCellWidth) / 2;
	graphics.lineStyle(innerMargin, color, 1, 0);
	graphics.beginFill(upperColor);
	graphics.drawRoundedRect(0, 0, cellWidth, cellWidth, DataManager.thumbnailCellRounded());
	graphics.x = this._padding;
	graphics.endFill();
	this.addChild(graphics);
	this._grid = graphics;
};

Sprite_SignatureSampleBase.prototype.createText = function() {
	this._textBitmap = new Bitmap(this.allWidth() - this.signatureWidth() - this._padding * 2, this.allHeight());
	this._textBitmap.outlineWidth = 0;
	this._textBitmap.fontSize = 14;
	this._textBitmap.textColor = "#551717";
	const textSprite = new Sprite(this._textBitmap);
	this.addChild(textSprite);
	textSprite.anchor.x = 1;
	textSprite.anchor.y = 0.5;
	textSprite.x = this.allWidth() - this._padding;
	textSprite.y = this.allHeight() / 2;
	this.refreshText();
};

Sprite_SignatureSampleBase.prototype.onLanguageChange = function() {
	this.refreshText();
};

Sprite_SignatureSampleBase.prototype.createSignature = function() {
	this._signatureSprite = new Sprite();
	this._signatureSprite.anchor.y = 0.5;
	this._signatureSprite.x = this._padding;
	this._signatureSprite.y = this.allHeight() / 2;
	this.addChild(this._signatureSprite);
	// overwrite...
};

Sprite_SignatureSampleBase.prototype.signatureWidth = function() {
	return DataManager.thumbnailCellWidth();
};

Sprite_SignatureSampleBase.prototype.allWidth = function() {
	return this._backSprite.width;
};

Sprite_SignatureSampleBase.prototype.allHeight = function() {
	return this._backSprite.height;
};

Sprite_SignatureSampleBase.prototype.refreshText = function() {
	this._textBitmap.clear();
	this._textBitmap.drawCenterText(TextManager[this._textKey]);
};

function Sprite_SignatureSampleLetter() {
	this.initialize(...arguments);
}

Sprite_SignatureSampleLetter.prototype = Object.create(Sprite_SignatureSampleBase.prototype);
Sprite_SignatureSampleLetter.prototype.constructor = Sprite_SignatureSampleLetter;

Sprite_SignatureSampleLetter.prototype.initExtOptions = function(options) {
	this._letterName = options.letterName;
};

Sprite_SignatureSampleLetter.prototype.createSignature = function() {
	Sprite_SignatureSampleBase.prototype.createSignature.call(this);
	const signatureBitmap = new Bitmap(DataManager.thumbnailCellWidth(), DataManager.thumbnailCellWidth());
	signatureBitmap.fontSize = DataManager.thumbnailInnerCellWidth();
	signatureBitmap.textColor = "#ffffff";
	signatureBitmap.outlineWidth = 0;
	signatureBitmap.drawCenterText(this._letterName);
	this._signatureSprite.bitmap = signatureBitmap;
};

function Sprite_SignatureSampleGate() {
	this.initialize(...arguments);
}

Sprite_SignatureSampleGate.prototype = Object.create(Sprite_SignatureSampleBase.prototype);
Sprite_SignatureSampleGate.prototype.constructor = Sprite_SignatureSampleGate;

Sprite_SignatureSampleGate.prototype.createSignature = function() {
	Sprite_SignatureSampleBase.prototype.createSignature.call(this);
	const graphics = new PIXI.Graphics();
	const cellWidth = DataManager.thumbnailCellWidth();
	const innerCellWidth = DataManager.thumbnailInnerCellWidth();
	const innerMargin = (cellWidth - innerCellWidth) / 2;
	const cwdiv2 = cellWidth / 2;
	const cwsubmar = cellWidth - innerMargin;
	graphics.beginFill(0xffffff);
	graphics.drawPolygon([new PIXI.Point(cwdiv2, innerMargin), new PIXI.Point(innerMargin, cwdiv2), new PIXI.Point(cwsubmar, cwdiv2)]);
	graphics.drawPolygon([new PIXI.Point(cwdiv2, cwdiv2), new PIXI.Point(innerMargin, cwsubmar), new PIXI.Point(cwsubmar, cwsubmar)]);
	graphics.endFill();
	graphics.x = 0;
	graphics.y = -innerCellWidth / 2 - innerMargin;
	this._signatureSprite.addChild(graphics);
};

function Sprite_SignatureSampleItem() {
	this.initialize(...arguments);
}

Sprite_SignatureSampleItem.prototype = Object.create(Sprite_SignatureSampleBase.prototype);
Sprite_SignatureSampleItem.prototype.constructor = Sprite_SignatureSampleItem;

Sprite_SignatureSampleItem.prototype.createSignature = function() {
	Sprite_SignatureSampleBase.prototype.createSignature.call(this);
	this._signatureSprite.bitmap = ImageManager.loadUI("collection_complete");
	this._signatureSprite.x = this._padding + (this.signatureWidth() - this._signatureSprite.width) / 2;
};

function Sprite_SignatureSampleTask() {
	this.initialize(...arguments);
}

Sprite_SignatureSampleTask.prototype = Object.create(Sprite_SignatureSampleBase.prototype);
Sprite_SignatureSampleTask.prototype.constructor = Sprite_SignatureSampleTask;

Sprite_SignatureSampleTask.prototype.createSignature = function() {
	this._signatureSprite = new Sprite(ImageManager.loadUI("task_signature"));
	this._signatureSprite.anchor.set(0.5);
	this._signatureSprite.y = this.allHeight() / 2;
	this._signatureSprite.x = this._padding + this.signatureWidth() / 2;
	this._signatureSprite.setBlendColor([64, 64, 64, 255]);
	this.addChild(this._signatureSprite);
};

Sprite_SignatureSampleTask.prototype.update = function() {
	Sprite.prototype.update.call(this);
	this._signatureSprite.rotation += 0.06;
};

function Sprite_SignatureSampleMyPos() {
	this.initialize(...arguments);
}

Sprite_SignatureSampleMyPos.prototype = Object.create(Sprite_SignatureSampleBase.prototype);
Sprite_SignatureSampleMyPos.prototype.constructor = Sprite_SignatureSampleMyPos;

Sprite_SignatureSampleMyPos.prototype.initialize = function() {
	Sprite_SignatureSampleBase.prototype.initialize.apply(this, arguments);
	this._signatureAlphaSign = 1;
	this._signatureAlpha = 0;
};

Sprite_SignatureSampleMyPos.prototype.createSignature = function() {
	Sprite_SignatureSampleBase.prototype.createSignature.call(this);
	const graphics = new PIXI.Graphics();
	graphics.beginFill(0xffffff);
	const cellWidth = DataManager.thumbnailCellWidth();
	graphics.drawRoundedRect(0, 0, cellWidth, cellWidth, DataManager.thumbnailCellRounded());
	graphics.endFill();
	this._signatureSprite.addChild(graphics);
	this._signatureSprite.alpha = 0;
	graphics.y = -cellWidth / 2;
};

Sprite_SignatureSampleMyPos.prototype.update = function() {
	Sprite.prototype.update.call(this);
	const min = 0;
	const max = 196;
	const duration = 36;
	this._signatureAlpha += (this._signatureAlphaSign * (max - min) / duration);
	if(this._signatureAlpha > max) {
		this._signatureAlphaSign = -1;
	} else if(this._signatureAlpha < min) {
		this._signatureAlphaSign = 1;
	}
	this._signatureSprite.alpha = this._signatureAlpha / 255;
};

// 随着文字长度而改变的带底板的文字
function Sprite_PadText() {
	this.initialize(...arguments);
}

Sprite_PadText.prototype = Object.create(Sprite.prototype);
Sprite_PadText.prototype.constructor = Sprite_PadText;

Sprite_PadText.prototype.initialize = function(options) {
	Sprite.prototype.initialize.call(this);
	this._edgeName = options.edgeName;
	this._innerName = options.innerName;
	this._textSize = options.textSize;
	this._textColor = options.textColor;
	if(options.text !== "") {
		this.setText(options.text);
	}
};

Sprite_PadText.prototype.setText = function(text) {
	this._text = text;
	this.removeChildren();
	this.createText();
};

Sprite_PadText.prototype.createText = function() {
	const bitmapTest = new Bitmap(1, 1);
	bitmapTest.outlineWidth = 0;
	bitmapTest.fontSize = this._textSize;
	bitmapTest.textColor = this._textColor;
	const width = bitmapTest.measureTextWidth(this._text);
	const tilingBitmap = ImageManager.loadUI(this._innerName);
	const innerSprite = new TilingSprite(tilingBitmap);
	this.addChild(innerSprite);
	innerSprite.move(-width / 2, -tilingBitmap.height / 2, width, tilingBitmap.height);
	const leftSprite = new Sprite(ImageManager.loadUI(this._edgeName));
	leftSprite.x = innerSprite.x - leftSprite.width;
	const rightSprite = new Sprite(ImageManager.loadUI(this._edgeName));
	rightSprite.x = innerSprite.x + width + rightSprite.width;
	rightSprite.scale.x = -1;
	leftSprite.y = rightSprite.y = innerSprite.y;
	this.addChild(leftSprite, rightSprite);
	
	bitmapTest.resize(width + leftSprite.width + rightSprite.width, innerSprite.height);
	bitmapTest.drawCenterText(this._text);
	const textSprite = new Sprite(bitmapTest);
	textSprite.anchor.set(0.5);
	this.addChild(textSprite);
};

function Sprite_KeyFrameAnimationEx() {
	this.initialize(...arguments);
}

Sprite_KeyFrameAnimationEx.prototype = Object.create(Sprite_KeyFrameAnimation.prototype);
Sprite_KeyFrameAnimationEx.prototype.constructor = Sprite_KeyFrameAnimationEx;

Sprite_KeyFrameAnimationEx.prototype.initialize = function(prefix, frameCount, folder, frameSpeed, fadeTime = 0) {
	Sprite_KeyFrameAnimation.prototype.initialize.apply(this, arguments);
	this._animation = new AnimationController();
	this._fadeTime = fadeTime;
};

Sprite_KeyFrameAnimationEx.prototype.onFrameIdxChange = function() {
	const delay = this._frameSpeed - 2 * this._fadeTime;
	this._animation.clear(this);
	this.alpha = 0;
	this._animation.add(this, {data:[{to:1, easingType:'linear', duration:this._fadeTime, property:'alpha'}, {to:0, delay:delay, easingType:'linear', duration:this._fadeTime, property:'alpha'}], loop:false});
};

Sprite_KeyFrameAnimationEx.prototype.update = function() {
	Sprite_KeyFrameAnimation.prototype.update.call(this);
	this._animation.update();
};

// boss战的机制提示，在游戏结束画面显示
function Sprite_BossHint() {
	this.initialize(...arguments);
}

Sprite_BossHint.prototype = Object.create(Sprite.prototype);
Sprite_BossHint.prototype.constructor = Sprite_BossHint;

Sprite_BossHint.prototype.initialize = function(hintId) {
	Sprite.prototype.initialize.call(this);
	this._hintId = hintId;
	this._allWidth = 0;
	this.createArtwork();
	this._hintContainer = new PIXI.Container();
	this.addChild(this._hintContainer);
	this.createHint();
};

Sprite_BossHint.prototype.createArtwork = function() {
	this._artwork = new Sprite(ImageManager.loadUI(this._hintId % 2 === 0 ? "hint_artwork2" : "hint_artwork1"));
	this._artwork.anchor.y = 1;
	const margin = 16;
	this._artwork.x = margin;
	this._artwork.y = Graphics.height - margin;
	this.addChild(this._artwork);
};

Sprite_BossHint.prototype.textRes = function() {
	return TextManager["STATIC_TEXT_BOSS_HINT" + this._hintId];
};

Sprite_BossHint.prototype.onLanguageChange = function() {
	this.createHint();
};

Sprite_BossHint.prototype.createHint = function() {
	this._hintContainer.removeChildren();
	let text = this.textRes();
	let escapeObjs = [];
	let textBuffer = "";
	const regexp = /\[([a-z0-9_;]+)\]\[([0-9\.]+)\]/i;
	while(text.match(regexp)) {
		const characterName = RegExp.$1;
		const scale = parseFloat(RegExp.$2);
		text = text.replace(regexp, "#");
		escapeObjs.push({characterName:characterName,scale:scale});
	}
	const margin = 16;
	let currentX = this._artwork.width + margin * 2;
	let maxY = margin;
	for(const c of text) {
		if(c === "#") {
			currentX = this.clearTextBuffer(textBuffer, currentX);
			const escapeObj = escapeObjs.shift();
			const bitmap = ImageManager.loadCharacter(escapeObj.characterName);
			const sprite = new Sprite(bitmap);
			const info = ImageFrame.info(escapeObj.characterName);
			const frameWidth = bitmap.width / info.width;
			const frameHeight = bitmap.height / info.height;
			maxY = Math.max(Math.round(escapeObj.scale * frameHeight), maxY);
			sprite.setFrame(0, 0, frameWidth, frameHeight);
			sprite.scale.set(escapeObj.scale);
			sprite.x = currentX + margin;
			sprite.anchor.y = 0.5;
			currentX += Math.round(escapeObj.scale * frameWidth);
			currentX += (margin * 2);
			this._hintContainer.addChild(sprite);
			textBuffer = "";
		} else {
			textBuffer += c;
		}
	}
	if(textBuffer !== "") {
		currentX = this.clearTextBuffer(textBuffer, currentX);
	}
	this._allWidth = currentX;
	this._hintContainer.x = 0;
	this._hintContainer.y = Graphics.height - Math.min(56, maxY / 2) - margin;
};

Sprite_BossHint.prototype.clearTextBuffer = function(text, currentX) {
	const textBitmap = new Bitmap(1, 1);
	textBitmap.textColor = "#551717";
	textBitmap.fontSize = 16;
	textBitmap.outlineWidth = 0;
	const width = textBitmap.measureTextWidth(text);
	textBitmap.resize(width, textBitmap.fontSize);
	textBitmap.drawCenterText(text);
	const sprite = new Sprite(textBitmap);
	sprite.anchor.y = 0.5;
	sprite.x = currentX;
	this._hintContainer.addChild(sprite);
	return currentX + width;
};

Sprite_BossHint.prototype.allWidth = function() {
	return this._allWidth;
};

function Sprite_Battery() {
	this.initialize(...arguments);
}

Sprite_Battery.prototype = Object.create(Sprite.prototype);
Sprite_Battery.prototype.constructor = Sprite_Battery;

NYA.ACHIEVES = {};

DataManager.shouldAutoSaveAfterTransfer = false;
DataManager._autoSaveAnimationRequest = false;
DataManager.makeSavefileInfo = function() {
    const info = {};
	info.hp = $gameParty.leader().battleObject().hp;
	info.coin = $gameParty.leader().coin();
    info.playtime = $gameSystem.playtimeText();
    info.timestamp = Date.now();
	info.thumbnail = SceneManager.cacheAchieveUrl();
	info.latest = true;
    return info;
};

DataManager._thumbnailCache = {};
DataManager.thumbnailCache = function(id) {
	return this._thumbnailCache[id];
};

DataManager.updateThumbnailCacheInternal = function(id, bitmap) {
	const old = this.thumbnailCache(id);
	if(old) {
		old.destroy();
	}
	this._thumbnailCache[id] = bitmap;
};


DataManager.updateThumbnailCache = function(id) {
	const info = this.savefileInfo(id);
	this.updateThumbnailCacheInternal(id, Bitmap.load(info.thumbnail));
};

DataManager.autoSaveGame = function() {
	$gameSystem.onBeforeSave();
	this.autoSaveGameInternal(0);
};

DataManager.pollAutoSaveRequest = function() {
	if(this._autoSaveAnimationRequest) {
		this._autoSaveAnimationRequest = false;
		return true;
	}
	return false;
};

DataManager.saveGame = function(savefileId) {
	const info = $gameMap.readyForSave();
    const contents = this.makeSaveContents();
    const saveName = this.makeSavename(savefileId);
    return StorageManager.saveObjectSync(saveName, contents, info).then(() => {
		for(const info of this._globalInfo) {
			if(info) { info.latest = false; }
		}
		this._globalInfo[savefileId] = this.makeSavefileInfo();
		this.saveGlobalInfo();
        return 0;
    });
};

DataManager.autoSaveGameInternal = function(savefileId) {
	const info = $gameMap.readyForSave();
    const contents = this.makeSaveContents();
    const saveName = this.makeSavename(savefileId);
    return StorageManager.saveObjectSync(saveName, contents, info).then(() => {
		const isSaveGlobalInfo = !this._globalInfo[savefileId];
		this._globalInfo[savefileId] = this.makeSavefileInfo();
		this._globalInfo[savefileId].latest = false;
		if(isSaveGlobalInfo) {
			this.saveGlobalInfo();
		}
        return 0;
    });
};

NYA.ACHIEVES.DataManager_makeSaveContents = DataManager.makeSaveContents;
DataManager.makeSaveContents = function() {
	const contents = NYA.ACHIEVES.DataManager_makeSaveContents.apply(this, arguments);
	contents.version = NYA.VERSION;
	contents.lily = $gameLily;
	return contents;
};

NYA.ACHIEVES.DataManager_extractSaveContents = DataManager.extractSaveContents;
DataManager.extractSaveContents = function(contents) {
	NYA.ACHIEVES.DataManager_extractSaveContents.apply(this, arguments);
	$gameLily = contents.lily;
	const before = contents.version || 0;
	const after = NYA.VERSION;
	for(let i = before; i < after; i++) {
		PatchManager.updatePatch(i);
	}
};

DataManager.isSaveFileExist = function(savefileId) {
	return !!this._globalInfo[savefileId];
};

SceneManager.cacheAchieveUrl = function() {
	if(!this._cacheAchieveUrl) {
		this.snapForBackground();
	}
	return this._cacheAchieveUrl;
};

SceneManager.snapForBackground = function() {
	if(SceneManager.isNextScene(Scene_Gameover)) {
		this.tempTransparentPlayerSprite();
	}
	const stage = this._scene;
	const width = Graphics.width;
    const height = Graphics.height;
	const renderer = Graphics.app.renderer;
	if(this._backGroundTexture) {
		this._backGroundTexture.destroy({ destroyBase: true });
	}
	this._backGroundTexture = PIXI.RenderTexture.create(width, height);
	renderer.render(stage, this._backGroundTexture);
	const sprite = this.backGroundSprite();
    
    const renderTexture = PIXI.RenderTexture.create(this.thumbnailWidth(), this.thumbnailHeight());
	
	const scale = sprite.scale;
	scale.x = this.thumbnailWidth() / width;
	scale.y = this.thumbnailHeight() / height;
    renderer.render(sprite, renderTexture);
    this._cacheAchieveUrl = renderer.extract.base64(renderTexture, 'image/jpeg');
	renderTexture.destroy({ destroyBase: true });
};

SceneManager.tempTransparentPlayerSprite = function() {
	const sprite = this._scene._spriteset.findTargetSprite($gamePlayer);
	sprite.alpha = 0;
};

SceneManager.thumbnailWidth = function() {
	return 271;
};

SceneManager.thumbnailHeight = function() {
	return 149;
};

DataManager.latestSavefileId = function() {
    const globalInfo = this._globalInfo;
    const index = globalInfo.findIndex(x => x && x.latest);
    return index;
};

DataManager.earliestSavefileId = function() {
    const globalInfo = this._globalInfo;
    const validInfo = globalInfo.filter(x => x);
    const earliest = Math.min(...validInfo.map(x => x.timestamp));
    const index = globalInfo.findIndex(x => x && x.timestamp === earliest);
    return index;
};

SceneManager.backGroundSprite = function() {
	const sprite = new PIXI.Sprite(this._backGroundTexture);
	return sprite;
};

window.$dataStory = null;
DataManager._storyLoadingError = "";
DataManager._requestStoryLoadingError = "";
DataManager._storyLoadingSuccess = false;
DataManager._languageChange = false;
DataManager.onLanguageChange = function() {
	this.reloadLanguage();
	DataManager.cacheExploreItem();
	this.updateDocumentTitle();
};
DataManager.reloadLanguage = function() {
	this._languageChange = true;
};
DataManager.updateDocumentTitle = function() {
	const posfix = NYA.DEMO ? " Demo" : "";
	document.title = TextManager.GAME_NAME + posfix;
};
DataManager.checkLanguageChange = function(handler) {
	if(this._languageChange) {
		this._languageChange = false;
		return true;
	}
	return false;
};
NYA.ACHIEVES.DataManager_loadDatabase = DataManager.loadDatabase;
DataManager.loadDatabase = function() {
	NYA.ACHIEVES.DataManager_loadDatabase.apply(this, arguments);
	this.loadLanguage();
};

DataManager.loadLanguage = function() {
	const storyName = 'data/story-%1.xlsx'.format($dataLanguage);
	this.loadNormalFile(storyName, this.onStoryXLSXLoad.bind(this), this.onStoryXLSXError.bind(this));
};

DataManager.onStoryXLSXError = function(filename) {
	if(filename) {
		this._storyLoadingError = filename;
	} else {
		const current = $dataLanguage;
		main.setDefaultLanguage();
		if(current !== $dataLanguage) {
			this._requestStoryLoadingError = current;
			this.loadLanguage();
		} else {
			throw("story file loading error");
		}
	}
};

DataManager.checkRequestStoryLoadingError = function() {
	if(this._requestStoryLoadingError) {
		this._storyLoadingError = this._requestStoryLoadingError;
		this._requestStoryLoadingError = "";
	}
};

DataManager.checkStoryLoadingError = function() {
	if(this._storyLoadingError) {
		const current = this._storyLoadingError;
		this._storyLoadingError = "";
		return current;
	}
	return "";
};

DataManager.checkStoryLoadingSuccess = function() {
	if(this._storyLoadingSuccess) {
		this._storyLoadingSuccess = false;
		return true;
	}
	return false;
};

NYA.ACHIEVES.DataManager_isDatabaseLoaded = DataManager.isDatabaseLoaded;
DataManager.isDatabaseLoaded = function() {
	return NYA.ACHIEVES.DataManager_isDatabaseLoaded.apply(this, arguments) && !!$dataStory;
};

window.$dataLanguageSystem = {};
DataManager.onStoryXLSXLoad = function(buffer, filename) {
	const xlsxBook = XLSX.read(buffer, {bookType: 'xlsx', type: 'array'});
	if(!xlsxBook || !xlsxBook.SheetNames.includes("#actor") || !xlsxBook.SheetNames.includes("#ui"))
	{
		this.onStoryXLSXError(filename);
		return;
	}
	$dataStory = {};
	xlsxBook.SheetNames.forEach((sheetName) => {
		const sheet = xlsxBook.Sheets[sheetName];
		if(sheetName.match(/^#(.+)/i)) {
			this.loadSpecialLocalizationSheet(RegExp.$1, sheet);
			return;
		}
		let i = 2;
		let eof = 0;
		while(eof < 99) {
			const header = sheet['A' + i];
			if(header === undefined) { eof++; i++; continue; }
			eof = 0;
			const id = header.v;
			if(Utils.tryParseInt(id) !== undefined) {
				$dataStory[id] = [];
				while(sheet['B' + i] && sheet['B' + i].v) {
					const story = sheet['B' + i].v;
					const regex = /^\#([a-z]+)\ (\d+)/i;
					const regex2 = /^\#choice/i;
					if(story.match(regex)) {
						const name = RegExp.$1;
						const paraStr = RegExp.$2;
						const para = Utils.tryParseInt(paraStr, 0);
						$dataStory[id].push({
							name:name
							,para:para
						});
					} else if(story.match(regex2)) {
						let tab = 67;
						let i2 = 0;
						const choiceItem = [];
						while(sheet[String.fromCharCode(tab + i2) + i] && sheet[String.fromCharCode(tab + i2) + i].v) {
							const choice = sheet[String.fromCharCode(tab + i2) + i].v;
							const choiceRegex = /^\#(\d+)\ (.+)/i;
							if(choice.match(choiceRegex)) {
								const choiceItemId = parseInt(RegExp.$1);
								const choiceItemContents = RegExp.$2;
								choiceItem.push({id:choiceItemId, contents:choiceItemContents});
							}
							i2++;
						}
						$dataStory[id].push({
							name:'choice'
							,choiceItem:choiceItem
						});
					} else {
						const speaker = sheet['C' + i] ? Utils.tryParseInt(sheet['C' + i].v, 0) : 0;
						const artwork = sheet['D' + i] ? sheet['D' + i].v : "";
						const artworkPos = sheet['E' + i] ? Utils.tryParseInt(sheet['E' + i].v, 0) : 0;
						const live2d = sheet['F' + i] ? !!sheet['F' + i].v : false;
						const align = sheet['G' + i] ? Utils.tryParseInt(sheet['G' + i].v, 0) : 0;
						const center = sheet['H' + i] ? !!sheet['H' + i].v : false;
						const extra = sheet['I' + i] ? sheet['I' + i].v : "";
						const extraOptions = extra.split(",").map((str) => {
							const tokens = str.split(" ");
							if(tokens[0] && tokens[0].match(/^\#(.+)/i)) {
								return {name:RegExp.$1, para:tokens.slice(1)}
							}
						}).filter((ext) => { return !!ext; });
						$dataStory[id].push({
							name:'story'
							,contents:story
							,speaker:speaker
							,artwork:artwork
							,artworkPos:artworkPos
							,live2d:live2d
							,align:align
							,center:center
							,extra:extraOptions
						});
					}
					i++;
				}
			} else {
				i++;
			}
		}
	});
	if(!filename) {
		this.checkRequestStoryLoadingError();
	} else {
		this._storyLoadingSuccess = true;
	}
	this.onLanguageChange();
};

NYA.ACHIEVES.Graphics__onKeyDown = Graphics._onKeyDown;
Graphics._onKeyDown = function(event) {
	if (!event.ctrlKey && !event.altKey) {
        switch (event.keyCode) {
            case 117: // F6
                DataManager.selectStoryFileToLoad();
                break;
			default: break;
        }
    }
};

DataManager.selectStoryFileToLoad = function() {
	this.selectGameFileToLoad('.xlsx', this.onStoryXLSXLoad.bind(this));
};

DataManager.selectGameFileToLoad = function(ext, callback) {
	const input = document.createElement('input');
	input.type = 'file';
	input.accept = ext;
	input.onchange = function() {
		if(input.files.length > 0) {
			const reader = new FileReader();
			const file = input.files[0];
			reader.onload = function() {
				const u8 = new Uint8Array(reader.result);
				callback(u8, file.name);
			}.bind(this);
			reader.readAsArrayBuffer(file);
		}
	}.bind(this);
	input.click();
};

DataManager.loadSpecialLocalizationSheet = function(name, sheet) {
	switch(name) {
		case "ui": this.loadUILocalizationSheet(sheet); break;
		case "actor": this.loadActorLocalizationSheet(sheet); break;
		case "region": this.loadRegionLocalizationSheet(sheet); break;
		case "task": this.loadTaskLocalizationSheet(sheet); break;
		case "system": this.loadSystemLocalizationSheet(sheet); break;
		case "legal": this.loadLegalSheet(sheet); break;
		default:break;
	}
};

DataManager.loadUILocalizationSheet = function(sheet) {
	let i = 2;
	while(sheet['A' + i]) {
		const id = sheet['A' + i].v;
		if(sheet['B' + i]) {
			const val = sheet['B' + i].v;
			TextManager[id] = val;
		} else {
			TextManager[id] = "";
		}
		i++;
	}
};

DataManager.loadLegalSheet = function(sheet) {
	if(Utils.isLegalMode()) {
		let i = 1;
		while(sheet['A' + i]) {
			const id = sheet['A' + i].v;
			const val = sheet['B' + i].v;
			TextManager[id] = val;
			i++;
		}
	}
};

DataManager.loadActorLocalizationSheet = function(sheet) {
	let i = 2;
	while(sheet['A' + i]) {
		const id = parseInt(sheet['A' + i].v);
		if(sheet['B' + i]) {
			const name = sheet['B' + i].v;
			$dataActors[id].name = name;
		} else {
			$dataActors[id].name = "???";
		}
		if(sheet['C' + i]) {
			const aliasName = sheet['C' + i].v;
			$dataActors[id].meta.aliasName = aliasName;
		} else {
			$dataActors[id].meta.aliasName = "" + id;
		}
		if(sheet['D' + i]) {
			const color = sheet['D' + i].v;
			$dataActors[id].meta.color = color;
		} else {
			$dataActors[id].meta.color = "#ffffff";
		}
		i++;
	}
};

var $dataRegion = {};
DataManager.loadRegionLocalizationSheet = function(sheet) {
	let i = 2;
	while(sheet['A' + i]) {
		const id = parseInt(sheet['A' + i].v);
		$dataRegion[id] = {};
		$dataRegion[id].exploreItem = [];
		if(sheet['B' + i]) {
			const name = sheet['B' + i].v;
			$dataRegion[id].name = name;
		} else {
			$dataRegion[id].name = "???";
		}
		if(sheet['C' + i]) {
			const nightSilent = sheet['C' + i].w;
			$dataRegion[id].nightSilent = nightSilent === "1";
		} else {
			$dataRegion[id].nightSilent = false;
		}
		i++;
	}
	for(const mapId in DataManager._cacheMapData) {
		const realMapId = parseInt(mapId);
		const dataMap = DataManager.getCachedData(realMapId);
		if(dataMap.transport && dataMap.transport.length > 0) {
			const x = dataMap.transport[0][0];
			const y = dataMap.transport[0][1];
			const cell = DataManager.getThumbnailCell(x, y, realMapId);
			if(cell) {
				$dataRegion[cell.regionId].transportCell = cell;
			}
		}
	}
};

var $dataTask = {};
DataManager.loadTaskLocalizationSheet = function(sheet) {
	let i = 2;
	while(sheet['A' + i]) {
		const id = parseInt(sheet['A' + i].v);
		$dataTask[id] = {};
		if(sheet['B' + i]) {
			const evid = parseInt(sheet['B' + i].v);
			$dataTask[id].ev = evid;
		} else {
			$dataTask[id].ev = 0;
		}
		if(sheet['C' + i]) {
			const title = sheet['C' + i].v;
			$dataTask[id].title = title;
		} else {
			$dataTask[id].title = "";
		}
		if(sheet['D' + i]) {
			const desc = sheet['D' + i].v;
			$dataTask[id].desc = desc;
		} else {
			$dataTask[id].desc = "";
		}
		if(sheet['E' + i]) {
			const type = sheet['E' + i].v;
			$dataTask[id].type = parseInt(type);
		} else {
			$dataTask[id].type = 0;
		}
		if(sheet['F' + i]) {
			const nextId = sheet['F' + i].v;
			$dataTask[id].nextId = parseInt(nextId);
		} else {
			$dataTask[id].nextId = 0;
		}
		if(sheet['G' + i]) {
			const maxProgress = sheet['G' + i].v;
			$dataTask[id].maxProgress = parseInt(maxProgress);
		} else {
			$dataTask[id].maxProgress = 0;
		}
		if(sheet['H' + i]) {
			const trigger = sheet['H' + i].v;
			$dataTask[id].trigger = trigger;
		} else {
			$dataTask[id].trigger = "";
		}
		if(sheet['I' + i]) {
			const parameter = sheet['I' + i].v;
			$dataTask[id].parameter = parseInt(parameter);
		} else {
			$dataTask[id].parameter = 0;
		}
		if(sheet['J' + i]) {
			const coin = sheet['J' + i].v;
			$dataTask[id].coin = parseInt(coin);
		} else {
			$dataTask[id].coin = 0;
		}
		if(sheet['K' + i]) {
			const sw = sheet['K' + i].v;
			$dataTask[id].openSwitch = parseInt(sw);
		} else {
			$dataTask[id].openSwitch = 0;
		}
		i++;
	}
};

DataManager.loadSystemLocalizationSheet = function(sheet) {
	$dataLanguageSystem = {};
	let i = 2;
	while(sheet['A' + i]) {
		const id = Utils.tryParseSheet(sheet['A' + i]);
		$dataLanguageSystem[id] = Utils.tryParseInt(Utils.tryParseSheet(sheet['B' + i]), 0);
		i++;
	}
};

DataManager.taskFullName = function(id) {
	if($dataTask[id]) {
		const typestr = this.taskTypeStr($dataTask[id].type);
		return '%1%2'.format(typestr, $dataTask[id].title);
	}
	return "";
};

DataManager.taskTypeStr = function(type) {
	switch(type) {
		case 0: return TextManager["STATIC_TEXT_TASK_TYPE_MAIN"];
		default: return TextManager["STATIC_TEXT_TASK_TYPE_SUB"];
	}
};

function Game_StoryInterpreter() {
	this.initialize(...arguments);
}

Game_StoryInterpreter.prototype = Object.create(Game_Interpreter.prototype);
Game_StoryInterpreter.prototype.constructor = Game_StoryInterpreter;

Game_StoryInterpreter.prototype.initialize = function() {
	Game_Interpreter.prototype.initialize.apply(this, arguments);
	this._storyId = 0;
};

Game_StoryInterpreter.prototype.setupStoryId = function(storyId) {
	this._storyId = storyId;
	if(!ConfigManager.isStoryRead(storyId)) {
		$gameMessage.resetSkipMode();
	}
};

Game_StoryInterpreter.prototype.loadImages = function() {
};

Game_StoryInterpreter.prototype.executeCommand = function() {
    const command = this.currentCommand();
    if (command) {
		const name = command.name;
		switch(name) {
			case "story": {
				if(command.align === 0) {
					$gameMessage.setBackground(0);
					$gameMessage.setPositionType(2);
				} else {
					$gameMessage.setBackground(1);
					$gameMessage.setPositionType(1);
				}
				if(command.speaker) {
					$gameMessage.setSpeakerId(command.speaker);
					$gameMessage.setSpeakerName($dataActors[command.speaker].name);
				}
				$gameMessage.setArtwork(command.artwork, command.artworkPos, command.live2d);
				$gameMessage.setCenter(command.center);
				$gameMessage.add(command.contents);
				$gameMessage.setExtraOpt(command.extra.clone());
				$gameMessage.setStoryId(this._storyId);
				const nextCommand = this.nextCommand();
				if(nextCommand && nextCommand.name === "choice") {
					this._index++;
					return this.executeCommand();
				} else if($gameMessage.isSkipMode()) {
					$gameMessage.clear();
					break;
				}
				this.setWaitMode("message");
				break;
			}
			case "wait" : {
				this.command230([command.para]);
				break;
			}
			case "common" : {
				this.command117([command.para]);
				break;
			}
			case "call" : {
				this.setupStoryChild(command.para);
				break;
			}
			case "choice" : {
				$gameMessage.resetSkipMode();
				const choices = command.choiceItem.map((item) => { return item.contents; });;
				this.setupChoices([choices,-1,-1,1,2]);    // [-1][-1][1][2] = [no default select][no cancel select][center align][transparent background]
				$gameMessage.setChoiceCallback(n => {
					this.setupStoryChild(command.choiceItem[n].id);
				});
				this.setWaitMode("message");
				break;
			}
		}
        this._index++;
    } else {
        this.terminate();
		this.recordStoryRead();
    }
    return true;
};

Game_Interpreter.prototype.setupStoryChild = function(storyId) {
	const list = $dataStory[storyId];
	const eventId = this.isOnCurrentMap() ? this._eventId : 0;
	this._childInterpreter = new Game_StoryInterpreter(this._depth + 1);
    this._childInterpreter.setup(list, eventId);
	this._childInterpreter.setupStoryId(storyId);
};

Game_StoryInterpreter.prototype.nextCommand = function() {
    return this._list[this._index + 1];
};

Game_Interpreter.prototype.recordStoryRead = function() {
	ConfigManager.recordStoryRead(this._storyId);
};

DataManager.actorAliasName = function(actorId) {
	const name = $dataActors[actorId].meta.aliasName;
	if(!name) {
		return "" + actorId;
	}
	return name;
};

NYA.ACHIEVES.Game_Message_initialize = Game_Message.prototype.initialize;
Game_Message.prototype.initialize = function() {
	NYA.ACHIEVES.Game_Message_initialize.apply(this, arguments);
	this._skipMode = false;
};

NYA.ACHIEVES.Game_Message_clear = Game_Message.prototype.clear;
Game_Message.prototype.clear = function() {
	NYA.ACHIEVES.Game_Message_clear.apply(this, arguments);
	this._speakerId = 0;
	this._artwork = "";
	this._artworkPos = 0;
	this._live2d = false;
	this._center = false;
	this._extraOpt = [];
	this._storyId = 0;
};

Game_Message.prototype.setSpeakerId = function(id) {
	this._speakerId = id;
};

Game_Message.prototype.speakerId = function() {
	return this._speakerId;
};

Game_Message.prototype.setArtwork = function(name, pos, live2d) {
	this._artwork = name;
	this._artworkPos = pos;
	this._live2d = live2d;
};	

Game_Message.prototype.artwork = function() {
	return this._artwork;
};

Game_Message.prototype.artworkPos = function() {
	return this._artworkPos;
};

Game_Message.prototype.setArtworkPos = function(pos) {
	this._artworkPos = pos;
};

Game_Message.prototype.live2d = function() {
	return this._live2d;
};

Game_Message.prototype.setCenter = function(center) {
	this._center = center;
};

Game_Message.prototype.center = function() {
	return this._center;
};

Game_Message.prototype.setExtraOpt = function(opt) {
	this._extraOpt = opt;
};

Game_Message.prototype.extraOpt = function() {
	return this._extraOpt;
};

Game_Message.prototype.setStoryId = function(storyId) {
	this._storyId = storyId;
};

// 是否是跳过剧情的状态，一般来说，如果storyId已读，则玩家按esc会导致后续已读过的所有剧情对话快进
// 但选项出现后，esc的持续快进状态将会终止
// !$gameMap._interpreter.isRunning()时也会将esc的持续快进状态关闭
Game_Message.prototype.isSkipMode = function() {
	return this._skipMode;
};

Game_Message.prototype.updateSkipMode = function(touchTriggered = false) {
	if(!this._skipMode && (touchTriggered || Input.isUITriggered("menu")) && ConfigManager.isStoryRead(this._storyId)) {
		this._skipMode = true;
		SoundManager.playCancel();
	}
};

Game_Message.prototype.canUseSkipMode = function() {
	return !this._skipMode && this.isBusy() && ConfigManager.isStoryRead(this._storyId);
};

Game_Message.prototype.resetSkipMode = function() {
	this._skipMode = false;
};

Game_Interpreter.prototype.findEventById = function(id) {
	if(id === 0) {
		return this.event();
	} else {
		return $gameMap.event(id);
	}
};

NYA.ACHIEVES.Game_Temp_initialize = Game_Temp.prototype.initialize;
Game_Temp.prototype.initialize = function() {
	NYA.ACHIEVES.Game_Temp_initialize.apply(this, arguments);
	this._autoSaveRequest = false;
	this._mapTransferHistory = [];
	this._mapTransferBeforeSave = this.mapTransferForSaveNum();
};

Game_Temp.prototype.pollAutoSaveRequest = function() {
	if(this._autoSaveRequest) {
		this._autoSaveRequest = false;
		return true;
	}
	return false;
};

Game_Temp.prototype.requestAutoSave = function() {
	this._autoSaveRequest = true;
};

// 每过两个图存一个档
Game_Temp.prototype.mapTransferForSaveNum = function() {
	return 2;
};

// 返回true：要自动存档
Game_Temp.prototype.triggerAutoSave = function() {
	const nextMapId = $gameMap.mapId();
	if(!$gamePlayer.isDeath() && !$dataMap.meta.autosaveoff && !this._mapTransferHistory.includes(nextMapId)) {
		this._mapTransferBeforeSave--;
		this._mapTransferHistory.push(nextMapId);
		if(this._mapTransferBeforeSave <= 0) {
			this._mapTransferBeforeSave = this.mapTransferForSaveNum();
			this._mapTransferHistory.reverse();
			this._mapTransferHistory.length = 1;
			return true;
		}
	}
	return false;
};



NYA.GAME.SYSTEM = {};

NYA.GAME.PLUGIN_TEST = 14;
NYA.GAME.NIGHT_SWITCH_ID = 36;

Game_Interpreter.prototype.command352 = function() {
    SceneManager.push(Scene_Save);
    return true;
};

Game_Party.prototype.leader = function() {
	return this.allMembers()[0];
};

NYA.GAME.SYSTEM.Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function() {
	NYA.GAME.SYSTEM.Game_Map_setup.apply(this, arguments);
	this.clearHotEvent();
	this.clearDigit();
	this.clearBossEvent();
	this.loadMapDeathStatus();
};

NYA.GAME.SYSTEM.Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
	NYA.GAME.SYSTEM.Game_Map_initialize.apply(this, arguments);
	this.clearHotEvent();
	this.clearDigit();
	this.clearBossEvent();
};

NYA.GAME.SYSTEM.Game_Map_update = Game_Map.prototype.update;
Game_Map.prototype.update = function() {
	NYA.GAME.SYSTEM.Game_Map_update.apply(this, arguments);
	this.updateDigit();
};

Game_Map.prototype.clearHotEvent = function() {
	this._hotEvent = undefined;
	this._hotEventOpt = undefined;
};

Game_Map.prototype.clearDigit = function() {
	this._damageDigit = [];
};

Game_Map.prototype.clearBossEvent = function() {
	this._bossEvent = undefined;
};

Game_Map.prototype.setBossEvent = function(evid) {
	this._bossEvent = evid;
};

Game_Map.prototype.bossEvent = function() {
	if(this._bossEvent === 0) {
		return $gamePlayer;
	}
	return this.event(this._bossEvent);
};

Game_Map.prototype.setHotEvent = function(evid, opt = {}) {
	this._hotEvent = evid;
	this._hotEventOpt = opt;
};

Game_Map.prototype.addDamageDigit = function(character, damage, effectPos) {
	const dx = this.displayX();
	const dy = this.displayY();
	let x = -dx * this.tileWidth();
	let y = -dy * this.tileHeight();
	if(effectPos) {
		x += effectPos.x;
		y += effectPos.y;
	} else {
		x += character.physicsCenterX();
		y += character.physicsCenterY();
	}
	if(character instanceof Game_Player && damage >= 0) {
		const vx = Math.random() * 6 - 3;
		const vy = -(Math.random() * 4 + 2);
		this._damageDigit.push({x:x, y:y, vx:vx, vy:vy, dx:dx, dy:dy, damage:damage, type:"player", time:0});
	} else {
		this._damageDigit.push({x:x, y:y, vx:0, vy:0, dx:dx, dy:dy, damage:damage, type:"enemy", time:0});
	}
};

Game_Map.prototype.hotEvent = function() {
	return this.event(this._hotEvent);
};

Game_Map.prototype.hotEventOpt = function() {
	return this._hotEventOpt;
};

Game_Map.prototype.clearHotEventOpt = function() {
	this._hotEventOpt = undefined;
};

Game_Map.prototype.updateDigit = function() {
	this._damageDigit = this._damageDigit.filter((digit) => {
		digit.time++;
		if(digit.time > this.maxDigitTime()) {
			return false;
		}
		digit.x += digit.vx;
		digit.y += digit.vy;
		if(digit.type === "player" && digit.damage >= 0) {
			digit.vy += 0.1;
			if(digit.vy > 10) {
				digit.vy = 10;
			}
		} else {
			if(digit.time > this.digitFloatTime()) {
				digit.vy = -3;
			}
		}
		return true;
	});
};

Game_Map.prototype.damageDigit = function() {
	return this._damageDigit;
};

Game_Map.prototype.maxDigitTime = function() {
	return 105;
};

Game_Map.prototype.digitFloatTime = function() {
	return 14;
};

Game_System.prototype.difficulty = function() {
	return this._difficulty;
};

NYA.GAME.SYSTEM.Game_System_initialize = Game_System.prototype.initialize;
Game_System.prototype.initialize = function() {
	NYA.GAME.SYSTEM.Game_System_initialize.apply(this, arguments);
	this._difficulty = 0;		//	实时难度
	this._difficultySettings = 0;		// 玩家设置的难度，因为有时玩家卡关太久需要暂时将难度降低，存档后恢复原本难度，所以要记两个难度值
	this._softGuide = {};
	this._hardGuide = "";
	this._previousMapDeathStatus1 = null;
	this._previousMapDeathStatus2 = null;
	this._lastObtainItems = [];
};

Game_System.prototype.saveMapDeathStatus = function() {
	this._previousMapDeathStatus2 = this._previousMapDeathStatus1;
	this._previousMapDeathStatus1 = $gameMap.currentDeathStatus();
};

Game_System.prototype.previousMapDeathStatus1 = function() {
	return this._previousMapDeathStatus1;
};

Game_System.prototype.previousMapDeathStatus2 = function() {
	return this._previousMapDeathStatus2;
};

Game_Map.prototype.currentDeathStatus = function() {
	const status = {};
	status.id = this.mapId();
	const deathArr = [];
	for(const ev of this.events()) {
		if(ev.isDeath()) {
			deathArr.push(ev.eventId());
		}
	}
	status.death = deathArr;
	return status;
};

Game_Map.prototype.loadMapDeathStatus = function() {
	const status1 = $gameSystem.previousMapDeathStatus1();
	const status2 = $gameSystem.previousMapDeathStatus2();
	if(!this.applyDeathStatus(status2)) {
		this.applyDeathStatus(status1);
	}
};

Game_Map.prototype.applyDeathStatus = function(status) {
	if(this.isNightSilent()) {
		$gameMap.events().forEach((event) => {
			if(event.battleObject() && event.battleObject().isMonster) {
				event.initToDeath();
			}
		});
		return true;
	}
	if(status && status.id === this.mapId() && !$dataMap.meta.always_reset) {
		status.death.forEach((evid) => {
			const event = $gameMap.event(evid);
			event && event.initToDeath();
		});
		return true;
	}
	return false;
};

Game_Map.prototype.checkBossHint = function() {
	if(ConfigManager.isHintEnabled) {
		const bossEvent = this.bossEvent();
		if(bossEvent && bossEvent.battleObject()) {
			const battleObjectId = bossEvent.battleObject().templateId();
			const length = bossEvent.battleObject().hint.length;
			if(length > 0) {
				const idx = ConfigManager.addHintUsage(battleObjectId, length);
				return bossEvent.battleObject().hint[idx];
			}
			return 0;
		}
	}
	return 0;
};

Game_System.prototype.resolveDifficultyDown = function() {
	const down = this.difficultyForProtect();
	if(down !== this.difficulty()) {
		this.setDifficulty(down.clamp(-1, 1));
		if(down === -2) {
			$gamePlayer.battleObject().addBuff("hp_resume_very_easy", 18000, 0.2, "consumables");
		}
	}
	this.adjustDifficultyHpDown();
};

// 简单-最简单 1次
Game_System.prototype.difficultyForProtect = function() {
	const difficulty = this.difficultySettings();
	const counter = ConfigManager.difficultyCounter();
	switch(difficulty) {
		case 1: {
			return 1;
		}
		case 0: {
			return 0;
		}
		case -1: {
			if(counter >= 1) {
				return -2;
			}
			break;
		}
	}
	return difficulty;
};

Game_System.prototype.setDifficulty = function(difficulty) {
	const oldDifficulty = this._difficulty;
	this._difficulty = difficulty;
	if(oldDifficulty < difficulty) {
		this.adjustDifficultyHpUp();			// 难度变高
	}
	if(difficulty === 1) {
		$gameSwitches.setValue(22, true);
	} else {
		$gameSwitches.setValue(22, false);
	}
	if(difficulty === -1) {
		$gameSwitches.setValue(43, true);
	} else {
		$gameSwitches.setValue(43, false);
	}
};

Game_System.prototype.setDifficultySettings = function(difficulty) {
	this._difficultySettings = difficulty;
	this.setDifficulty(difficulty);
};

Game_System.prototype.difficultySettings = function() {
	return this._difficultySettings;
};

Game_System.prototype.adjustDifficultyHpUp = function() {
	if($gamePlayer.battleObject().hp > $gamePlayer.battleObject().mhp) {
		$gamePlayer.battleObject().hp = $gamePlayer.battleObject().mhp;
	}
};

Game_System.prototype.adjustDifficultyHpDown = function() {
	if($gamePlayer.battleObject().hp < $gamePlayer.battleObject().mhp) {
		$gamePlayer.battleObject().hp = $gamePlayer.battleObject().mhp;
	}
};

Game_System.prototype.setupSoftGuide = function(message) {
	this._softGuide = {};
	this._softGuide.message = message;
	this._softGuide.animationRuntime = undefined;
	this.preprocessSoftGuideMessage();
};

Game_System.prototype.preprocessSoftGuideMessage = function() {
	const regexp = /^\~([a-z]+)\~/i;
	if(this._softGuide.message.match(regexp)) {
		this._softGuide.signature = RegExp.$1;
		this._softGuide.message = this._softGuide.message.replace(regexp, "~");
	}
};

Game_System.prototype.setGuideCompleted = function(signature) {
	if(this._softGuide.signature === signature) {
		this._softGuide.isClosing = true;
	}
};

Game_System.prototype.clearSoftGuide = function() {
	this._softGuide.message = undefined;
	this._softGuide.animationRuntime = undefined;
};

Game_System.prototype.softGuide = function() {
	return this._softGuide;
};

Game_System.prototype.hardGuide = function() {
	return this._hardGuide;
};

Game_System.prototype.clearHardGuide = function() {
	this._hardGuide = "";
};

Game_System.prototype.setHardGuide = function(guidePicture) {
	this._hardGuide = guidePicture;
};

Game_System.prototype.setLastObtainItem = function(item) {
	this._lastObtainItems.push(item);
};

Game_System.prototype.lastObtainItem = function() {
	return this._lastObtainItems.shift();
};

Game_System.prototype.hasLastObtainItem = function() {
	return this._lastObtainItems.length > 0;
};

NYA.GAME.SYSTEM.Game_Player_reserveTransfer = Game_Player.prototype.reserveTransfer;
Game_Player.prototype.reserveTransfer = function() {
	NYA.GAME.SYSTEM.Game_Player_reserveTransfer.apply(this, arguments);
	const mapId = $gameMap.mapId();
	if(mapId === 0 || mapId === this._newMapId) {
		DataManager.shouldAutoSaveAfterTransfer = false;
	} else {
		DataManager.shouldAutoSaveAfterTransfer = true;
	}
};

function Game_Consumables() {
	this.initialize(...arguments);
}

Game_Consumables.prototype.initialize = function() {
	this._data = {};
};

Game_Consumables.prototype.add = function(dataId, num, noMaxControl) {
	if(!this._data[dataId]) {
		this._data[dataId] = 0;
	}
	this._data[dataId] += num;
	if(!noMaxControl && num > 0) {
		this._data[dataId] = this._data[dataId].clamp(0, this.maxNum(dataId));
	} else {
		this._data[dataId] = Math.max(0, this._data[dataId]);
	}
};

Game_Consumables.prototype.maxNum = function(dataId) {
	const data = this.data();
	return data[dataId].maxNum;
};

Game_Consumables.prototype.clear = function() {
	this._data = {};
};

Game_Consumables.prototype.itemNum = function(dataId) {
	if(!this._data[dataId]) {
		return 0;
	}
	return this._data[dataId];
};

Game_Consumables.prototype.hasAnyItem = function() {
	return Object.values(this._data).some((num) => {
		return num > 0;
	});
};

Game_Consumables.prototype.deductNum = function(dataId, num) {
	if(this.itemNum(dataId) >= num) {
		this.add(dataId, -num);
		return true;
	}
	return false;
};

Game_Consumables.prototype.data = function() {
	return {
		"0": {
			effect:[{name: "add_hp", para:[0.3]}]
			, maxNum:6
			, desc: TextManager.STATIC_TEXT_CONSUMABLES_DESC_0
			, name: TextManager.STATIC_TEXT_CONSUMABLES_NAME_0
			, openTask:0
			, se:"Recovery"
			, price:100
			, demo:true
			, demoPrice:100
		}
		, "1": {
			effect:[{name: "add_hp", para:[0.8]}]
			, maxNum:2
			, desc: TextManager.STATIC_TEXT_CONSUMABLES_DESC_1
			, name: TextManager.STATIC_TEXT_CONSUMABLES_NAME_1
			, openTask:0
			, se:"Recovery"
			, price:350
			, demo:true
			, demoPrice:350
		}
		, "2": {
			effect:[{name:"add_hp_resume", para:[7200,0.0001]},{name:"add_hp", para:[-0.15]}]
			, maxNum:4
			, desc: TextManager.STATIC_TEXT_CONSUMABLES_DESC_2
			, name: TextManager.STATIC_TEXT_CONSUMABLES_NAME_2
			, openTask:0
			, se: "resume_add"
			, price:175
			, demo:true
			, demoPrice:175
		}
		, "3": {
			effect:[{name:"add_sp_resume", para:[7200,0.0006]}]
			, maxNum:2
			, desc: TextManager.STATIC_TEXT_CONSUMABLES_DESC_3
			, name: TextManager.STATIC_TEXT_CONSUMABLES_NAME_3
			, openTask:0
			, se: "resume_add"
			, price:200
			, demo:true
			, demoPrice:200
		}
		, "4": {
			effect:[{name:"add_zp_resume",para:[7200,0.00018]}]
			, maxNum:2
			, desc: TextManager.STATIC_TEXT_CONSUMABLES_DESC_4
			, name: TextManager.STATIC_TEXT_CONSUMABLES_NAME_4
			, openTask:0
			, se: "resume_add"
			, price:400
			, demo:true
			, demoPrice:400
		}
		, "5": {
			effect:[{name:"add_immue",para:[360]}]
			, maxNum:1
			, desc: TextManager.STATIC_TEXT_CONSUMABLES_DESC_5
			, name: TextManager.STATIC_TEXT_CONSUMABLES_NAME_5
			, openTask:0
			, price:600
			, demo:true
			, demoPrice:600
		}
	};
};

function Game_Weapons() {
	this.initialize(...arguments);
}

Game_Weapons.prototype.initialize = function() {
	this.clear();
	this._currentWeapon = this._unlock[0];
};

Game_Weapons.prototype.next = function() {
	const idx = this._unlock.indexOf(this._currentWeapon);
	const len = this._unlock.length;
	if(idx < len - 1) {
		return this._unlock[idx + 1];
	} else {
		return this._unlock[0];
	}
};

Game_Weapons.prototype.data = function() {
	return {
		"0": {
			desc: TextManager.STATIC_TEXT_WEAPONS_DESC_0
			, name: TextManager.STATIC_TEXT_WEAPONS_NAME_0
			, openTask:-1
			, attackName:"zxc_fish1"
			, demo:false
		}
		, "1": {
			desc: TextManager.STATIC_TEXT_WEAPONS_DESC_1
			, name: TextManager.STATIC_TEXT_WEAPONS_NAME_1
			, openTask:-1
			, attackName:"zxc_fish1"
			, demo:false
		}
		, "2": {
			desc: TextManager.STATIC_TEXT_WEAPONS_DESC_2
			, name: TextManager.STATIC_TEXT_WEAPONS_NAME_2
			, openTask:0
			, price:4500
			, attackName:"zxc_fish3"
			, demo:true
			, demoPrice:1200
		}
		, "3": {
			desc: TextManager.STATIC_TEXT_WEAPONS_DESC_3
			, name: TextManager.STATIC_TEXT_WEAPONS_NAME_3
			, openTask:-1
			, attackName:"zxc_fish1"
			, demo:false
		}
	};
};

Game_Weapons.prototype.clear = function() {
	this._unlock = [0];
};

Game_Weapons.prototype.unlock = function(dataId) {
	const data = this.data();
	if(data[dataId] && !this.isUnlock(dataId)) {
		this._unlock.push(dataId);
		this._unlock.sort();
	}
};

Game_Weapons.prototype.isUnlock = function(dataId) {
	return this._unlock.includes(dataId);
};

Game_Weapons.prototype.currentWeapon = function() {
	return this._currentWeapon;
};

Game_Weapons.prototype.equip = function(dataId) {
	if(this.currentWeapon() !== dataId && this.isUnlock(dataId)) {
		this._currentWeapon = dataId;
		return true;
	}
	return false;
};

Game_Weapons.prototype.currentZXCName = function() {
	const info = this.data()[this.currentWeapon()];
	return info.attackName;
};

function Game_Stones() {
	this.initialize(...arguments);
}

Game_Stones.prototype.initialize = function() {
	this.clear();
};

Game_Stones.prototype.unlock = function(dataId) {
	const data = this.data();
	if(data[dataId] && !this.isUnlock(dataId)) {
		this._unlock.push(dataId);
	}
};

Game_Stones.prototype.isUnlock = function(dataId) {
	return this._unlock.includes(dataId);
};

Game_Stones.prototype.clear = function() {
	this._unlock = [];
};

Game_Stones.prototype.isSubAttackSkill = function(dataId) {
	const info = this.data()[dataId];
	if(info.step) {
		return info.step.some((item) => {
			return item.some((subItem) => {
				return subItem.name === "subattack";
			});
		});
	}
	return false;
};

Game_Stones.prototype.data = function() {
	return {
		"0": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_0
			, name: TextManager.STATIC_TEXT_STONES_NAME_0
			, step:[[{name:"bullet",type:"press"},{name:"cancel",type:"press"}],[{name:"left",type:"hold"},{name:"bullet",type:"press"},{name:"cancel",type:"press"}]]
			, sampleImage:[[{name:";toru_dash_attack",index:4}],[{name:";toru_reverse_dash_attack",index:0}]]
			, openTask:0
			, price:4000
			, demo:true
			, demoPrice:1000
		}
		, "1": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_1
			, name: TextManager.STATIC_TEXT_STONES_NAME_1
			, step:[[{name:"down",type:"hold"}, {name:"subattack",type:"press"}]]
			, sampleImage:[[{name:";toru_down_dash_attack",index:1}]]
			, openTask:0
			, price:4000
			, demo:true
			, demoPrice:1000
		}
		, "2": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_2
			, name: TextManager.STATIC_TEXT_STONES_NAME_2
			, step:[[{name:"up",type:"hold"}, {name:"subattack",type:"press"}]]
			, sampleImage:[[{name:";toru_dash_down_attack",index:1}]]
			, openTask:0
			, price:4000
			, demo:false
		}
		, "3": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_3
			, name: TextManager.STATIC_TEXT_STONES_NAME_3
			, openTask:0
			, price:4000
			, demo:true
			, demoPrice:1000
		}
		, "4": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_4
			, name: TextManager.STATIC_TEXT_STONES_NAME_4
			, openTask:0
			, price:4000
			, demo:true
			, demoPrice:1000
		}
		, "5": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_5
			, name: TextManager.STATIC_TEXT_STONES_NAME_5
			, openTask:-1
			, demo:false
		}
		, "6": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_6
			, name: TextManager.STATIC_TEXT_STONES_NAME_6
			, openTask:-1
			, demo:false
		}
		, "7": {
			desc: TextManager.STATIC_TEXT_STONES_DESC_7
			, name: TextManager.STATIC_TEXT_STONES_NAME_7
			, openTask:-1
			, demo:false
		}
	};
};

function Game_Ornaments() {
	this.initialize(...arguments);
}

Game_Ornaments.prototype.initialize = function() {
	this.clear();
};

Game_Ornaments.prototype.clear = function() {
	this._equip = [];
	this._unlock = [];
	this._bell = 0;
};

Game_Ornaments.prototype.isEquip = function(dataId) {
	return this._equip.includes(dataId);
};

Game_Ornaments.prototype.isUnlock = function(dataId) {
	return this._unlock.includes(dataId);
};

Game_Ornaments.prototype.equip = function(dataId) {
	if(this._equip.length < this.maxEquip() && !this.isEquip(dataId) && this.isUnlock(dataId)) {
		this._equip.push(dataId);
		return true;
	}
	return false;
};

Game_Ornaments.prototype.unequip = function(dataId) {
	this._equip = this._equip.filter((id) => { return id !== dataId; });
	return true;
};

Game_Ornaments.prototype.maxEquip = function() {
	return 2 + Math.trunc(this._bell / 5);
};

Game_Ornaments.prototype.addBell = function() {
	this._bell++;
};

Game_Ornaments.prototype.unlock = function(dataId) {
	const data = this.data();
	if(data[dataId] && !this.isUnlock(dataId)) {
		this._unlock.push(dataId);
	}
};

Game_Ornaments.prototype.isAnyEquip = function() {
	return this._equip.length > 0;
};

Game_Actor.prototype.checkRaiseHpLockOrnaments = function(damage) {
	if(damage > 1 && this._ornaments.isEquip(0)) {
		if(this.battleObject().hp <= 0) {
			this.battleObject()._hp = 1;
			this.battleObject().addBuff("hp_lock", 150, 1, true);
			this.battleObject().delBuff("hp_resume");
			return true;
		}
	}
	return false;
};

Game_Actor.prototype.isDefenceShieldOrnaments = function() {
	return this._ornaments.isEquip(2);
};

Game_Actor.prototype.isBowOrnaments = function() {
	return this._ornaments.isEquip(3);
};

Game_Actor.prototype.checkRaiseDamageReflectionOrnaments = function(character, damage) {
	if(character && damage > 1 && this._ornaments.isEquip(1)) {
		character.requestDamage(damage, false);
	}
};

Game_Ornaments.prototype.data = function() {
	return {
		"0": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_0
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_0
			, openTask:-1
			, price:3000
			, demo:true
			, demoPrice:850
		}
		, "1": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_1
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_1
			, openTask:-1
			, price:3000
			, demo:true
			, demoPrice:850
		}
		, "2": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_2
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_2
			, openTask:0
			, price:3000
			, demo:true
			, demoPrice:850
		}
		, "3": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_3
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_3
			, openTask:0
			, price:3000
			, demo:true
			, demoPrice:850
		}
		, "4": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_4
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_4
			, openTask:-1
		}
		, "5": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_5
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_5
			, openTask:-1
		}
		, "6": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_6
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_6
			, openTask:-1
		}
		, "7": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_7
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_7
			, openTask:-1
		}
		, "8": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_8
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_8
			, openTask:-1
		}
		, "9": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_9
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_9
			, openTask:-1
		}
		, "10": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_10
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_10
			, openTask:-1
		}
		, "11": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_11
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_11
			, openTask:-1
		}
		, "12": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_12
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_12
			, openTask:-1
			, price:3000
		}
		, "13": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_13
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_13
			, openTask:-1
		}
		, "14": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_14
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_14
			, openTask:-1
		}
		, "15": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_15
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_15
			, openTask:-1
		}
		, "16": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_16
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_16
			, openTask:-1
		}
		, "17": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_17
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_17
			, openTask:-1
		}
		, "18": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_18
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_18
			, openTask:-1
		}
		, "19": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_19
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_19
			, openTask:-1
		}
		, "20": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_20
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_20
			, openTask:-1
		}
		, "21": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_21
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_21
			, openTask:-1
		}
		, "22": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_22
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_22
			, openTask:-1
		}
		, "23": {
			desc: TextManager.STATIC_TEXT_ORNAMENTS_DESC_23
			, name: TextManager.STATIC_TEXT_ORNAMENTS_NAME_23
			, openTask:-1
		}
	};
};

Game_Ornaments.prototype.bellData = function() {
	return {
		desc: TextManager.STATIC_TEXT_BELL_DESC
		, name: TextManager.STATIC_TEXT_BELL_NAME
	};
};

NYA.GAME.SYSTEM.Game_Actor_initMembers = Game_Actor.prototype.initMembers;
Game_Actor.prototype.initMembers = function() {
	NYA.GAME.SYSTEM.Game_Actor_initMembers.apply(this, arguments);
	this._consumables = new Game_Consumables();
	this._weapons = new Game_Weapons();
	this._stones = new Game_Stones();
	this._ornaments = new Game_Ornaments();
	this._task = [];
	this._taskShowing = [];
	this._taskCompleted = [];
	this._useConsumableReady = -1;
	this._taskProgress = {};
};

NYA.GAME.SYSTEM.Game_Actor_setup = Game_Actor.prototype.setup;
Game_Actor.prototype.setup = function() {
	NYA.GAME.SYSTEM.Game_Actor_setup.apply(this, arguments);
	this._consumables.clear();
	this._weapons.clear();
	this._stones.clear();
	this._ornaments.clear();
	this._coin = 0;
	this._task = [];
	this._taskShowing = [];
	this._taskCompleted = [];
	this._taskCompletedShowing = [];
	this._useConsumableReady = -1;
	this._taskProgress = {};
	this._battleObject = new Game_BattleObject(Utils.tryParseInt(this.actor().meta.battleObjectId, 0));
};

Game_Actor.prototype.addBell = function() {
	this._ornaments.addBell();
};

Game_Actor.prototype.bellNum = function() {
	return this._ornaments._bell;
};

Game_Actor.prototype.requestUseConsumable = function(id) {
	if(this._consumables.itemNum(id)) {
		this._useConsumableReady = id;
		return true;
	}
	return false;
};

Game_Actor.prototype.findConsumableUsing = function() {
	for(const key in this._consumables.data()) {
		const id = parseInt(key);
		if(this.requestUseConsumable(id)) {
			break;
		}
	}
	return this.isConsumableUsing();
};

Game_Actor.prototype.isConsumableUsing = function() {
	return this._useConsumableReady !== -1;
};

Game_Actor.prototype.clearConsumableUsing = function() {
	return this._useConsumableReady = -1;
};

Game_Actor.prototype.consumableUsing = function() {
	return this._useConsumableReady;
};

Game_Actor.prototype.addTask = function(taskId) {
	if(!this.hasTask(taskId)) {
		this._task.push(taskId);
		this._taskShowing.push(taskId);
	}
};

Game_Actor.prototype.getProgress = function(taskId) {
	
};

Game_Actor.prototype.hasTask = function(taskId) {
	return this._task.includes(taskId);
};

Game_Actor.prototype.hasTaskComplete = function(taskId) {
	return this._taskCompleted.includes(taskId);
};

Game_Actor.prototype.completeTask = function(taskId) {
	this.delTask(taskId);
	if(!this._taskCompleted.includes(taskId)) {
		this._taskCompleted.push(taskId);
		this._taskCompletedShowing.push(taskId);
		const data = $dataTask[taskId];
		if(data.type === 0) {
			const latestMainTaskVarId = 4;
			$gameVariables.setValue(latestMainTaskVarId, taskId);
		}
		if(data.nextId) {
			this.addTask(data.nextId);
		}
		if(data.coin) {
			this.addCoin(data.coin);
		}
		if(data.maxProgress) {
			this.setTaskProgress(taskId, 0);
		}
		if(data.openSwitch) {
			$gameSwitches.setValue(data.openSwitch, true);
		}
	}
};

Game_Actor.prototype.delTask = function(taskId) {
	this._task.remove(taskId);
	this._taskShowing.remove(taskId);
};

Game_Actor.prototype.isTaskCompleted = function(taskId) {
	return this._taskCompleted.includes(taskId);
};

Game_Actor.prototype.tasks = function() {
	return this._task;
};

Game_Actor.prototype.getShowingTask = function() {
	return this._taskShowing.pop();
};

Game_Actor.prototype.getCompleteShowingTask = function() {
	return this._taskCompletedShowing.pop();
};

Game_Actor.prototype.triggerTask = function(triggerType, para = 0, num = 1) {
	const tasks = this.tasks().slice();
	for(const taskId of tasks) {
		const data = $dataTask[taskId];
		if(data.trigger === triggerType && data.parameter === para) {
			const progress = this.addTaskProgress(taskId, num);
			if(progress >= data.maxProgress) {
				this.completeTask(taskId);
			}
		}
	}
};

Game_Actor.prototype.getTaskProgress = function(taskId) {
	if(!this._taskProgress[taskId]) {
		this.setTaskProgress(taskId, 0);
	}
	return this._taskProgress[taskId];
};

Game_Actor.prototype.addTaskProgress = function(taskId, num) {
	const num2 = this.getTaskProgress(taskId) + num;
	this.setTaskProgress(taskId, num2);
	return num2;
};

Game_Actor.prototype.setTaskProgress = function(taskId, val) {
	this._taskProgress[taskId] = val;
};

Game_Actor.prototype.addCoin = function(coin) {
	this._coin += coin;
	this._coin = Math.min(this._coin, 99999);
};

Game_Player.prototype.addCoin = function(coin) {
	this.actor().addCoin(coin);
};

Game_Actor.prototype.deductCoin = function(coin) {
	if(this._coin < coin) {
		return false;
	}
	this._coin -= coin;
	return true;
};

Game_Actor.prototype.isCoinEnough = function(coin) {
	return this._coin >= coin;
};

Game_Actor.prototype.coin = function() {
	return this._coin;
};

Game_Actor.prototype.isCoinLackOfAllShowItems = function() {
	const shopData = this.shopData();
	const coin = this.coin();
	return shopData.every((item) => {
		if(!item.price) { return false; }
		return coin < item.price;
	});
};

// item是来自shopData函数返回的result里的数组项
// 也可自行构造
Game_Actor.prototype.addItem = function(item, noMaxControl, obtain = true, num = 1) {
	switch(item.type) {
		case "consumables": this.addConsumables(item.idx, num, noMaxControl); break;
		case "weapons": this.unlockWeapons(item.idx); break;
		case "stones": this.unlockStones(item.idx); break;
		case "ornaments": this.unlockOrnaments(item.idx); break;
		case "bell": this.addBell(); break;
	}
	if(obtain) { 
		$gameSystem.setLastObtainItem(item);
	}
};

Game_Actor.prototype.itemData = function(item) {
	switch(item.type) {
		case "consumables": return this._consumables.data()[item.idx];
		case "weapons": return this._weapons.data()[item.idx];
		case "stones": return this._stones.data()[item.idx];
		case "ornaments": return this._ornaments.data()[item.idx];
		case "bell": return this._ornaments.bellData();
	}
};

Game_Actor.prototype.addConsumables = function(dataId, num = 1, noMaxControl) {
	this._consumables.add(dataId, num, noMaxControl);
};

Game_Actor.prototype.foldConsumables = function(f) {
	const data = this._consumables.data();
	for(const k in data) {
		const num = this._consumables.itemNum(k);
		f(parseInt(k), data[k], num);
	}
};

Game_Actor.prototype.performUseConsumable = function() {
	const id = this.consumableUsing();
	if(this._consumables.deductNum(id, 1)) {
		this.executeConsumableEffect(this._consumables.data()[id]);
	}
};

Game_Actor.prototype.executeConsumableEffect = function(data) {
	const useDefaultSe = !data.se;
	AudioManager.playNormalSe(data.se);
	for(const effect of data.effect) {
		switch(effect.name) {
			case "add_hp": {
				const addRate = effect.para[0];
				const addHp = Math.round(addRate * this.battleObject().mhp);
				this.battleObject().addHp(addHp);
				$gameMap.addDamageDigit($gamePlayer, -addHp);
				break;
			}
			case "add_immue": {
				const time = effect.para[0];
				this.battleObject().addBuff("anti_stagger", time, 1, useDefaultSe, "consumables");
				break;
			}
			case "add_sp_resume": {
				const time = effect.para[0];
				const resume = effect.para[1] * this.battleObject().msp;
				this.battleObject().addBuff("sp_resume", time, resume, useDefaultSe, "consumables");
				break;
			}
			case "add_hp_resume": {
				const time = effect.para[0];
				const resume = effect.para[1] * this.battleObject().mhp;
				this.battleObject().addBuff("hp_resume", time, resume, useDefaultSe, "consumables");
				break;
			}
			case "add_zp_resume": {
				const time = effect.para[0];
				const resume = effect.para[1] * this.battleObject().mzp;
				this.battleObject().addBuff("zp_resume", time, resume, useDefaultSe, "consumables");
				break;
			}
			default: break;
		}
	}
};

Game_Actor.prototype.isWeaponUnlock = function(dataId) {
	return this._weapons.isUnlock(dataId);
};

Game_Actor.prototype.currentWeapon = function() {
	return this._weapons.currentWeapon();
};

Game_Actor.prototype.unlockWeapons = function(dataId) {
	this._weapons.unlock(dataId);
};

Game_Actor.prototype.foldWeapons = function(f) {
	const data = this._weapons.data();
	for(const k in data) {
		const id = parseInt(k);
		f(id, data[k], this._weapons.isUnlock(id));
	}
};

Game_Actor.prototype.isWeaponEquip = function(dataId) {
	return this.currentWeapon() === dataId;
};

Game_Actor.prototype.changeWeapon = function(dataId) {
	return this._weapons.equip(dataId);
};

Game_Actor.prototype.nextWeapon = function() {
	return this._weapons.next();
};

Game_Actor.prototype.isStoneUnlock = function(dataId) {
	return this._stones.isUnlock(dataId);
};

Game_Actor.prototype.unlockStones = function(dataId) {
	this._stones.unlock(dataId);
};

Game_Actor.prototype.foldStones = function(f) {
	const data = this._stones.data();
	for(const k in data) {
		const id = parseInt(k);
		f(id, data[k], this._stones.isUnlock(id));
	}
};

Game_Actor.prototype.ornamentsRest = function(dataId) {
	return Math.max(0, this._ornaments.maxEquip() - this._ornaments._equip.length);
};

Game_Actor.prototype.isOrnamentEquip = function(dataId) {
	return this._ornaments.isEquip(dataId);
};

Game_Actor.prototype.unlockOrnaments = function(dataId) {
	return this._ornaments.unlock(dataId);
};

Game_Actor.prototype.changeOrnament = function(dataId) {
	if(this.isOrnamentEquip(dataId)) {
		return this._ornaments.unequip(dataId);
	} else {
		return this._ornaments.equip(dataId);
	}
};

Game_Actor.prototype.foldOrnaments = function(f) {
	const data = this._ornaments.data();
	for(const k in data) {
		const id = parseInt(k);
		f(id, data[k], this._ornaments.isUnlock(id));
	}
};

Game_Actor.prototype.hasAnyConsumable = function() {
	return this._consumables.hasAnyItem();
};

Game_Actor.prototype.battleObject = function() {
	return this._battleObject;
};

Game_Actor.prototype.jumpStrength = function() {
	return this.battleObject().jumpStrength;
};

Game_Actor.prototype.moveStrength = function() {
	return this.battleObject().moveStrength;
};

Game_Actor.prototype.maxMoveSpeed = function() {
	return this.battleObject().maxMoveSpeed;
};

Game_Actor.prototype.doubleJumpRate = function() {
	return this.battleObject().doubleJumpRate;
};

Game_Actor.prototype.doubleJumpStrength = function() {
	return this.doubleJumpRate() * this.jumpStrength();
};

Game_Actor.prototype.doubleJump = function() {
	return this.battleObject().doubleJump;
};

Game_Actor.prototype.jumpDashNum = function() {
	return this.battleObject().jumpDashNum;
};

Game_Actor.prototype.jumpDashTime = function() {
	return this.battleObject().jumpDashTime;
};

Game_Actor.prototype.jumpDashRate = function() {
	return this.battleObject().jumpDashRate;
};

Game_Actor.prototype.jumpDashStrength = function() {
	return this.jumpDashRate() * this.maxMoveSpeed();
};

Game_Actor.prototype.hitRect = function() {
	return this.battleObject().hitRect;
};

Game_Actor.prototype.movingImage = function() {
	return this.battleObject().movingImage;
};

Game_Actor.prototype.standingImage = function() {
	return this.battleObject().standingImage;
};

Game_Actor.prototype.jumpUpImage = function() {
	return this.battleObject().jumpUpImage;
};

Game_Actor.prototype.jumpDownImage = function() {
	return this.battleObject().jumpDownImage;
};

Game_Actor.prototype.jumpMiddleImage = function() {
	return this.battleObject().jumpMiddleImage;
};

Game_Actor.prototype.jumpGroundImage = function() {
	return this.battleObject().jumpGroundImage;
};

Game_Actor.prototype.doubleJumpUpImage = function() {
	return this.battleObject().doubleJumpUpImage;
};

Game_Actor.prototype.staggerImage = function() {
	return this.battleObject().staggerImage;
};

Game_Actor.prototype.wallDownImage = function() {
	return this.battleObject().wallDownImage;
};

Game_Actor.prototype.getDownImage = function() {
	return this.battleObject().getDownImage;
};

Game_Actor.prototype.getDownMoveImage = function() {
	return this.battleObject().getDownMoveImage;
};

Game_Actor.prototype.attackSlashAnimations = function() {
	return this.battleObject().attackSlashAnimations;
};

Game_Actor.prototype.beHitInvincibleTime = function() {
	return this.battleObject().beHitInvincibleTime - 20;
};

Game_Actor.prototype.deathCoin = function() {
	return this.battleObject().coin;
};

Game_Actor.prototype.shopData = function() {
	const result = [];
	const consumablesData = this._consumables.data();
	for(const idstr in consumablesData) {
		const id = parseInt(idstr);
		const consumable = consumablesData[id];
		const openTaskId = consumable.openTask;
		if((this.isTaskCompleted(openTaskId) || openTaskId === 0) && (!NYA.DEMO || consumable.demo)) {
			consumable.hasNum = this._consumables.itemNum(id);
			consumable.itemNum = Math.max(0, consumable.maxNum - consumable.hasNum);
			consumable.type = "consumables";
			consumable.idx = parseInt(id);
			result.push(consumable);
		}
	}
	const weaponsData = this._weapons.data();
	for(const idstr in weaponsData) {
		const id = parseInt(idstr);
		const weapon = weaponsData[id];
		const openTaskId = weapon.openTask;
		if((this.isTaskCompleted(openTaskId) || openTaskId === 0) && (!NYA.DEMO || weapon.demo)) {
			weapon.itemNum = this._weapons.isUnlock(id) ? 0 : 1;
			weapon.hasNum = weapon.itemNum === 0 ? 1 : 0;
			weapon.type = "weapons";
			weapon.idx = parseInt(id);
			weapon.itemNum > 0 && result.push(weapon);
		}
	}
	const stonesData = this._stones.data();
	for(const idstr in stonesData) {
		const id = parseInt(idstr);
		const stone = stonesData[id];
		const openTaskId = stone.openTask;
		if((this.isTaskCompleted(openTaskId) || openTaskId === 0) && (!NYA.DEMO || stone.demo)) {
			stone.itemNum = this._stones.isUnlock(id) ? 0 : 1;
			stone.hasNum = stone.itemNum === 0 ? 1 : 0;
			stone.type = "stones";
			stone.idx = parseInt(id);
			stone.itemNum > 0 && result.push(stone);
		}
	}
	const ornamentsData = this._ornaments.data();
	for(const idstr in ornamentsData) {
		const id = parseInt(idstr);
		const ornament = ornamentsData[id];
		const openTaskId = ornament.openTask;
		if((this.isTaskCompleted(openTaskId) || openTaskId === 0) && (!NYA.DEMO || ornament.demo)) {
			ornament.itemNum = this._ornaments.isUnlock(id) ? 0 : 1;
			ornament.hasNum = ornament.itemNum === 0 ? 1 : 0;
			ornament.type = "ornaments";
			ornament.idx = parseInt(id);
			ornament.itemNum > 0 && result.push(ornament);
		}
	}
	return result.sort((a, b) => {
		if(a.itemNum > 0 && b.itemNum > 0 || a.itemNum < 0 && b.itemNum < 0) {
			return 0;
		}
		if(a.itemNum === 0) {
			return 1;
		}
		return -1;
	});
};

Game_Event.prototype.battleObject = function() {
	return this._battleObject;
};

Game_Event.prototype.initBattleObject = function(templateId) {
	this._battleObject = new Game_BattleObject(templateId);
	this._physicsFlag = this._battleObject.physicsFlag || 0;
	this._lighting = this._battleObject.lighting;
};

Game_Player.prototype.battleObject = function() {
	return this.actor().battleObject();
};

function Game_BattleObject() {
	this.initialize(...arguments);
}

Game_BattleObject.prototype.initialize = function(templateId) {
	this._templateId = templateId;
	this._hp = 1;
	this._mhp = 1;
	this._buff = [];
	
	this.initConfigMembers();
	this.applyTemplate(templateId);
	this.hp = this.mhp;
	this.sp = this.msp;
	this.zp = (this.mzp / 2) | 0;
	this._unlockSkill = [];
	this.initControlValues();
};

Game_BattleObject.prototype.initConfigMembers = function() {
	this.msp = 0;
	this.mzp = 0;
	this.jumpStrength = 0;
	this.moveStrength = 0;
	this.maxMoveSpeed = 0;
	this.doubleJumpRate = 0;
	this.doubleJump = false;
	this.jumpDashNum = 0;
	this.jumpDashTime = 0;
	this.jumpDashRate = 0;
	this.beHitInvincibleTime = 0;
	this.dashJumpAddSpeed = 0;
	this.hitRect = {l:0, t:0, r:0, b:0};
	this.movingImage = '';
	this.standingImage = '';
	this.jumpUpImage = '';
	this.doubleJumpUpImage = '';
	this.jumpDownImage = '';
	this.jumpMiddleImage = '';
	this.jumpGroundImage = '';
	this.staggerImage = '';
	this.wallDownImage = '';
	this.attackSlashAnimations = [];
	this.spResumeWaiting = 0;
	this.spResumeSpeed = 0;
	this.onHitSe = [];
	this.team = 0;
	this.player = false;
	this.faceName = '';
	this.dangerFaceName = '';
	this.deathAnimation = 0;
	this.unlimitHp = false;
	this.coin = [];
	this.targets = [];
	this.maxWaiting = 0;
	this.minWaiting = 0;
	this.specailHitFlag = 0;
	this.immueSquash = false;
	this.physicsFlag = 0;
	this.fallDownReset = false;
	this.fallDownSe = "";
	this.fallDownCommonEventId = 0;
	this.playerAttachDistance = 0;
	this.factorA = 0;
	this.isBoss = false;
	this.lighting = null;
	this.beAttackSlashAnimations = [];
	this.factorB = [];
	this.noDeathShake = false;
	this.noHotEvent = false;
	this.deathFadeoutDuration = 0;
	this.mapRecoverCreate = false;
	this.hitCreateFragment = [];
	this.isMonster = false;
	this.enableFloatMessage = false;
	this.deathAddZp = 0;
	this.sfadd = 1;
	this.upElasticWithJumpStrength = 0;
	this.alwaysShowDamageDigit = false;
	this.deathNoZp = false;
	this.getDownImage = "";
	this.getDownMoveImage = "";
	this.immueDeath = false;
	this.immueStaggerAttack = false;
	this.hasSpecProgress = false;
	this.hint = [];
};

Game_BattleObject.prototype.templateId = function() {
	return this._templateId;
};

Object.defineProperty(Game_BattleObject.prototype, "hp", {
	get: function() {
		return this._hp | 0;
	},
	set: function(val) {
		if(this._hp !== 0) {
			this._hp = Math.max(0, val);
		}
		if(this._hp < 1 && (this.getBuffVal("hp_lock") !== 0 || this.immueDeath)) {
			this._hp = 1;
		}
	},
	configurable: true
});

Object.defineProperty(Game_BattleObject.prototype, "mhp", {
	get: function() {
		if(!this.isPlayerObject()) {
			return this._mhp;
		}
		switch($gameSystem.difficulty()) {
			case 0: return this._mhp;
			case -1: return this._mhp + 100;
			case -2: return this._mhp + 200;
			default: return this._mhp;
		}
	},
	set: function(val) {
		this._mhp = val;
	},
	configurable: true
});

Object.defineProperty(Game_BattleObject.prototype, "jumpStrength", {
	get: function() {
		return this._jumpStrength * (1 - this.getBuffVal("jump_down"));
	},
	set: function(val) {
		this._jumpStrength = val;
	},
	configurable: true
});

Object.defineProperty(Game_BattleObject.prototype, "maxMoveSpeed", {
	get: function() {
		return this._maxMoveSpeed * (1 + this.getBuffVal("mov_up") - this.getBuffVal("mov_down"));
	},
	set: function(val) {
		this._maxMoveSpeed = val;
	},
	configurable: true
});

Game_BattleObject.prototype.applyTemplate = function(templateId) {
	const realId = templateId ? templateId : 0;
	const template = Game_BattleObject.template();
	Object.assign(this, template[realId]);
};

Game_BattleObject.prototype.initField = function(field) {
	const template = Game_BattleObject.template()[this._templateId];
	if(template[field]) {
		this[field] = template[field];
	}
};

Game_BattleObject.prototype.addBuff = function(name, time, para = 1, se = false, src = "", ext) {
	let effectId = 0;
	let effectInterval = 0;
	if(ext) {
		effectId = ext.effectId;
		effectInterval = ext.effectInterval;
	}
	for(const buff of this._buff) {
		if(buff.name === name) {
			buff.time = time;
			buff.maxTime = time;
			buff.para = para;
			buff.src = src;
			buff.effectId = effectId;
			buff.effectInterval = effectInterval;
			return;
		}
	}
	this._buff.push({name:name, time:time, maxTime:time, para:para, src:src, effectId:effectId, effectInterval:effectInterval});
	se && AudioManager.playNormalSe("buff_add");
};

Game_BattleObject.prototype.delBuff = function(name) {
	this._buff = this._buff.filter((buff) => {
		if(buff.name !== name) {
			return true;
		}
		buff.time = 0;
		return false;
	});
};

Game_BattleObject.prototype.getBuffVal = function(name) {
	for(const buff of this._buff) {
		if(buff.name === name) {
			return buff.para;
		}
	}
	return 0;
};

Game_BattleObject.prototype.updateBuff = function() {
	this._buff = this._buff.filter((buff) => {
		buff.time--;
		if(buff.time <= 0) {
			return false;
		}
		return true;
	});
};

Game_BattleObject.prototype.clearBuff = function() {
	this._buff = [];
};

Game_BattleObject.prototype.initControlValues = function() {
	this._vsp = this.sp;
	this._spResumePause = 0;
};

Game_BattleObject.prototype.update = function() {
	this.updateHp();
	this.updateSp();
	this.updateZp();
	this.updateBuff();
};

Game_BattleObject.prototype.allBuff = function() {
	return this._buff;
};

Game_BattleObject.prototype.isPlayerObject = function() {
	return !!this.player;
};

Game_BattleObject.prototype.addHp = function(hp) {
	this.hp = this._hp + hp;
	this.hp = this._hp.clamp(0, this.mhp);
};

Game_BattleObject.prototype.addZp = function(zp) {
	this.zp += zp;
	this.zp = this.zp.clamp(0, this.mzp);
};

Game_BattleObject.prototype.useZp = function(zp) {
	if(this.zp >= zp) {
		this.addZp(-zp);
		return true;
	}
	return true;
};

Game_BattleObject.prototype.updateHp = function() {
	const add = this.getBuffVal("hp_resume") - this.getBuffVal("hp_drop") + this.getBuffVal("hp_resume_very_easy");
	if(add !== 0) {
		this.addHp(add);
	}
};

Game_BattleObject.prototype.updateSp = function() {
	if(!this.msp) {
		return;
	}
	if(this._spResumePause > 0) {
		this._spResumePause--;
	}
	if(this._vsp > this.sp) {
		this._spResumePause = this.spResumeWaiting;
		this._vsp = this.sp;
	}
	if(!this._spResumePause && this.sp < this.msp) {
		this.sp += (this.spResumeSpeed + this.getBuffVal("sp_resume") - this.getBuffVal("sp_drop"));
		this._vsp = this.sp;
		if(this.sp > this.msp) {
			this.sp = this.msp;
		}
	}
};

Game_BattleObject.prototype.updateZp = function() {
	const add = this.getBuffVal("zp_resume");
	if(add !== 0) {
		this.addZp(add);
	}
};

Game_BattleObject.template = function() {
	return this._template;
};

Game_BattleObject._template = {
		"0": {
			mhp:100
			,msp:100
			,mzp:200
			,_jumpStrength:-13		// 跳跃动力
			,moveStrength:2.8		// 行走动力
			,_maxMoveSpeed:6			// 最大行走速度
			,doubleJumpRate:0.75    // 二段跳动力比率（相对于一段跳）
			,doubleJump:true		// 是否有二段跳
			,jumpDashNum:2			// 空中冲刺最大次数
			,jumpDashTime:10		// 空中冲刺滞空时间
			,jumpDashRate:2			// 空中冲刺动力比率（相对于最大行走速度）
			,beHitInvincibleTime:90 // 受击无敌时间
			,dashJumpAddSpeed:4		// 前冲跳跃在落地前增加最大移动速度
			,hitRect:{				// 物理引擎判定矩形
				l:26
				,t:88
				,r:26
				,b:0
			}
			,movingImage:';toru_move'
			,standingImage:';toru_standing'
			,attack1Image:';toru_normal_attack1'
			,attack1MovingImage:';toru_normal_attack1'
			,jumpUpImage:';toru_jump_up'
			,doubleJumpUpImage:';toru_double_jump_up'
			,jumpDownImage:';toru_jump_down'
			,jumpMiddleImage:';toru_jump_middle'
			,jumpGroundImage:';toru_jump_ground'
			,staggerImage:';toru_stagger'
			,wallDownImage:';toru_walldown'
			,getDownMoveImage:';toru_get_down_move'
			,getDownImage:';toru_get_down'
			,attackSlashAnimations:[1]
			,spResumeWaiting:0
			,spResumeSpeed:0.2
			,onHitSe:["player_hit_01", "player_hit_02", "player_hit_03"]
			,team:0
			,player:true
			,faceName:"map_player_face1"
			,dangerFaceName:"map_player_face_danger1"
			,deathAnimation:0
		}
		,"1": {
			mhp:1
			,unlimitHp:true
			,onHitSe:["woodenonhit"]
			,team:-1
			,deathAnimation:3
		}
		,"2": {
			mhp:48
			, _jumpStrength:-8
			, hitRect:{
				l:22
				,t:46
				,r:22
				,b:0
			}
			, standingImage:";cat1_stand"
			, movingImage:";cat1_move"
			, staggerImage:";cat1_stagger"
			, moveStrength:0.7		
			, _maxMoveSpeed:3
			, coin:[{num:1,count:1},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, lighting: {r:0.2,g:0,b:0,max:1,radius:200}
			, isMonster: true
			, mapRecoverCreate:true
		}
		,"3": {
			mhp:60
			, _jumpStrength:-13
			, hitRect:{
				l:26
				,t:68
				,r:26
				,b:0
			}
			, standingImage:";cat2_stand"
			, movingImage:";cat2_move"
			, staggerImage:";cat2_stagger"
			, moveStrength:0.6		
			, _maxMoveSpeed:2.2	
			, coin:[{num:1,count:3},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, lighting: {r:0.2,g:0.2,b:0,max:1,radius:200}
			, isMonster: true
			, mapRecoverCreate:true
		}
		,"4": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-12
			,hitRect:{
				l:28
				,t:98
				,r:28
				,b:0
			}
			, team:-2
			, movingImage:';resident1_move'
			, standingImage:';resident1_standing'
			, moveStrength:2
			, _maxMoveSpeed:3
			, targets:[{x:270,y:964,smooth:32},{x:960,y:964,smooth:32},{x:2688,y:964,smooth:32},{x:3216,y:964,smooth:32}, {x:862,y:768,smooth:16}]
			, maxWaiting:900
			, minWaiting:360
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"5": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-14
			,hitRect:{
				l:26
				,t:102
				,r:26
				,b:0
			}
			, team:-2
			, movingImage:';resident3_move'
			, standingImage:';resident3_standing'
			, moveStrength:2
			, _maxMoveSpeed:3
			, targets:[{x:1056,y:964,smooth:32},{x:1536,y:964,smooth:32},{x:2016,y:918,smooth:32},{x:2256,y:724,smooth:32}, {x:3648,y:768,smooth:16}]
			, maxWaiting:1280
			, minWaiting:480
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"6": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-10
			,hitRect:{
				l:26
				,t:102
				,r:26
				,b:0
			}
			, team:-2
			, movingImage:';resident2_move'
			, standingImage:';resident2_standing'
			, moveStrength:2
			, _maxMoveSpeed:3.6
			, targets:[{x:774,y:964,smooth:32},{x:1152,y:964,smooth:32},{x:1632,y:964,smooth:32},{x:2496,y:918,smooth:32}, {x:3072,y:768,smooth:16}]
			, maxWaiting:1080
			, minWaiting:280
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"7": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-12
			,hitRect:{
				l:28
				,t:98
				,r:28
				,b:0
			}
			, team:-2
			, movingImage:';resident4_move'
			, standingImage:';resident4_standing'
			, moveStrength:2
			, _maxMoveSpeed:3
			, targets:[{x:1488,y:980,smooth:32}]
			, maxWaiting:200
			, minWaiting:100
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"8": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-11
			,hitRect:{
				l:26
				,t:102
				,r:26
				,b:0
			}
			, team:-2
			, movingImage:';resident5_move'
			, standingImage:';resident5_standing'
			, moveStrength:2
			, _maxMoveSpeed:4
			, targets:[{x:1680,y:980,smooth:32}]
			, maxWaiting:200
			, minWaiting:100
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"9": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-16
			,hitRect:{
				l:26
				,t:102
				,r:26
				,b:0
			}
			, team:-2
			, movingImage:';resident6_move'
			, standingImage:';resident6_standing'
			, moveStrength:2
			, _maxMoveSpeed:3
			, targets:[{x:624,y:768,smooth:32},{x:912,y:768,smooth:32}]
			, maxWaiting:360
			, minWaiting:1220
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"10": {
			mhp:1
			, unlimitHp:true
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:-1
			, deathAnimation:8
			, immueSquash:true
		}
		,"11": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-17
			,hitRect:{
				l:25
				,t:90
				,r:25
				,b:0
			}
			, team:-2
			, movingImage:';berries_move'
			, standingImage:';berries_standing'
			, jumpUpImage:';berries_jumpup'
			, jumpDownImage:';berries_jumpdown'
			, moveStrength:0.5
			, _maxMoveSpeed:3
			, targets:[]
			, maxWaiting:360
			, minWaiting:1220
			, deathAnimation:3
			, enableFloatMessage:true
			, fallDownReset:true
			, fallDownSe:"player_fall"
		}
		,"12": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-12.5
			,hitRect:{
				l:38
				,t:82
				,r:38
				,b:0
			}
			, team:-2
			, movingImage:';wall_mushroom_move'
			, standingImage:';wall_mushroom'
			, deathAnimation:3
			, physicsFlag:6
		}
		,"13": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-16
			,hitRect:{
				l:39
				,t:80
				,r:39
				,b:0
			}
			, team:1
			, movingImage:';mushroom_move'
			, standingImage:';mushroom'
			, deathAnimation:3
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, physicsFlag:6
		}
		,"14": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-16
			, team:-2
			, standingImage:';forest_stone2'
			, deathAnimation:3
			, immueSquash:true
			, fallDownReset:true
		}
		,"15": {
			mhp:48
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";cat3_stand"
			, movingImage:";cat3_stand"
			, staggerImage:";cat3_stand"
			, moveStrength:3	
			, _maxMoveSpeed:8
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, isMonster: true
			, coin:[{num:1,count:1},{num:5,count:1}]
		}
		,"16": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:1172,y:1005},{x:3264,y:1005},{x:3264,y:3405},{x:672,y:3405},{x:672,y:1005}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"17": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:1172,y:1005},{x:3264,y:1005},{x:3264,y:3405},{x:672,y:3405},{x:672,y:1005}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"18": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:3264,y:3000},{x:3264,y:3405},{x:672,y:3405},{x:672,y:1005},{x:3264,y:1005}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"19": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:3264,y:3000},{x:3264,y:3405},{x:672,y:3405},{x:672,y:1005},{x:3264,y:1005}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"20": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:0
			,hitRect:{
				l:40
				,t:58
				,r:40
				,b:0
			}
			, team:-1
			, movingImage:';forest_terrain_damage'
			, standingImage:';forest_terrain_damage'
			, deathAnimation:3
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, physicsFlag:6
		}
		,"21": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:144,y:710},{x:1344,y:710}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"22": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:144,y:710},{x:1344,y:710}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"23": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:1344,y:518},{x:2400,y:518}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"24": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:1344,y:518},{x:2400,y:518}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"25": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:2400,y:902},{x:3198,y:902}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"26": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:2400,y:902},{x:3198,y:902}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"27": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-16
			, hitRect:{
				l:29
				,t:48
				,r:29
				,b:0
			}
			, standingImage:";author"
			, movingImage:";author"
			, moveStrength:0.7		
			, _maxMoveSpeed:3
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:-2
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, targets:[]
			, fallDownReset:true
			, fallDownCommonEventId:11
			, enableFloatMessage:true
		}
		,"28": {
			mhp:60
			, _jumpStrength:-12
			, hitRect:{
				l:41
				,t:84
				,r:41
				,b:0
			}
			, standingImage:";mushroom_monster"
			, movingImage:";mushroom_monster"
			, staggerImage:";mushroom_stagger"
			, moveStrength:1		
			, _maxMoveSpeed:5	
			, coin:[{num:1,count:2},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, lighting: {r:0,g:0,b:0.2,max:1,radius:200}
			, isMonster: true
			, mapRecoverCreate:true
		}
		,"29": {
			mhp:76
			, _jumpStrength:-13
			, hitRect:{
				l:30
				,t:124
				,r:30
				,b:0
			}
			, standingImage:";cat4_stand"
			, movingImage:";cat4_move"
			, staggerImage:";cat4_stagger"
			, moveStrength:3
			, _maxMoveSpeed:7
			, coin:[{num:1,count:3},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, isMonster: true
			, mapRecoverCreate:true
		}
		,"30": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:528,y:2416},{x:528,y:626}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"31": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:528,y:2416},{x:528,y:626}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"32": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:972,y:3405},{x:672,y:3405},{x:672,y:1005},{x:3264,y:1005},{x:3264,y:3405}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"33": {
			mhp:1
			,unlimitHp:true
			, _jumpStrength:-12
			,hitRect:{
				l:36
				,t:50
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_upper"
			, moveStrength:4	
			, _maxMoveSpeed:4
			, targets:[{x:972,y:3405},{x:672,y:3405},{x:672,y:1005},{x:3264,y:1005},{x:3264,y:3405}]
			, team:-2
			, deathAnimation:3
			, immueSquash:true
		}
		,"34": {
			mhp:100
			,msp:100
			,mzp:200
			,unlimitHp:true
			,_jumpStrength:-17		// 跳跃动力
			,moveStrength:4			// 行走动力
			,_maxMoveSpeed:6			// 最大行走速度
			,jumpDashNum:2			// 空中冲刺最大次数
			,jumpDashTime:10		// 空中冲刺滞空时间
			,jumpDashRate:2			// 空中冲刺动力比率（相对于最大行走速度）
			,beHitInvincibleTime:120// 受击无敌时间
			,dashJumpAddSpeed:4		// 前冲跳跃在落地前增加最大移动速度
			,hitRect:{				// 物理引擎判定矩形
				l:26
				,t:88
				,r:26
				,b:0
			}
			,movingImage:';lily_move'
			,standingImage:';lily_standing'
			,jumpUpImage:';lily_jump_up'
			,jumpDownImage:';lily_jump_down'
			,staggerImage:';lily_stagger'
			,faceName:"map_player_face3"
			,dangerFaceName:"map_player_face3"
			,jumpMiddleImage:';lily_jump_up'
			,attackSlashAnimations:[]
			,spResumeWaiting:0
			,spResumeSpeed:0.4
			,onHitSe:["player_hit_01", "player_hit_02", "player_hit_03"]
			,team:0
			,deathAnimation:0
			, enableFloatMessage:true
			,alwaysShowDamageDigit:true
			,hasSpecProgress:true
		}
		,"35": {
			mhp:475
			,_jumpStrength:-17		// 跳跃动力
			,moveStrength:4			// 行走动力
			,_maxMoveSpeed:6			// 最大行走速度
			,dashJumpAddSpeed:4		// 前冲跳跃在落地前增加最大移动速度
			,hitRect:{				// 物理引擎判定矩形
				l:25
				,t:88
				,r:25
				,b:0
			}
			,movingImage:';lily_move'
			,standingImage:';lily_standing'
			,jumpUpImage:';lily_jump_up'
			,jumpDownImage:';lily_jump_down'
			,staggerImage:';lily_stagger'
			,onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			,team:1
			,faceName:"map_player_face3"
			,dangerFaceName:"map_player_face3"
			,deathAnimation:34
			,isBoss:true
			, enableFloatMessage:true
			,hint:[1,2]
		}
		,"36": {
			mhp:65
			,_jumpStrength:0		// 跳跃动力
			,movingImage:';defence_shield'
			,standingImage:';defence_shield'
			,onHitSe:["shield_hit1", "shield_hit2"]
			,team:1
			,deathAnimation:12
			, physicsFlag:3
			,hitRect:{				// 物理引擎判定矩形
				l:96
				,t:144
				,r:96
				,b:48
			}
		}
		,"37": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:0
			,movingImage:';lily_bomb_boom'
			,standingImage:';lily_bomb'
			,onHitSe:["shield_hit1", "shield_hit2"]
			,team:1
			,deathAnimation:0
		}
		,"38": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:0
			,standingImage:';lily_fan_bullet'
			,onHitSe:["prop_hit1", "prop_hit2"]
			,team:1
			,deathAnimation:0
		}
		,"39": {		// 莉莉亚的NPC版本
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-17		// 跳跃动力
			,moveStrength:4			// 行走动力
			,_maxMoveSpeed:6			// 最大行走速度
			,dashJumpAddSpeed:4		// 前冲跳跃在落地前增加最大移动速度
			,hitRect:{				// 物理引擎判定矩形
				l:25
				,t:88
				,r:25
				,b:0
			}
			,movingImage:';lily_move'
			,standingImage:';lily_standing'
			,jumpUpImage:';lily_jump_up'
			,jumpDownImage:';lily_jump_down'
			,staggerImage:';lily_stagger'
			,onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			,team:-2
			,faceName:"map_player_face3"
			,dangerFaceName:"map_player_face3"
			,deathAnimation:3
			, enableFloatMessage:true
		}
		,"40": {
			mhp:45
			, _jumpStrength:0
			, hitRect:{
				l:36
				,t:80
				,r:36
				,b:0
			}
			, standingImage:";cat5_stand"
			, movingImage:";cat5_stand"
			, staggerImage:";cat5_stagger"
			, moveStrength:2
			, _maxMoveSpeed:10
			, coin:[{num:1,count:1},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
		}
		,"41": {
			mhp:140
			, _jumpStrength:-11
			, hitRect:{
				l:91
				,t:162
				,r:91
				,b:0
			}
			, standingImage:";cat6_stand"
			, movingImage:";cat6_move"
			, staggerImage:";cat6_stagger"
			, jumpDownImage:";cat6_jumpdown"
			, jumpUpImage:";cat6_jumpup"
			, moveStrength:16
			, _maxMoveSpeed:4
			, coin:[{num:1,count:4},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, mapRecoverCreate:true
		}
		,"42": {
			mhp:60
			, _jumpStrength:-14
			, hitRect:{
				l:40
				,t:84
				,r:40
				,b:0
			}
			, standingImage:";cat7_move"
			, movingImage:";cat7_move"
			, staggerImage:";cat7_stagger"
			, moveStrength:1
			, _maxMoveSpeed:3
			, coin:[{num:1,count:3},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
		}
		,"43": {
			mhp:40
			, _jumpStrength:0
			, hitRect:{
				l:23
				,t:64
				,r:23
				,b:0
			}
			, standingImage:";glass_mon_stand"
			, movingImage:";glass_mon_stand"
			, staggerImage:";glass_mon_stand"
			, moveStrength:0
			, _maxMoveSpeed:0
			, coin:[{num:1,count:1},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, beAttackSlashAnimations:[18]
			, mapRecoverCreate:true
		}
		,"44": {		// 矿车，矿车的轨道physicsFlag为1，只和矿车发生碰撞
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:144
				,t:100
				,r:144
				,b:0
			}
			, standingImage:";minecar_body"
			, movingImage:";minecar_body"
			, staggerImage:";minecar_body"
			, team:-2
			, deathAnimation:3
			, fallDownReset:true
			, moveStrength:99999
			, _maxMoveSpeed:3
			, physicsFlag:2
		}
		,"45": {		// 矿车拉杆
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:22
				,t:46
				,r:22
				,b:0
			}
			, standingImage:";minecar_switch"
			, movingImage:";minecar_switch"
			, staggerImage:";minecar_switch"
			, team:1
			, deathAnimation:3
			, fallDownReset:true
			, physicsFlag:3
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
		}
		,"46": {		// 大铁球
			mhp:1
			, unlimitHp:true
			, standingImage:";iron_ball"
			, movingImage:";iron_ball"
			, staggerImage:";iron_ball"
			, team:1
			, fallDownReset:true
		}
		,"47": {		// 大炮
			mhp:1
			, unlimitHp:true
			, standingImage:";artillery_body"
			, movingImage:";artillery_in"
			, staggerImage:";artillery_body"
			, team:-2
			, fallDownReset:true
		}
		,"48": {		// 森林草堆
			mhp:1
			, hitRect:{
				l:55
				,t:60
				,r:55
				,b:0
			}
			, standingImage:";forest_grass1"
			, movingImage:";forest_grass1"
			, staggerImage:";forest_grass1"
			, team:1
			, physicsFlag:5
			, deathAnimation:21
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["grass_hit"]
			, isMonster:true
			, deathAddZp:15
		}
		,"49": {		// 森林草堆2
			mhp:1
			, hitRect:{
				l:56
				,t:88
				,r:56
				,b:0
			}
			, standingImage:";forest_grass2"
			, movingImage:";forest_grass2"
			, staggerImage:";forest_grass2"
			, team:1
			, physicsFlag:5
			, deathAnimation:24
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["grass_hit"]
			, isMonster:true
			, deathAddZp:15
		}
		,"50": {		// 矿石堆
			mhp:1
			, hitRect:{
				l:34
				,t:84
				,r:34
				,b:0
			}
			, standingImage:";stone_mass1"
			, movingImage:";stone_mass1"
			, staggerImage:";stone_mass1"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";stone_fragment1", minX:-8, maxX:10, maxY:0, minY:-8, duplicate:3},{name:";stone_fragment2", minX:-4, maxX:4, maxY:0, minY:-10, duplicate:3}
			,{name:";stone_fragment3", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:3},{name:";stone_fragment4", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:3}
			,{name:";stone_fragment5", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:3},{name:";stone_fragment6", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:3}]
			, deathAddZp:15
		}
		,"51":{
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:144
				,t:26
				,r:144
				,b:0
			}
			, standingImage:";balance_broad"
			, movingImage:";balance_broad"
			, staggerImage:";balance_broad"
			, team:-2
			, fallDownReset:true
		}
		,"52":{
			mhp:1
			, unlimitHp:true
			, standingImage:";jet_port"
			, movingImage:";jet_port"
			, staggerImage:";jet_port"
			, team:-2
			, fallDownReset:true
			, physicsFlag:5
		}
		,"53": {		// 矿石堆2
			mhp:1
			, hitRect:{
				l:46
				,t:146
				,r:46
				,b:0
			}
			, standingImage:";stone_mass2"
			, movingImage:";stone_mass2"
			, staggerImage:";stone_mass2"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";stone_fragment1", minX:-8, maxX:8, maxY:0, minY:-12, duplicate:3},{name:";stone_fragment2", minX:-4, maxX:4, maxY:0, minY:-12, duplicate:3}
			,{name:";stone_fragment3", minX:-8, maxX:8, maxY:0, minY:-12, duplicate:3},{name:";stone_fragment4", minX:-8, maxX:8, maxY:0, minY:-12, duplicate:3}
			,{name:";stone_fragment6", minX:-8, maxX:8, maxY:0, minY:-12, duplicate:3},{name:";stone_fragment7", minX:-8, maxX:8, maxY:0, minY:-12, duplicate:3}]
			, deathAddZp:15
		}
		,"54": {		// 矿石堆3
			mhp:1
			, hitRect:{
				l:23
				,t:38
				,r:23
				,b:0
			}
			, standingImage:";stone_mass3"
			, movingImage:";stone_mass3"
			, staggerImage:";stone_mass3"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";stone_fragment2", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:2},{name:";stone_fragment3", minX:-4, maxX:4, maxY:0, minY:-10, duplicate:2}
			,{name:";stone_fragment4", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:2},{name:";stone_fragment5", minX:-8, maxX:8, maxY:0, minY:-10, duplicate:2}]
			, deathAddZp:15
		}
		,"55": {		// 矿车轨道
			mhp:1
			, unlimitHp:true
			, onHitSe:[]
			, team:-2
			, physicsFlag:1
			, immueSquash:true
		}
		,"56": {		// 从天花板上掉下来的石头刺
			mhp:1
			, hitRect:{
				l:6
				,t:240
				,r:6
				,b:0
			}
			, standingImage:";stone_spike"
			, movingImage:";stone_spike"
			, staggerImage:";stone_spike"
			, team:1
			, physicsFlag:3
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";stone_spike_fragment1", minX:-2, maxX:2, maxY:0, minY:-5, duplicate:2},{name:";stone_spike_fragment2", minX:-5, maxX:5, maxY:0, minY:-5, duplicate:2}
			,{name:";stone_spike_fragment3", minX:-5, maxX:5, maxY:0, minY:-5, duplicate:2},{name:";stone_spike_fragment4", minX:-5, maxX:5, maxY:0, minY:-5, duplicate:2},{name:";stone_spike_fragment5", minX:-5, maxX:5, maxY:0, minY:-5, duplicate:2}]
		}
		,"57": {		// 从天花板上掉下来的石头刺2
			mhp:1
			, hitRect:{
				l:6
				,t:350
				,r:6
				,b:0
			}
			, standingImage:";stone_spike2"
			, movingImage:";stone_spike2"
			, staggerImage:";stone_spike2"
			, team:1
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";stone_spike_fragment1", minX:-2, maxX:2, maxY:0, minY:-5, duplicate:4},{name:";stone_spike_fragment5", minX:-5, maxX:5, maxY:0, minY:-5, duplicate:4}]
		}
		,"58": {		// 山洞boss橘花猫
			mhp:515
			, hitRect:{
				l:37
				,t:164
				,r:37
				,b:0
			}
			, standingImage:";orange_cat_stand"
			, movingImage:";orange_cat_move"
			, jumpUpImage:';orange_cat_jumpup'
			, jumpDownImage:';orange_cat_jumpdown'
			, staggerImage:';orange_cat_stagger'
			, moveStrength:6
			, _maxMoveSpeed:4.2
			, _jumpStrength:-15
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:34
			, fallDownReset:true
			, fallDownSe:"player_fall"
			, isBoss:true
			, hasSpecProgress:true
			, coin:[{num:5,count:40}, {num:20, count:10}]
			, enableFloatMessage:true
			, faceName:"map_player_face4"
			, dangerFaceName:"map_player_face4"
			, hint:[3]
		}
		,"59": {		// 橘花猫的分身
			mhp:65
			, hitRect:{
				l:37
				,t:164
				,r:37
				,b:0
			}
			, standingImage:";orange_cat_s_stand"
			, movingImage:";orange_cat_s_move"
			, jumpUpImage:';orange_cat_s_jumpup'
			, jumpDownImage:';orange_cat_s_jumpdown'
			, staggerImage:';orange_cat_s_stagger'
			, moveStrength:4
			, _maxMoveSpeed:4
			, _jumpStrength:-14
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownReset:true
			, fallDownSe:"player_fall"
		}
		,"60": {		// 橘花猫的黑洞
			mhp:1
			, unlimitHp:true
			, noHotEvent:true
			, standingImage:";empty_character"
			, deathAnimation:30
			, team:1
			, onHitSe:["shield_hit1", "shield_hit2"]
		}
		,"61": {		// 橘花猫-NPC版本
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-14
			, hitRect:{
				l:37
				,t:164
				,r:37
				,b:0
			}
			, team:-2
			, standingImage:";orange_cat_stand"
			, movingImage:";orange_cat_move"
			, jumpUpImage:';orange_cat_jumpup'
			, jumpDownImage:';orange_cat_jumpdown'
			, moveStrength:6
			, _maxMoveSpeed:4.2
			, maxWaiting:1280
			, minWaiting:480
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, fallDownReset:true
			, enableFloatMessage:true
		}
		,"62": {		// 萤火虫
			team:-2
		}
		,"63": {		// 校长-NPC
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-13		// 跳跃动力
			,moveStrength:2			// 行走动力
			,_maxMoveSpeed:3			// 最大行走速度
			,hitRect:{				// 物理引擎判定矩形
				l:22
				,t:90
				,r:22
				,b:0
			}
			,movingImage:';sakura_move'
			,standingImage:';sakura_standing' 		// 另有;sakura_standingex另一个站立动画
			,team:-2
			, enableFloatMessage:true
			, fallDownReset:true
		}
		,"64": {		// 贝壳（水底关可破坏物体）
			mhp:1
			, hitRect:{
				l:50
				,t:80
				,r:56
				,b:0
			}
			, standingImage:";sea_shell"
			, movingImage:";sea_shell"
			, staggerImage:";sea_shell"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";sea_shell_fragment1", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:3},{name:";sea_shell_fragment2", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:1}
			,{name:";sea_shell_fragment3", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2},{name:";sea_shell_fragment4", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2}
			,{name:";sea_shell_fragment5", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2},{name:";sea_shell_fragment6", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2}
			,{name:";sea_shell_fragment7", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2}]
			, deathAddZp:15
		}
		,"65": {		// 废弃宝箱（水底关可破坏物体）
			mhp:1
			, hitRect:{
				l:53
				,t:80
				,r:53
				,b:0
			}
			, standingImage:";treasure_box"
			, movingImage:";treasure_box"
			, staggerImage:";treasure_box"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";treasure_box_fragment1", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2},{name:";treasure_box_fragment2", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2}
			,{name:";treasure_box_fragment3", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2},{name:";treasure_box_fragment4", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2}
			,{name:";treasure_box_fragment5", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2},{name:";treasure_box_fragment6", minX:-6, maxX:6, maxY:0, minY:-8, duplicate:2}]
			, deathAddZp:15
		}
		,"66": {		// 废弃宝箱叠加光
			mhp:1
			, hitRect:{
				l:53
				,t:80
				,r:53
				,b:0
			}
			, standingImage:";treasure_box_light"
			, movingImage:";treasure_box_light"
			, staggerImage:";treasure_box_light"
			, team:-2
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
		}
		,"67": {		// 水底困住人的泡泡
			mhp:1
			, standingImage:";water_bubble"
			, movingImage:";water_bubble_move"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["bubble"]
			, noDeathShake:true
		}
		,"68": {		// 水底关的乌龟怪
			mhp:72
			, _jumpStrength:0
			, hitRect:{
				l:40
				,t:80
				,r:40
				,b:0
			}
			, standingImage:";tortoise_move_fast"
			, movingImage:";tortoise_move"
			, staggerImage:";tortoise_stagger"
			, jumpDownImage:";tortoise_shrink_out"
			, jumpUpImage:";tortoise_shrink_in"
			, jumpMiddleImage:";tortoise_shrink"
			, moveStrength:2
			, _maxMoveSpeed:2
			, coin:[{num:1,count:3},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, mapRecoverCreate:true
		}
		,"69": {		// 电水母
			mhp:60
			, _jumpStrength:0
			, hitRect:{
				l:44
				,t:94
				,r:44
				,b:0
			}
			, standingImage:";electron_jellyfish"
			, movingImage:";electron_jellyfish"
			, staggerImage:";electron_jellyfish_stagger"
			, _maxMoveSpeed:9
			, coin:[{num:1,count:2},{num:5,count:1}]
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
			, mapRecoverCreate:true
		}
		,"70": {		// 食人鱼
			mhp:120
			, _jumpStrength:0
			, hitRect:{
				l:35
				,t:70
				,r:35
				,b:0
			}
			, standingImage:";piranha"
			, movingImage:";piranha_eating"
			, staggerImage:";piranha"
			, _maxMoveSpeed:5
			, coin:[{num:1,count:1},{num:5,count:1}]
			, moveStrength:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, fallDownSe:"player_fall"
		}
		,"71": {		// 自爆河豚
			mhp:80
			, hitRect:{
				l:30
				,t:34
				,r:30
				,b:0
			}
			, standingImage:";globefish"
			, movingImage:";globefish"
			, staggerImage:";globefish_stagger"
			, _maxMoveSpeed:4
			, coin:[{num:1,count:1},{num:5,count:1}]
			, moveStrength:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, deathFadeoutDuration:1
			, mapRecoverCreate:true
		}
		,"72": {		// 金枪鱼
			mhp:68
			, hitRect:{
				l:76
				,t:76
				,r:76
				,b:0
			}
			, standingImage:";tunas"
			, movingImage:";tunas"
			, staggerImage:";tunas_stagger"
			, _maxMoveSpeed:4
			, coin:[{num:1,count:2},{num:5,count:1}]
			, moveStrength:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
		}
		,"73": {		// 普通海胆（静止不动）
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:36
				,t:66
				,r:36
				,b:0
			}
			, standingImage:";sea_urchin"
			, movingImage:";sea_urchin"
			, staggerImage:";sea_urchin"
			, team:1
			, physicsFlag:6
		}
		, "74": {		// 喷水口
			team:-2
		}
		,"75": {		// 海胆-两个固定点移动
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:36
				,t:66
				,r:36
				,b:0
			}
			, standingImage:";sea_urchin_green"
			, movingImage:";sea_urchin_green"
			, staggerImage:";sea_urchin_green"
			, team:1
			, physicsFlag:6
		}
		,"76": {		// 蓝色海胆-靠近时快速下落
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:36
				,t:66
				,r:36
				,b:0
			}
			, standingImage:";sea_urchin_blue"
			, movingImage:";sea_urchin_blue"
			, staggerImage:";sea_urchin_blue"
			, team:1
			, physicsFlag:6
		}
		,"77": {		// 普通海胆
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:36
				,t:66
				,r:36
				,b:0
			}
			, standingImage:";sea_urchin_purple"
			, movingImage:";sea_urchin_purple"
			, staggerImage:";sea_urchin_purple"
			, team:-1
			, physicsFlag:6
		}
		,"78": {		// 普通海胆
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:36
				,t:66
				,r:36
				,b:0
			}
			, standingImage:";sea_urchin_red"
			, movingImage:";sea_urchin_red"
			, staggerImage:";sea_urchin_red"
			, team:-1
			, physicsFlag:6
		}
		,"79": {		// 密码锁
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:144
				,t:48
				,r:144
				,b:0
			}
			, standingImage:";password_lock"
			, movingImage:";password_lock"
			, staggerImage:";password_lock"
			, team:-2
		}
		,"80": {		// 密码1
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:40
				,t:80
				,r:40
				,b:0
			}
			, standingImage:";password1"
			, movingImage:";password1"
			, staggerImage:";password1"
			, team:1
			,onHitSe:["woodenonhit"]
		}
		,"81": {		// 密码2
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:40
				,t:80
				,r:40
				,b:0
			}
			, standingImage:";password2"
			, movingImage:";password2"
			, staggerImage:";password2"
			, team:1
			, onHitSe:["woodenonhit"]
		}
		,"82": {		// 密码3
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:40
				,t:80
				,r:40
				,b:0
			}
			, standingImage:";password3"
			, movingImage:";password3"
			, staggerImage:";password3"
			, team:1
			,onHitSe:["woodenonhit"]
		}
		,"83": {		// 密码4
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:40
				,t:80
				,r:40
				,b:0
			}
			, standingImage:";password4"
			, movingImage:";password4"
			, staggerImage:";password4"
			, team:1
			,onHitSe:["woodenonhit"]
		}
		,"84": {		// 湖底的石台，反重力区域判定
			mhp:1
			,unlimitHp:true
			,team:-2
		}
		,"85": {		// 莉莉亚的平底锅
			mhp:196
			,team:1
			, standingImage:";lily_pan"
			, movingImage:";lily_pan"
			, staggerImage:";lily_pan"
			, hitRect: {
				l:26
				,t:54
				,r:26
				,b:0
			}
			, moveStrength:3
			, _maxMoveSpeed:3
			, onHitSe:["pan_hit1", "pan_hit2"]
			, deathAnimation:3
		}
		,"86": {		// 莉莉亚的炸弹-水底版
			mhp:1
			,unlimitHp:true
			,_jumpStrength:0
			,movingImage:';lily_bomb_boom'
			,standingImage:';lily_bomb_water'
			,onHitSe:["shield_hit1", "shield_hit2"]
			,team:1
			,deathAnimation:0
		}
		,"87": {		// 莉莉亚 boss 水底版本
			mhp:475
			,_jumpStrength:-17		// 跳跃动力
			,moveStrength:4			// 行走动力
			,_maxMoveSpeed:6			// 最大行走速度
			,dashJumpAddSpeed:4		// 前冲跳跃在落地前增加最大移动速度
			,hitRect:{				// 物理引擎判定矩形
				l:25
				,t:88
				,r:25
				,b:0
			}
			,movingImage:';lily_move'
			,standingImage:';lily_standing'
			,jumpUpImage:';lily_jump_up'
			,jumpDownImage:';lily_jump_down'
			,staggerImage:';lily_stagger'
			,onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			,team:1
			,faceName:"map_player_face3"
			,dangerFaceName:"map_player_face3"
			,deathAnimation:34
			,isBoss:true
			, enableFloatMessage:true
			,hint:[4,5]
		}
		,"88": {		// 莉莉亚水底boss战的红色泡泡
			mhp:1
			, standingImage:";water_bubble_red"
			, movingImage:";water_bubble_red_move"
			, team:1
			, physicsFlag:5
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["bubble"]
			, noDeathShake:true
		}
		,"89": {		// 去天空层顶区域的大号蘑菇
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-16
			,hitRect:{
				l:100
				,t:160
				,r:100
				,b:0
			}
			, team:1
			, movingImage:';mushroom_move'
			, standingImage:';mushroom'
			, deathAnimation:3
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, physicsFlag:6
		}
		,"90": {		// 天空区域狮子怪丢的铁饼
			mhp:1
			,unlimitHp:true
			,_maxMoveSpeed:6
			, moveStrength:5
			,hitRect:{
				l:48
				,t:96
				,r:48
				,b:0
			}
			, team:1
			, movingImage:';iron_pie'
			, standingImage:';iron_pie'
			, staggerImage:';iron_pie'
			, deathAnimation:3
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
		}
		,"91": {		// 扔铁饼的狮子怪
			mhp:80
			, hitRect:{
				l:62
				,t:176
				,r:62
				,b:0
			}
			, standingImage:";lion_jumpup"
			, movingImage:";lion_jumpup"
			, staggerImage:";lion_stagger"
			, jumpUpImage:";lion_jumpup"
			, jumpDownImage:";lion_jumpdown"
			, _maxMoveSpeed:8
			, _jumpStrength:-11
			, coin:[{num:1,count:3},{num:5,count:1}]
			, moveStrength:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			, isMonster:true
			, hasSpecProgress:true
		}
		,"92": {
			mhp:52
			, hitRect:{
				l:68
				,t:80
				,r:68
				,b:0
			}
			, standingImage:";dark_cloud"
			, movingImage:";dark_cloud"
			, staggerImage:";dark_cloud_stagger"
			, _maxMoveSpeed:4
			, coin:[{num:1,count:1},{num:5,count:1}]
			, moveStrength:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			, isMonster:true
		}
		,"93": {
			mhp:140
			, hitRect:{
				l:68
				,t:80
				,r:68
				,b:0
			}
			, standingImage:";dark_cloud2"
			, movingImage:";dark_cloud2"
			, staggerImage:";dark_cloud2_stagger"
			, _maxMoveSpeed:2
			, coin:[{num:1,count:4},{num:5,count:1}]
			, moveStrength:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			, isMonster:true
		}
		,"94": {
			mhp:66
			, hitRect:{
				l:40
				,t:92
				,r:40
				,b:0
			}
			, standingImage:";bomb_cat_jumpup"
			, movingImage:";bomb_cat_jumpup"
			, staggerImage:";bomb_cat_stagger"
			, jumpUpImage:";bomb_cat_jumpup"
			, jumpDownImage:";bomb_cat_jumpdown"
			, _maxMoveSpeed:5
			, coin:[{num:1,count:2},{num:5,count:1}]
			, moveStrength:5
			, _jumpStrength:-15
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			, isMonster:true
			, hasSpecProgress:true
		}
		,"95": {
			mhp:1
			, unlimitHp:true
			, _jumpStrength:-14
			, standingImage:";small_bomb"
			, movingImage:";small_bomb"
			, staggerImage:";small_bomb"
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
		}
		,"96": {		// 气球1（可破坏物体）
			mhp:1
			, hitRect:{
				l:30
				,t:76
				,r:30
				,b:0
			}
			, standingImage:";balloon2"
			, movingImage:";balloon2"
			, staggerImage:";balloon2"
			, team:1
			, physicsFlag:5
			, deathAnimation:48
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, isMonster:true
			, deathAddZp:15
		}
		,"97": {		// 气球2（可破坏物体）
			mhp:1
			, hitRect:{
				l:53
				,t:78
				,r:53
				,b:0
			}
			, standingImage:";balloon1"
			, movingImage:";balloon1"
			, staggerImage:";balloon1"
			, team:1
			, physicsFlag:5
			, deathAnimation:47
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, isMonster:true
			, deathAddZp:15
		}
		,"98": {
			mhp:92
			, hitRect:{
				l:50
				,t:154
				,r:50
				,b:0
			}
			, standingImage:";horn_cat_jumpup"
			, movingImage:";horn_cat_jumpup"
			, staggerImage:";horn_cat_stagger"
			, jumpUpImage:";horn_cat_jumpup"
			, jumpDownImage:";horn_cat_jumpdown"
			, _maxMoveSpeed:4
			, coin:[{num:1,count:3},{num:5,count:1}]
			, moveStrength:4
			, _jumpStrength:-14
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			, isMonster:true
		}
		,"99": {
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:46
				,t:76
				,r:46
				,b:0
			}
			, standingImage:";down_attack_cloud"
			, movingImage:";down_attack_cloud"
			, staggerImage:";down_attack_cloud"
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, sfadd:2
			, physicsFlag:5
		}
		,"100": {
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:78
				,t:52
				,r:78
				,b:0
			}
			, standingImage:";jump_change_cloud"
			, movingImage:";jump_change_cloud"
			, staggerImage:";jump_change_cloud"
			, team:-2
			, physicsFlag:0
			, upElasticWithJumpStrength:1.0
		}
		,"101": {
			mhp:1
			,noHotEvent:true
			, hitRect:{
				l:88
				,t:76
				,r:88
				,b:0
			}
			, standingImage:";hitable_cloud_hort"
			, movingImage:";hitable_cloud_hort"
			, staggerImage:";hitable_cloud_hort"
			, team:1
			, physicsFlag:6
			, deathAnimation:3
			, upElasticWithJumpStrength:1.0
		}
		,"102": {
			mhp:1
			,noHotEvent:true
			, hitRect:{
				l:38
				,t:176
				,r:38
				,b:0
			}
			, standingImage:";hitable_cloud_vert"
			, movingImage:";hitable_cloud_vert"
			, staggerImage:";hitable_cloud_vert"
			, team:1
			, physicsFlag:6
			, deathAnimation:3
			, upElasticWithJumpStrength:1.0
		}
		,"103": {
			mhp:1
			,unlimitHp:true
			, hitRect:{
				l:36
				,t:64
				,r:36
				,b:0
			}
			, standingImage:";moving_platform_cloud"
			, movingImage:";moving_platform_cloud"
			, staggerImage:";moving_platform_cloud"
			, team:-2
			, upElasticWithJumpStrength:1.0
			, physicsFlag:0
		}
		,"104": {
			mhp:1
			,unlimitHp:true
			, standingImage:";coin_stoneA"
			, movingImage:";coin_stoneB"
			, jumpUpImage:";coin_stoneC"
			, jumpDownImage:";coin_stoneD"
			, staggerImage:""
			, team:1
			, physicsFlag:5
			, onHitSe:["coin_stone1"]
		}
		,"105": {
			mhp:1
			, team:-1
			, specailHitFlag:1
			, deathAnimation:8
			, immueSquash:true
			, deathNoZp:true
			, noHotEvent:true
		}
		,"106": {		// 老板娘BOSS登场
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-17
			,hitRect:{
				l:25
				,t:90
				,r:25
				,b:0
			}
			, team:-2
			, movingImage:';berries_air_standing'
			, standingImage:';berries_air_standing'
			, moveStrength:0.5
			, _maxMoveSpeed:3
			, targets:[]
		}
		,"107": {			// 老板娘的boss房云
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:44
				,t:56
				,r:44
				,b:0
			}
			, standingImage:";berries_cloud"
			, movingImage:";berries_cloud_off"
			, staggerImage:";berries_cloud_hitting"
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, physicsFlag:5
		}
		,"108": {
			mhp:1
			, unlimitHp:true
			, team:1
			, immueSquash:true
			, physicsFlag:5
		}
		,"109": {		// 老板娘BOSS本体
			mhp:360
			,_jumpStrength:-12
			,hitRect:{
				l:25
				,t:90
				,r:25
				,b:0
			}
			, team:1
			, movingImage:';berries_air_standing'
			, standingImage:';berries_air_standing'
			, jumpUpImage:';berries_jumpup'
			, jumpDownImage:';berries_jumpdown'
			, staggerImage:';berries_stagger'
			, moveStrength:2
			, _maxMoveSpeed:6
			, faceName:"map_player_face5"
			, dangerFaceName:"map_player_face5"
			, isBoss:true
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, deathAnimation:34
			, immueDeath:true
			, hint:[6]
		}
		,"110": {		// 老板娘召唤的石头
			mhp:1
			, hitRect:{
				l:25
				,t:80
				,r:25
				,b:0
			}
			, standingImage:";berries_lockon"
			, movingImage:";berries_lockon"
			, staggerImage:";berries_lockon"
			, team:1
			, noHotEvent:true
			, deathFadeoutDuration:1
			, deathAddZp:20
			, onHitSe:["stone_mass_onhit"]
			, hitCreateFragment:[{name:";berries_stone2", minX:-2, maxX:2, maxY:0, minY:-5, duplicate:2},{name:";berries_stone3", minX:-5, maxX:5, maxY:0, minY:-5, duplicate:6}]
		}
		,"111": {		// 老板娘召唤的球闪电
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:20
				,t:20
				,r:20
				,b:20
			}
			, standingImage:";berries_ball_lighting"
			, movingImage:";berries_ball_lighting"
			, staggerImage:";berries_ball_lighting"
			, team:1
			, physicsFlag:5
			, _maxMoveSpeed:2
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
		}
		,"112": {		// 老板娘的过电电流
			mhp:1
			, unlimitHp:true
			, standingImage:""
			, movingImage:""
			, staggerImage:""
			, team:1
			, physicsFlag:5
			, onHitSe:["Paralyze1"]
		}
		,"113": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-17
			,hitRect:{
				l:45
				,t:42
				,r:45
				,b:0
			}
			, team:-2
			, movingImage:';berries_lie'
			, standingImage:';berries_lie'
			, moveStrength:0.5
			, _maxMoveSpeed:3
			, physicsFlag:3
		}
		,"114": {
			mhp:1
			,unlimitHp:true
			,_jumpStrength:-17
			,hitRect:{
				l:45
				,t:42
				,r:45
				,b:0
			}
			, team:-2
			, movingImage:';berries_lie'
			, standingImage:';berries_lie'
			, moveStrength:0.5
			, _maxMoveSpeed:3
		}
		,"115": {		// 老板娘的回血球罩子
			mhp:1
			,unlimitHp:true		
			, team:1
			, movingImage:';berries_recover_sheild'
			, standingImage:';berries_recover_sheild'
			, onHitSe:["glass_mon_onhit"]
			, beAttackSlashAnimations:[18]
		}
		,"116": {		// 喷雾毒花
			mhp:60
			, hitRect:{
				l:45
				,t:160
				,r:45
				,b:0
			}
			, standingImage:";strange_flower"
			, movingImage:";strange_flower"
			, staggerImage:";strange_flower_stagger"
			, _maxMoveSpeed:0
			, coin:[{num:1,count:2},{num:5,count:1}]
			, moveStrength:0
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
		}
		,"117": {		// 黑鼠
			mhp:78
			, hitRect:{
				l:18
				,t:58
				,r:18
				,b:0
			}
			, standingImage:";black_rat"
			, movingImage:";black_rat_move"
			, staggerImage:";black_rat_stagger"
			, _maxMoveSpeed:6
			, coin:[{num:1,count:3},{num:5,count:1}]
			, moveStrength:6
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			,_jumpStrength:-12
		}
		,"118": {		// 灰鼠
			mhp:78
			, hitRect:{
				l:18
				,t:58
				,r:18
				,b:0
			}
			, standingImage:";gray_rat"
			, movingImage:";gray_rat_move"
			, staggerImage:";gray_rat_stagger"
			, jumpUpImage:";gray_rat"
			, jumpDownImage:";gray_rat"
			, _maxMoveSpeed:6
			, coin:[{num:1,count:3},{num:5,count:1}]
			, moveStrength:600
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, team:1
			, deathAnimation:3
			, mapRecoverCreate:true
			,_jumpStrength:-14
		}
		,"119": {		// 黑色曼陀罗花堆
			mhp:1
			, hitRect:{
				l:69
				,t:78
				,r:69
				,b:0
			}
			, standingImage:";mandala1"
			, movingImage:";mandala1"
			, staggerImage:";mandala1"
			, team:1
			, physicsFlag:5
			, deathAnimation:74
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["grass_hit"]
			, isMonster:true
			, deathAddZp:15
		}
		,"120": {		// 黑色曼陀罗花堆2
			mhp:1
			, hitRect:{
				l:54
				,t:68
				,r:54
				,b:0
			}
			, standingImage:";mandala2"
			, movingImage:";mandala2"
			, staggerImage:";mandala2"
			, team:1
			, physicsFlag:5
			, deathAnimation:75
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, onHitSe:["grass_hit"]
			, isMonster:true
			, deathAddZp:15
		}
		,"121": {		// 恶魔石墙（不包括眼睛）
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:56
				,t:1138
				,r:56
				,b:0
			}
			, standingImage:";evil_wall"
			, movingImage:";evil_wall"
			, staggerImage:";evil_wall"
			, team:1
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:90
			, _maxMoveSpeed:4
		}
		,"122": {		// 恶魔石墙的光柱底座
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:48
				,t:48
				,r:46
				,b:0
			}
			, standingImage:";evil_light_bottom"
			, movingImage:";evil_light_bottom"
			, staggerImage:";evil_light_bottom"
			, team:1
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, _maxMoveSpeed:2
			, moveStrength:2
			, physicsFlag:5
			, hasSpecProgress:true
		}
		,"123": {		// 恶魔石墙的移动光柱
			mhp:25
			, immueStaggerAttack:true
			, hitRect:{
				l:24
				,t:1920
				,r:24
				,b:0
			}
			, standingImage:";evil_laser"
			, movingImage:";evil_laser"
			, staggerImage:";evil_laser"
			, team:1
			, noDeathShake:true
			, deathFadeoutDuration:1
			, deathAnimation:86
			, _maxMoveSpeed:2.5
			, physicsFlag:5
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, deathAddZp:85
		}
		,"124": {		// 恶魔石墙的分裂弹幕-母体
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:22
				,t:22
				,r:22
				,b:22
			}
			, standingImage:";evil_eye_division"
			, movingImage:";evil_eye_division"
			, staggerImage:";evil_eye_division"
			, team:1
			, deathFadeoutDuration:1
			, _maxMoveSpeed:4
			, moveStrength:4
		}
		,"125": {		// 恶魔石墙的分裂弹幕
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:11
				,t:11
				,r:11
				,b:11
			}
			, standingImage:";evil_eye_division_fragment"
			, movingImage:";evil_eye_division_fragment"
			, staggerImage:";evil_eye_division_fragment"
			, team:1
			, deathFadeoutDuration:1
			, _maxMoveSpeed:3
			, moveStrength:3
		}
		,"126": {		// 恶魔石墙的紫色花朵
			mhp:1
			, unlimitHp:true
			, physicsFlag:5
			, hitRect:{
				l:42
				,t:24
				,r:42
				,b:0
			}
			, standingImage:";evil_purple_flower"
			, movingImage:";evil_purple_flower_break"
			, staggerImage:""
			, team:0
			, deathFadeoutDuration:1
			, hasSpecProgress:true
		}
		,"127": {		// 恶魔石墙的眼睛
			mhp:1065
			, isBoss:true
			, physicsFlag:5
			, hitRect:{
				l:45
				,t:90
				,r:45
				,b:0
			}
			, standingImage:";evil_eye"
			, movingImage:";evil_eye"
			, staggerImage:""
			, team:1
			, deathFadeoutDuration:1
			, hasSpecProgress:true
			, faceName:""
			, dangerFaceName:""
			, deathAnimation:34
			, onHitSe:["attack_impact_01","attack_impact_02","attack_impact_03","attack_impact_04","attack_impact_05"]
			, moveStrength:2
			, _maxMoveSpeed:2
			, faceName:"map_player_face6"
			, dangerFaceName:"map_player_face6"
			, hint:[8]
		}
		,"128": {		// 恶魔石墙眼睛背后的肉芽
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:1
				,t:1
				,r:1
				,b:1
			}
			, standingImage:";evil_eye_body"
			, movingImage:";evil_eye_body"
			, staggerImage:";evil_eye_body"
			, team:1
			, noDeathShake:true
			, noHotEvent:true
			, physicsFlag:5
		}
		,"129": {		// 恶魔石墙（变暗下沉）
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:56
				,t:1138
				,r:56
				,b:0
			}
			, standingImage:";evil_wall_fade"
			, movingImage:";evil_wall_fade"
			, staggerImage:";evil_wall_fade"
			, team:1
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, _maxMoveSpeed:2.5
		}
		,"130": {		// 墙高层的角
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:1
				,t:1
				,r:1
				,b:1
			}
			, standingImage:";evil_wall_upper"
			, movingImage:";evil_wall_upper"
			, staggerImage:";evil_wall_upper"
			, team:1
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:90
			, _maxMoveSpeed:4
		}
		,"131": {		// 墙中层的基座，用于挡住老鼠营造层次感
			mhp:1
			, unlimitHp:true
			, hitRect:{
				l:1
				,t:1
				,r:1
				,b:1
			}
			, standingImage:";evil_wall_normal_upper"
			, movingImage:";evil_wall_normal_upper"
			, staggerImage:";evil_wall_normal_upper"
			, team:1
			, noDeathShake:true
			, noHotEvent:true
			, deathFadeoutDuration:1
			, _maxMoveSpeed:4
		}
};























NYA.IFRAME = {};

DataManager._iframeLoaded = false;

NYA.IFRAME.DataManager_loadDatabase = DataManager.loadDatabase;
DataManager.loadDatabase = function() {
	NYA.IFRAME.DataManager_loadDatabase.apply(this, arguments);
	this.loadIFrame();
};

NYA.IFRAME.DataManager_isDatabaseLoaded = DataManager.isDatabaseLoaded;
DataManager.isDatabaseLoaded = function() {
	return NYA.IFRAME.DataManager_isDatabaseLoaded.apply(this, arguments) && this._iframeLoaded;
};

DataManager.loadIFrame = function() {
	this.loadNormalFile("data/iframe.xlsx", this.onIFrameXLSXLoad.bind(this), this.onIFrameXLSXError.bind(this));
};

DataManager.onIFrameXLSXError = function() {
	throw("iframe.xlsx loading error.");
};

DataManager.onIFrameXLSXLoad = function(buffer) {
	const xlsxBook = XLSX.read(buffer, {bookType: 'xlsx', type: 'array'});
	if(!xlsxBook) {
		this.onIFrameXLSXError();
	}
	xlsxBook.SheetNames.forEach((sheetName) => {
		const sheet = xlsxBook.Sheets[sheetName];
		if(sheetName === "ImageFrame") {
			this.loadImageFrameXLSXSheet(sheet);
		} else if(sheetName === "AttackFrame") {
			this.loadAttackFrameXLSXSheet(xlsxBook.Sheets, sheet);
		}
	});
	this._iframeLoaded = true;
};

DataManager.loadImageFrameXLSXSheet = function(sheet) {
	const data = {};
	let i = 2;
	while(sheet["A" + i]) {
		const info = new ImageFrameData();
		const name = sheet["A" + i].w;
		info.width = Utils.tryParseInt(Utils.tryParseSheet(sheet["B" + i]), 1);
		info.height = Utils.tryParseInt(Utils.tryParseSheet(sheet["C" + i]), 1);
		info.anchorX = Utils.tryParseNumber(Utils.tryParseSheet(sheet["D" + i]), 0.5);
		info.anchorY = Utils.tryParseNumber(Utils.tryParseSheet(sheet["E" + i]), 1);
		info.frameSpeed = Utils.tryParseInt(Utils.tryParseSheet(sheet["F" + i]), 1);
		info.rtl = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["G" + i]), false);
		info.frameSpeedDetail = !!sheet["H" + i] ? JSON.parse(Utils.tryParseSheet(sheet["H" + i])) : null;
		info.res = Utils.tryParseSheet(sheet["I" + i]);
		info.blendMode = Utils.tryParseInt(Utils.tryParseSheet(sheet["J" + i]));
		info.noCycle = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["K" + i]));
		data[name] = info;
		i++;
	}
	ImageFrame.data = data;
};

DataManager.loadAttackFrameXLSXSheet = function(sheets, sheet) {
	const data = {};
	let i = 2;
	const sheetHit = sheets["HIT"];
	const sheetOnHit = sheets["ONHIT"];
	const sheetOnHitAttackChange = sheets["ONHITATTACKCHANGE"];
	const sheetAction = sheets["ATTACKACTION"]; 
	const bullet = sheets["BULLET"];
	const sheetSectionAction = sheets["ATTACKSECTIONACTION"];
	while(sheet["A" + i]) {
		const info = new AttackFrameData();
		const name = sheet["A" + i].w;
		
		info.next = Utils.tryParseSheet(sheet["B" + i]);
		info.nextDelay = Utils.tryParseInt(Utils.tryParseSheet(sheet["C" + i]));
		info.cd = Utils.tryParseInt(Utils.tryParseSheet(sheet["D" + i]));
		info.sp = Utils.tryParseInt(Utils.tryParseSheet(sheet["E" + i]));
		info.time = Utils.tryParseInt(Utils.tryParseSheet(sheet["F" + i]));
		info.image = Utils.tryParseSheet(sheet["G" + i]);
		info.moveimage = Utils.tryParseSheet(sheet["H" + i]);
		info.jumpimage = Utils.tryParseSheet(sheet["I" + i]);
		info.breakPriority = Utils.tryParseInt(Utils.tryParseSheet(sheet["J" + i]));
		info.unlockId = Utils.tryParseInt(Utils.tryParseSheet(sheet["K" + i]));
		info.suspendGravity = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["L" + i]));
		info.suspendFriction = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["M" + i]));
		info.softBreak = Utils.tryParseInt(Utils.tryParseSheet(sheet["N" + i]));
		info.heavyLock = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["O" + i]));
		info.se = Utils.tryParseSheet(sheet["P" + i]);
		info.se2 = Utils.tryParseSheet(sheet["Q" + i]);
		info.se3 = Utils.tryParseSheet(sheet["R" + i]);
		info.zxc = Utils.tryParseSheet(sheet["S" + i]);
		info.zp = Utils.tryParseInt(Utils.tryParseSheet(sheet["T" + i]));
		info.specialAction = Utils.tryParseSheet(sheet["U" + i]);
		info.fx = Utils.tryParseInt(Utils.tryParseSheet(sheet["V" + i]));
		info.fy = Utils.tryParseInt(Utils.tryParseSheet(sheet["W" + i]));
		info.enableFx = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["X" + i]));
		info.enableFy = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["Y" + i]));
		info.airFreeSp = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["Z" + i]));
		info.endFlags = Utils.tryParseIntArray(Utils.tryParseSheet(sheet["AA" + i]));
		info.lockInvincible = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["AB" + i]));
		info.ftime = Utils.tryParseInt(Utils.tryParseSheet(sheet["AC" + i]));
		info.temporaryScreenZ = Utils.tryParseNumber(Utils.tryParseSheet(sheet["AD" + i]));
		info.changePhysicsFlag = Utils.tryParseInt(Utils.tryParseSheet(sheet["AE" + i]));
		info.animationId = Utils.tryParseInt(Utils.tryParseSheet(sheet["AF" + i]));
		info.staticAnimationId = Utils.tryParseInt(Utils.tryParseSheet(sheet["AG" + i]));
		info.noControlTimeExBreak = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["AH" + i]));
		info.nextAttackNoSe = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["AI" + i]));
		info.noDirectionLock = Utils.tryParseBoolean(Utils.tryParseSheet(sheet["AJ" + i]));
		info.noJumpTime = Utils.tryParseInt(Utils.tryParseSheet(sheet["AK" + i]));
		data[name] = info;
		i++;
	}
	i = 2;
	const fill = {};
	while(sheetHit["A" + i]) {
		const info = new AttackFrameHitData();
		const name = sheetHit["A" + i].w;
		data[name].hit.push(info);
		info.vertices = JSON.parse(Utils.tryParseSheet(sheetHit["B" + i]));
		info.delay = Utils.tryParseInt(Utils.tryParseSheet(sheetHit["C" + i]));
		info.time = Utils.tryParseInt(Utils.tryParseSheet(sheetHit["D" + i]));
		info.se = Utils.tryParseSheet(sheetHit["E" + i]);
		info.se2 = Utils.tryParseSheet(sheetHit["F" + i]);
		fill[name] = 0;
		i++;
	}
	i = 2;
	while(sheetOnHit["A" + i]) {
		const info = new AttackFrameOnHitData();
		const name = sheetOnHit["A" + i].w;
		const idx = fill[name];
		data[name].hit[idx].onHit = info;
		fill[name]++;
		info.noHitF = Utils.tryParseBoolean(Utils.tryParseSheet(sheetOnHit["B" + i]));
		info.staggerTime = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["C" + i]));
		info.shake = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["D" + i]));
		info.damage = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["E" + i]));
		info.fx = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["F" + i]));
		info.fy = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["G" + i]));
		info.sfx = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["H" + i]));
		info.sfy = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["I" + i]));
		info.refresh_air = Utils.tryParseBoolean(Utils.tryParseSheet(sheetOnHit["J" + i]));
		info.noControlTime = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["K" + i]));
		info.specailHitFlag = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["L" + i]));
		info.noHitOnce = Utils.tryParseBoolean(Utils.tryParseSheet(sheetOnHit["M" + i]));
		info.hitCDTime = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["N" + i]));
		info.pauseTime = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["O" + i]));
		info.se = Utils.tryParseSheet(sheetOnHit["P" + i]);
		info.fix = Utils.tryParseBoolean(Utils.tryParseSheet(sheetOnHit["Q" + i]));
		info.animationId = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHit["R" + i]));
		info.attackForSpecialFlag = Utils.tryParseBoolean(Utils.tryParseSheet(sheetOnHit["S" + i]));
		info.buff = Utils.tryParseIntArray(Utils.tryParseSheet(sheetOnHit["T" + i]));
		i++;
	}
	for(const name in fill) {
		fill[name] = 0;
	}
	i = 2;
	while(sheetOnHitAttackChange["A" + i]) {
		const info = new AttackFrameOnHitAttackChangeData();
		const name = sheetOnHitAttackChange["A" + i].w;
		info.name = Utils.tryParseSheet(sheetOnHitAttackChange["B" + i]);
		info.pauseTime = Utils.tryParseInt(Utils.tryParseSheet(sheetOnHitAttackChange["C" + i]));
		const idx = fill[name];
		data[name].hit[idx].onHit.attackChange = info;
		fill[name]++;
		i++;
	}
	i = 2;
	while(sheetAction["A" + i]) {
		const info = new AttackFrameActionData();
		const name = sheetAction["A" + i].w;
		info.type = Utils.tryParseSheet(sheetAction["B" + i]);
		info.delay = Utils.tryParseInt(Utils.tryParseSheet(sheetAction["C" + i]));
		info.para = Utils.tryParseIntArray(Utils.tryParseSheet(sheetAction["D" + i]));
		data[name].action.push(info);
		i++;
	}
	i = 2;
	while(bullet["A" + i]) {
		const info = new AttackFrameBulletData();
		const name = bullet["A" + i].w;
		info.x = Utils.tryParseInt(Utils.tryParseSheet(bullet["B" + i]));
		info.y = Utils.tryParseInt(Utils.tryParseSheet(bullet["C" + i]));
		info.delay = Utils.tryParseInt(Utils.tryParseSheet(bullet["D" + i]));
		info.name = Utils.tryParseSheet(bullet["E" + i]);
		info.duplicate = Utils.tryParseInt(Utils.tryParseSheet(bullet["F" + i]));
		info.dirLock = Utils.tryParseBoolean(Utils.tryParseSheet(bullet["G" + i]));
		data[name].bullet.push(info);
		i++;
	}
	i = 2;
	while(sheetSectionAction["A" + i]) {
		const info = new AttackFrameSectionActionData();
		const name = sheetSectionAction["A" + i].w;
		info.type = Utils.tryParseSheet(sheetSectionAction["B" + i]);
		info.delay = Utils.tryParseInt(Utils.tryParseSheet(sheetSectionAction["C" + i]));
		info.time = Utils.tryParseInt(Utils.tryParseSheet(sheetSectionAction["D" + i]));
		info.para = Utils.tryParseIntArray(Utils.tryParseSheet(sheetSectionAction["E" + i]));
		data[name].sectionAction.push(info);
		i++;
	}
	AttackFrame.data = data;
};

function ImageFrameData() {
	this.initialize(...arguments);
}

ImageFrameData.prototype.initialize = function() {
	this.width = 1;
	this.height = 1;
	this.anchorX = 0.5;
	this.anchorY = 1;
	this.frameSpeed = 1;
	this.rtl = false;
	this.frameSpeedDetail = null;
	this.res = "";
	this.blendMode = 0;
	this.noCycle = false;
};

function ImageFrame() {
	throw new Error("This is a static class");
}

ImageFrame.info = function(characterName) {
	const data = this.data;
	const info = data[characterName];
	return info ? info : this.defaultData();
};

ImageFrame.data = null;

ImageFrame.defaultData = function() {
	return {
		width:1
		, height:1
		, anchorX:0.5
		, anchorY:1
		, frameSpeed:0
	};
};

function AttackFrameData() {
	this.initialize(...arguments);
}

AttackFrameData.prototype.initialize = function() {
	this.next = "";
	this.nextDelay = 0;
	this.cd = 0;
	this.sp = 0;
	this.time = 0;
	this.hit = [];
	this.image = "";
	this.moveimage = "";
	this.jumpimage = "";
	this.breakPriority = 0;
	this.unlockId = 0;
	this.suspendGravity = false;
	this.suspendFriction = false;
	this.softBreak = 0;
	this.heavyLock = false;
	this.se = "";
	this.se2 = "";
	this.se3 = "";
	this.zxc = "";
	this.zp = 0;
	this.specialAction = "";
	this.fx = 0;
	this.fy = 0;
	this.enableFx = false;
	this.enableFy = false;
	this.airFreeSp = false;
	this.bullet = [];
	this.jumpnoend = false;
	this.action = [];
	this.lockInvincible = false;
	this.ftime = 0;
	this.temporaryScreenZ = 0;
	this.changePhysicsFlag = 0;
	this.animationId = 0;
	this.staticAnimationId = 0;
	this.noControlTimeExBreak = false;
	this.downnoend = false;
	this.upnoend = false;
	this.sectionAction = [];
	this.nextAttackNoSe = false;
	this.noDirectionLock = false;
	this.noJumpTime = 0;
};

AttackFrameData.prototype.randSelectSe = function() {
	if(!this.se3 && !this.se2) {
		return this.se;
	}
	if(!this.se3) {
		return Math.random() < 0.5 ? this.se : this.se2;
	}
	const seed = Utils.randomInt(0, 2);
	if(seed === 0) {
		return this.se;
	} else if(seed === 1) {
		return this.se2;
	} else {
		return this.se3;
	}
};

function AttackFrameHitData() {
	this.initialize(...arguments);
}

AttackFrameHitData.prototype.initialize = function() {
	this.onHit = new AttackFrameOnHitData();
	this.vertices = [];
	this.delay = 0;
	this.time = 0;
	this.se = "";
	this.se2 = "";
};

AttackFrameHitData.prototype.randSelectSe = function() {
	if(!this.se2) {
		return this.se;
	}
	return Math.random() < 0.5 ? this.se : this.se2;
};

function AttackFrameOnHitData() {
	this.initialize(...arguments);
}

AttackFrameOnHitData.prototype.initialize = function() {
	this.noHitF = false;
	this.attackChange = new AttackFrameOnHitAttackChangeData();
	this.staggerTime = 0;
	this.shake = 0;
	this.damage = 0;
	this.fx = 0;
	this.fy = 0;
	this.sfx = 0;
	this.sfy = 0;
	this.refresh_air = false;
	this.noControlTime = 0;
	this.specailHitFlag = 0;
	this.noHitOnce = false;
	this.hitCDTime = 0;
	this.pauseTime = 0;
	this.se = "";
	this.fix = false;
	this.animationId = 0;
	this.buff = [];
};

function AttackFrameOnHitAttackChangeData() {
	this.initialize(...arguments);
}

AttackFrameOnHitAttackChangeData.prototype.initialize = function() {
	this.name = "";
	this.pauseTime = 0;
};

function AttackFrameBulletData() {
	this.initialize(...arguments);
}

AttackFrameBulletData.prototype.initialize = function() {
	this.delay = 0;
	this.name = "";
	this.x = 0;
	this.y = 0;
	this.duplicate = 0;
	this.dirLock = false;
};

function AttackFrameActionData() {
	this.initialize(...arguments);
}

AttackFrameActionData.prototype.initialize = function() {
	this.type = "";
	this.delay = 0;
	this.para = [];
};

function AttackFrameSectionActionData() {
	this.initialize(...arguments);
}

AttackFrameSectionActionData.prototype.initialize = function() {
	this.type = "";
	this.delay = 0;
	this.para = [];
	this.time = 0;
};

function AttackFrame() {
	throw new Error("This is a static class");
}

AttackFrame.info = function(attackName) {
	const data = this.data;
	const info = data[attackName];
	return info;
};

AttackFrame.extractKeys = function() {
	const result = [];
	for(const name in this.data) {
		const keys = Object.keys(this.data[name]);
		for(const key of keys) {
			if(!result.includes(key)) {
				result.push(key);
			}
		}
	}
	return result;
};

AttackFrame.extractXLSX = function() {
	let result = "";
	let hitresult = "";
	let onhitresult = "";
	let onhitattackchangeresult = "";
	let actionresult = "";
	let bulletresult = "";
	for(const name in this.data) {
		let hitId = 0;
		let bulletId = 0;
		let actionId = 0;
		const info = this.data[name];
		result += name;
		result += "\t";
		const infoInstance = new AttackFrameData();
		Object.assign(infoInstance, info);
		result += infoInstance.next;
		result += "\t";
		result += infoInstance.nextDelay;
		result += "\t";
		result += infoInstance.cd;
		result += "\t";
		result += infoInstance.sp;
		result += "\t";
		result += infoInstance.time;
		result += "\t";
		result += JSON.stringify(infoInstance.hit.map((data) => { 
			if(data.onHit.attackChange) {
				const attackchangeinfo = new AttackFrameOnHitAttackChangeData();
				const onHit = data.onHit || {};
				Object.assign(attackchangeinfo, onHit.attackChange || {});
				onhitattackchangeresult += name;
				onhitattackchangeresult += "\t";
				onhitattackchangeresult += hitId;
				onhitattackchangeresult += "\t";
				onhitattackchangeresult += attackchangeinfo.name;
				onhitattackchangeresult += "\t";
				onhitattackchangeresult += attackchangeinfo.pauseTime;
				onhitattackchangeresult += "\n";
			}
			const onhitinfo = new AttackFrameOnHitData();
			Object.assign(onhitinfo, data.onHit || {});
			onhitresult += name;
			onhitresult += "\t";
			onhitresult += hitId;
			onhitresult += "\t";
			onhitresult += onhitinfo.noHitF ? "1" : "";
			onhitresult += "\t";
			onhitresult += onhitinfo.staggerTime;
			onhitresult += "\t";
			onhitresult += onhitinfo.shake;
			onhitresult += "\t";
			onhitresult += onhitinfo.damage;
			onhitresult += "\t";
			onhitresult += onhitinfo.fx;
			onhitresult += "\t";
			onhitresult += onhitinfo.fy;
			onhitresult += "\t";
			onhitresult += onhitinfo.sfx;
			onhitresult += "\t";
			onhitresult += onhitinfo.sfy;
			onhitresult += "\t";
			onhitresult += onhitinfo.refresh_air ? "1" : "";
			onhitresult += "\t";
			onhitresult += onhitinfo.noControlTime;
			onhitresult += "\t";
			onhitresult += onhitinfo.specailHitFlag;
			onhitresult += "\n";
			
			const info = new AttackFrameHitData();
			Object.assign(info, data);
			hitresult += name;
			hitresult += "\t";
			hitresult += hitId;
			hitresult += "\t";
			hitresult += JSON.stringify(info.vertices);
			hitresult += "\t";
			hitresult += info.delay;
			hitresult += "\t";
			hitresult += info.time;
			hitresult += "\t";
			hitresult += info.se;
			hitresult += "\n";
			return hitId++; 
		}));
		result += "\t";
		result += infoInstance.image;
		result += "\t";
		result += infoInstance.moveimage;
		result += "\t";
		result += infoInstance.jumpimage;
		result += "\t";
		result += infoInstance.breakPriority;
		result += "\t";
		result += infoInstance.unlockId;
		result += "\t";
		result += (infoInstance.suspendGravity ? "1" : "");
		result += "\t";
		result += (infoInstance.suspendFriction ? "1" : "");
		result += "\t";
		result += infoInstance.softBreak;
		result += "\t";
		result += (infoInstance.heavyLock ? "1" : "");
		result += "\t";
		result += infoInstance.se;
		result += "\t";
		result += infoInstance.zxc;
		result += "\t";
		result += infoInstance.zp;
		result += "\t";
		result += infoInstance.specialAction;
		result += "\t";
		result += infoInstance.fx;
		result += "\t";
		result += infoInstance.fy;
		result += "\t";
		result += (infoInstance.enableFx ? "1" : "");
		result += "\t";
		result += (infoInstance.enableFy ? "1" : "");
		result += "\t";
		result += (infoInstance.airFreeSp ? "1" : "");
		result += "\t";
		result += JSON.stringify(infoInstance.bullet.map((data) => { 
			const info = new AttackFrameBulletData();
			Object.assign(info, data);
			bulletresult += name;
			bulletresult += "\t";
			bulletresult += bulletId;
			bulletresult += "\t";
			bulletresult += info.x;
			bulletresult += "\t";
			bulletresult += info.y;
			bulletresult += "\t";
			bulletresult += info.delay;
			bulletresult += "\t";
			bulletresult += info.name;
			bulletresult += "\t";
			bulletresult += info.duplicate;
			bulletresult += "\n";
			return bulletId++; 
		}));
		result += "\t";
		result += (infoInstance.jumpnoend ? "1" : "");
		result += "\t";
		result += JSON.stringify(infoInstance.action.map((data) => { 
			const info = new AttackFrameActionData();
			Object.assign(info, data);
			actionresult += name;
			actionresult += "\t";
			actionresult += actionId;
			actionresult += "\t";
			actionresult += info.type;
			actionresult += "\t";
			actionresult += info.delay;
			actionresult += "\t";
			actionresult += JSON.stringify(info.para);
			actionresult += "\n";
			return actionId++; 
		}));
		result += "\t";
		result += (infoInstance.lockInvincible ? "1" : "");
		result += "\t";
		result += infoInstance.ftime;
		result += "\t";
		result += infoInstance.temporaryScreenZ;
		result += "\t";
		result += infoInstance.changePhysicsFlag;
		result += "\n";
	}
	return {result:result, bulletresult:bulletresult, actionresult:actionresult, hitresult:hitresult, onhitresult:onhitresult, onhitattackchangeresult:onhitattackchangeresult};
};

AttackFrame.data = null;

function BulletFrame() {
	throw new Error("This is a static class");
}

BulletFrame.info = function(bulletName) {
	const data = this.data;
	const info = data[bulletName];
	return info;
};

BulletFrame.data = 
	{
		"cat1_bullet" : {
			type: 0				// 直线运行ax = yb，经过一段时间消失，可规定拥有攻击判定的时间段，可定义各个时间段内的动画组
			, liveTime:70
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:9
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:70, interval:120}]
			, image:[{start:1, end:70, name:";cat1_bullet_run"}]
			, endimage:{time:12, name:";cat1_bullet_end"}
			, vertices:[{x:-7,y:7},{x:7,y:7},{x:7,y:-7},{x:-7,y:-7}]
			, path:[{start:1, end:70, type:-1, a:4, b:0}]
			, end_se:"cat1_ball_end"
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		,"zxc1_bullet" : {
			type: 0
			, liveTime:60
			, canThroughTerrain:true
			
			, onHit: {
				staggerTime:45
				, shake:3
				, pauseTime:6
				, damage:9
				, fx:15
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:75
			}
			, attackTime:[{start:15, end:65, interval:20}]
			, image:[{start:1, end:60, name:";toru_zxc_bullet1"}]
			, endimage:{time:12, type:"fadeout"}
			, vertices:[{"x":-4,"y":192},{"x":142,"y":106},{"x":226,"y":-42},{"x":226,"y":-202},{"x":96,"y":-202},{"x":-156,"y":-82}]
			, path:[{start:1, end:60, type:-1, a:1, b:0}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		,"mushroom_bullet" : {
			type: 1			//  y = x^2 抛物线运行的弹道，a纵向加速度，(b, g)横向随机速度区间，c纵向速度最大值，纵向速度的绝对值不会超过这个速度
			, liveTime:480			// ，d纵向速度初始值随机max，e纵向速度初始值随机min，f是x轴速度递减值，最多x轴速度减少（增加）到0，h是否根据怪物朝向反转X轴参数，朝右为正数基准
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:6
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:480, interval:60}]
			, image:[{start:1, end:480, name:";mushroom_bullet"}]
			, endimage:{time:6, type:"fadeout"}
			, vertices:[{x:-6,y:6},{x:6,y:6},{x:6,y:-6},{x:-6,y:-6}]
			, path:[{start:1, end:480, type:-1, a:0.1, b:-4, c:8, d:-4, e:-8, f:0, g:4, h:0}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "glass_mon_bullet_hard": {
			type: 2				// 与type=0相同，但具体飞行方向是根据飞行道具的创建顺序决定的，速度值为a，第一发为自机狙，第二-最后一发则均匀分布在其他方向
			, liveTime:480
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:7
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:480, interval:120}]
			, image:[{start:1, end:480, name:";glass_mon_bullet"}]
			, endimage:{time:1, name:";glass_mon_bullet"}
			, vertices:[{x:-7,y:7},{x:7,y:7},{x:7,y:-7},{x:-7,y:-7}]
			, path:[{start:1, end:480, type:-1, a:6}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "glass_mon_bullet": {
			type: 2				
			, liveTime:480
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:7
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:480, interval:120}]
			, image:[{start:1, end:480, name:";glass_mon_bullet"}]
			, endimage:{time:1, name:";glass_mon_bullet"}
			, vertices:[{x:-7,y:7},{x:7,y:7},{x:7,y:-7},{x:-7,y:-7}]
			, path:[{start:1, end:480, type:-1, a:4}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "glass_mon_bullet_easy": {
			type: 2				
			, liveTime:480
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:7
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:480, interval:120}]
			, image:[{start:1, end:480, name:";glass_mon_bullet"}]
			, endimage:{time:1, name:";glass_mon_bullet"}
			, vertices:[{x:-7,y:7},{x:7,y:7},{x:7,y:-7},{x:-7,y:-7}]
			, path:[{start:1, end:480, type:-1, a:3}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "tortoise_bullet" : {
			type: 1	
			, liveTime:600
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:8
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:600, interval:60}]
			, image:[{start:1, end:600, name:";tortoise_bullet"}]
			, endimage:{time:6, type:"fadeout"}
			, vertices:[{x:-18,y:18},{x:18,y:18},{x:18,y:-18},{x:-18,y:-18}]
			, path:[{start:1, end:600, type:-1, a:-0.05, b:12, c:-4, d:0, e:0, f:-0.16, g:12, h:1}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "lightning_easy" : {
			type: 0
			, liveTime:999
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:8
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:120}]
			, image:[{start:1, end:999, name:";lightning"}]
			, endimage:{time:1, name:";lightning"}
			, vertices:[{x:-10,y:20},{x:10,y:20},{x:10,y:-20},{x:-10,y:-20}]
			, path:[{start:1, end:999, type:-1, a:0, b:4}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "lightning" : {
			type: 0
			, liveTime:999
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:8
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:120}]
			, image:[{start:1, end:999, name:";lightning"}]
			, endimage:{time:1, name:";lightning"}
			, vertices:[{x:-10,y:20},{x:10,y:20},{x:10,y:-20},{x:-10,y:-20}]
			, path:[{start:1, end:999, type:-1, a:0, b:5}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "lightning_hard" : {
			type: 0
			, liveTime:999
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:8
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:120}]
			, image:[{start:1, end:999, name:";lightning"}]
			, endimage:{time:1, name:";lightning"}
			, vertices:[{x:-10,y:20},{x:10,y:20},{x:10,y:-20},{x:-10,y:-20}]
			, path:[{start:1, end:999, type:-1, a:0, b:6}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "lightning2_easy" : {
			type: 3					// 与type2相同，但第一发不是自机狙而是固定朝下
			, liveTime:999
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:11
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:120}]
			, image:[{start:1, end:999, name:";lightning"}]
			, endimage:{time:1, name:";lightning"}
			, vertices:[{x:-10,y:20},{x:10,y:20},{x:10,y:-20},{x:-10,y:-20}]
			, path:[{start:1, end:999, type:-1, a:6}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "lightning2" : {
			type: 3
			, liveTime:999
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:11
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:120}]
			, image:[{start:1, end:999, name:";lightning"}]
			, endimage:{time:1, name:";lightning"}
			, vertices:[{x:-10,y:20},{x:10,y:20},{x:10,y:-20},{x:-10,y:-20}]
			, path:[{start:1, end:999, type:-1, a:7}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "lightning2_hard" : {
			type: 3
			, liveTime:999
			, canThroughTerrain:false
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:11
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:120}]
			, image:[{start:1, end:999, name:";lightning"}]
			, endimage:{time:1, name:";lightning"}
			, vertices:[{x:-10,y:20},{x:10,y:20},{x:10,y:-20},{x:-10,y:-20}]
			, path:[{start:1, end:999, type:-1, a:8}]
			, end_se:""
			, start_se:[]
			, upper:false
			, latestAttackingCounterDamageScale:0
		}
		, "toru_reverse_dash_attack_bullet": {
			type: 0
			, liveTime:999
			, canThroughTerrain:true
			
			, onHit: {
				staggerTime:0
				, shake:0
				, pauseTime:0
				, damage:17
				, fx:7
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:6
			}
			, attackTime:[{start:1, end:14, interval:120}]
			, image:[{start:1, end:14, name:";toru_reverse_dash_attack_bullet"}]
			, endimage:{time:1, name:";toru_reverse_dash_attack_bullet"}
			, vertices:[{"x":-70,"y":-66},{"x":4,"y":-66},{"x":48,"y":-46},{"x":72,"y":-16},{"x":72,"y":18},{"x":60,"y":34},{"x":30,"y":54},{"x":2,"y":64},{"x":-68,"y":64}]
			, path:[{start:1, end:14, type:-1, a:24, b:0}]
			, end_se:""
			, start_se:["toru_dash_bullet1","toru_dash_bullet2"]
			, upper:true
			, latestAttackingCounterDamageScale:0
		}
		, "toru_down_dash_attack_boom": {
			type: 0
			, liveTime:999
			, canThroughTerrain:true
			
			, onHit: {
				staggerTime:0
				, shake:0
				, pauseTime:0
				, damage:15
				, fx:11
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:9
				, specailHitFlag:1
			}
			, attackTime:[{start:1, end:20, interval:120}]
			, image:[{start:1, end:35, name:""}]
			, endimage:{time:1, name:""}
			, vertices:[{"x":64,"y":-155},{"x":155,"y":-64},{"x":155,"y":64},{"x":64,"y":155},{"x":-64,"y":155},{"x":-155,"y":64},{"x":-155,"y":-64},{"x":-64,"y":-155}]
			, path:[{start:1, end:35, type:-1, a:0, b:0}]
			, end_se:""
			, start_se:[]
			, upper:true
			, latestAttackingCounterDamageScale:8
		}
		, "berries_line": {
			type: 4
			, liveTime:180
			, canThroughTerrain:true
			
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:18
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:180, interval:120}]
			, image:[{start:1, end:180, name:";berries_bullet"}]
			, endimage:{time:1, name:";berries_bullet"}
			, vertices:[{"x":36,"y":36},{"x":36,"y":-36},{"x":-36,"y":-36},{"x":-36,"y":36}]
			, path:[{start:1, end:180, type:-1, a:30}]
			, end_se:""
			, start_se:[]
			, upper:true
			, latestAttackingCounterDamageScale:0
		}
		, "berries_prop1": {
			type: 0
			, liveTime:180
			, canThroughTerrain:true
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:15
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:180, interval:120}]
			, image:[{start:1, end:180, name:";berries_down_prop1"}]
			, endimage:{time:1, name:";berries_down_prop1"}
			, vertices:[{"x":-112,"y":-38},{"x":110,"y":-38},{"x":-30,"y":34},{"x":46,"y":34}]
			, path:[{start:1, end:180, type:-1, a:0, b:18}]
			, end_se:""
			, start_se:["berries_prop"]
			, upper:true
			, latestAttackingCounterDamageScale:0
		}
		, "berries_prop2": {
			type: 0
			, liveTime:8
			, canThroughTerrain:true
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:15
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:8, interval:120}]
			, image:[{start:1, end:8, name:";berries_down_prop2"}]
			, endimage:{time:1, name:";berries_down_prop2"}
			, vertices:[{"x":-112,"y":-38},{"x":122,"y":-38},{"x":-34,"y":36},{"x":40,"y":36}]
			, path:[{start:1, end:8, type:-1, a:0, b:0}]
			, end_se:""
			, start_se:[]
			, upper:true
			, latestAttackingCounterDamageScale:0
		}
		, "evil_wall_thick_bullet": {
			type: 0
			, liveTime:999
			, canThroughTerrain:true
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:15
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:999, interval:60}]
			, image:[{start:1, end:999, name:";evil_eye_long_bullet"}]
			, endimage:{time:1, name:";evil_eye_long_bullet"}
			, vertices:[{"x":-78,"y":-30},{"x":-78,"y":30},{"x":78,"y":30},{"x":78,"y":-30}]
			, path:[{start:1, end:999, type:-1, a:-4, b:0}]
			, end_se:""
			, start_se:[]
			, upper:true
			, latestAttackingCounterDamageScale:0
		}
		, "evil_wall_laser_bullet": {
			type: 5						// 跟随所有者的位置
			, liveTime:3
			, canThroughTerrain:true
			, onHit: {
				staggerTime:35
				, shake:0
				, pauseTime:0
				, damage:12
				, fx:0
				, fy:0
				, sfx:0
				, sfy:0
				, refresh_air:false
				, noControlTime:0
			}
			, attackTime:[{start:1, end:3, interval:60}]
			, image:[{start:1, end:3, name:";evil_eye_laser"}]
			, endimage:{time:1, name:";evil_eye_laser"}
			, vertices:[{"x":-960,"y":-20},{"x":-960,"y":20},{"x":960,"y":20},{"x":960,"y":-20}]
			, path:[{start:1, end:3, type:-1, a:-980, b:0}]
			, end_se:""
			, start_se:[]
			, upper:true
			, latestAttackingCounterDamageScale:0
		}
	};







//  y = x^2 抛物线运行的弹道，a纵向加速度，(b, g)横向随机速度区间，c纵向速度最大值，纵向速度的绝对值不会超过这个速度
// ，d纵向速度初始值随机max，e纵向速度初始值随机min，f是x轴速度递减值，最多x轴速度减少（增加）到0，h是否根据怪物朝向反转X轴参数，朝右为正数基准


//initStatemMembers[N](members)
//doPState[N](members, state)
//doPStateChange[N](members, oldState, newState)
//detectState[N](members)

// 0
Game_Event.prototype.initStatemMembers0 = function(members) {
	
};
Game_Event.prototype.doPState0 = function(members, state) {
	
};
Game_Event.prototype.doPStateChange0 = function(members, oldState, newState) {
	
};
Game_Event.prototype.detectState0 = function() {
	
};
// 1
Game_Event.prototype.initStatemMembers1 = function() {
	this.initBattleObject(1);
	this.m = 0.15;
};
Game_Event.prototype.doPState1 = function() {
};
Game_Event.prototype.doPStateChange1 = function() {
};
Game_Event.prototype.detectState1 = function() {
};

Game_Event.prototype.commonInit = function(members) {
	members.isTriggerLeft = this.direction() === 4;
	members.startAttackCD = 60;
	this.m = 0.2;
	this.setImage(this.battleObject().standingImage);
};

Game_Event.prototype.commonDoPStateChange = function(members, oldState, newState) {
	const obj = this.battleObject();
	if(obj.jumpDownImage && obj.jumpUpImage) {
		this.doPStateChange18(...arguments);
		return;
	}
	this.baseDoPStateChange(oldState, newState);
};

// 2
Game_Event.prototype.initStatemMembers2 = function(members) {
	this.commonInit(members);
	members.readyAttack = false;
	members.readyAttackCounter = 0;
};
Game_Event.prototype.doPState2 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	if(!members.readyAttack) {
		this.controlMove2(members);
	}
	if(members.startAttackCD > 0) {
		members.startAttackCD--;
	} else {
		this.controlAttack2(members);
	}
};
Game_Event.prototype.controlMove2 = function(members) {
	const x = members.isTriggerLeft ? -15 : 15;
	if(this.hitPreview(x, 1)) {     // 往前走不会掉下去
		const moveStrength = this.battleObject().moveStrength;
		const maxMoveSpeed = this.battleObject().maxMoveSpeed;
		const maxMoveSpeedDir = members.isTriggerLeft ? -maxMoveSpeed : maxMoveSpeed;
		if(!this.impactObject() || this._impactDirection !== 0) {
			this.performMove(moveStrength, maxMoveSpeed, members.isTriggerLeft, !members.isTriggerLeft);
		} else {
			members.isTriggerLeft = !members.isTriggerLeft;
			this.vx = 0;
		}
	} else {
		members.isTriggerLeft = !members.isTriggerLeft;
	}
};
Game_Event.prototype.controlAttack2 = function(members) {
	const distanceX = Math.abs(this.px - $gamePlayer.px);
	const distanceY = Math.abs(this.py - $gamePlayer.py);
	const difficulty = $gameSystem.difficulty();
	if(!this.isBodyAttacking() && !members.readyAttack && distanceY < 48 && distanceX < 200 && !this.isAttackCD("cat1_normal") && (members.isTriggerLeft && this.px > $gamePlayer.px || !members.isTriggerLeft && this.px < $gamePlayer.px)) {
		members.readyAttack = true;
		members.readyAttackCounter = difficulty === 1 ? 40 : (difficulty == 0 ? 60 : 80);
		$gameTemp.requestBalloon(this, 1);
	}
	if(members.readyAttack && members.readyAttackCounter > 0) {
		members.readyAttackCounter--;
		this.setDirection(members.isTriggerLeft ? 4 : 6);
	} else if(members.readyAttack) {
		members.readyAttack = false;
		if(this.requestBodyAttack("cat1_normal")) {
			if(difficulty === 1) {
				this.reduceAttackCD(90);
			} else if(difficulty === 0) {
				this.reduceAttackCD(50);
			}
		}
	}
};
Game_Event.prototype.doPStateChange2 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState2 = function() {
};

// 3
Game_Event.prototype.initStatemMembers3 = function(members) {
	this.commonInit(members);
	members.jumpcd = 0;
	members.attackReady = false;
	members.attackReadyCounter = 0;
};
Game_Event.prototype.doPState3 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	this.updateJumpCD(members);
	this.controlMove3(members);
	if(members.startAttackCD > 0) {
		members.startAttackCD--;
	} else {
		this.controlAttack3(members);
	}
};
Game_Event.prototype.updateJumpCD = function(members) {
	if(members.jumpcd) {
		members.jumpcd--;
	}
};
Game_Event.prototype.controlMove3 = function(members) {
	const x = members.isTriggerLeft ? -15 : 15;
	if(!this.isGrounding() || this.hitPreview(x, 1)) {     // 往前走不会掉下去 
		const moveStrength = this.battleObject().moveStrength;
		const maxMoveSpeed = this.battleObject().maxMoveSpeed;
		const maxMoveSpeedDir = members.isTriggerLeft ? -maxMoveSpeed : maxMoveSpeed;
		if(!this.impactObject() || this._impactDirection !== 0) {
			const rate = this.isBodyAttacking() ? 3 : 1;
			this.performMove(moveStrength, maxMoveSpeed * rate, members.isTriggerLeft, !members.isTriggerLeft, false);
		} else {
			members.isTriggerLeft = !members.isTriggerLeft;
			this.vx = 0;
		}
	} else if(this.isBodyAttacking()) {
		this.executeJump3(members);
	} else {
		members.isTriggerLeft = !members.isTriggerLeft;
	}
};
Game_Event.prototype.executeJump3 = function(members, cd = 40, se, jumpStrength) {
	if(members.jumpcd === 0) {
		jumpStrength = jumpStrength || this.battleObject().jumpStrength;
		this._vy = jumpStrength;
		AudioManager.playPlayerRoundSe(this, se ? se : ["enemy_jump1", "enemy_jump2", "enemy_jump3"].randomElement(), 0.6);
		members.jumpcd = cd;
		this._impact = null;		// 阻止系统自带的弹性碰撞
	}
};
Game_Event.prototype.controlAttack3 = function(members) {
	const distanceX = Math.abs(this.px - $gamePlayer.px);
	const distanceY = Math.abs(this.py - $gamePlayer.py);
	const difficulty = $gameSystem.difficulty();
	const skillName = this.difficultySkillName("cat2_normal");
	if(!this.isBodyAttacking() && !members.readyAttack && distanceY < 200 && distanceX < 240 && !this.isAttackCD(skillName) && (members.isTriggerLeft && this.px > $gamePlayer.px || !members.isTriggerLeft && this.px < $gamePlayer.px)) {
		members.readyAttack = true;
		members.readyAttackCounter = difficulty === 1 ? 40 : (difficulty == 0 ? 60 : 80);
		$gameTemp.requestBalloon(this, 1);
	}
	if(members.readyAttack && members.readyAttackCounter > 0) {
		members.readyAttackCounter--;
	} else if(members.readyAttack) {
		members.readyAttack = false;
		this.requestBodyAttack(skillName);
	}
};
Game_Event.prototype.doPStateChange3 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState3 = function() {
};


Game_Event.prototype.npcCommonInit = function(members) {
	this.m = 1;
	this._shoundUseSpeedCompareForMovingState = true;
	members.targetIndex = 0;
	members.waiting = Utils.randomInt(1, 300);
	members.state = 1;
	members.jumpSimulate = true;
	members.pathFinder = new Game_ProperPathFindContext();
	this.setImage(this.battleObject().standingImage);
}
// 4 NPC-AI
Game_Event.prototype.initStatemMembers4 = function(members) {
	this.npcCommonInit(members);
};
Game_Event.prototype.doPState4 = function(members) {
	if(this.isOutControl() || this.battleObject().targets.length === 0) {
		return;
	}
	const target = this.npcFindTarget(members);
	this.npcDeterminedTargetMove(members, target);
};
Game_Event.prototype.npcDeterminedTargetMove = function(members, target) {
	const tx = target.x;
	const ty = target.y;
	const smooth = target.smooth;
	const px = this.px;
	const py = this.py;
	const maxWaiting = this.battleObject().maxWaiting;
	const minWaiting = this.battleObject().minWaiting;
	if(px < tx - smooth && members.state === 0) {
		this.commonDirectionMove(6);
	} else if(px > tx + smooth && members.state === 0) {
		this.commonDirectionMove(4);
	} else if(py > ty && members.state === 0 && this.isGrounding()) {
		AudioManager.playPlayerRoundSe(this, "Jump1", 0.6);
		this._vy = this.battleObject().jumpStrength;
	} else if(members.state === 0) {
		members.state = 1;
		members.waiting = Utils.randomInt(minWaiting, maxWaiting);
	} else if(members.waiting > 0) {
		members.waiting--;
	} else {
		const targets = this.battleObject().targets;
		members.targetIndex = Utils.randomInt(0, targets.length - 1);
		members.state = 0;
	}
};
Game_Event.prototype.npcFindTarget = function(members) {
	const targets = this.battleObject().targets;
	if(members.targetIndex >= targets.length) {
		members.targetIndex = 0;
	}
	const target = targets[members.targetIndex];
	return target;
	
};
Game_Event.prototype.commonDirectionMove = function(dir) {
	const moveStrength = this.battleObject().moveStrength;
	const maxMoveSpeed = this.battleObject().maxMoveSpeed;
	const x = dir === 4 ? -24 : 24;
	if(this.isGrounding() && this.hitPreview(x, 0)) {
		AudioManager.playPlayerRoundSe(this, "Jump1", 0.6);
		this._vy = this.battleObject().jumpStrength;
	} else {
		this.performMove(moveStrength, maxMoveSpeed, dir === 4, dir !== 4);
	}
};
Game_Event.prototype.doPStateChange4 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState4 = function(members) {
	this.smoothDirection();
};

Game_Event.prototype.initStatemMembers5 = function() {
	this.initBattleObject(5);
	this.m = 99999;
};
Game_Event.prototype.doPState5 = function() {
};
Game_Event.prototype.doPStateChange5 = function() {
};
Game_Event.prototype.detectState5 = function() {
};

// lilia's ai
Game_Event.prototype.initStatemMembers6 = function(members) {
	this.npcCommonInit(members);
};
Game_Event.prototype.doPState6 = function(members) {
	if(this.isOutControl()) {
		return;
	}
	this.processFinderResult(this.followPlayer(members));
};
Game_Event.prototype.doPStateChange6 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState6 = function(members) {
};

// 弹簧蘑菇
Game_Event.prototype.initStatemMembers7 = function(members) {
	members.state = 0;
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState7 = function(members, state) {
	if(members.state > 0) {
		members.state--;
	}
};
Game_Event.prototype.doPStateChange7 = function(members, oldState, newState) {
	const obj = this.battleObject();
	switch(newState) {
		case 0: this.resetImage(obj.standingImage); break;
		case 1: this.resetImage(obj.movingImage); break;
		default: this.resetImage(obj.standingImage); break;
	}
};
Game_Event.prototype.detectState7 = function(members) {
	const hitBefore = this.hitPreviewDynamicObject(0, 0) || [];
	const hitAfter = this.hitPreviewDynamicObject(0, -$gameMap.mg() - 1) || [];
	for(const event of hitAfter) {
		if(!hitBefore.includes(event)) {
			event.vy = this.battleObject().jumpStrength;
			event.onMushroomHit();
			if(event._impact === this) {
				event._impact = null;		// 阻止系统自带的弹性碰撞
			}
			if(!members.state) {
				members.state = 32;
				AudioManager.playPlayerRoundSe(this, "mushroom", 0.9);
			}
		}
	}
	this.setPstate(members.state === 0 ? 0 : 1);
};

// 大石头
Game_Event.prototype.initStatemMembers8 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.setVertices([{"x":48,"y":-83},{"x":96,"y":0},{"x":48,"y":83},{"x":-48,"y":83},{"x":-96,"y":0},{"x":-48,"y":-83}]);
	this.m = 8;
};
Game_Event.prototype.doPState8 = function(members, state) {
	if(this._groundHitObj && this._groundHitObj.battleObject() && !this._groundHitObj.isSquash()) {
		this._groundHitObj.requestSquashEffect();
	}
	if(this.isGrounding() && members.state !== this.px) {
		const rotation = this.rotation();
		this.setImmueVground(true);
		if(this.direction() === 4) {
			const result = !this.hitPreviewFixObject(-6, 0);
			if(result) {
				this.setRotation(rotation - 0.03);
				this.vx = -6;
			}
		} else {
			const result = !this.hitPreviewFixObject(6, 0);
			if(result) {
				this.setRotation(rotation + 0.03);
				this.vx = 6;
			}
		}
		this.setImmueVground(false);
		if(this._groundHitObj.triggerDamage && this._groundHitObj.triggerDamage.moveBack) {
			this.py++;
			this.vx = 0;
		} 
	}
};
Game_Event.prototype.doPStateChange8 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState8 = function(members) {
	this.setPstate(0);
};

// 专门挤人的黑猫
Game_Event.prototype.initStatemMembers9 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.m = $gameSystem.difficulty() === 1 ? 3 : 0.7;
	members.jumpcd = 0;
	this.setFriction(0);
	this.setAirFriction(0);
};
Game_Event.prototype.doPState9 = function(members) {
	if(this.isAttackOutControl() && this.noControlTime()) {
		return;
	}
	this.updateJumpCD(members);
	this.controlMove9(members);
};
Game_Event.prototype.controlMove9 = function(members) {
	const xDistance = this.px - $gamePlayer.px;
	const isTriggerLeft = xDistance > 0;
	const x = isTriggerLeft ? -48 : 48;
	const moveStrength = this.battleObject().moveStrength + ($gameSystem.difficulty() === 1 ? 10 : 0);
	const maxMoveSpeed = this.battleObject().maxMoveSpeed + ($gameSystem.difficulty() === 1 ? 5 : 0);
	if(this.hitPreview(x, 1)) {     // 往前走不会掉下去
		const maxMoveSpeedDir = isTriggerLeft ? -maxMoveSpeed : maxMoveSpeed;
		const hit = this.hitPreview(maxMoveSpeedDir, 0) || [];
		if(hit.length === 0 || hit.includes($gamePlayer)) {
			this.performMove(moveStrength, maxMoveSpeed, isTriggerLeft, !isTriggerLeft, true);
		} else if(this.isGrounding()) {
			this.executeJump3(members, 20, "cat3jump");
		}
	} else if(this.isGrounding()) {
		this.executeJump3(members, 20, "cat3jump");
	} else {
		if(Math.abs(xDistance) > $gameMap.tileWidth()) {
			this.performMove(moveStrength, maxMoveSpeed, isTriggerLeft, !isTriggerLeft, true);
		} else {
			this.performMove(moveStrength, maxMoveSpeed / 4, isTriggerLeft, !isTriggerLeft, true);
		}
	}
};
Game_Event.prototype.doPStateChange9 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState9 = function() {
	const maxMoveSpeed = this.battleObject().maxMoveSpeed + ($gameSystem.difficulty() === 1 ? 5 : 0);
	this.smoothDirection(maxMoveSpeed);
};
Game_Event.prototype.smoothDirection = function(maxMoveSpeed) {
	if(this.isBodyAttacking()) {
		return;
	}
	maxMoveSpeed = maxMoveSpeed || this.battleObject().maxMoveSpeed;
	if(this._vx >= maxMoveSpeed && this.direction() === 4) {
		this.setDirection(6);
	} else if(this._vx <= -maxMoveSpeed && this.direction() === 6) {
		this.setDirection(4);
	}
	if(Math.abs(this.vx) <= 1 && this.isGrounding()) {
		this.setPstate(0);
	}
};
Game_Event.prototype.smoothDirection2 = function(maxMoveSpeed) {
	if(this.isBodyAttacking()) {
		return;
	}
	maxMoveSpeed = maxMoveSpeed || this.battleObject().maxMoveSpeed;
	if(this._vx >= maxMoveSpeed && this.direction() === 4) {
		this.setDirection(6);
	} else if(this._vx <= -maxMoveSpeed && this.direction() === 6) {
		this.setDirection(4);
	}
};

// 大石头-坠落型
Game_Event.prototype.initStatemMembers10 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.setVertices([{"x":40,"y":-69},{"x":80,"y":0},{"x":40,"y":69},{"x":-40,"y":69},{"x":-80,"y":0},{"x":-40,"y":-69}]);
	this.m = 99999;
	this.setFriction(1);
	this.setAirFriction(1);
	members.state = this.px;
};
Game_Event.prototype.doPState10 = function(members, state) {
	if(this._groundHitObj && this._groundHitObj.battleObject() && !this._groundHitObj.isSquash()) {
		this._groundHitObj.requestSquashEffect();
	}
	if(this.px < (members.state - 2)) {
		this.vx = 2;
	} else if(this.py > (members.state + 2)) {
		this.vx = -2;
	} else {
		this.vx = 0;
	}
	if(this._groundHitObj && this._groundHitObj.triggerDamage && this._groundHitObj.triggerDamage.moveBack) {
		this.py++;
		this.vx = 0;
	} 
};
Game_Event.prototype.doPStateChange10 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState10 = function(members) {
	this.setPstate(0);
};

// 缆车
Game_Event.prototype.initStatemMembers11 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.setVertices([{"x":-80,"y":-114},{"x":80,"y":-114},{"x":80,"y":-74},{"x":-80,"y":-74}]);
	this.type = 1;
	this.m = 999;
	members.targetIndex = 1;
	const initTarget = this.battleObject().targets[0];
	this.px = this.rx = initTarget.x;
	this.py = this.ry = initTarget.y;
	this.suspendGravity();
};
Game_Event.prototype.doPState11 = function(members, state) {
	const speed = this.battleObject().maxMoveSpeed;
	const target = this.battleObject().targets[members.targetIndex];
	if(this.px !== target.x || this.py !== target.y) {
		const dx = target.x - this.px;
		const dy = target.y - this.py;
		if(Math.abs(dx) >= speed) {
			this.vx = Utils.sign(dx) * speed;
		} else {
			this.vx = dx;
		}
		if(Math.abs(dy) >= speed) {
			this.vy = Utils.sign(dy) * speed;
		} else {
			this.vy = dy;
		}
	} else {
		members.targetIndex++;
		if(members.targetIndex >= this.battleObject().targets.length) {
			members.targetIndex = 0;
		}
		this.vx = this.vy = 0;
	}
	
};
Game_Event.prototype.doPStateChange11 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState11 = function(members) {
	this.setPstate(0);
};

// 缆车的高层栏杆图层，也充当缆车顶部的碰撞图层
Game_Event.prototype.initStatemMembers12 = function(members) {
	this.initStatemMembers11(members);
	this.setVertices([{"x":-96,"y":-266},{"x":96,"y":-266},{"x":96,"y":-226},{"x":-96,"y":-226}]);
};
Game_Event.prototype.doPState12 = function(members, state) {
	this.doPState11(members, state);
};
Game_Event.prototype.doPStateChange12 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState12 = function(members) {
	this.detectState11(members);
};

// 弹簧蘑菇，横着弹的
Game_Event.prototype.initStatemMembers13 = function(members) {
	members.state = 0;
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState13 = function(members, state) {
	if(members.state > 0) {
		members.state--;
	}
};
Game_Event.prototype.doPStateChange13 = function(members, oldState, newState) {
	const obj = this.battleObject();
	switch(newState) {
		case 0: this.resetImage(obj.standingImage); break;
		case 1: this.resetImage(obj.movingImage); break;
		default: this.resetImage(obj.standingImage); break;
	}
};
Game_Event.prototype.detectState13 = function(members) {
	const dir = this.direction() === 6;
	const hitBefore = this.hitPreviewDynamicObject(0, 0) || [];
	const hitAfter = this.hitPreviewDynamicObject(dir ? 22 : -22, 0) || [];
	for(const event of hitAfter) {
		if(!hitBefore.includes(event)) {
			event.vy = this.battleObject().jumpStrength;
			event.vx = dir ? this.battleObject().moveStrength : -this.battleObject().moveStrength;
			event.onMushroomHit();
			const noControlTime = this.battleObject().factorA || 120;
			event.setNoControlTime(noControlTime);
			event.enableTempFriction(0.2, noControlTime);
			if(event._impact === this) {
				event._impact = null;		// 阻止系统自带的弹性碰撞
			}
			if(!members.state) {
				members.state = 32;
				AudioManager.playPlayerRoundSe(this, "mushroom", 0.9);
			}
		}
	}
	this.setPstate(members.state === 0 ? 0 : 1);
};

// 弹簧蘑菇，对怪物弹力增加50%
Game_Event.prototype.initStatemMembers14 = function(members) {
	members.state = 0;
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState14 = function(members, state) {
	if(members.state > 0) {
		members.state--;
	}
};
Game_Event.prototype.doPStateChange14 = function(members, oldState, newState) {
	const obj = this.battleObject();
	switch(newState) {
		case 0: this.resetImage(obj.standingImage); break;
		case 1: this.resetImage(obj.movingImage); break;
		default: this.resetImage(obj.standingImage); break;
	}
};
Game_Event.prototype.detectState14 = function(members) {
	const hitBefore = this.hitPreviewDynamicObject(0, 0) || [];
	const hitAfter = this.hitPreviewDynamicObject(0, -1) || [];
	for(const event of hitAfter) {
		if(!hitBefore.includes(event)) {
			event.vy = event !== $gamePlayer ? this.battleObject().jumpStrength * 1.5 : this.battleObject().jumpStrength;
			event.onMushroomHit();
			if(event._impact === this) {
				event._impact = null;		// 阻止系统自带的弹性碰撞
			}
			if(!members.state) {
				members.state = 32;
				AudioManager.playPlayerRoundSe(this, "mushroom", 0.9);
			}
		}
	}
	this.setPstate(members.state === 0 ? 0 : 1);
};

// 荆棘
Game_Event.prototype.initStatemMembers15 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.m = 99;
};
Game_Event.prototype.doPState15 = function() {
	this.vx = this.vy = 0;
};
Game_Event.prototype.doPStateChange15 = function() {
};
Game_Event.prototype.detectState15 = function() {
};

// 蘑菇怪
Game_Event.prototype.initStatemMembers16 = function(members) {
	this.commonInit(members);
	members.jumpcd = 0;
	members.initAttack = false;
};
Game_Event.prototype.doPState16 = function(members) {
	if(this.isAttackOutControl()) {
		if(this.isStagger()) {
			members.initAttack = true;
		}
		return;
	}
	if(!members.initAttack) {
		if($gameMap.pixelDistance($gamePlayer.px, $gamePlayer.py, this.px, this.py) < 320) {
			this.requestBodyAttack("mushroom_monster_in");
			members.initAttack = true;
		} else {
			this.resetImage(";mushroom_monster_in");
		}
		return;
	}
	this.updateJumpCD(members);
	this.controlMove16(members);
	if(members.startAttackCD > 0) {
		members.startAttackCD--;
	} else {
		this.controlAttack16(members);
	}
};
Game_Event.prototype.controlMove16 = function(members) {
	const x = members.isTriggerLeft ? -48 : 48;
	if(!this.isGrounding() || this.hitPreview(x, 1)) {     // 往前走不会掉下去 
		const moveStrength = this.battleObject().moveStrength;
		const maxMoveSpeed = this.battleObject().maxMoveSpeed;
		const maxMoveSpeedDir = members.isTriggerLeft ? -maxMoveSpeed : maxMoveSpeed;
		if(this.isGrounding() && this.canAttackWithJump() && this.hitPreview(maxMoveSpeedDir * 10, 0)) {
			this.executeJump3(members);
		} else if(!this.impactObject() || this._impactDirection !== 0) {
			if($gameSystem.difficulty() === 1 && $gameMap.pixelDistance($gamePlayer.px, $gamePlayer.py, this.px, this.py) < 200) {
				this.performMove(moveStrength, maxMoveSpeed + 3, members.isTriggerLeft, !members.isTriggerLeft, false);
			} else {
				this.performMove(moveStrength, maxMoveSpeed, members.isTriggerLeft, !members.isTriggerLeft, false);
			}
		} else {
			members.isTriggerLeft = !members.isTriggerLeft;
			this.vx = 0;
		}
	} else {
		members.isTriggerLeft = !members.isTriggerLeft;
	}
};
Game_Event.prototype.controlAttack16 = function(members) {
	if($gameSystem.difficulty() === 1) {
		this.requestBodyAttack("mushroom_monster_normal_difficult");
	} else if($gameSystem.difficulty() === -1) {
		this.requestBodyAttack("mushroom_monster_normal_easy");
	} else {
		this.requestBodyAttack("mushroom_monster_normal");
	}
};
Game_Event.prototype.doPStateChange16 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState16 = function() {
};

Game_Event.prototype.initStatemMembers17 = function(members) {
	this.commonInit(members);
	this.m = 2;
	this.setFriction(3);
	this.setAirFriction(3);
	members.jumpcd = 0;
	members.attackReady = false;
	members.attackReadyCounter = 0;
};
Game_Event.prototype.doPState17 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	if(this.pixelDistanceToPlayer() > 620) {
		return;
	}
	this.updateJumpCD(members);
	this.controlMove17(members);
	if(members.startAttackCD > 0) {
		members.startAttackCD--;
	} else {
		this.controlAttack17(members);
	}
};
Game_Event.prototype.controlMove17 = function(members) {
	const targetX = $gamePlayer.px > this.px ? $gamePlayer.px - 82 : $gamePlayer.px + 82;
	const xDistance = this.px - targetX;
	const jumpStrength = $gameSystem.difficulty() === 1 ? this.battleObject().jumpStrength - 2 : this.battleObject().jumpStrength;
	if(Math.abs(xDistance) < 20) {
		if(this.isGrounding() && this.py > $gamePlayer.py + 48) {
			this.executeJump3(members, 40, undefined, jumpStrength);
		} else if($gameSystem.difficulty() === 1 && this.isGrounding() && this.py < $gamePlayer.py - 48) {
			this.setImmueVground(true);
		} else {
			this.setDirection($gamePlayer.px > this.px ? 6 : 4);
		}
		return;
	}
	this.setImmueVground(false);
	const isTriggerLeft = xDistance > 0;
	const x = isTriggerLeft ? -48 : 48;
	const moveStrength = this.battleObject().moveStrength;
	const maxMoveSpeed = $gameSystem.difficulty() === 1 ? this.battleObject().maxMoveSpeed + 2 : this.battleObject().maxMoveSpeed;
	if(this.hitPreview(x, 1)) {     // 往前走不会掉下去
		const maxMoveSpeedDir = isTriggerLeft ? -maxMoveSpeed : maxMoveSpeed;
		const hit = this.hitPreview(maxMoveSpeedDir, 0) || [];
		if(this.isGrounding() && !hit.includes($gamePlayer) && hit.length > 0) {
			this.executeJump3(members, 40, undefined, jumpStrength);
		} else {
			this.performMove(moveStrength, maxMoveSpeed, isTriggerLeft, !isTriggerLeft);
		}
	} else if(this.isGrounding()) {
		this.executeJump3(members, 40, undefined, jumpStrength);
	} else {
		if(Math.abs(xDistance) > 96) {
			this.performMove(moveStrength, maxMoveSpeed, isTriggerLeft, !isTriggerLeft);
		} else {
			this.performMove(moveStrength, maxMoveSpeed / 4, isTriggerLeft, !isTriggerLeft);
		}
	}
};
Game_Event.prototype.doPStateChange17 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState17 = function() {
};
Game_Event.prototype.controlAttack17 = function(members) {
	const distanceX = Math.abs(this.px - $gamePlayer.px);
	const distanceY = Math.abs(this.py - $gamePlayer.py);
	const difficulty = $gameSystem.difficulty();
	const skillName = "cat4_attack";
	if(!this.isBodyAttacking() && !members.readyAttack && distanceY < 60 && distanceX < 144 && !this.isAttackCD(skillName)) {
		members.readyAttack = true;
		members.readyAttackCounter = difficulty === 1 ? 40 : (difficulty == 0 ? 60 : 80);
		$gameTemp.requestBalloon(this, 1);
	}
	if(members.readyAttack && members.readyAttackCounter > 0) {
		members.readyAttackCounter--;
	} else if(members.readyAttack) {
		members.readyAttack = false;
		if(this.requestBodyAttack(skillName)) {
			if(difficulty === 1) {
				this.reduceAttackCD(140);
			} else if(difficulty === -1) {
				this.reduceAttackCD(-60);
			}
		}
	}
};

// boss-莉莉亚
Game_Event.prototype.initStatemMembers18 = function(members) {
	this.commonInit(members);;
	members.jumpcd = 0;
	members.shieldState = 0;
	members.shieldOpacity = 0;
	members.state = 0;
	members.shieldEventId = 6;
	members.initCD = 60;
	this.setFriction(3);
	this.setAirFriction(3);
};
Game_Event.prototype.doPState18 = function(members) {
	if(!$gameSwitches.value(56)) {
		return;
	}
	if($gameSystem.difficulty() === 1) {
		this.updateShieldEvent18(members);
	} else {
		this.unlockSkillInvincible();
		$gameMap.clearHotEvent();
	}
	if(this.isAttackOutControl()) {
		return;
	}
	if(members.initCD) {
		members.initCD--;
		return;
	}
	this.updateJumpCD(members);
	this.updateControlState18(members);
	this.updateControl18(members);
};

Game_Event.prototype.updateControlState18 = function(members) {
	const distance = this.pixelDistanceToPlayer();
	const distanceY = Math.abs(this.py - $gamePlayer.py);
	if(this.isBodyAttacking() || this._changeAttackInfo) {
		if(this._bodyAttacking === "lily_floating") {
			this.setControlState18(members, 0);
		} else {
			this.setControlState18(members, 9);
		}
		return;
	}
	const attackCD1 = this.isAttackCD(this.difficultySkillName("lily_pan_attack"));
	const attackCD2 = this.isAttackCD(this.difficultySkillName("lily_pan_jump_attack"));
	if(this.isGrounding() && !$gamePlayer.isInvincible()) {
		if(this.battleObject().hp <= this.battleObject().mhp / 2 && !this.isAttackCD(this.difficultySkillName("lily_zxc"))) {
			this.setControlState18(members, 3);
			return;
		}
		if(!this.isAttackCD("lily_throw_bomb")) {
			this.setControlState18(members, 4);
			return;
		}
		if(distance < 120 && distanceY < 60 && !attackCD1) {
			this.faceToPlayer();
			this.setControlState18(members, 6);
			return;
		}
		if(distance < 240 && distanceY < 100 && !attackCD2) {
			this.faceToPlayer();
			this.setControlState18(members, 1);
			return;
		}
		if(distance > 660 && !this.isAttackCD("lily_fan")) {
			this.faceToPlayer();
			this.setControlState18(members, 2);
			return;
		}
	}
	const attackCD3 = this.isAttackCD("lily_floating");
	if(members.shieldState === 1 && this.py < $gamePlayer._terrainGroundingY - 320 && !attackCD3) {
		this.setControlState18(members, 7);
		return;
	}
	if(distance < 240) {
		this.setControlState18(members, 0);
	} else if(distance > 480 && (!attackCD2 || !attackCD2)) {
		this.setControlState18(members, 5);
	}
};
Game_Event.prototype.difficultySkillName = function(name) {
	if($gameSystem.difficulty() === 1) {
		return name + "_hard";
	} else if($gameSystem.difficulty() === 0) {
		return name;
	} else {
		return name + "_easy";
	}
};
Game_Event.prototype.setControlState18 = function(members, state) {
	members.state = state;
};
Game_Event.prototype.updateControl18 = function(members) {
	switch(members.state) {
		case 0: {		// 跳跃+移动+远离玩家，选择左下角和右下角离玩家较远的作为目标点
			const distance1 = $gameMap.pixelDistance(0, $gameMap.height() * $gameMap.tileHeight(), $gamePlayer.px, $gamePlayer.py);
			const distance2 = $gameMap.pixelDistance($gameMap.width() * $gameMap.tileWidth(), $gameMap.height() * $gameMap.tileHeight(), $gamePlayer.px, $gamePlayer.py);
			let targetX = $gameMap.width() * $gameMap.tileWidth();
			if(distance1 > distance2) {		// 往右下角走
				targetX = 0
			}
			const dx = this.px - targetX;
			if(Math.abs(dx) > 100) {
				this.updateMoveSimple(dx > 0);
				if(this.isGrounding() && !this.isBodyAttacking()) {
					this.executeJump3(members, 180);
				}
			} else {
				this.faceToPlayer();
			}
			break;
		}
		case 1: {		// 平底锅跳劈
			this.requestBodyAttack(this.difficultySkillName("lily_pan_jump_attack"));
			break;
		}
		case 2: {		// 远程攻击，折扇剑气
			this.requestBodyAttack("lily_fan");
			break;
		}
		case 3: {		// 大招一飞冲天
			this.requestBodyAttack(this.difficultySkillName("lily_zxc"));
			break;
		}				
		case 4: {		// 扔炸弹
			this.requestBodyAttack("lily_throw_bomb");
			break;
		}
		case 5: {		// 接近玩家
			const dx = this.px - $gamePlayer.px;
			if(Math.abs(dx) > 100) {
				this.updateMoveSimple(dx > 0);
			} else {
				this.faceToPlayer();
			}
			break;
		}
		case 6: {		// 平底锅重击
			this.requestBodyAttack(this.difficultySkillName("lily_pan_attack"));
			break;
		}
		case 7: {
			this.requestBodyAttack("lily_floating");
			break;
		}
	}
};
Game_Event.prototype.updateShieldEvent18 = function(members) {
	if(this.isDeath()) {
		$gameMap.clearSpecProgress();
		return;
	}
	const eventId = members.shieldEventId;
	const event = $gameMap.event(eventId);
	$gameMap.setHotEvent(eventId);
	if(event.isDeathAnimationComplete() && members.shieldState === 0) {
		members.shieldState = 1;
		members.shieldOpacity = 0;
		this.battleObject().addBuff("invincible", 40);
		$gameMap.setSpecProgress(0);
		event.setOpacity(0);
	}
	if(members.shieldState === 1) {
		$gameMap.setSpecProgress($gameMap.specProgress() + 0.0018);
		if($gameMap.specProgress() >= 1) {
			members.shieldState = 0;
			event.physics = true;
			event._deathAnimationCompleted = false;
			AudioManager.playPlayerRoundSe(this, "Raise3");
			event.setupPageSettings();
			$gameMap.clearSpecProgress();
		}
	}
	if(members.shieldState === 0) {
		if(members.shieldOpacity < 255) {
			members.shieldOpacity += 10;
			members.shieldOpacity = members.shieldOpacity.clamp(0, 255);
			event.setOpacity(members.shieldOpacity);
		}
		this.lockSkillInvincible();
	} else {
		this.unlockSkillInvincible();
	}
};
Game_Event.prototype.doPStateChange18 = function(members, oldState, newState) {
	const battleObject = this.battleObject();
	switch(newState) {
		case 0: this.resetImage(battleObject.standingImage); break;
		case 1: this.resetImage(battleObject.movingImage); break;
		case 3: this.resetImage(battleObject.jumpDownImage); break;
		case 2: case 4: case 5: this.resetImage(battleObject.jumpUpImage); break;
		case 6: case 10: this.resetImage(battleObject.staggerImage); break;
		case 7: case 8: case 9: { 
			if(!this.normalAttackCompatibleStateGroup().includes(oldState)) {
				this.resetFrameAnimation(); 
			}
			this.setImage(this.preferAttackImage(newState));
			break;
		}
		default: this.resetImage(battleObject.standingImage); break;
	}
};
Game_Event.prototype.detectState18 = function() {
	this.smoothDirection2(this.battleObject().maxMoveSpeed / 2);
};

Game_Event.prototype.initStatemMembers19 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.setNoHpSmallBar(true);
};
Game_Event.prototype.doPState19 = function(members) {
};
Game_Event.prototype.doPStateChange19 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState19 = function() {
};

// 飞行怪
// 非攻击状态下与玩家保持距离
Game_Event.prototype.initStatemMembers20 = function(members) {
	this.commonInit(members);
	this.suspendGravity();
	this.setAirFriction(1);
	this.faceToPlayer();
	this.m = 40;
	this.setImmueVground(true);
	members.state = 0;
	members.attackReadyCounter = 0;
};
Game_Event.prototype.doPState20 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	if(this.pixelDistanceToPlayer() > 1200 && members.state === 0) {
		this.vx = this.vy = 0;
		return;
	} else if(members.state === 0) {
		members.state = 1;
	} else if(members.state === 1) {
		if(this.isAttackCD(this.difficultySkillName("cat5_attack"))) {
			this.faceToPlayer();
			if(this.pixelDistanceToPlayer() < 360) {
				this.updateMoveSimple(this.direction() === 6, 1, true);
				if(!this.noControlTime()) {
					this._vy -= 0.5;
					this._vy = Math.max(-8, this._vy);
				}
			} else if(this.py > $gamePlayer.py - 240 && !this.noControlTime()) {
				this._vy -= 0.5;
				this._vy = Math.max(-8, this._vy);
			} else {
				this._vy += (Utils.sign(this._vy) * -0.5);
				if(Math.abs(this._vy) < 1) {
					this._vy = 0;
				}
			}
		} else {
			if(!this.noControlTime()) {
				let speed = 14;
				if($gameSystem.difficulty() === -1) {
					speed = 10;
				} else if($gameSystem.difficulty() === 0) {
					speed = 12;
				}
				if(this.isBodyAttacking()) {
					this.vy = speed;
					this.vx = Utils.sign(this.direction() === 6) * speed;
				} else {
					this.faceToPlayer();
					this.updateMoveSimple(this.direction() === 4, 1, true);
					if(this.px === $gamePlayer.px) {
						this.vy = 2 * Utils.sign(($gamePlayer.py - 100) - this.py);
					} else {
						this.vy = (($gamePlayer.py - 100) - this.py) / ($gamePlayer.px - this.px) * this.vx;
						this.vy = this.vy.clamp(-speed, speed);
					}
				}
			}
			if(this.pixelDistanceToPlayer() < 240 && !this.isBodyAttacking()) {
				members.state = 2;
				members.attackReadyCounter = 0;
				$gameTemp.requestBalloon(this, 1);
			}
		}
	} else if(members.state === 2) {
		let time = 90;
		if($gameSystem.difficulty() === 1) {
			time = 50;
		} else if($gameSystem.difficulty() === 0) {
			time = 70;
		}
		members.attackReadyCounter++;
		if(members.attackReadyCounter >= time && this.requestBodyAttack(this.difficultySkillName("cat5_attack"))) {
			members.state = 1;
		} else {
			this.vx = this.vy = 0;
		}
	}
};
Game_Event.prototype.doPStateChange20 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState20 = function() {
	this.smoothDirection2();
};

// 笨重猫怪
Game_Event.prototype.initStatemMembers21 = function(members) {
	this.commonInit(members);
	this.faceToPlayer();
	this.m = 99;
	members.standing = 0;
	members.isTriggerLeft = this.direction() === 4;
	members.jumpcd = 0;
	members.isAttackReady = false;
	members.attackReadyCounter = 0;
};
Game_Event.prototype.doPState21 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	this.updateJumpCD(members);
	const distance = this.pixelDistanceToPlayer();
	const distanceY = Math.abs(this.py - $gamePlayer.py);
	if(this.isBodyAttacking()) {
		this.updateMoveSimple(this.direction() === 4, 2, false, 2);
	} else { 
		if(members.isAttackReady) {
			let time = 90;
			if($gameSystem.difficulty() === 1) {
				time = 35;
			} else if($gameSystem.difficulty() === 0) {
				time = 60;
			}
			if(members.attackReadyCounter > time) {
				if(this.requestBodyAttack(this.difficultySkillName("cat6_normal"))) {
					this.faceToPlayer();
					members.isAttackReady = false;
				}
			} else {
				members.attackReadyCounter++;
			}
			return;
		}
		if(distance <= 420 && distanceY <= 140 && !this.isAttackCD(this.difficultySkillName("cat6_normal"))) {
			$gameTemp.requestBalloon(this, 1);
			members.isAttackReady = true;
			members.attackReadyCounter = 0;
			return;
		} else if(distance < 580 && this.isGrounding() && !this.hitPreviewDynamicObject(0, -1) && this.requestBodyAttack("cat6_jump")) {
			return;
		}
		if(!this.isBodyAttacking() && $gamePlayer.py < this.py - 100 && distance < 240 && !this.hitPreviewDynamicObject(0, -1)) {
			this.executeJump3(members, 240);
		}
		if(!members.standing) {
			const dx = members.isTriggerLeft ? -60 : 60;
			if(this.hitPreviewNoVGround(dx, 0) || !this.hitPreview(dx, 2)) {
				members.standing = 300;
				members.isTriggerLeft = !members.isTriggerLeft;
			} else {
				this.updateMoveSimple(members.isTriggerLeft);
			}
		} else {
			members.standing--;
		}
	}
};
Game_Event.prototype.doPStateChange21 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
	switch(newState) {
		case 3: this.resetImage(this.battleObject().jumpDownImage); break;
		case 2: this.resetImage(this.battleObject().jumpUpImage); break;
	}
};
Game_Event.prototype.detectState21 = function() {
};

// 圆滚滚吸人猫怪
Game_Event.prototype.initStatemMembers22 = function(members) {
	this.commonInit(members);
	this.m = 0.5;
	members.isTriggerLeft = this.direction() === 4;
	members.attackReady = false;
	members.attackReadyCounter = 0;
};
Game_Event.prototype.doPState22 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	const difficulty = $gameSystem.difficulty();
	const attackName = this.difficultySkillName("cat7_attack");
	const distance = this.pixelDistanceToPlayer();
	if(!this.isBodyAttacking() && !members.readyAttack && distance < 380 && !this.isAttackCD(attackName)) {
		members.readyAttack = true;
		members.readyAttackCounter = difficulty === 1 ? 40 : (difficulty == 0 ? 60 : 80);
		$gameTemp.requestBalloon(this, 1);
	}
	if(members.readyAttack && members.readyAttackCounter > 0) {
		members.readyAttackCounter--;
		this.setDirection(members.isTriggerLeft ? 4 : 6);
	} else if(members.readyAttack) {
		members.readyAttack = false;
		if(this.requestBodyAttack(attackName)) {
			if(difficulty === 1) {
				this.reduceAttackCD(90);
			} else if(difficulty === 0) {
				this.reduceAttackCD(50);
			}
		}
	} 
	const dx = members.isTriggerLeft ? -20 : 20;
	if(this.hitPreviewNoVGround(dx, 0) || !this.hitPreview(dx, 1)) {
		members.isTriggerLeft = !members.isTriggerLeft;
	} else {
		this.updateMoveSimple(members.isTriggerLeft);
	}
};
Game_Event.prototype.doPStateChange22 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState22 = function() {
};

// 玻璃水母怪
Game_Event.prototype.initStatemMembers23 = function(members) {
	this.commonInit(members);
	members.state = 0;
	members.originalOnHitSe = this.battleObject().onHitSe;
};
Game_Event.prototype.doPState23 = function(members) {
	if(this.pixelDistanceToPlayer() > 600 && members.state === 0) {
		return;
	}
	if(members.state === 0) {
		members.state = 1;
		return;
	}
	this.vx = 0;
	this.vy = 0;
	if(this.battleObject().getBuffVal("def_up") === 1) {
		this.battleObject().onHitSe = ["glass_mon_onhit"];
		this.battleObject().beAttackSlashAnimations = [18];
	} else {
		this.battleObject().onHitSe = members.originalOnHitSe;
		this.battleObject().beAttackSlashAnimations = [];
	}
	if(this.isAttackOutControl()) {
		return;
	}
	if(!this.isBodyAttacking()) {
		this.battleObject().addBuff("def_up", 2);
	}
	this.requestBodyAttack(this.difficultySkillName("glass_mon_attack"));
};
Game_Event.prototype.doPStateChange23 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState23 = function() {
};

// 矿车
Game_Event.prototype.initStatemMembers24 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.m = 9999;
	members.isTriggerLeft = this.direction() === 4;
};
Game_Event.prototype.syncRelativeEvent24 = function(members) {
	const eventIds = this.battleObject().factorB;
	const events = eventIds.map((evid) => {
		return $gameMap.event(evid);
	});
	
	const switchOn = events[5].statemMembers().switchOn;
	if(switchOn === 2 && this.isGrounding()) {
		this.updateMoveSimple(members.isTriggerLeft, 2);
	} else if(switchOn === 0 && this.isGrounding()) {
		this.updateMoveSimple(members.isTriggerLeft);
	}
	if(this.py > $gameMap.height() * $gameMap.tileHeight()) {
		events[5].statemMembers().switchOn = 1;
	}
	const dir = this.direction() === 6 ? 1 : -1;
	events[0].rx = events[0].px = this.px - 88 * dir;		// 大轱辘左 - 不启用物理
	events[0].ry = events[0].py = this.py;
	events[1].rx = events[1].px = this.px - 28 * dir;		// 小轱辘左 - 不启用物理
	events[1].ry = events[1].py = events[0].py;
	events[2].rx = events[2].px = this.px + 10 * dir;		// 小轱辘中 - 不启用物理
	events[2].ry = events[2].py = events[0].py;
	events[3].rx = events[3].px = this.px + 48 * dir;		// 小轱辘右 - 不启用物理
	events[3].ry = events[3].py = events[0].py;
	events[4].rx = events[4].px = this.px + 100 * dir;		// 大轱辘右 - 不启用物理
	events[4].ry = events[4].py = events[0].py;
	events[0].flush();
	events[1].flush();
	events[2].flush();
	events[3].flush();
	events[4].flush();
	events[5].vx = events[5].vy = 0;
	if(switchOn === 2) {
		events[5].px = this.px - 115 * dir;		// 拉闸 - 往右边
		events[5].py = this.py - 148;
		events[5].setRotation(-Math.PI / 2 * dir);
	} else if(switchOn === 0) {
		events[5].px = this.px - 75 * dir;		// 拉闸 - 往左边
		events[5].py = this.py - 148;
		events[5].setRotation(0);
	} else {
		events[5].px = this.px - 90 * dir;		// 拉闸 - 往中间
		events[5].py = this.py - 148;
		events[5].setRotation(-Math.PI / 4 * dir);
	}
	const hit = this.hitPreview(dir, 0);
	if(hit) {
		const stop = hit.some((obj) => {
			return obj.terrain;
		});
		if(stop) {
			this.vx = 0;
			return;
		}
	}
	if(this.vx !== 0) {
		const rotation = events[0].rotation() + 0.05 * dir * (switchOn === 2 ? 2 : 1);
		events[0].setRotation(rotation);
		events[1].setRotation(rotation);
		events[2].setRotation(rotation);
		events[3].setRotation(rotation);
		events[4].setRotation(rotation);
	}
	events[0].setDirection(this.direction());
	events[1].setDirection(this.direction());
	events[2].setDirection(this.direction());
	events[3].setDirection(this.direction());
	events[4].setDirection(this.direction());
	events[5].setDirection(this.direction());
	if(this._groundHitObj && this._groundHitObj.triggerDamage && this._groundHitObj.triggerDamage.moveBack) {
		this.py++;
		this.vx = 0;
	} 
};
Game_Event.prototype.doPState24 = function(members) {
	this.syncRelativeEvent24(members);
};
Game_Event.prototype.doPStateChange24 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState24 = function() {
};

// 矿车的拉杆
Game_Event.prototype.initStatemMembers25 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.switchOn = 1;
	members.beHitNum = 0;
};
Game_Event.prototype.doPState25 = function(members) {
	if(members.beHitNum !== this.beHitNum()) {
		members.beHitNum = this.beHitNum();
		if(members.switchOn === 1) {
			members.switchOn = 0;
		} else if(members.switchOn === 0) {
			members.switchOn = 2;
		} else {
			members.switchOn = 0;
		}
	}
};
Game_Event.prototype.doPStateChange25 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState25 = function() {
};

// 带刺的铁球
Game_Event.prototype.initStatemMembers26 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.m = 99;
	members.d = this.battleObject().factorA;			// 初始转动方向（-1顺时针，1逆时针）;
	this.suspendGravity();
	this.suspendFriction();
	this.setVertices([{"x":0,"y":-76},{"x":42,"y":-60},{"x":60,"y":-44},{"x":74,"y":-6},{"x":74,"y":16},{"x":60,"y":48},{"x":44,"y":64}
	,{"x":14,"y":76},{"x":-20,"y":78},{"x":-48,"y":64},{"x":-66,"y":42},{"x":-78,"y":14},{"x":-78,"y":-10},{"x":-68,"y":-36},{"x":-40,"y":-66}]);
/* 	console.log(JSON.stringify(this.vertices.map((p) => {
		let x = 0; let y = 0;
		if(p.x > 0) {
			x = p.x + 12;
		} else if(p.x < 0) {
			x = p.x - 12;
		}
		if(p.y > 0) {
			y = p.y + 12;
		} else if(p.y < 0) {
			y = p.y - 12;
		}
		return {x:x, y:y};
	}))); */
	//const para = this.battleObject().factorB;
	//const stringEventId = para[0];
	//const stringEvent = $gameMap.event(stringEventId);
	this.lockInvincible();
};
Game_Event.prototype.doPState26 = function(members) {
	const para = this.battleObject().factorB;
	const stringEventId = para[0];		// 绳子的事件ID
	const rspeed = para[1];				// 最大角速度
	const rspeedAcc = para[2];			// 角速度的加速度
	const angleBound = rspeed * rspeed / rspeedAcc / 2;			// 最大摆动角度
	
	const stringEvent = $gameMap.event(stringEventId);
	const radius = stringEvent.patternHeight() / 2;			// 转动半径
	const rotation = stringEvent.rotation();
	const centerX = stringEvent.px;							// 扇形圆心X
	const centerY = stringEvent.py - radius;				// 扇形圆心Y
	const px = this.px + this.dotX;
	const py = this.py + this.dotY;
	const currentAngle = angleBound - Math.abs(angleBound - centerX === px ? 0 : Math.atan((centerX - px) / (centerY - py)));
	// (0 + n * rspeedAcc) * n / 2 = currentAngle;
	// n^2 = currentAngle / rspeedAcc * 2;
	const n = Math.round(Math.sqrt(Math.max(0, currentAngle) / rspeedAcc * 2));
	const currentAngleRounded = angleBound - (n * rspeedAcc) * n / 2;
	const nextAngle = Utils.sign(px - centerX) * currentAngleRounded + members.d * rspeedAcc * (n + 1);
	const nextX = centerX + radius * Math.sin(nextAngle);
	const nextY = centerY + radius * Math.cos(nextAngle);
	this.vx = nextX - px;
	this.vy = nextY - py;
	if(n === 0 && members.d * Utils.sign(px - centerX) === 1) {
		members.d *= -1;
	}
	stringEvent.setRotation(Utils.sign(centerX - px) * (angleBound - currentAngle));
	this.requestBodyAttack("iron_ball_attack");
};
Game_Event.prototype.doPStateChange26 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState26 = function() {
};

Game_Event.prototype.initStatemMembers27 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.isIn = false;
	members.angle = 0;
	members.strength = 0;
	members.strengthRollDirection = 1;
};
Game_Event.prototype.doPState27 = function(members) {
	const baseEvent = $gameMap.event(this.battleObject().factorA);
	const dir = Utils.sign(this.direction() === 6);
	this.px = baseEvent.px - 40 * dir;
	this.py = baseEvent.py + 36;
	baseEvent._mirrorLR = this._mirrorLR;
	if(!members.isIn) {
		this.setImage(this.battleObject().standingImage);
	} else {
		this.setImage(this.battleObject().movingImage);
		const baseAngleOffset = dir === 1 ? 0.38397 : Math.PI - 0.38397;		// 贴图的初始朝向角度
		const maxStrength = 50;
		
		members.strength += 0.01 * members.strengthRollDirection;
		if(members.strength >= 1) {
			members.strengthRollDirection = -1;
		} else if(members.strength <= 0) {
			members.strengthRollDirection = 1;
		}
		members.strength = members.strength.clamp(0, 1);
		$gameMap.setMovingCursorProgress(Math.round(members.strength * 1000) + 1);
		const left = Input.isTriggered('left') || Input.isLongPressed('left') || TouchInput.isScreenButtonPressed('left');
		const right = Input.isTriggered('right') || Input.isLongPressed('right') || TouchInput.isScreenButtonPressed('right');
		const cellLength = 0.01;		// 调整发射角度的粒度
		const minAngle = -baseAngleOffset;				// 从大炮朝向的水平线为0角度开始计算，逆时针转动角度逐渐增加
		const maxAngle = Math.PI - baseAngleOffset;
		if(left ^ right) {
			if(left) {
				members.angle += cellLength;
				if(members.angle > maxAngle) {
					members.angle -= cellLength;
				}
			}
			if(right) {
				members.angle -= cellLength;
				if(members.angle < minAngle) {
					members.angle += cellLength;
				}
			}
		}
		const realAngle = members.angle + baseAngleOffset;		// 实际发射的角度
		this.setRotation(-members.angle);
		$gamePlayer.rx = $gamePlayer.px = this.px + 130 * Math.cos(realAngle);
		$gamePlayer.ry = $gamePlayer.py = this.py - 85 - (130 * Math.sin(realAngle));
		$gamePlayer.vx = $gamePlayer.vy = 0;
		if(Input.isStrictTriggered('ok') || Input.isStrictTriggered('bullet') || TouchInput.isScreenButtonTriggered('jump') || TouchInput.isScreenButtonTriggered('bullet')) {
			members.isIn = false;
			$gamePlayer.endBodyAttack(false);
			$gameMap.setMovingCursorProgress(0);
		}
		if(Input.isStrictTriggered('cancel') || TouchInput.isScreenButtonTriggered('attack')) {
			members.isIn = false;
			$gamePlayer.endBodyAttack(false);
			$gamePlayer.vx = members.strength * maxStrength * Math.cos(realAngle);
			$gamePlayer.vy = -members.strength * maxStrength * Math.sin(realAngle);
			$gamePlayer.setNoControlTimeEx(1);
			this.requestAnimation(20, {staticPosition:true, x:$gamePlayer.px, y:$gamePlayer.py - ($gamePlayer.hitOffsetT() + $gamePlayer.hitOffsetB()) / 2});
			$gamePlayer.setDirection(this.direction());
			$gameMap.setMovingCursorProgress(0);
		}
	}
};
Game_Event.prototype.doPStateChange27 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState27 = function() {
};
Game_System.prototype.checkArtilleryGuide = function() {
	if(!$gameSwitches.value(19)) {
		$gameSwitches.setValue(19, true);
		$gameSystem.setupSoftGuide(TextManager.STATIC_TEXT_ARTILLERY_USE);
	}
};

// 可破坏物体，例如草堆
Game_Event.prototype.initStatemMembers28 = function(members) {
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState28 = function(members) {
	this.vx = this.vy = 0;
};
Game_Event.prototype.doPStateChange28 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState28 = function() {
};

// 平衡板，两边物体谁更重，左边的物体为主控单位
// fix = true
Game_Event.prototype.initStatemMembers29 = function(members) {
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState29 = function(members) {
	const linkEventId = this.battleObject().factorA;
	if(!linkEventId) {
		return;
	}
	const linkEvent = $gameMap.event(linkEventId);
	const leftEvents = this.findUpperEvent();
	const rightEvents = linkEvent.findUpperEvent();
	let lm = 0;
	let rm = 0;
	for(const ev of leftEvents) {
		lm += ev.m;
	}
	for(const ev of rightEvents) {
		rm += ev.m;
	}
	const mg = $gameMap.mg();
	const plvy = this._vy;
	const prvy = linkEvent._vy;
	if(lm > rm) {
		this.doGravity();
		linkEvent.vy = -this._vy;
	} else if(lm < rm) {
		linkEvent.doGravity();
		this.vy = -linkEvent._vy;
	} else {
		linkEvent.vy = -this._vy;
	}
	this.dotY = linkEvent.dotY = 0;
	this.makeMomentum();
	linkEvent.makeMomentum();
	while((this.hitPreviewNoVGround(0, 0) && this._vy > 0) || (linkEvent.hitPreviewNoVGround(0, 0) && linkEvent._vy > 0)) {
		this.vy -= Utils.sign(this.vy);
		linkEvent.vy -= Utils.sign(linkEvent.vy);
		this.makeMomentum();
		linkEvent.makeMomentum();
	}
	for(const ev of leftEvents) {
		if(ev._vy * this._vy >= 0) {
			if(Math.abs(ev._vy) <= Math.abs(this._vy) || ev._vy >= 0) {
			    ev._vy = this._vy;
				ev.dotY = 0;
			}
		}
	}
	for(const ev of rightEvents) {
		if(ev._vy * linkEvent._vy >= 0) {
			if(Math.abs(ev._vy) <= Math.abs(linkEvent._vy) || ev._vy >= 0) {
			    ev._vy = linkEvent._vy;
				ev.dotY = 0;
			}
		}
	}
};
Game_Event.prototype.doPStateChange29 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState29 = function() {
};

Game_Event.prototype.initStatemMembers30 = function(members) {
	this.setImage(this.battleObject().standingImage);
	const rotation = this.battleObject().factorA;
	this.setRotation(rotation);		// 这里是顺时针
	members.state = 0;
};
Game_Event.prototype.doPState30 = function(members) {
	const para = this.battleObject().factorB;
	const rotation = this.battleObject().factorA;
	const interval = para[0]; // 由于喷气动画不是一下子就喷上去的，所以根据气体运动的速度分三次判断
	if(members.state > interval + 25) {
		members.state = 0;
	} else if(members.state === interval + 25) {
		this.controlAttack30(270);
		members.state++;
	} else if(members.state === interval + 18) {
		this.controlAttack30(270);
		members.state++;
	} else if(members.state === interval + 11) {
		this.controlAttack30(180);
		members.state++;
	} else if(members.state === interval + 4) {
		this.controlAttack30(90);
		members.state++;
	} else if(members.state === interval) {
		const animationId = 25;
		const se = "jet_port";
		this.requestAnimation(animationId, {rotation:rotation});
		AudioManager.playPlayerRoundSe(this, se);
		members.state++;
	} else {
		members.state++;
	}
};
Game_Event.prototype.doPStateChange30 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState30 = function() {
};
Game_Event.prototype.controlAttack30 = function(height, width = 60) {
	const para = this.battleObject().factorB;
	const rotation = this.battleObject().factorA;
	const strength = para[1];
	const noControlTimeEx = para[2];
	const c = Math.cos(rotation);		// 下面的计算公式是逆时针，所以正负反过来
	const s = Math.sin(rotation);		// 下面的计算公式是逆时针，所以正负反过来
	const left = -width / 2;
	const top = -height;
	const right = -left;
	const bottom = 0;
	
	const vertices = [{x:left,y:top},{x:left,y:bottom},{x:right,y:bottom},{x:right,y:top}];
	for(const p of vertices) {
		const x = p.x; const y = p.y;
		p.x = Math.round(x * c - y * s);
		p.y = Math.round(y * c + x * s);
	}
	this.setVertices(vertices);
	this._physicsFlag = 0;
	const hit = $gameMap.hitTest(this, $gameMap._physicsDynamicGrid, false);
	this._physicsFlag = 5;
	if(hit) {
		hit.forEach((ev) => {
			const vx = strength * Math.sin(rotation);
			const vy = -strength * Math.cos(rotation);
			if(Math.abs(Math.round(vx)) > 0) {
				ev.vx = strength * Math.sin(rotation);
			}
			if(Math.abs(Math.round(vy)) > 0) {
				ev.vy = -strength * Math.cos(rotation);
			}
			ev.onMushroomHit(5);
			ev.setNoControlTimeEx(noControlTimeEx);
		});
	}
};

Game_Event.prototype.initStatemMembers31 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.suspendGravity();
};
Game_Event.prototype.doPState31 = function(members) {
	const distanceX = this.battleObject().factorA;
	if(this._suspendGravity && Math.abs($gamePlayer.px - this.px) < distanceX) {
		this.resumeGravity();
	} 
	if(this.isGrounding()) {
		this.beHit();
		this.battleObject().hp = 0;
	} else {
		this.requestBodyAttack("stone_spike_attack");
	}
};
Game_Event.prototype.doPStateChange31 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState31 = function() {
};

// BOSS橘花猫
// 模式1：远程模式-维持10秒切入近战模式
// 模式2：近战模式-维持5秒切入远程模式
// 共通逻辑：分身CD好了就放，黑洞只在离一定距离下CD好了放，猫抓二连击只在离一定距离下CD好了就放
// 共通逻辑：遇到路障会跳，遇到合适角度会尝试释放空中狙击
// 共通逻辑：升猫拳预判玩家在合适位置时尝试释放
Game_Event.prototype.initStatemMembers32 = function(members) {
	this.commonInit(members);
	this.m = 2;
	members.eyesOpen = false;
	members.eyesTimeCounter = 0;
	members.eyesOnHit = new Game_BodyOnHit({hitCDTime:30});
	members.eyesInitCD = [];
	members.distanceMode = 0;
	members.distanceModeCounter = 0;
	members.summonSkillStartCD = 480;
	members.isFastMoveEffect = false;
	members.isDistanceModeInLeft = false;		// 选定一个距离模式后，boss会在这个距离模式左边和右边的目标点徘徊，这里指的是是否正在往左边的点走
	members.jumpcd = 0;
	members.targetX = -1;
	members.fastMoveTargetX = 0;
	this.setAirFriction(6);
	this.setFriction(6);
};
Game_Event.prototype.doPState32 = function(members) {
	if(!$gameSwitches.value(27)) {
		return;
	}
	if($gameMap.isEventRunning()) {
		return;
	}
	this.updateHellEyes32(members);
	this.updateSummon32(members);
	if(this.isOutControl()) {
		return;
	}
	this.updateDistanceMode32(members);
	if(this.isBodyAttacking()) {
		return;
	}
	this.updateJumpCD(members);
	const distanceX = Math.abs(this.px - $gamePlayer.px);
	if(this.updateNormalAttack32(members, distanceX)) {
		return;
	}
	if(!members.isFastMoveEffect && this.updateUpAttack32(members, distanceX)) {
		return;
	}
	if(!members.isFastMoveEffect && this.updateDownAttack32(members, distanceX)) {
		return;
	}
	if(!members.isFastMoveEffect && this.updateOtherAttack32(members, distanceX)) {
		return;
	}
	this.updateMove32(members, distanceX);
};
Game_Event.prototype.updateDistanceMode32 = function(members) {
	if(members.distanceMode === 0) {		// 远程模式
		if(members.distanceModeCounter >= 600) {
			members.distanceMode = 1;
			members.distanceModeCounter = 0;
		} else {
			members.distanceModeCounter++;
		}
	} else if(members.distanceMode === 1) {			// 近战模式
		if(members.distanceModeCounter >= 300) {
			members.distanceMode = 0;
			members.distanceModeCounter = 0;
		} else {
			members.distanceModeCounter++;
		}
	}
};
Game_Event.prototype.updateOtherAttack32 = function(members, distanceX) {
	if(this.isGrounding() && this._groundHitObj.terrain && this.battleObject().hp < this.battleObject().mhp / 2 && $gamePlayer.attackDragFx() === 0
		&& this.requestBodyAttack(this.difficultySkillName("orange_cat_black_hole"))) {
		return true;
	}
	if($gameSystem.difficulty() === 1) {
		if(members.summonSkillStartCD) {
			members.summonSkillStartCD--;
			return false;
		}
		if(this.isGrounding() && this.requestBodyAttack("orange_cat_summon")) {
			return true;
		}
	}
	return false;
};
Game_Event.prototype.updateDownAttack32 = function(members, distanceX) {
	const distanceY = $gamePlayer.py - this.py;
	const name = this.difficultySkillName("orange_cat_down_attack");
	if(distanceX > 100 && distanceX < 400 && !this.isAttackCD(name) && this.isGrounding()) {
		this.executeJump3(members, 40);
		return true;
	}
	if(distanceY > 250 && distanceX > 100 && distanceX < 400 && !this.isGrounding()) {
		if(this.requestBodyAttack(this.difficultySkillName("orange_cat_down_attack"))) {
			this.faceToPlayer();
			return true;
		}
	}
	return false;
};
Game_Event.prototype.updateUpAttack32 = function(members, distanceX) {
	const distanceY = this.py - $gamePlayer.py;
	if(distanceY >= 164 && distanceX < 200 && this.isGrounding()) {
		if(this.requestBodyAttack(this.difficultySkillName("orange_cat_up_attack"))) {
			this.faceToPlayer();
			return true;
		}
	}
	return false;
};
Game_Event.prototype.updateNormalAttack32 = function(members, distanceX) {
	const attackName = "orange_cat_attack";
	if(members.isFastMoveEffect) {
		if(Math.abs(this.px - members.fastMoveTargetX) < 10 || this._impact) {
			members.isFastMoveEffect = false;
			this.battleObject().movingImage = ";orange_cat_move";
			if(this.requestBodyAttack(attackName)) {
				this.faceToPlayer();
			}
			return true;
		} else {
			return false;
		}
	} else {
		if(this.isGrounding() && distanceX > 500 && this._groundHitObj.terrain && !this.isAttackCD(attackName)) {
			members.isFastMoveEffect = true;
			members.fastMoveTargetX = $gamePlayer.px + Utils.sign(this.px - $gamePlayer.px) * 100;
			this.battleObject().movingImage = ";orange_cat_fast_move";
			this.requestBodyAttack(this.difficultySkillName("orange_cat_fast_move_ready"));
		}
	}
	return members.isFastMoveEffect;
};
Game_Event.prototype.updateMove32 = function(members, playerDistanceX) {
	if(members.isFastMoveEffect) {
		this.updateMoveSimple(this.px > members.fastMoveTargetX, 3 + $gameSystem.difficulty());
	} else {
		if(members.eyesOpen && playerDistanceX > 128) {
			this.faceToPlayer();
			return;
		} else if(members.eyesOpen && this.isGrounding()) {
			this.updateMoveSimple(this.px - $gamePlayer.px < 0, 1, true);
			this.faceToPlayer();
			return;
		}
		const baseX = $gamePlayer.px;
		const baseY = $gamePlayer.py;
		const distanceLR = 150;
		const threshold = 10;
		let distanceBase = 0;
		if(members.distanceMode === 0) {
			distanceBase = 200;
		} else {
			distanceBase = 700;
		}
		distanceBase = baseX > $gameMap.width() * $gameMap.tileWidth() / 2 ? baseX - distanceBase : baseX + distanceBase;
		let targetX = -1;
		if(members.isDistanceModeInLeft) {
			targetX = distanceBase - distanceLR;
		} else {
			targetX = distanceBase + distanceLR;
		}
		targetX = targetX.clamp(0, $gameMap.width() * $gameMap.tileWidth());
		const distanceX = this.px - members.targetX;
		if(Math.abs(distanceX) < threshold || members.targetX === -1) {
			members.isDistanceModeInLeft = !members.isDistanceModeInLeft;
			members.targetX = targetX;
		} else {
			const isLeft = distanceX > 0;
			this.updateMoveSimple(isLeft);
			const detectJumpDistance = 48;
			if(this.isGrounding() && this.hitPreview(48 * Utils.sign(-distanceX), 0)) {
				this.executeJump3(members, 40);
			}
		}
	}
};
Game_Event.prototype.updateHellEyes32 = function(members) {
	if(this.isDeath()) {
		AudioManager.stopRandLoopSe(AudioManager.RL_ORANGE_CAT_EYES);
		$gameTemp.requestRemoveAnimation([this], 26);
		$gameTemp.requestRemoveAnimation([this], 27);
		return;
	}
	if(members.eyesOpen) {
		this.requestAnimation(26, {physicsPosition:true, unique:true, align:"top", y:-64, z:6});
		let closeTime = 240;
		if($gameSystem.difficulty() === 1) {
			closeTime = 330;
		} else if($gameSystem.difficulty() === 0) {
			closeTime = 270;
		}
		if(members.eyesTimeCounter >= closeTime) {
			members.eyesOpen = false;
			members.eyesTimeCounter = 0;
			$gameTemp.requestRemoveAnimation([this], 26);
			AudioManager.stopRandLoopSe(AudioManager.RL_ORANGE_CAT_EYES);
		} else {
			members.eyesTimeCounter++;
			AudioManager.playRandLoopSe(7);
			for(const character of $gameMap.events().concat([$gamePlayer])) {
				if(character.battleObject() && !$gameMap.checkSameTeam(this, character)) {
					if(!character.battleObject().unlimitHp) {
						if((character.px > this.px && this.direction() === 6 && character.direction() === 4) || (character.px < this.px && this.direction() === 4 && character.direction() === 6)) {
							let threshold = false;
							let shouldAdd = true;
							let thresholdTime = 8;
							if($gameSystem.difficulty() === -1) {
								thresholdTime = 16;
							} else if($gameSystem.difficulty() === 0) {
								thresholdTime = 12;
							}
							for(const obj of members.eyesInitCD) {
								if(obj.id === character.eventId()) {
									shouldAdd = false;
									obj.time++;
									threshold = obj.time > 16;
									break;
								}
							}
							if(shouldAdd) {
								members.eyesInitCD.push({id:character.eventId(), time:0});
							}
							if(threshold && !members.eyesOnHit.isObjectInHitCD(character)) {
								members.eyesOnHit.enterObjectHitCD(character);
								character.requestDamage(15, false, true, true);
								character.requestAnimation(28, {physicsPosition:true});
								if(character.constructor === Game_Player) {
									character.triggerBossScoreOnHit();
								}
							}
						} else {
							members.eyesInitCD = members.eyesInitCD.filter((obj) => {
								return obj.id !== character.eventId();
							});
						}
					}
				}
			}
		}
		
	} else {
		this.requestAnimation(27, {physicsPosition:true, unique:true, align:"top", y:-64, z:6});
		let openTime = 630;
		if($gameSystem.difficulty() === 1) {
			openTime = 450;
		} else if($gameSystem.difficulty() === 0) {
			openTime = 570;
		}
		if(members.eyesTimeCounter >= openTime) {
			members.eyesOpen = true;
			members.eyesTimeCounter = 0;
			$gameTemp.requestRemoveAnimation([this], 27);
			this.setSpecProgress(0);
			this.clearSpecProgress();
			members.eyesInitCD = [];
		} else {
			members.eyesTimeCounter++;
			this.setSpecProgress(members.eyesTimeCounter / openTime);
		}
	}
	members.eyesOnHit.updateHitObjCD();
};
Game_Event.prototype.updateSummon32 = function(members) {
	if($gameSystem.difficulty() !== 1) {
		return;
	}
	const info = AttackFrame.data["orange_cat_summon"];
	for(const action of info.action) {
		if(action.type === "orange_cat_summon") {
			const aliveSummon = action.para.filter((evid) => {
				return !$gameMap.event(evid).isDeath();
			});
			if(aliveSummon.length > 0) {
				if(this.isDeath()) {
					for(const evid of aliveSummon) {
						const event = $gameMap.event(evid);
						event.battleObject().hp = 0;
					}
					$gameMap.clearSpecProgress();
					return;
				}
				$gameMap.setSpecProgress($gameMap.specProgress() + 0.002);
				if($gameMap.specProgress() >= 1) {
					for(const evid of aliveSummon) {
						const event = $gameMap.event(evid);
						event.battleObject().deathAnimation = 0;
						const recoverNum = event.battleObject().hp;
						event.battleObject().hp = 0;
						const recover = new Game_BossRecover();
						recover.setupBossId(this.eventId(), recoverNum);
						recover.px = event.physicsCenterX();
						recover.py = event.physicsCenterY();
						$gameMap.createCharacter(recover);
						event.requestAnimation(31, {physicsPosition:true});
					}
					AudioManager.playPlayerRoundSe(this, "Darkness7");
				}
			} else {
				$gameMap.setSpecProgress(0);
				$gameMap.clearSpecProgress();
			}
			break;
		}
	}
};
Game_Event.prototype.doPStateChange32 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState32 = function(members) {
	if(!members.eyesOpen) {
		this.detectState18(...arguments);
	}
};

// 橘花猫的分身
Game_Event.prototype.initStatemMembers33 = function(members) {
	this.commonInit(members);
	this.m = 1;
	members.jumpcd = 0;
	members.isLeft = this.eventId() % 2 === 0;
	members.counter = 0;
	this.setAirFriction(2);
	this.setFriction(2);
};
Game_Event.prototype.doPState33 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	this.updateJumpCD(members);
	if(members.counter > this.battleObject().factorA || this.hitPreview(Utils.sign(members.isLeft) * -24, 0)) {
		members.isLeft = !members.isLeft;
		members.counter = 0;
	} else {
		members.counter++;
		this.updateMoveSimple(members.isLeft);
	}
};
Game_Event.prototype.doPStateChange33 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState33 = function(members) {
	this.detectState18(...arguments);
};

// 萤火虫，就是一团光
Game_Event.prototype.initStatemMembers34 = function(members) {
	const ltx = this.battleObject().factorB[0];
	const lty = this.battleObject().factorB[1];
	const rdx = this.battleObject().factorB[2];
	const rdy = this.battleObject().factorB[3];
	members.ltx = ltx + this.px;
	members.lty = lty + this.py;
	members.rdx = rdx + this.px;
	members.rdy = rdy + this.py;
	const lightAdd = this.lightingAdd(true);
	members.initLightAddR = lightAdd.r;
	members.initLightAddG = lightAdd.g;
	members.initLightAddB = lightAdd.b;
	const lightMultiply = this.lightingMultiply(true);
	members.initLightMultiplyR = lightMultiply.r;
	members.initLightMultiplyG = lightMultiply.g;
	members.initLightMultiplyB = lightMultiply.b;
	const context = Utils.createBezierContext(this.px, this.py, members.ltx, members.lty, members.rdx, members.rdy);
	members.bezierList = context.bezierList;
	members.bezierInterpolation = context.bezierInterpolation;
	members._bezierd = 0;
	members.brightness = 1;
	members.brightnessMoveDirection = 1;
	this.createBrightnessMove34(members);
	this.fix = true;
	this._physicsFlag = 3;
};
Game_Event.prototype.createBrightnessMove34 = function(members) {
	members.brightnessMoveDirection = -members.brightnessMoveDirection;
	members.brightnessMoveSpeed = 0.01 + Math.random() * 0.01;
	members.brightnessMoveCounter = 0;
	members.brightnessMoveTime = 60 + Math.random() * 180;
	members.brightness = members.brightness.clamp(0, 1);
};
Game_Event.prototype.doPState34 = function(members) {
	const d = members._bezierd ? members._bezierd : 0.002 + Math.random() * 0.002;
	members._bezierd = d;
	members.bezierInterpolation += d;
	const t = members.bezierInterpolation;
	const p = members.bezierList;
	const c1 = Math.pow(1 - t, 2);
	const c2 = 2 * t * (1 - t);
	const c3 = Math.pow(t, 2);
	this.px = Math.floor(c1 * p[0][0] + c2 * p[1][0] + c3 * p[2][0]);
	this.py = Math.floor(c1 * p[0][1] + c2 * p[1][1] + c3 * p[2][1]);
	if(members.bezierInterpolation >= 1)
	{
		members._bezierd = 0;
		const ltx = members.ltx;
		const lty = members.lty;
		const rdx = members.rdx;
		const rdy = members.rdy;
		const dx = (p[2][0] - p[1][0]);
		const dy = (p[2][1] - p[1][1]);
		const k = dy / dx;
		let px2 = 0;
		let py2 = 0;
		const r1 = Math.random();
		if(Math.abs(k) > 1)
		{
			py2 = p[2][1] + (r1 * 0.4 + 0.6) * dy;
			px2 = p[2][0] + (py2 - p[2][1]) / k;
		}
		else
		{
			px2 = p[2][0] + (r1 * 0.4 + 0.6) * dx;
			py2 = p[2][1] + (px2 - p[2][0]) * k;
		}
		const r3 = Math.random();
		const r4 = Math.random();
		const px3 = Math.trunc(r3 * (rdx - ltx) + ltx);
		const py3 = Math.trunc(r4 * (rdy - lty) + lty);
		members.bezierList = [[this.px, this.py],[px2, py2],[px3, py3]];
		members.bezierInterpolation = 0;
	}
	if(members.brightness < 0 || members.brightness > 1) {
		this.createBrightnessMove34(members);
	} else {
		if(members.brightnessMoveCounter < members.brightnessMoveTime) {
			members.brightnessMoveCounter++;
		} else {
			members.brightness += members.brightnessMoveSpeed * members.brightnessMoveDirection;
		}
	}
	const lightAdd = this.lightingAdd(true);
	lightAdd.r = members.initLightAddR * members.brightness;
	lightAdd.g = members.initLightAddG * members.brightness;
	lightAdd.b = members.initLightAddB * members.brightness;
	const lightMultiply = this.lightingMultiply(true);
	lightMultiply.r = members.initLightMultiplyR * members.brightness;
	lightMultiply.g = members.initLightMultiplyG * members.brightness;
	lightMultiply.b = members.initLightMultiplyB * members.brightness;
};
Game_Event.prototype.doPStateChange34 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState34 = function(members) {
};

// 水底关卡可破坏宝箱上的发光物体
// 实际上就是本体被破坏该物体也被破坏的模式
Game_Event.prototype.initStatemMembers35 = function(members) {
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState35 = function(members) {
	const linkEventId = this.battleObject().factorA;
	if($gameMap.event(linkEventId).isDeath()) {
		this.initToDeath();
	}
};
Game_Event.prototype.doPStateChange35 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState35 = function(members) {
};

// 巨型泡泡，不分敌我的困住接近的对象，然后自行销毁
// 只困住掉落血球的对象和instanceof Game_Player
Game_Event.prototype.initStatemMembers36 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.destroyTime = 180;
	this.setVertices([{"x":14,"y":-71},{"x":40,"y":-60},{"x":60,"y":-40},{"x":71,"y":-14},{"x":71,"y":14},{"x":60,"y":40},{"x":40,"y":60}
	,{"x":14,"y":71},{"x":-14,"y":71},{"x":-40,"y":60},{"x":-60,"y":40},{"x":-71,"y":14},{"x":-71,"y":-14},{"x":-60,"y":-40},{"x":-40,"y":-60},{"x":-14,"y":-71}]);
	members.py = this.py;
};
Game_Event.prototype.doPState36 = function(members) {
	const flag = this._physicsFlag;
	this._physicsFlag = 0;
	const hit = this.hitPreview(0, 0);
	this._physicsFlag = flag;
	if(hit) {
		let availHit = false;
		for(const obj of hit) {
			if((obj.battleObject() && obj.battleObject().mapRecoverCreate) || obj instanceof Game_Player) {
				availHit = true;
				obj.requestStagger(1);
				obj.px = this.px;
				const cycle = 20;
				const timeCycle = members.destroyTime % cycle;
				const sign = Utils.sign(timeCycle - cycle / 2);
				this.py = members.py + sign * (timeCycle - cycle / 2);
				obj.py = this.py + (obj.hitOffsetB() + obj.hitOffsetT()) / 2;
				if(!obj.isBalloonPlaying()) {
					$gameTemp.requestBalloon(obj, 7);
				}
				if(obj.constructor === Game_Lily) {
					obj.triggerUniqueFloatMessage(235);
				}
			}
		}
		if(availHit) {
			if(members.destroyTime === 180) {
				AudioManager.playPlayerRoundSe(this, "bubble_in");
			}
			members.destroyTime--;
		}
	} else if(members.destroyTime < 180) {
		members.destroyTime--;
	}
	if(members.destroyTime <= 0) {
		this.battleObject().hp = 0;
	}
};
Game_Event.prototype.doPStateChange36 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState36 = function(members) {
	if(!this.isDeath()) {
		if(members.destroyTime < 180) {
			this.setPstate(1);
		} else {
			this.setPstate(0);
		}
	}
};

// 水底的乌龟怪
Game_Event.prototype.initStatemMembers37 = function(members) {
	this.commonInit(members);
	members.isTriggerLeft = this.direction() === 4;
	members.shrinkCd = 0;			// 缩壳CD
	members.shrinkBefore = 0;		// 缩壳的前摇状态计数
	members.shrinkAfter = 0;		// 出壳的前摇状态计数
	members.isShrink = false;		// 是否是正在缩壳状态
	members.isFastMove = false;
};

Game_Event.prototype.doPState37 = function(members) {
	if(this.isAttackOutControl()) {
		members.shrinkBefore = 0;
		members.shrinkAfter = 0;
		members.isShrink = false;
		return;
	}
	const distance = this.pixelDistanceToPlayer();
	if(!members.isShrink && !members.shrinkBefore && !members.shrinkAfter && this.isGrounding()) {
		if(members.isFastMove) {
			this.updateMoveSimple(members.isTriggerLeft, 1.5);
		} else {
			this.updateMoveSimple(members.isTriggerLeft);
		}
		const testX = this.battleObject().maxMoveSpeed * 8 * Utils.sign(!members.isTriggerLeft);
		if(!this.hitPreview(testX, 1) || this.hitPreview(testX, 0)) {
			if(this.hitPreview(-testX, 1) && !this.hitPreview(-testX, 0)) {
				members.isTriggerLeft = !members.isTriggerLeft;
			}
		}
		if(this.requestBodyAttack("tortoise_attack")) {
			if($gameSystem.difficulty() === 0) {
				this.reduceAttackCD(14);
			} else if($gameSystem.difficulty() === 1) {
				this.reduceAttackCD(20);
			}
		}
	}
	if(distance < 180 && !members.isShrink && (members.shrinkCd === 0 || !this.isGrounding()) && members.shrinkBefore === 0) {
		members.shrinkBefore = this.getAllFrameTime(ImageFrame.info(this.battleObject().jumpUpImage));
	} else if(distance > 560 && members.isShrink && this.isGrounding()) {
		members.isShrink = false;
		if($gameSystem.difficulty() === 0) {
			members.shrinkCd = 300;
		} else if($gameSystem.difficulty() === 1) {
			members.shrinkCd = 150;
		} else {
			members.shrinkCd = 480;
		}
		members.shrinkAfter = this.getAllFrameTime(ImageFrame.info(this.battleObject().jumpDownImage));
	}
	if(members.shrinkCd > 0) {
		members.shrinkCd--;
	}
	if(members.shrinkBefore > 0) {
		members.shrinkBefore--;
		if(members.shrinkBefore === 0) {
			members.isShrink = true;
			members.isFastMove = true;
		}
	}
	if(members.shrinkAfter > 0) {
		members.shrinkAfter--;
	}
	if(members.isShrink || (members.shrinkBefore < 40 && members.shrinkBefore > 0)) {
		this.battleObject().addBuff("def_up", 2);
	}
};

Game_Event.prototype.doPStateChange37 = function(members, oldState, newState) {
	const battleObject = this.battleObject();
	switch(newState) {
		case 0: this.resetImage(battleObject.standingImage); break;
		case 1: this.resetImage(battleObject.movingImage); break;
		case 3: this.resetImage(battleObject.jumpDownImage); break;					// 出壳中
		case 4: case 5: this.resetImage(battleObject.jumpMiddleImage); break;		// 正在缩壳
		case 2: this.resetImage(battleObject.jumpUpImage); break;					// 缩壳中
		case 6: case 10: this.resetImage(battleObject.staggerImage); break;
		case 7: case 8: case 9: { 
			if(!this.normalAttackCompatibleStateGroup().includes(oldState)) {
				this.resetFrameAnimation(); 
			}
			this.setImage(this.preferAttackImage(newState));
			break;
		}
		default: this.resetImage(battleObject.standingImage); break;
	}
};
Game_Event.prototype.detectState37 = function(members) {
	if(this.pstate() === 2 || this.pstate() === 3 || this.pstate() === 4 || this.pstate() === 5) {
		this.setPstate(1);
	}
	if(members.isShrink) {
		this.setPstate(4);
	} else if(members.shrinkBefore) {
		this.setPstate(2);
	} else if(members.shrinkAfter) {
		this.setPstate(3);
	}
};

// 电水母 当y轴速度小于0时，x轴速度的绝对值总是和y轴速度相同
// x轴碰壁时改变方向
// 有两个行动模式，
// 1.一直下落，（触底后切换为2模式）
// 2.斜上走两拨，下落一拨（触顶或到达地图上界后切换为1模式）
Game_Event.prototype.initStatemMembers38 = function(members) {
	this.commonInit(members);
	members.isTriggerLeft = this.direction() === 4;
	members.state = 2;
	members.upTimes = 0;
	members.directionChangeCD = 0;
	this.m = 12;
};
Game_Event.prototype.doPState38 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	this.requestBodyAttack("jellyfish_attack");
	if(members.directionChangeCD) {
		members.directionChangeCD--;
	}
	switch(members.state) {
		case 1: {
			if(this.isGrounding() || this.py > $gameMap.height() * $gameMap.tileHeight()) {
				members.state = 2;
				members.upTimes = 0;
			}
			break;
		}
		case 2: {
			if(this.vy >= 0) {
				if(members.upTimes < 10) {
					this.vy = -this.battleObject().maxMoveSpeed;
					if($gameSystem.difficulty() === 1) {
						this.vy -= 2;
					} else if($gameSystem.difficulty() === -1) {
						this.vy += 2;
					}
					members.upTimes++;
				} else {
					members.state = 1;
				}
			} else {
				if(!this.noControlTime()) {
					this.vx = this._vy * Utils.sign(!members.isTriggerLeft);
					if(this._impact && this._impactDirection === 0 && !members.directionChangeCD) {
						members.isTriggerLeft = !members.isTriggerLeft;
						members.directionChangeCD = 30;
					}
				}
			}
			if(this.py < 0 || (this._impact && this._impactDirection === 1)) {
				members.state = 1;
			}
			break;
		}
	}
};
Game_Event.prototype.doPStateChange38 = function() {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState38 = function(members) {
};

// 食人鱼 实际上就是黑猫的水下版本，一直挤玩家
Game_Event.prototype.initStatemMembers39 = function(members) {
	this.commonInit(members);
	members.beHitNum = 0;
	this.useMiniumFriction(true);
	this.setFriction(0.2);
};
Game_Event.prototype.doPState39 = function(members) {
	this.suspendGravity();
	if(this.beHitNum() !== members.beHitNum) {
		members.beHitNum = this.beHitNum();
		this.setNoControlTime(16);
		return;
	}
	if(this.isAttackOutControl() || this.noControlTime() || this.pixelDistanceToPlayer() > 600) {
		return;
	}
	let speedAdd = 1;
	if($gameSystem.difficulty() === 1) {
		speedAdd = 1.5;
		this.m = 50;
	} else if($gameSystem.difficulty() === 0) {
		this.m = 2;
	}
	this.commonMoveToPlayerInWater(members, speedAdd);
};
Game_Event.prototype.doPStateChange39 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState39 = function(members) {
};

Game_Event.prototype.commonMoveToPlayerInWater = function(members, speedAdd = 1) {
	const distanceX = Math.abs($gamePlayer.px - this.px);
	members.isTriggerLeft = $gamePlayer.px < this.px;
	if(distanceX >= this.battleObject().maxMoveSpeed) {
		this.updateMoveSimple(members.isTriggerLeft, speedAdd, false, speedAdd*this.m);
	} else {
		this.vx = Utils.sign(!members.isTriggerLeft) * distanceX;
	}
	const distanceY = Math.abs($gamePlayer.py - this.py);
	this.vy = Utils.sign($gamePlayer.py - this.py) * Math.min(distanceY, this.battleObject().maxMoveSpeed);
};

// 河豚 玩家靠近后会变大且切换行动模式，固定时间后自爆
Game_Event.prototype.initStatemMembers40 = function(members) {
	this.commonInit(members);
	this.useMiniumFriction(true);
	this.setFriction(0.2);
	members.isTriggerLeft = this.direction() === 4;
	members.state = 0;
	members.boomCounter = 0;
	members.biggerCounter = 0;
	members.beHitNum = 0;
};
Game_Event.prototype.doPState40 = function(members) {
	this.suspendGravity();
	if(this.isAttackOutControl()) {
		return;
	}
	if(this.beHitNum() !== members.beHitNum) {
		members.beHitNum = this.beHitNum();
		this.setNoControlTime(12);
		return;
	}
	if(members.state === 0) {		// 左右移动
		const testX = this.battleObject().maxMoveSpeed * 8 * Utils.sign(!members.isTriggerLeft);
		if(this.hitPreview(testX, 0)) {
			if(!this.hitPreview(-testX, 0)) {
				members.isTriggerLeft = !members.isTriggerLeft;
			}
		}
		this.vy = 0;
		let speedAdd = 1;
		if($gameSystem.difficulty() === 1) {
			speedAdd = 1.5;
		} else if($gameSystem.difficulty() === -1) {
			speedAdd = 0.7;
		}
		this.updateMoveSimple(members.isTriggerLeft, speedAdd);
		let distance = 200;
		if($gameSystem.difficulty() === 1) {
			distance = 400;
		} else if($gameSystem.difficulty() === 0) {
			distance = 300;
		}
		if(this.pixelDistanceToPlayer() < distance) {
			members.state = 2;
		}
	} else if(members.state === 1) {						// 一直靠近玩家，4秒后爆炸
		members.boomCounter++;
		if(members.boomCounter < 240) {
			if(!this.noControlTime()) {
				this.commonMoveToPlayerInWater(members);
			}
		} else if(members.boomCounter === 240) {
			this.battleObject().team = -1;
			this.requestBodyAttack(this.difficultySkillName("globefish_attack"));
			this._physicsFlag = 5;
			this.setOpacity(0);
			this.battleObject().deathAnimation = 0;
			this.vx = this.vy = 0;
		} else if(!this.isBodyAttacking()) {
			this.battleObject().hp = 0;
			this.vx = this.vy = 0;
		}
	} else {												// 正在变大
		if(members.biggerCounter < 8) {
			this.battleObject().standingImage = this.battleObject().movingImage = ";globefish_bigger";
			this.setImage(this.battleObject().standingImage, 0);
			members.biggerCounter++;
		} else {
			this.battleObject().standingImage = this.battleObject().movingImage = ";globefish_big";
			members.state = 1;
		}
	}
};
Game_Event.prototype.doPStateChange40 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState40 = function(members) {
};

// 金枪鱼，矩形运动路线，改变X方向时有一个转身动作
Game_Event.prototype.initStatemMembers41 = function(members) {
	this.commonInit(members);
	members.state = this.direction() === 4 ? 0 : 1;			// 状态：0左 1右 2上 3下
	members.moveType = members.state;						// 0 左上右下循环 1右上左下循环
	members.readyChange = false;
	members.beHitNum = 0;
};
Game_Event.prototype.doPState41 = function(members) {
	this.suspendGravity();
	if(this.beHitNum() !== members.beHitNum) {
		members.beHitNum = this.beHitNum();
		this.setNoControlTime(12);
		return;
	}
	if(this.isAttackOutControl()) {
		members.readyChange = false;
		return;
	}
	if(this.noControlTime()) {
		return;
	}
	if(members.readyChange && !this.isBodyAttacking()) {
		members.readyChange = false;
		switch(members.state) {
			case 2: {
				if(members.moveType === 0) {
					members.state = 1;
					this.setDirection(6);
				} else {
					members.state = 0;
					this.setDirection(4);
				}
				break;
			}
			case 3: {
				if(members.moveType === 0) {
					members.state = 0;
					this.setDirection(4);
				} else {
					members.state = 1;
					this.setDirection(6);
				}
				break;
			}
		}
		return;
	} else if(members.readyChange) {
		return;
	}
	switch(members.state) {
		case 0: {
			this.updateMoveSimple(true);
			this.vy = 0;
			const testX = -this.battleObject().maxMoveSpeed * 8;
			if(this.hitPreview(testX, 0)) {
				if(members.moveType === 0) {
					members.state = 2;
				} else {
					members.state = 3;
				}
			}
			break;
		}
		case 1: {
			this.updateMoveSimple(false);
			this.vy = 0;
			const testX = this.battleObject().maxMoveSpeed * 8;
			if(this.hitPreview(testX, 0)) {
				if(members.moveType === 0) {
					members.state = 3;
				} else {
					members.state = 2;
				}
			}
			break;
		}
		case 2: {
			this.vx = 0;
			this.vy = -this.battleObject().maxMoveSpeed;
			if(this.hitPreview(0, this.vy) || this.py < 0) {
				if(members.moveType && this.direction() === 6 || !members.moveType && this.direction() === 4) {
					members.readyChange = this.requestBodyAttack("tunas_change_direction");
				} else {
					members.readyChange = true;
				}
			}
			break;
		}
		case 3: {
			this.vx = 0;
			this.vy = this.battleObject().maxMoveSpeed;
			if(this.hitPreview(0, this.vy)) {
				if(members.moveType && this.direction() === 4 || !members.moveType && this.direction() === 6) {
					members.readyChange = this.requestBodyAttack("tunas_change_direction");
				} else {
					members.readyChange = true;
				}
			}
			break;
		}
	}
	this.requestBodyAttack("tunas_attack");
};
Game_Event.prototype.doPStateChange41 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState41 = function(members) {
};

// 海胆
Game_Event.prototype.initStatemMembers42 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockInvincible();
};
Game_Event.prototype.doPState42 = function(members) {
	this.vx = this.vy = 0;
};
Game_Event.prototype.doPStateChange42 = function(members) {
};
Game_Event.prototype.detectState42 = function(members) {
};

// 喷水口，逻辑类似于喷气口
Game_Event.prototype.initStatemMembers43 = function(members) {
	members.needRemove = false;
};
Game_Event.prototype.doPState43 = function(members) {
	const para = this.battleObject().factorB;
	const rotation = this.battleObject().factorA;
	const height = para[0];
	const width = para[3];
	const animationId = para.length > 4 ? para[4] : 39;
	this.controlAttack30(height, width);
	const left = this.vertices[0].x;
	const top = this.vertices[0].y;
	const right = this.vertices[2].x;
	const bottom = this.vertices[2].y;
	if(!physicsASM.isRectOutBound(this.px, this.py, this.hitOffsetL(), this.hitOffsetT(), this.hitOffsetR(), this.hitOffsetB(), $gameMap.displayX() * $gameMap.tileWidth(), $gameMap.displayY() * $gameMap.tileHeight(), 0, 0, Graphics.width, Graphics.height)) {
		this.requestAnimation(animationId, {rotation:rotation, unique:true, z:3});
		members.needRemove = true;
	} else if(members.needRemove) {
		$gameTemp.requestRemoveAnimation([this], animationId);
		members.needRemove = false;
	}
};
Game_Event.prototype.doPStateChange43 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState43 = function() {
};

// 海胆-在两个固定点来回移动
Game_Event.prototype.initStatemMembers44 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockInvincible();
	members.initX = this.px;
	members.initY = this.py;
	members.state = 0;		// 0朝目标移动，1返回
};
Game_Event.prototype.doPState44 = function(members) {
	const factorA = this.battleObject().factorA;
	const para = this.battleObject().factorB;
	const moveDistance = para[0];
	const speed = para[1];
	let target = 0;
	if(factorA === 0) {			// 横向
		this.vy = 0;
		if(members.state === 0) {
			target = members.initX + moveDistance;
			this.vx = Utils.sign(moveDistance) * speed;
		} else {
			target = members.initX;
			this.vx = -Utils.sign(moveDistance) * speed;
		}
		if((target - this.px) * this.vx < 0) {
			members.state = members.state === 0 ? 1 : 0;
		}
	} else {					// 纵向
		this.vx = 0;
		if(members.state === 0) {
			target = members.initY + moveDistance;
			this.vy = Utils.sign(moveDistance) * speed;
		} else {
			target = members.initY;
			this.vy = -Utils.sign(moveDistance) * speed;
		}
		if((target - this.py) * this.vy < 0) {
			members.state = members.state === 0 ? 1 : 0;
		}
	}
};
Game_Event.prototype.doPStateChange44 = function(members) {
};
Game_Event.prototype.detectState44 = function(members) {
};

// 密码锁，有四个密码，输入固定密码后自行往左移开自身贴图长度
Game_Event.prototype.initStatemMembers45 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.currentInputPassword = "";
	members.hasPlaySe = false;
	members.beHitNum1 = 0;
	members.beHitNum2 = 0;
	members.beHitNum3 = 0;
	members.beHitNum4 = 0;
	members.startX = this.px;
};
Game_Event.prototype.doPState45 = function(members) {
	const para = this.battleObject().factorB;
	const swid = para[4];
	const password = "" + this.battleObject().factorA;
	if(members.currentInputPassword === password) {
		if(!members.hasPlaySe) {
			AudioManager.playNormalSe("stone_move");
			members.hasPlaySe = true;
		}
		if(this.px > members.startX - this.patternWidth()) {
			this.vx = -2;
		} else {
			this.vx = 0;
			$gameSwitches.setValue(swid, true);
		}
		return;
	}
	const passwordEvent1 = $gameMap.event(para[0]);
	const passwordEvent2 = $gameMap.event(para[1]);
	const passwordEvent3 = $gameMap.event(para[2]);
	const passwordEvent4 = $gameMap.event(para[3]);
	if(members.beHitNum1 !== passwordEvent1.beHitNum()) {
		members.beHitNum1 = passwordEvent1.beHitNum();
		members.currentInputPassword += "1";
	}
	if(members.beHitNum2 !== passwordEvent2.beHitNum()) {
		members.beHitNum2 = passwordEvent2.beHitNum();
		members.currentInputPassword += "2";
	}
	if(members.beHitNum3 !== passwordEvent3.beHitNum()) {
		members.beHitNum3 = passwordEvent3.beHitNum();
		members.currentInputPassword += "3";
	}
	if(members.beHitNum4 !== passwordEvent4.beHitNum()) {
		members.beHitNum4 = passwordEvent4.beHitNum();
		members.currentInputPassword += "4";
	}
	if(members.currentInputPassword.length > 6) {
		members.currentInputPassword = members.currentInputPassword.substr(members.currentInputPassword.length - 6);
	}
};
Game_Event.prototype.doPStateChange45 = function(members) {
};
Game_Event.prototype.detectState45 = function(members) {
};

// 密码箱
Game_Event.prototype.initStatemMembers46 = function(members) {
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState46 = function(members) {
	this.vx = this.vy = 0;
};
Game_Event.prototype.doPStateChange46 = function(members) {
};
Game_Event.prototype.detectState46 = function(members) {
};

// 靠近会纵向快速落地的海胆
Game_Event.prototype.initStatemMembers47 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.state = 0;
	members.waiting = 0;
	this.lockSkillInvincible();
	this.suspendGravity();
};
Game_Event.prototype.doPState47 = function(members) {
	// x = b1; y = k2x + b2;
	// x = b1;
	// y = k2b1 + b2;
	// x = b1; x = b2;
	// b1 === b2 ? 
	const v = 14;
	this.vx = 0;
	switch(members.state) {
		case 0: {
			this.vy = 0;
			const vx = $gamePlayer.vx;
			const vy = $gamePlayer.vy;
			const px = $gamePlayer.px;
			const py = $gamePlayer.py;
			const threshold = 48;
			const b1 = this.px;
			if(vx === 0) {			// 预判玩家轨迹
				if(Math.abs($gamePlayer.px - b1) < threshold) {
					members.state = 1;
				}
			} else {
				const k2 = vy / vx;
				const b2 = py - k2 * px;
				const tx = b1;
				const ty = k2 * b1 + b2;
				const time1 = Math.abs(ty - this.py) / v; 
				const time2 = Math.abs((tx - px) / vx);
				if(ty > this.py && Utils.sign(tx - px) * vx >= 0 && Utils.sign(ty - py) * vy >= 0 && Math.abs(time1 - time2) < Math.round(threshold / v)) {		// 两个射线相交，并且两者到达的时间基本相同
					members.state = 1;
				}
			}
			break;
		}
		case 1: {
			this.vy = v;
			if(this.hitPreview(0, 1)) {
				members.state = 2;
				members.waiting = 120;
			}
			break;
		}
		case 2: {
			this.vy = 0;
			members.waiting--;
			if(!members.waiting) {
				members.state = 3;
			}
			break;
		}
		case 3: {
			this.vy = -3;
			if(this._impact && this._impactDirection === 1) {
				members.state = 0;
			}
			break;
		}
	}
	
};
Game_Event.prototype.doPStateChange47 = function(members) {
};
Game_Event.prototype.detectState47 = function(members) {
};

// 靠近会横向快速移动的海胆
Game_Event.prototype.initStatemMembers48 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.state = 0;
	members.waiting = 0;
	this.lockSkillInvincible();
	this.suspendGravity();
};
Game_Event.prototype.doPState48 = function(members) {
	// y = b1; x = k2y + b2;
	// y = b1;
	// x = (b1 - b2) / k2;
	// y = b1; x = b2;
	// b1 === b2 ? 
	const v = 14;
	this.vy = 0;
	switch(members.state) {
		case 0: {
			this.vx = 0;
			const vx = $gamePlayer.vx;
			const vy = $gamePlayer.vy;
			const px = $gamePlayer.px;
			const py = $gamePlayer.py;
			const threshold = 48;
			const b1 = this.py;
			if(vy === 0) {			// 预判玩家轨迹
				if(Math.abs($gamePlayer.py - b1) < threshold) {
					members.state = 1;
				}
			} else {
				const k2 = vx / vy;
				const b2 = px - k2 * py;
				const ty = b1;
				const tx = k2 * b1 + b2;
				const time1 = Math.abs(tx - this.px) / v; 
				const time2 = Math.abs((ty - py) / vy);
				if(Utils.sign(this.direction() === 6) * (tx - this.px) >= 0 && Utils.sign(tx - px) * vx >= 0 && Utils.sign(ty - py) * vy >= 0 && Math.abs(time1 - time2) < Math.round(threshold / v)) {		// 两个射线相交，并且两者到达的时间基本相同
					members.state = 1;
				}
			}
			break;
		}
		case 1: {
			this.vx = v * Utils.sign(this.direction() === 6);
			if(this._impact && this._impactDirection === 0) {
				members.state = 2;
				members.waiting = 120;
			}
			break;
		}
		case 2: {
			this.vx = 0;
			members.waiting--;
			if(!members.waiting) {
				members.state = 3;
			}
			break;
		}
		case 3: {
			this.vx = -3 * Utils.sign(this.direction() === 6);
			if(this._impact && this._impactDirection === 0) {
				members.state = 0;
			}
			break;
		}
	}
	
};
Game_Event.prototype.doPStateChange48 = function(members) {
};
Game_Event.prototype.detectState48 = function(members) {
};

// 水底莉莉亚BOSS
// 
Game_Event.prototype.initStatemMembers49 = function(members) {
	this.commonInit(members);
	this.setFriction(3);
	this.setAirFriction(3);
	members.isStarted = false;
	members.isLeftBubbleGenerate = true;
	members.bubbleGenerateCounter = 300;
	members.beHitNum = 0;
	members.beHitNumArr = [0, 0, 0, 0];	// 用来判定小于某个时间内产生了四连击，则触发后撤步
	members.readyReverseDash = false;
	members.testFanDashVertices = [{x:-2000,y:-50},{x:2000,y:-50},{x:2000,y:50},{x:-2000,y:50}];
	members.jumpcd = 0;
};
Game_Event.prototype.doPState49 = function(members) {
	if(!members.isStarted) {
		return;
	}
	this.controlBeHitNum49(members);
	if(this.isAttackOutControl()) {
		return;
	}
	this.updateJumpCD(members);
	this.controlBubble49(members);
	if(!this.isBodyAttacking()) {
		this.controlAttack49(members);
		this.controlMove49(members);
	}
};
Game_Event.prototype.doPStateChange49 = function(members) {
	this.doPStateChange18(...arguments);
};
Game_Event.prototype.detectState49 = function(members) {
};
Game_Event.prototype.controlBeHitNum49 = function(members) {
	if(members.beHitNum !== this.beHitNum()) {
		members.beHitNum = this.beHitNum();
		for(let i = 0; i < members.beHitNumArr.length - 1; i++) {
			members.beHitNumArr[i] = members.beHitNumArr[i + 1];
		}
		members.beHitNumArr[members.beHitNumArr.length - 1] = Graphics.frameCount;
		if(Graphics.frameCount - members.beHitNumArr[0] < 90) {
			members.readyReverseDash = true;
		}
	}
};
// 每过一段时间在屏幕左边和右边交替生成泡泡
Game_Event.prototype.controlBubble49 = function(members) {
	if(members.bubbleGenerateCounter > 0) {
		if($gameMap.allCharacters().every((obj) => {return obj.constructor !== Game_LilyBubble;})) {
			members.bubbleGenerateCounter--;
		}
	} else {
		members.bubbleGenerateCounter = 600;
		const cellX = Math.round($gameMap.width() * $gameMap.tileWidth() / 3);
		const y = Math.round($gameMap.height() * $gameMap.tileHeight() / 2);
		let x = cellX;
		if(!members.isLeftBubbleGenerate) {
			x += cellX;
		}
		members.isLeftBubbleGenerate = !members.isLeftBubbleGenerate;
		const bubble = new Game_LilyBubble();
		bubble.initPosition(x, y);
		$gameMap.createCharacter(bubble);
	}
};
// 判定优先级从高到低
// 后撤步，扔炸弹，折扇冲击（50%血量以下），平底锅召唤，折扇斩击，折扇下劈，折扇气流
Game_Event.prototype.controlAttack49 = function(members) {
	if(members.readyReverseDash) {
		const width = this.hitOffsetL() + this.hitOffsetR();
		this.faceToPlayer();
		const sign = this.direction() === 4 ? 1 : -1;
		const flag = this._physicsFlag;
		this._physicsFlag = 1;
		const result = this.hitPreview(Math.round(sign * width * 2), 0);
		this._physicsFlag = flag;
		if(result) {		// 后撤步会撞墙，反过来冲
			this.setDirection(this.direction() === 4 ? 6 : 4);
		}
		this.requestBodyAttack("lily_reverse_dash");
		members.readyReverseDash = false;
	}
	const bombInCd = this.isAttackCD("lily_throw_sea_bomb");
	if(!bombInCd) {		// 头顶有2个身位的自由空间则可以放
		if(this.py > 420 && this.px > 170 && this.px < $gameMap.width() * $gameMap.tileWidth() - 170) {
			this.requestBodyAttack("lily_throw_sea_bomb");
			return;
		}	
	}
	if($gamePlayer.isInvincible()) {
		return;
	}
	const hpPer = this.battleObject().hp / this.battleObject().mhp;
	const fanDashName = this.difficultySkillName("lily_fan_dash");
	if(hpPer < 0.5 && !this.isAttackCD(fanDashName)) {
		const testCharacter = $gameTemp.tempCharacter();
		testCharacter._physicsFlag = 4;
		testCharacter.setVertices(members.testFanDashVertices);
		testCharacter.px = testCharacter.rx = this.px;
		testCharacter.py = testCharacter.ry = this.py;
		if(testCharacter.hitTest($gamePlayer)) {
			this.faceToPlayer();
			this.requestBodyAttack(fanDashName);
			return;
		}
	}
	if($gameSystem.difficulty() === 1) {
		const summonInCd = this.isAttackCD("lily_pan_summon");
		if(!summonInCd) {	// 头顶有1个身位的自由空间则可以放
			const height = this.hitOffsetT() + this.hitOffsetB();
			const flag = this._physicsFlag;
			this._physicsFlag = 5;
			const result = !this.hitPreview(0, -height);
			this._physicsFlag = flag;
			if(result) {
				this.requestBodyAttack("lily_pan_summon");
				return;
			}
		}
	}
	const xDistance = Math.abs(this.px - $gamePlayer.px);
	const yDistance = Math.abs(this.py - $gamePlayer.py);
	if(xDistance < 180 && yDistance < 40) { 
		const fanNormalName = this.difficultySkillName("lily_fan_normal");
		const fanNormalInCd = this.isAttackCD(fanNormalName);
		if(!fanNormalInCd) {
			this.faceToPlayer();
			this.requestBodyAttack(fanNormalName);
			return;
		}
	}
	if(xDistance < 120 && yDistance < 140 && this.py < $gamePlayer.py) {
		const fanDownName = this.difficultySkillName("lily_fan_down");
		const fanDownInCd = this.isAttackCD(fanDownName);
		if(!fanDownInCd) {
			this.requestBodyAttack(fanDownName);
			return;
		}
	}
	if(xDistance > 680 && yDistance < 200) {
		const fanPropCd = this.isAttackCD("lily_fan");
		if(!fanPropCd) {
			this.faceToPlayer();
			this.requestBodyAttack("lily_fan");
			return;
		}
	}
	
};
// 行动模式
// 优先级--X轴靠近玩家（折扇斩击未CD）--Y轴上方靠近玩家（折扇下劈未CD）--远离玩家（折扇气流未CD）--在玩家左右两边一定距离的地方来回移动
Game_Event.prototype.controlMove49 = function(members) {
	const fanNormalName = this.difficultySkillName("lily_fan_normal");
	const fanNormalInCd = this.isAttackCD(fanNormalName);
	const fanDownInCd = this.isAttackCD(this.difficultySkillName("lily_fan_down"));
	const fanPropInCd = this.isAttackCD("lily_fan");
	let targetX = $gamePlayer.px;
	let targetY = $gamePlayer.py;
	const dirX = Utils.sign(this.px - $gamePlayer.px);
	if(!fanNormalInCd) {
		targetX = $gamePlayer.px + dirX * 96;
	} else if(!fanDownInCd) {
		targetY = $gamePlayer.py - 96;
	} else if(!fanPropInCd) {
		if($gamePlayer.px < $gameMap.width() * $gameMap.tileWidth() / 2) {
			targetX = $gamePlayer.px + 580;
		} else {
			targetX = $gamePlayer.px - 580;
		}
	} else {
		if($gamePlayer.px < $gameMap.width() * $gameMap.tileWidth() / 2) {
			targetX = 96;
			targetY = this.py;
		} else {
			targetX = $gameMap.width() * $gameMap.tileWidth() - 96;
			targetY = this.py;
		}
	}
	const threshold = 24;
	if(Math.abs(this.px - targetX) > 24) {
		this.updateMoveSimple(this.px - targetX > 0);
	}
	if(Math.abs(this.py - targetY) > 24) {
		if(this.py > targetY) {
			this.executeJump3(members, 80);
		}
	}
};

// 扔铁饼的狮子
// 玩家过于靠近则远离玩家，但有CD，碰墙直接结束远离状态
Game_Event.prototype.initStatemMembers50 = function(members) {
	this.commonInit(members);
	this.m = 4;
	members.jumpcd = 0;
	members.state = 0;
	members.backwardTime = 0;
	members.backwardCD = 0;
};
Game_Event.prototype.doPState50 = function(members) {
	if(this.isAttackOutControl() || this.isBodyAttacking()) {
		return;
	}
	this.showAttackCd("lion_attack", 30, 60);
	if(members.state === 0) {
		if(members.backwardCD > 0) {
			members.backwardCD--;
		}
		if(this.pixelDistanceToPlayer() > 240 || members.backwardCD > 0) {
			this.faceToPlayer();
			if(this.requestBodyAttack("lion_attack")) {
				if($gameSystem.difficulty() === 0) {
					this.reduceAttackCD(30);
				} else if($gameSystem.difficulty() === 1) {
					this.reduceAttackCD(60);
				}
			}
		} else {
			members.state = 1;
			members.backwardTime = 40;
		}
	} else {
		this.updateMoveSimple($gamePlayer.px - this.px > 0);
		members.backwardTime--;
		if(members.backwardTime <= 0 || (this.impactObject() && this._impactDirection === 0)) {
			members.state = 0;
			members.backwardCD = 300;
		}
	}
};
Game_Event.prototype.doPStateChange50 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState50 = function(members) {
};

// 落闪电的乌云
Game_Event.prototype.initStatemMembers51 = function(members) {
	this.commonInit(members);
	this.m = 1;
	members.initY = this.py;
};
Game_Event.prototype.doPState51 = function(members) {
	this.suspendGravity();
	if(this.isAttackOutControl() || this.isBodyAttacking()) {
		return;
	}
	if(this.py > members.initY + 10) {
		this.vy = -2;
	} else if(this.py < members.initY - 10) {
		this.vy = 2;
	} else {
		this.vy = 0;
	}
	if(Math.abs(this.px - $gamePlayer.px) > 10) {
		this.updateMoveSimple(this.px - $gamePlayer.px > 0);
	}
	this.requestBodyAttack(this.difficultySkillName("dark_cloud_attack"));
};
Game_Event.prototype.doPStateChange51 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState51 = function(members) {
};

// 乌云2，移动较为缓慢，但发射四方向闪电弹幕
Game_Event.prototype.initStatemMembers52 = function(members) {
	this.commonInit(members);
	this.m = 1;
	members.dirX = Utils.sign(this.direction() === 6);
	members.dirY = 0;
	members.pauseMoveTime = 90;
};
Game_Event.prototype.doPState52 = function(members) {
	this.suspendGravity();
	if(this.isAttackOutControl() || this.isBodyAttacking()) {
		return;
	}
	if(members.pauseMoveTime) {
		members.pauseMoveTime--;
		this.vx = this.vy = 0;
		return;
	}
	const speed = this.battleObject().maxMoveSpeed;
	this.vy = speed * members.dirY;
	if(members.dirX !== 0) {
		this.updateMoveSimple(members.dirX < 0, 1, true);
	} else {
		this.vx = 0;
	}
	const boundTop = members.dirY === -1 && this.py - this.hitOffsetT() < 0;
	const boundBottom = members.dirY === 1 && this.py + this.hitOffsetB() > $gameMap.height() * $gameMap.tileHeight();
	if(this.impactObject() || boundTop || boundBottom) {
		this.requestBodyAttack(this.difficultySkillName("dark_cloud2_attack"));
		members.pauseMoveTime = 150;
		if(members.dirX !== 0 && this._impactDirection === 0 && !boundTop && !boundBottom) {
			if(members.dirX === 1 ^ this.direction() === 4) {
				members.dirY = 1;
			} else {
				members.dirY = -1;
			}
			members.dirX = 0;
		} else if(members.dirY !== 0 && (this._impactDirection === 1 || boundTop || boundBottom)) {
			if(members.dirY === 1 ^ this.direction() === 6) {
				members.dirX = 1;
			} else {
				members.dirX = -1;
			}
			members.dirY = 0;
			members.pauseMoveTime = 150;
		}
	}
	
};
Game_Event.prototype.doPStateChange52 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState52 = function(members) {
};

// 掉炸弹的猫头怪，左右移动，碰到物体或者坠落状态下判定脚底是悬崖会改变移动方向
// 炸弹对一般物体没有碰撞判定，但对技能有判定
Game_Event.prototype.initStatemMembers53 = function(members) {
	this.commonInit(members);
	members.isTriggerLeft = this.direction() === 4;
};
Game_Event.prototype.doPState53 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	this.showAttackCd("drop_small_bomb", 30, 60);
	const character = $gameTemp.tempCharacter();
	character.setHitRect({l:this.hitOffsetL(),t:this.hitOffsetT(),r:this.hitOffsetR(),b:1000});
	character.rx = this.px;
	character.ry = this.py;
	character.vertices = null;
	const current = character.hitPreviewAntiVGround(0, 0) || [];
	const back = character.hitPreviewAntiVGround(Utils.sign(members.isTriggerLeft) * 20, 0) || [];
	if(this._impactDirection === 0 && this.impactObject() || !current.some((obj) => { return obj.type <= 1 && obj !== this; }) && back.some((obj) => { return obj.type <= 1 && obj !== this; })) {
		members.isTriggerLeft = !members.isTriggerLeft;
	} else {
		this.updateMoveSimple(members.isTriggerLeft);
	}
	if(this.requestBodyAttack("drop_small_bomb")) {
		if($gameSystem.difficulty() === 0) {
			this.reduceAttackCD(30);
		} else if($gameSystem.difficulty() === 1) {
			this.reduceAttackCD(60);
		}
	}
};
Game_Event.prototype.doPStateChange53 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState53 = function(members) {
};

// 可破坏物体气球
Game_Event.prototype.initStatemMembers54 = function(members) {
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState54 = function(members) {
	this.suspendGravity();
	this.vx = this.vy = 0;
};
Game_Event.prototype.doPStateChange54 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState54 = function() {
};

// 下劈加弹力的云
Game_Event.prototype.initStatemMembers55 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.beHitNum = this.beHitNum();
	members.resumeCounter = 0;
};
Game_Event.prototype.doPState55 = function(members) {
	this.vx = this.vy = 0;
	if(this.beHitNum() !== members.beHitNum) {
		members.beHitNum = this.beHitNum();
		members.resumeCounter = 330;
		this.lockInvincible();
		this.battleObject().standingImage = ";down_attack_cloud_fadeout";
		this.resetImage(this.battleObject().standingImage);
	}
	if(members.resumeCounter === 282) {
		this.battleObject().standingImage = ";empty_character";
		this.resetImage(this.battleObject().standingImage);
	}
	if(members.resumeCounter === 48) {
		this.battleObject().standingImage = ";down_attack_cloud_fadein";
		this.resetImage(this.battleObject().standingImage);
	}
	if(members.resumeCounter > 0) {
		members.resumeCounter--;
		if(members.resumeCounter === 0) {
			this.unlockInvincible();
			this.battleObject().standingImage = ";down_attack_cloud";
			this.resetImage(this.battleObject().standingImage);
		}
	}
};
Game_Event.prototype.doPStateChange55 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState55 = function() {
	this.setPstate(0);
};

// 玩家地形弹跳会让自己在半透明和实体之间来回切换的云
Game_Event.prototype.initStatemMembers56 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.state = $gamePlayer.elasticSeCd === 0 ? 0 : 1;			// 0检测玩家被弹起CD开始，1检测玩家被弹起CD结束
	this.elasticSe = 1;
	if(this.battleObject().factorA) {
		this.setOpacity(128);
		this._physicsFlag = 1;
	} else {
		this.setOpacity(255);
		this._physicsFlag = 0;
	}
};
Game_Event.prototype.doPState56 = function(members) {
	this.vx = this.vy = 0;
	if(members.state === 0) {
		if($gamePlayer.elasticSeCd > 0) {
			members.state = 1;
			if(this.opacity() < 255) {
				this.setOpacity(255);
				this._physicsFlag = 0;
			} else {
				this.setOpacity(128);
				this._physicsFlag = 1;
			}
		}
	} else { 
		if($gamePlayer.elasticSeCd === 0) {
			members.state = 0;
		}
	}
};
Game_Event.prototype.doPStateChange56 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState56 = function() {
	this.setPstate(0);
};

//追着玩家并且冲撞的两角猫怪
Game_Event.prototype.initStatemMembers57 = function(members) {
	this.commonInit(members);
	this.setAirFriction(0.3);
};
Game_Event.prototype.doPState57 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	const distance = this.pixelDistanceToPlayer();
	if(distance > 560) {
		return;
	}
	const distanceX = Math.abs(this.px - $gamePlayer.px);
	if(distanceX < 160) {
		if(!this.isBodyAttacking()) {
			this.faceToPlayer();
		}
		if(Math.abs(this.py - $gamePlayer.py) < 100) {
			this.requestBodyAttack(this.difficultySkillName("horn_cat_attack"));
		}
	} else {
		if($gameSystem.difficulty() === 1) {
			this.updateMoveSimple(this.px - $gamePlayer.px > 0, 2);
		} else if($gameSystem.difficulty() === 0) {
			this.updateMoveSimple(this.px - $gamePlayer.px > 0, 1.5);
		} else {
			this.updateMoveSimple(this.px - $gamePlayer.px > 0);
		}
		
	}
};
Game_Event.prototype.doPStateChange57 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState57 = function() {
};

// 可破坏云朵
Game_Event.prototype.initStatemMembers58 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.elasticSe = 1;
};
Game_Event.prototype.doPState58 = function(members) {
};
Game_Event.prototype.doPStateChange58 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState58 = function() {
};

// 玩家一踩上去就开始移动到目的地的云朵
Game_Event.prototype.initStatemMembers59 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.elasticSe = 1;
	members.started = false;
	members.tx = 0;
	members.ty = 0;
};
Game_Event.prototype.doPState59 = function(members) {
	const para = this.battleObject().factorB;
	const vx = para[0];
	const vy = para[1];
	const tx = para[2];
	const ty = para[3];
	this.suspendGravity();
	if(!members.started) {
		this.vx = this.vy = 0;
		if($gamePlayer._groundHitObj === this) {
			members.started = true;
			if(vx !== 0) {
				members.tx = Math.round((tx - this.px) / vx);
			}
			if(vy !== 0) {
				members.ty = Math.round((ty - this.py) / vy);
			}
		}
	} else {
		if(members.tx > 0) {
			this.vx = vx;
			members.tx--;
		} else {
			this.vx = 0;
		}
		if(members.ty > 0) {
			this.vy = vy;
			members.ty--;
		} else {
			this.vy = 0;
		}
	}
	if($gamePlayer._immuePhysicsObject && this.fix) {
		this.fix = false;
		$gamePlayer.vy = 0;
		this._physicsFlag = 5;
	} else if(!$gamePlayer._immuePhysicsObject && !this.fix) {
		this.fix = true;
		this._physicsFlag = 0;
	}
};
Game_Event.prototype.doPStateChange59 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState59 = function() {
};

// 猫币堆
Game_Event.prototype.initStatemMembers60 = function(members) {
	members.beHitNum = 0;
	this.determineState60(members, $gameVariables.getCoinStoneBeHitNum($gameMap.mapId(), this.eventId()));
};
Game_Event.prototype.doPState60 = function(members) {
	this.vx = this.vy = 0;
	if(members.beHitNum !== this.beHitNum()) {
		for(let i = 0; i < 8; i++) {
			$gameMap.dropCoin(this.px + Utils.randomInt(-this.hitOffsetL(), this.hitOffsetR()), this.py + Utils.randomInt(-this.hitOffsetT(), this.hitOffsetB()), 1, Math.random() * 2 - 1, Utils.randomInt(0, 1) === 0 ? -1 : 1);
		}
		for(let i = 0; i < 3; i++) {
			$gameMap.dropCoin(this.px + Utils.randomInt(-this.hitOffsetL(), this.hitOffsetR()), this.py + Utils.randomInt(-this.hitOffsetT(), this.hitOffsetB()), 5, Math.random() * 2 - 1, Utils.randomInt(0, 1) === 0 ? -1 : 1);
		}
		$gameMap.dropCoin(this.px + Utils.randomInt(-this.hitOffsetL(), this.hitOffsetR()), this.py + Utils.randomInt(-this.hitOffsetT(), this.hitOffsetB()), 20, Math.random() * 2 - 1, Utils.randomInt(0, 1) === 0 ? -1 : 1);
		this.startShake(1, 35, 18);
		this.requestAnimation(54, {physicsPosition:true});
		members.beHitNum = this.beHitNum();
		const beHitNum = $gameVariables.getCoinStoneBeHitNum($gameMap.mapId(), this.eventId()) + 1;
		$gameVariables.setCoinStoneBeHitNum($gameMap.mapId(), this.eventId(), beHitNum);
		if(beHitNum >= 8) {
			$gameSelfSwitches.setValue([$gameMap.mapId(), this.eventId(), "A"], true);
		}
		this.determineState60(members, beHitNum);
	}
};
Game_Event.prototype.doPStateChange60 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState60 = function() {
};
Game_Event.prototype.determineState60 = function(members, beHitNum) {
	if($gameSelfSwitches.value([$gameMap.mapId(), this.eventId(), "A"])) {
		this.setImage(";coin_stoneD");
		this.lockSkillInvincible();
		this.setVertices([{"x":-48,"y":0},{"x":16,"y":-34},{"x":58,"y":0}]);
	} else if(beHitNum >= 5) {
		this.setImage(";coin_stoneC");
		this.setVertices([{"x":-54,"y":0},{"x":-4,"y":-70},{"x":84,"y":0}]);
	} else if(beHitNum >= 2) {
		this.setImage(";coin_stoneB");
		this.setVertices([{"x":-80,"y":0},{"x":18,"y":-110},{"x":76,"y":0}]);
	} else {
		this.setImage(";coin_stoneA");
		this.setVertices([{"x":-76,"y":0},{"x":10,"y":-138},{"x":78,"y":0}]);
	}
};

Game_Event.prototype.initStatemMembers61 = function(members) {
	const page = this.page();
    const image = page.image;
	this.terrain = true;
	this.battleObject().standingImage = image.characterName;
	const factorB = this.battleObject().factorB;
	this.battleObject().hitRect = {l:factorB[0],t:factorB[1],r:factorB[2],b:factorB[3]};
	this.resetHitOffset();
	this.setImage(this.battleObject().standingImage);
	this.fix = false;
};
Game_Event.prototype.doPState61 = function(members) {
	this.vx = this.vy = 0;
};
Game_Event.prototype.doPStateChange61 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState61 = function() {
};

Game_Event.prototype.initStatemMembers62 = function(members) {
	const page = this.page();
    const image = page.image;
	this.battleObject().standingImage = image.characterName;
	this.setImage(this.battleObject().standingImage);
	this.battleObject().deathAnimation = 0;
	this.lockSkillInvincible();
};
Game_Event.prototype.doPState62 = function(members) {
	const eventId = this.battleObject().factorA;
	if($gameMap.event(eventId).isDeath()) {
		this.battleObject().hp = 0;
	}
};
Game_Event.prototype.doPStateChange62 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState62 = function() {
};

// 老板娘初登场
Game_Event.prototype.initStatemMembers63 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockInvincible();
	this.requestAnimation(59, {physicsPosition:true, z:1});
};
Game_Event.prototype.doPState63 = function(members) {
	this.vx = this.vy = 0;
	if(Graphics.frameCount % 60 === 0) {
		this.requestAnimation(59, {physicsPosition:true, z:1});
	}
};
Game_Event.prototype.doPStateChange63 = function(members) {
};
Game_Event.prototype.detectState63 = function(members) {
};

// 可以下劈的云，围绕地图中央点旋转
Game_Event.prototype.initStatemMembers64 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.beHitNum = this.beHitNum();
	members.counter = 0;
	members.state = 0;
	const para = this.battleObject().factorB;
	members.rotation = 2 * Math.PI * para[0] / para[1];
};
Game_Event.prototype.doPState64 = function(members) {
	this.vx = this.vy = 0;
	switch(members.state) {
		case 0: {
			if(this.beHitNum() !== members.beHitNum && $gameSystem.difficulty() === 1) {
				members.beHitNum = this.beHitNum();
				this.lockInvincible();
				this.battleObject().standingImage = ";berries_cloud_hitting";
				this.resetImage(this.battleObject().standingImage);
				members.state = 1;
				members.counter = 0;
			}
			break;
		}
		case 1: {
			if(members.counter < this.getAllFrameTime(ImageFrame.info(this.battleObject().standingImage)) - 4) {
				members.counter++;
			} else {
				this.battleObject().standingImage = ";berries_cloud_off";
				this.resetImage(this.battleObject().standingImage);
				members.state = 2;
				members.counter = 0;
			}
			break;
		}
		case 2: {
			if(members.counter < 180) {
				members.counter++;
			} else {
				this.battleObject().standingImage = ";berries_cloud_reverse";
				this.resetImage(this.battleObject().standingImage);
				members.state = 3;
				members.counter = 0;
			}
			break;
		}
		case 3: {
			if(members.counter < this.getAllFrameTime(ImageFrame.info(this.battleObject().standingImage)) - 4) {
				members.counter++;
			} else {
				this.battleObject().standingImage = ";berries_cloud";
				this.resetImage(this.battleObject().standingImage);
				members.state = 0;
				members.counter = 0;
				this.unlockInvincible();
			}
			break;
		}
	}
	const para = this.battleObject().factorB;
	const centerX = $gameMap.width() * $gameMap.tileWidth() / 2;
	const centerY = $gameMap.height() * $gameMap.tileHeight() / 2 - 48;
	const rspeed = para[2];
	const radius = para[3];
	if($gameSystem.difficulty() !== -1) {
		members.rotation += rspeed;
	}
	if(members.rotation >= Math.PI * 2) {
		members.rotation -= (Math.PI * 2);
	}
	this.rx = this.px = Math.round(centerX + 1.4 * radius * Math.sin(members.rotation));
	this.ry = this.py = Math.round(centerY - radius * Math.cos(members.rotation));
};
Game_Event.prototype.doPStateChange64 = function(members, oldState, newState) {
};
Game_Event.prototype.detectState64 = function() {
	this.setPstate(0);
};

// 菓酱的BOSS版本
// 主行动模式有以下几种
// 0：浮空静止
// 1：靠近玩家直到在一定范围内
// 2：远离玩家直到碰墙或者超过一定距离
// 3：靠近远离玩家的墙+向上跳
// 4：滑墙
// 5：自由落体
Game_Event.prototype.initStatemMembers65 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.battleObject().jumpUpImage = "";
	this.battleObject().jumpDownImage = "";
	members.state = 0;
	members.stage = 0;
	members.stoneGenerate = 0;
	members.stoneGenerateCounter = 0;
	members.stateCounter = 0;
	members.jumpcd = 0;
	members.isTriggerLeft = false;
	members.stageChangeReady = false;
	members.emfieldGenerateCounter = 0;
	members.emState = false;
	members.emStateEndCounter = 0;
	members.emStateStartCounter = 0;
	members.shouldBreakHeadAttack = false;
	members.shouldUseHeadAttack = false;
	members.headAttackCDInNonHardMode = 0;
	members.playerRecoverGenerateLeft = false;
	if($gameSystem.difficulty() === -1) {
		members.pauseFloatTime = 50;
	} else if($gameSystem.difficulty() === 0) {
		members.pauseFloatTime = 40;
	} else {
		members.pauseFloatTime = 20;
	}
};
Game_Event.prototype.doPState65 = function(members) {
	this.updateJumpCD(members);
	this.updateStage65(members);
	this.updateStoneGenerate65(members);
	this.updateEMFieldGenerate65(members);
	this.updateEMState65(members);
	this.updateHeadAttackCD65(members);
	this.updateBallLightningStaggerSe65();
	if(this.isStagger()) {
		return;
	}
	if(!this.isBodyAttacking()) {
		this.stateControl65(members);
	}
	if(!this.isBodyAttacking()) {
		this.stateControlChange65(members);
	}
};
Game_Event.prototype.doPStateChange65 = function(members, oldState, newState) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState65 = function(members) {
	const state = this.pstate();
	if(state === 10 && members.stage === 0) {
		this.setPstate(0);
	}
};
Game_Event.prototype.stateControl65 = function(members) {
	switch(members.state) {
		case 0: {		// 空中站立不动
			this.vx = this.vy = 0;
			if(members.emStateStartCounter > 1300 && members.stage === 1 && $gameSystem.difficulty() === 1) {
				break;
			}
			if(members.shouldUseHeadAttack && members.stage === 1) {
				break;
			}
			if(members.stateCounter === members.pauseFloatTime) {
				if(members.stage === 0 && !members.stageChangeReady && !this.battleObject().immueDeath && this.requestBodyAttack("berries_stage2")) {
					members.stageChangeReady = true;
					break;
				}
				if(members.stageChangeReady) {
					members.stage = 1;
					members.emfieldGenerateCounter = 800;
					members.emStateStartCounter = 1300;
					members.stageChangeReady = false;
					$gameScreen.startFlash([255,255,255,128], 30);
					AudioManager.playNormalSe("Thunder9");
					$gameMap.setNightEnabled(true);
					$gameMap.refreshDayNightLayers();
					this.requestAnimation(63, {z:-4});
					AudioManager.playNormalBgm("boss_battle_berries_p2");
					break;
				}
				members.stateCounter++;
				if(this.requestBodyAttack("berries_stone_attack")) {
					if($gameSystem.difficulty() === 1) {
						members.stoneGenerate = 7;
					} else if($gameSystem.difficulty() === 0) {
						members.stoneGenerate = 5;
					} else {
						members.stoneGenerate = 4;
					}
					members.stoneGenerateCounter = 0;
					break;
				} 
				if(this.requestBodyAttack(this.difficultySkillName("berries_line_attack"))) {
					break;
				}
				if($gamePlayer._groundHitObj === this && this.requestBodyAttack(this.difficultySkillName("berries_lightning_boom"))) {
					break;
				}
			}
			break;
		}
		case 1: {		// 靠近玩家
			if(Math.abs(this.px - $gamePlayer.px) >= 50) {
				this.updateMoveSimple($gamePlayer.px < this.px);
			}
			const jumpStrength = this.battleObject().jumpStrength;
			if(this.vy > -jumpStrength / 2 && this.py > $gamePlayer.py && this.py > 144) {
				this.executeJump3(members);
			}
			break;
		}
		case 3: {		// 向离玩家较远的一面墙移动
			this.updateMoveSimple(members.isTriggerLeft);
			const jumpStrength = this.battleObject().jumpStrength;
			if(this.vy > -jumpStrength / 2 && this.py > 240) {
				this.executeJump3(members);
			}
			break;
		}
		case 5: {		// 头槌移动
			break;
		}
		case 4: {		// 滑墙
			this.updateMoveSimple(members.isTriggerLeft);
			this.setDirection(members.isTriggerLeft ? 6 : 4);
			if(Math.abs(this.py - $gamePlayer.py) < 36) {
				this.requestBodyAttack(this.difficultySkillName("berries_wall_attack"));
			}
			break;
		}
		case 2: case 6: case 7: case 8: {		// 2闪现头槌 6闪现向下发波 7过电 8头槌静止
			this.vx = this.vy = 0;
			break;
		}
	}
};
Game_Event.prototype.stateControlChange65 = function(members) {
	const oldState = members.state;
	switch(oldState) {
		case 0: {
			if(members.stateCounter <= members.pauseFloatTime) {
				members.stateCounter++;
				break;
			}
			if(members.stage === 1 && members.shouldUseHeadAttack) {
				members.state = 2;
				members.shouldUseHeadAttack = false;
				break;
			}
			if(members.emStateStartCounter > 1300 && members.stage === 1 && $gameSystem.difficulty() === 1) {
				members.state = 7;
				break;
			}
			if(($gamePlayer.px < 240 || $gamePlayer.px > $gameMap.width() * $gameMap.tileWidth() - 240) && !this.isAttackCD(this.difficultySkillName("berries_prop_down_attack"))) {
				members.state = 6;
				break;
			}
			if(members.stage === 0 && this.battleObject().getBuffVal("hp_lock") === 0) {
				if(!this.isAttackCD(this.difficultySkillName("berries_wall_attack"))) {
					members.state = 3;
					break;
				}
			}
			if(this.pixelDistanceToPlayer() >= 200) {
				members.state = 1;
			} else if(members.stateCounter > members.pauseFloatTime) {
				members.stateCounter = 0;
			}
			break;
		}
		case 1: {
			if(this.pixelDistanceToPlayer() < 200) {
				members.state = 0;
			}
			if(($gamePlayer.px < 240 || $gamePlayer.px > $gameMap.width() * $gameMap.tileWidth() - 240) && !this.isAttackCD(this.difficultySkillName("berries_prop_down_attack"))) {
				members.state = 6;
				break;
			}
			break;
		}
		case 2: {
			members.stateCounter++;
			if(members.stateCounter > 40) {
				members.state = 8;
			}
			break;
		}
		case 3: {
			if(this.impactObject() && this._impactDirection === 0 && this.impactObject().terrain && this.py <= 144) {
				members.state = 4;
				break;
			}
			if($gamePlayer._groundHitObj === this) {
				members.state = 0;
			}
			break;
		}
		case 4: {
			if(this.isGrounding() || $gamePlayer._groundHitObj === this || this.vy < -6) {
				members.state = 0;
			}
			break;
		}
		case 5: {
			if(members.shouldBreakHeadAttack) {
				members.state = 0;
				break;
			}
			if(!this.isBodyAttacking()) {
				members.state = 8;
			}
			break;
		}
		case 6: {
			members.stateCounter++;
			if(members.stateCounter > 40) {
				members.state = 0;
			}
			break;
		}
		case 7: {
			members.stateCounter++;
			if(members.stateCounter > 120) {
				members.state = 0;
			}
			break;
		}
		case 8: {
			if(this.py >= 192) {
				members.state = 5;
			} else {
				members.state = 0;
			}
			break;
		}
	}
	const newState = members.state;
	if(oldState !== newState) {
		switch(newState) {
			case 0: {
				members.stateCounter = 0;
				this.setFastMoveEffect(false);
				this.battleObject().jumpUpImage = "";
				this.battleObject().jumpDownImage = "";
				this.resetImage(this.battleObject().standingImage);
				break;
			}
			case 2: {
				this.battleObject().jumpUpImage = ";berries_jumpup";
				this.battleObject().jumpDownImage = ";berries_jumpdown";
				this.makeBlinkEffect(1, 60);
				members.stateCounter = 0;
				this.lockSkillInvincible();
				this.requestTemporaryPhysicsFlag1();
				this.setFastMoveEffect(true);
				break;
			}
			case 3: {
				members.isTriggerLeft = $gamePlayer.px > $gameMap.tileWidth() * $gameMap.width() / 2;
				this.battleObject().jumpUpImage = ";berries_jumpup";
				this.battleObject().jumpDownImage = ";berries_jumpdown";
				break;
			}
			case 4: {
				members.isTriggerLeft = this.px < $gameMap.tileWidth() * $gameMap.width() / 2;
				this.battleObject().jumpUpImage = ";berries_jumpup";
				this.battleObject().jumpDownImage = ";berries_wall_down";
				this.resetImage(this.battleObject().jumpDownImage);
				this._mg = -$gameMap.mg() / 2;
				this.vy = 0;
				break;
			}
			case 5: {
				this.battleObject().jumpUpImage = ";berries_jumpup";
				this.battleObject().jumpDownImage = ";berries_jumpdown";
				this.setDirection(members.isTriggerLeft ? 4 : 6);
				this.requestBodyAttack(this.difficultySkillName("berries_head_attack"));
				members.isTriggerLeft = !members.isTriggerLeft;
				break;
			}
			case 6: {
				this.battleObject().jumpUpImage = ";berries_jumpup";
				this.battleObject().jumpDownImage = ";berries_jumpdown";
				this.makeBlinkEffect(1, 60);
				members.stateCounter = 0;
				this.lockSkillInvincible();
				this.requestTemporaryPhysicsFlag1();
				break;
			}
			case 7: {
				members.emStateStartCounter = 0;
				this.battleObject().jumpUpImage = ";berries_magnet";
				this.battleObject().jumpDownImage = ";berries_magnet";
				this.resetImage(this.battleObject().jumpUpImage);
				const magnetEvent = $gameMap.event(this.battleObject().factorA);
				magnetEvent.unlockInvincible();
				this.lockInvincible();
				members.emStateEndCounter = 0;
				members.emStateStartCounter = 0;
				members.stateCounter = 0;
				this.requestAnimation(64);
				AudioManager.playNormalSe("Thunder12");
				break;
			}
			default: {
				this.battleObject().jumpUpImage = ";berries_jumpup";
				this.battleObject().jumpDownImage = ";berries_jumpdown";
				break;
			}
		}
		switch(oldState) {
			case 2: {
				this.unlockSkillInvincible();
				this.cancelTemporaryPhysicsFlag1();
				members.shouldBreakHeadAttack = false;
				if($gamePlayer.px < $gameMap.width() * $gameMap.tileWidth() / 2) {
					this.py = this.ry = $gameMap.height() * $gameMap.tileHeight() - 96;
					this.px = this.rx = 192;
					members.isTriggerLeft = false;
				} else {
					this.py = this.ry =  $gameMap.height() * $gameMap.tileHeight() - 96;
					this.px = this.rx = $gameMap.width() * $gameMap.tileWidth() - 192;
					members.isTriggerLeft = true;
				}
				this.makeBlinkEffect(2, 0);
				break;
			}
			case 4: {
				this._mg = 0;
				break;
			}
			case 6: {
				this.unlockSkillInvincible();
				this.cancelTemporaryPhysicsFlag1();
				if($gamePlayer.px < $gameMap.width() * $gameMap.tileWidth() / 2) {
					this.py = this.ry = Math.max(96, $gamePlayer.py - 192);
					this.px = this.rx = 192;
				} else {
					this.py = this.ry = Math.max(96, $gamePlayer.py - 192);
					this.px = this.rx = $gameMap.width() * $gameMap.tileWidth() - 192;
				}
				this.makeBlinkEffect(2, 0);
				this.requestBodyAttack(this.difficultySkillName("berries_prop_down_attack"));
				break;
			}
			case 7: {
				const magnetEvent = $gameMap.event(this.battleObject().factorA);
				magnetEvent.battleObject().standingImage = magnetEvent.battleObject().movingImage = magnetEvent.battleObject().staggerImage = ";berries_electronic_shield";
				magnetEvent.resetImage(magnetEvent.battleObject().standingImage);
				members.emState = true;
				this.battleObject().addBuff("hp_resume", 1500, 0.05, true);
				break;
			}
		}
	}
};
Game_Event.prototype.updateStoneGenerate65 = function(members) {
	if(members.stoneGenerate) {
		members.stoneGenerateCounter++;
		if(members.stoneGenerateCounter > 60) {
			members.stoneGenerate--;
			members.stoneGenerateCounter = 0;
			const stone = new Game_BerriesSmallBomb();
			stone.px = stone.rx = $gamePlayer.physicsCenterX();
			stone.py = stone.ry = $gamePlayer.physicsCenterY();
			$gameMap.createCharacter(stone);
			this.requestAnimation(59, {physicsPosition:true, z:-1});
		}
	}
};
Game_Event.prototype.updateStage65 = function(members) {
	if(this.battleObject().hp === 1 && members.stage === 0 && this.battleObject().immueDeath) {
		this.battleObject().addBuff("hp_lock", 9999999, 1, true);
		this.battleObject().immueDeath = false;
		AudioManager.fadeOutBgm(1);
	}
};
Game_Event.prototype.updateEMFieldGenerate65 = function(members) {
	if(members.stage === 1) {
		const time = $gameSystem.difficulty() === 1 ? 900 : 1200;
		if(members.emfieldGenerateCounter < time) {
			if(members.emfieldGenerateCounter === time - 100) {
				if($gameSystem.difficulty() !== -1) {
					const hasGen = $gameMap.dynamicCharacters().some((obj) => {
						return obj.constructor === Game_BerriesShieldRecover && obj._bossId === this.eventId();
					});
					if(!hasGen) {
						const recoverBoss = new Game_BerriesShieldRecover();
						recoverBoss.setupBossId(this.eventId(), 145);
						recoverBoss.px = $gameMap.centerX();
						recoverBoss.py = ($gameMap.height() - 1) * $gameMap.tileHeight();
						$gameMap.createCharacter(recoverBoss);
					}
				}
			}
			members.emfieldGenerateCounter++;
		} else {
			members.emfieldGenerateCounter = 0;
			const em = new Game_BallLighting();
			em.px = em.rx = $gameMap.centerX();
			$gameMap.createCharacter(em);
		}
	}
};
Game_Event.prototype.updateEMState65 = function(members) {
	if(members.stage === 1) {
		if(members.emState) {
			members.emStateEndCounter++;
			$gameMap.setSpecProgress(members.emStateEndCounter / 1500);
			if(members.emStateEndCounter >= 1500 || this.isStagger()) {
				members.emState = false;
				const magnetEvent = $gameMap.event(this.battleObject().factorA);
				magnetEvent.battleObject().standingImage = magnetEvent.battleObject().movingImage = magnetEvent.battleObject().staggerImage = ";berries_electronic_shield_off";
				magnetEvent.resetImage(magnetEvent.battleObject().standingImage);
				magnetEvent.lockInvincible();
				magnetEvent.statemMembers().clearImageTime = 24;
				this.unlockInvincible();
				$gameMap.clearSpecProgress();
				if(!this.isStagger()) {
					this.battleObject().addBuff("def_up", 1300, 0.75, true);
					this.create8DirLightBullet65();
				} else {
					this.battleObject().delBuff("hp_resume");
					this.requestRealDamage(20);
					this.requestAnimation(67);
				}
				AudioManager.playNormalSe("berries_lightning_off");
				members.shouldUseHeadAttack = true;
			}
		} else {
			members.emStateStartCounter++;
		}
	}
};
Game_Event.prototype.create8DirLightBullet65 = function(members) {
	const x = this.physicsCenterX();
	const y = this.physicsCenterY();
	for(let i = 0; i < 8; i++) {
		this.createBulletDirectly(x, y, this.difficultySkillName("lightning2"), i, 8);
	}
};
Game_Event.prototype.updateHeadAttackCD65 = function(members) {
	if(this.isStagger() && (members.state === 5 || members.state === 8)) {
		members.shouldBreakHeadAttack = true;
	}
	if($gameSystem.difficulty() !== 1 && members.stage === 1 && !members.shouldUseHeadAttack && members.state !== 2 && members.state !== 5 && members.state !== 8) {
		if(members.headAttackCDInNonHardMode <= 0) {
			members.shouldUseHeadAttack = true;
			members.headAttackCDInNonHardMode = 1000;
			$gameMap.clearSpecProgress();
		} else {
			members.headAttackCDInNonHardMode--;
			$gameMap.setSpecProgress((1000 - members.headAttackCDInNonHardMode) / 1000);
		}
	}
};
Game_Event.prototype.updateBallLightningStaggerSe65 = function() {
	if(!this.isDeath()) {
		let se = false;
		for(const character of $gameMap.dynamicCharacters()) {
			if(character.constructor === Game_BallLighting && character.shouldPlaySe()) {
				se = true;
			}
		}
		if(se) {
			AudioManager.playRandLoopSe(8);
		} else {
			AudioManager.stopRandLoopSe(AudioManager.RL_PARALYZE1);
		}
	} else {
		AudioManager.stopRandLoopSe(AudioManager.RL_PARALYZE1);
	}
};

// 老板娘的过电模式
Game_Event.prototype.initStatemMembers66 = function(members) {
	this.lockInvincible();
	members.clearImageTime = 0;
	this.setVertices([{"x":22,"y":-81},{"x":59,"y":-59},{"x":81,"y":-22},{"x":81,"y":22},{"x":59,"y":59},{"x":22,"y":81},{"x":-22,"y":81},{"x":-59,"y":59},{"x":-81,"y":22},{"x":-81,"y":-22},{"x":-59,"y":-59},{"x":-22,"y":-81}]);
};
Game_Event.prototype.doPState66 = function(members) {
	this.suspendGravity();
	this.battleObject().addBuff("def_up", 999999, 1);
	this.battleObject().addBuff("skill_force_immue", 999999, 1);
	const event = $gameMap.event(this.battleObject().factorA);
	if(event.statemMembers().stage === 1 && event.isDeath()) {
		this.battleObject().hp = 0;
	} else {
		this.px = this.rx = event.physicsCenterX();
		this.py = this.rx = event.physicsCenterY();
	}
	if(members.clearImageTime) {
		members.clearImageTime--;
		if(!members.clearImageTime) {
			this.battleObject().standingImage = this.battleObject().movingImage = this.battleObject().staggerImage = "";
			this.resetImage(this.battleObject().standingImage);
		}
	}
};
Game_Event.prototype.doPStateChange66 = function(members) {
};
Game_Event.prototype.detectState66 = function(members) {
};

// 奇异毒花怪
Game_Event.prototype.initStatemMembers67 = function(members) {
	this.setImage(this.battleObject().standingImage);
};
Game_Event.prototype.doPState67 = function(members) {
	this.vx = this.vy = 0;
	this._physicsFlag = 5;
	if(this.isAttackOutControl()) {
		return;
	}
	const x1 = this.physicsCenterX();
	const y1 = this.physicsCenterY();
	const x2 = $gamePlayer.physicsCenterX();
	const y2 = $gamePlayer.physicsCenterY();
	if($gameMap.pixelDistance(x1, y1, x2, y2) < 196) {
		this.requestBodyAttack(this.difficultySkillName("strange_flower_attack"));
	}
};
Game_Event.prototype.doPStateChange67 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState67 = function(members) {
};

// 改变重力参数的判定逻辑
Game_Event.prototype.initStatemMembers68 = function(members) {	
	this._physicsFlag = 3;
	this.lockInvincible();
};
Game_Event.prototype.doPState68 = function(members) {
	this.suspendGravity();
	this.vx = this.vy = 0;
	this._physicsFlag = 0;
	const hit = $gameMap.hitTest(this, $gameMap._physicsDynamicGrid, false);
	this._physicsFlag = 3;
	if(hit) {
		const shouldResetDownDash = this.battleObject().factorA;
		const para = this.battleObject().factorB;
		for(const obj of hit) {
			obj.setTempGravity(para[0]);
			obj.setTempMGravity(para[1]);
			if(shouldResetDownDash && obj instanceof Game_Player) {
				if(obj._bodyAttacking === "toru_down_dash_attack") {
					obj.vy = 0;
				}
			}
			obj.endFrameJump();
		}
	}
};
Game_Event.prototype.doPStateChange68 = function(members) {
};
Game_Event.prototype.detectState68 = function(members) {
};

// 黑鼠
Game_Event.prototype.initStatemMembers69 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.awake = false;
	members.moveTime = 0;
	members.waitTime = 0;
	members.jumpcd = 0;
	this.setFriction(12);
	this.setAirFriction(12);
	if($gameSystem.difficulty() === 1) {
		members.maxMoveTime = 300;
		members.maxWaitTime = 60;
	} else if($gameSystem.difficulty() === 0) {
		members.maxMoveTime = 240;
		members.maxWaitTime = 90;
	} else {
		members.maxMoveTime = 180;
		members.maxWaitTime = 120;
	}
};
Game_Event.prototype.doPState69 = function(members) {
	if(this.isAttackOutControl()) {
		return;
	}
	const distance = this.pixelDistanceToPlayer();
	if(!members.awake && distance < 600) {
		members.awake = true;
	}
	if(!members.awake) {
		return;
	}
	this.updateJumpCD(members);
	if(members.moveTime < members.maxMoveTime && Math.abs($gamePlayer.py - this.py) < 400 && Math.abs($gamePlayer.px - this.px) > 52) {
		const height = 100;
		const isLeft = $gamePlayer.px < this.px;
		if(this.hitPreview(-48 * Utils.sign(isLeft), height, emptyPhysicsGrid)) {
			members.moveTime++;
			const difficulty = $gameSystem.difficulty();
			const speedAdd = difficulty === 1 ? 1.6 : (difficulty === 0 ? 1.3 : 1);
			this.updateMoveSimple(isLeft, speedAdd);
			if(this.isGrounding()) {
				if(this.py - $gamePlayer.py > 60) {
					this.executeJump3(members);
				}
			}
		}
		
	} else if(members.waitTime < members.maxWaitTime) {
		members.waitTime++;
	} else {
		members.waitTime = 0;
		members.moveTime = 0;
	}
	if(distance < 96) {
		this.faceToPlayer();
		this.requestBodyAttack("black_rat_attack");
	}
};
Game_Event.prototype.doPStateChange69 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState69 = function(members) {
};

// 灰鼠
// 恶魔墙的召唤物灰鼠Game_WallRat也有调用这些函数
Game_Event.prototype.initStatemMembers70 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.setFriction(12);
	this.setAirFriction(12);
	members.bite = false;
	members.lockX = 0;
	members.lockY = 0;
	members.jumpcd = 0;
	members.biteTarget = 0;
	members.directionFix = this.direction();
	this.m = 99;
};
Game_Event.prototype.doPState70 = function(members) {
	if(members.bite) {
		const target = members.biteTarget === 0 ? $gamePlayer : $gameLily;
		this.px = target.px + members.lockX;
		this.py = target.py + members.lockY;
		target.battleObject().addBuff("jump_down", 2, 0.5);
		target.battleObject().addBuff("mov_down", 2, 0.5);
		this.battleObject().addBuff("def_up", 90, 0.75);
		this.suspendGravity();
		this.vx = this.vy = 0;
		target.setTempGravity(0.4);
		target.setTempMGravity(0.4);
	}
	if(this.isStagger() && members.bite) {
		members.bite = false;
		this.battleObject().jumpUpImage = this.battleObject().jumpDownImage = ";gray_rat";
		this.resumeGravity();
		const min = -72;
		let y = 0;
		while(this.hitPreview(0, y, emptyPhysicsGrid) && y > min) {
			y--;
		}
		this.py += y;
	}
	if(this.isAttackOutControl()) {
		return;
	}
	this.updateJumpCD(members);
	if(!members.bite) {
		const isFollowLily = this.battleObject().factorA;	// 是否是以莉莉亚为目标的灰鼠（恶魔墙BOSS战有用）
		if(this.impactObject() === $gamePlayer || $gamePlayer.impactObject() === this || this._groundHitObj === $gamePlayer || $gamePlayer._groundHitObj === this) {
			members.bite = true;
			members.lockX = Utils.randomInt(-12, 12);
			members.lockY = Utils.randomInt(-18, 0);
			this.battleObject().jumpUpImage = this.battleObject().jumpDownImage = ";gray_rat_jump";
			this.setImage(this.battleObject().jumpUpImage);
			AudioManager.playPlayerRoundSe(this, "rat_bite5");
			members.biteTarget = 0;
		} else if(this.impactObject() === $gameLily || $gameLily.impactObject() === this || this._groundHitObj === $gameLily || $gameLily._groundHitObj === this) {
			members.bite = true;
			members.lockX = Utils.randomInt(-12, 12);
			members.lockY = Utils.randomInt(-18, 0);
			this.battleObject().jumpUpImage = this.battleObject().jumpDownImage = ";gray_rat_jump";
			this.setImage(this.battleObject().jumpUpImage);
			AudioManager.playPlayerRoundSe(this, "rat_bite5");
			members.biteTarget = 1;
			$gameLily.triggerUniqueFloatMessage(277);
		} else if(isFollowLily || this.pixelDistanceToPlayer() < 900) {
			const height = 100;
			const followTarget = isFollowLily ? $gameLily : $gamePlayer;
			const isLeft = this.isGrounding() ? followTarget.px < this.px : members.directionFix === 4;
			if(this.hitPreview(-96 * Utils.sign(isLeft), height, emptyPhysicsGrid)) {
				const difficulty = $gameSystem.difficulty();
				const speedAdd = difficulty === 1 ? 1.6 : (difficulty === 0 ? 1.3 : 1);
				if(Math.abs(this.px - followTarget.px) > 8) {
					this.updateMoveSimple(isLeft, speedAdd);
				} 
				if(this.isGrounding()) {
					members.directionFix = this.direction();
					if(this.py - followTarget.py > 60) {
						this.executeJump3(members);
					}
				}
			} 
		}
	}

};
Game_Event.prototype.doPStateChange70 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState70 = function(members) {
	if(members.bite && !this.isDeath()) {
		this.setPstate(4);
	}
};

// 恶魔石墙（不包括眼睛）
Game_Event.prototype.initStatemMembers71 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.startMoving = false;			// 开始出场的开关
	members.movingComplete = false;
	this.lockInvincible();
};
Game_Event.prototype.doPState71 = function(members) {
	const targetX = this.battleObject().factorA;
	if(members.startMoving) {
		if(this.px > targetX) {
			this.vx = -this.battleObject().maxMoveSpeed;
		} else {
			members.startMoving = false;
			members.movingComplete = true;
			this.vx = 0;
		}
	}
	const eyeEvent = $gameMap.event(this.battleObject().factorB[0]);
	if(eyeEvent.isDeath()) {
		this.battleObject().hp = 0;
	}
};
Game_Event.prototype.doPStateChange71 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState71 = function(members) {
};

// 恶魔石墙被击败后，眼球消失，原石墙消失前将位置输出+到该对象，然后该对象缓慢下沉（变暗效果在贴图上实现）
Game_Event.prototype.initStatemMembers72 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockInvincible();
	const wallEvent = $gameMap.event(this.battleObject().factorB[0]);
	this.px = wallEvent.px;
	this.py = wallEvent.py;
	members.effectPositionX = this.px;
	members.effectPositionY = this.py - 458;
	members.state = 0;
	members.stateTime = 0;
	AudioManager.playNormalSe("Earthquake3");
};
Game_Event.prototype.doPState72 = function(members) {
	this.vx = 0;
	if(members.state === 0) {
		this.startShake(2, 10, 10);
		members.stateTime++;
		this.vy = 0;
		if(members.stateTime < 90) {
			members.stateTime++;
		} else {
			members.state = 1;
		}
		return;
	}
	if(this.py < $gameMap.height() * $gameMap.tileHeight() + this.patternHeight()) {
		this.vy = this.battleObject().maxMoveSpeed;
		this.startShake(1, 18, 10);
		const effectId = this.battleObject().factorA;
		if(Graphics.frameCount % 15 === 0) {
			this.requestAnimation(effectId, {staticPosition:true, x:members.effectPositionX, y:members.effectPositionY});
		}
	} else if(!$gameSelfSwitches.value([$gameMap.mapId(), this.eventId(), "A"])) {
		this.vy = 0;
		$gameSelfSwitches.setValue([$gameMap.mapId(), this.eventId(), "A"], true);
		AudioManager.playNormalSe("Bluezone_BC0253_impact_11");
		$gameScreen.startShake(2, 15, 10);
	}
};
Game_Event.prototype.doPStateChange72 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState72 = function(members) {
};

// 恶魔石墙BOSS的移动光柱底座，光柱会同步底座的X坐标和Y坐标，底座会同步光柱的生命状态（死亡后切图，并且静止不动，一段时间后将光柱重生）
// 光柱死亡动画用粒子特效实现，挂在deathAnimation上，重生动画也用粒子特效实现，在本AI类型里启动特效
Game_Event.prototype.initStatemMembers73 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockInvincible();
	members.respawnTime = 0;
	members.state = -1;			// 0熄火1永远熄火2启动3启动准备4眼睛破防暂时熄火
	members.readyTime = 0;
	members.isTriggerLeft = false;
	members.isStarted = false;		// 剧情演出后，boss战正式开始就=true
	members.directionChangeCD = 0;
};
Game_Event.prototype.doPState73 = function(members) {
	if(!members.isStarted) {
		return;
	}
	const targetEventId = this.battleObject().factorA;
	const targetEvent = $gameMap.event(targetEventId);
	const para = this.battleObject().factorB;
	const bossEventId = para[0];
	const respawnMaxTime = para[1];
	const respawnEffectId = para[2];		// 87
	const maxReadyTime = para[3];			// 重生读条完毕到执行重生的准备时间，等于重生特效的长度24
	const oldState = members.state;
	const eyeEvent = $gameMap.event(bossEventId);
	if(eyeEvent.isDeath()) {
		members.state = 1;
	} else if(eyeEvent.statemMembers().state === 2) {
		members.state = 4;
	} else if(eyeEvent.statemMembers().state !== 2 && members.state === 4) {
		members.state = 3;
	} else if(targetEvent.isDeath() && members.state === 2) {
		members.state = 0;
	} else if(members.respawnTime >= respawnMaxTime && members.state === 0) {
		members.state = 3;
	} else if(members.readyTime >= maxReadyTime && members.state === 3) {
		members.state = 2;
	} else if(members.state === -1 && members.isStarted) {
		members.state = 2;
	}
	if(members.state === 1 && oldState === 2) {
		targetEvent.battleObject().hp = 0;
		this.clearSpecProgress();
	}
	if(members.state === 0 && oldState !== 0) {
		this.setCommonImage(";evil_light_bottom_break");
		members.respawnTime = 0;
	} else if(members.state === 0 && members.respawnTime < respawnMaxTime) {
		members.respawnTime++;
		this.setSpecProgress(members.respawnTime / respawnMaxTime);
	}
	if(members.state === 3 && oldState !== 3) {
		this.clearSpecProgress();
		this.requestAnimation(respawnEffectId, {physicsPosition:true});
		members.readyTime = 0;
	} else if(members.state === 3) {
		members.readyTime++;
	}
	if(members.state === 4 && oldState !== 4) {
		this.setCommonImage(";evil_light_bottom_break");
		targetEvent.battleObject().hp = 0;
		this.clearSpecProgress();
	}
	
	targetEvent.px = this.px;
	targetEvent.py = this.py - this.hitOffsetT() - this.hitOffsetB();
	if(members.state === 2 && oldState !== 2) {
		targetEvent.respawn();
		this.setCommonImage(";evil_light_bottom");
	} else if(members.state === 2 && targetEvent.isStagger()) {
		this.vx = this.vy = 0;
		targetEvent._vx = this._vx;
		targetEvent._vy = this._vy;
		this.requestBodyAttack("evil_wall_moving_light");
	} else if(members.state === 2) {
		if(this.impactObject() && this._impactDirection === 0 && members.directionChangeCD === 0) {
			members.isTriggerLeft = !members.isTriggerLeft;
			members.directionChangeCD = 60;
		} else if(members.directionChangeCD > 0) {
			members.directionChangeCD--;
		}
		this.updateMoveSimple(members.isTriggerLeft, eyeEvent.battleObject().hp <= eyeEvent.battleObject().mhp / 2 ? 1.5 : 1);
		targetEvent._vx = this._vx;
		targetEvent._vy = this._vy;
		this.requestBodyAttack("evil_wall_moving_light");
	}
};
Game_Event.prototype.doPStateChange73 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState73 = function(members) {
};

// 恶魔石墙BOSS的移动光柱，带硬直的攻击伤害为0，this.battleObject().immueStaggerAttack=true
Game_Event.prototype.initStatemMembers74 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.battleObject().addBuff("anti_stagger", 99999999, 1);
};
Game_Event.prototype.doPState74 = function(members) {
	this.suspendGravity();
};
Game_Event.prototype.doPStateChange74 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState74 = function(members) {
};

// 恶魔石墙的周围的花堆，血量无限但受到分裂攻击后会无敌并停止攻击一段时间并开始读条，读条完毕后恢复
Game_Event.prototype.initStatemMembers75 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.state = 0;
	members.restartTime = 0;
};
Game_Event.prototype.doPState75 = function(members) {
	this.vx = this.vy = 0;
	if(members.state === 0) {
		this.requestBodyAttack("evil_wall_flower");
		if(this.isLatestHitObject(Game_WallDivisionBulletFragment)) {
			members.restartTime = 0;
			members.state = 1;
			this.lockInvincible();
			this.requestAnimation(this.battleObject().factorA, {physicsPosition:true});
		}
	} else if($gameSystem.difficulty() === 1) {
		const maxTime = 1500;
		if(members.restartTime < maxTime) {
			members.restartTime++;
			this.setSpecProgress(members.restartTime / maxTime);
		} else {
			this.clearSpecProgress();
			this.unlockInvincible();
			members.state = 0;
		}
	}
};
Game_Event.prototype.doPStateChange75 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState75 = function(members) {
	this.setPstate(members.state);
};

// 恶魔石墙的眼睛（BOSS本体）
// 基础逻辑：范围内上下移动，同步墙体X坐标
// 技能逻辑（根据眼球的离地高度决定技能是否发动）：紫色弹幕(0.5) -> 双排粗大弹幕(高度=1) -> 紫色弹幕(0.5) -> 双排粗大弹幕(0) -> 双排粗大弹幕(0.5) -> 扫射激光(1) -> 双排粗大弹幕(0) -> 【从头循环】
// 光柱消失时眼睛闭上状态，移动停止
// 光柱消失+被炸弹攻击则进入眩晕状态，防御力BUFF解除，受击特效暂时移除，移动停止
// 定时生成连续落石（独立逻辑）
Game_Event.prototype.initStatemMembers76 = function(members) {
	this.setImage(this.battleObject().standingImage);
	members.state = 3;			// 0正常1闭眼2眩晕3睁眼无敌（用于开场剧情）
	members.moveSign = 0;
	members.isStarted = false;
	members.defenceBreakTime = 0;
	members.closeTime = 0;
	members.currentSkillIndex = 0;
	members.ratSummonReadyTime = 200;
	members.stoneSummonReadyTime = 500;
	members.stoneGenerate = 0;
	members.stoneGenerateCounter = 0;
	members.hasPlayHalfHpEffect = false;
	members.laserEndCounter = 0;
	members.defenceBreakCoolTime = 0;
	this.battleObject().addBuff("anti_stagger", 99999999, 1);
	this.lockSkillInvincible();
	this._immueFixObject = true;
};
Game_Event.prototype.doPState76 = function(members) {
	const wallEventId = this.battleObject().factorA;
	const wallEvent = $gameMap.event(wallEventId);
	this.px = wallEvent.px;
	this.vx = wallEvent.vx;
	if(members.state !== 2) {
		this.vy = 0;
		this.suspendGravity();
	}
	const para = this.battleObject().factorB;
	const oldState = members.state;
	const lightEvent = $gameMap.event(para[0]);
	const maxY = para[1];
	const minY = para[2];
	const maxBreakTime = 480;
	const difficulty = $gameSystem.difficulty();
	if($gamePlayer.px > this.px && members.state === 0) {
		this.battleObject().addBuff("hp_resume", 99999999, 0.4, false);
	} else if(members.state === 0) {
		this.battleObject().delBuff("hp_resume");
	}
	// detect
	switch(members.state) {
		case 0: {
			if(members.defenceBreakCoolTime <= 0) {
				if(lightEvent.isDeath()) {
				members.state = 1;
				} else if(this.isLatestHitObject(Game_LilyBombPartner)) {
					members.state = 2;
				}
			} else {
				members.defenceBreakCoolTime--;
			}
			break;
		}
		case 1: {
			if(this.isLatestHitObject(Game_LilyBombPartner)) {
				members.state = 2;
			} else if(!lightEvent.isDeath()) {
				members.state = 0;
			}
			break;
		}
		case 2: {
			if(members.defenceBreakTime >= maxBreakTime) {
				members.state = 0;
				members.defenceBreakCoolTime = 60;
			}
			break;
		}
		default: {
			if(members.isStarted) {
				members.state = 0;
				this.unlockSkillInvincible();
			}
			break;
		}
	}
	// state change
	if(oldState !== members.state) {
		switch(members.state) {
			case 0: {
				this.setCommonImage(";evil_eye");
				this.battleObject().beAttackSlashAnimations = [];
				this.battleObject().onHitSe = lightEvent.battleObject().onHitSe;
				break;
			}
			case 1: {
				members.closeTime = 0;
				this.setCommonImage(";evil_eye_closing");
				const resume = difficulty === 1 ? 1 : (difficulty === 0 ? 0.5 : 0.1);
				this.battleObject().addBuff("hp_resume", 99999999, resume, true, "", {effectId:22, effectInterval:90});
				this.battleObject().addBuff("def_up", 99999999, 1, false);
				this.battleObject().addBuff("useless_invincible", 99999999, 1, false);
				this.battleObject().beAttackSlashAnimations = [18];
				this.battleObject().onHitSe = ["glass_mon_onhit"];
				break;
			}
			case 2: {
				members.defenceBreakTime = 0;
				this.setCommonImage(";evil_eye_dizzy");
				this.battleObject().beAttackSlashAnimations = [];
				this.battleObject().onHitSe = lightEvent.battleObject().onHitSe;
				this.requestAnimation(90, {physicsPosition:true});
				this.resumeGravity();
				break;
			}
			default: break;
		}
		switch(oldState) {
			case 0: {
				if(this.isBodyAttacking()) {
					this.endBodyAttack(false);
				}
				break;
			}
			case 1: {
				this.battleObject().delBuff("hp_resume");
				this.battleObject().delBuff("useless_invincible");
				this.battleObject().delBuff("def_up");
				break;
			}
			case 2: {
				$gameMap.clearSpecProgress();
				members.currentSkillIndex = 0;
				break;
			}
			default: {
				members.moveSign = -1; 
				break;
			}
		}
	}
	// do state
	if(this.isBodyAttacking() && this._bodyAttacking !== "evil_wall_laser") {
		this.vy = 0;
		return;
	}
	switch(members.state) {
		case 0: {
			const half = this.battleObject().hp <= this.battleObject().mhp / 2;
			if(this.py <= minY) {
				members.moveSign = 1;
			} else if(this.py >= maxY) {
				members.moveSign = -1;
			}
			this.vy = members.moveSign * this.battleObject().maxMoveSpeed * (difficulty === -1 ? 1 : (difficulty === 0 ? 1.5 : 2)) * (half ? 1.5 : 1);
			this.py = Math.ceil(this.py / this.vy) * this.vy;
			const distance = maxY - minY;
			const position1 = minY;
			const position2 = minY + distance / 2;
			const position3 = minY + distance;
			const nextY = this.py + this.vy;
			if(nextY === position1 || nextY === position2 || nextY === position3) {
				if(this._bodyAttacking === "evil_wall_laser") {
					members.laserEndCounter--;
					if(members.laserEndCounter === 0) {
						this.endBodyAttack(false);
					}
				}
				if(!this.isBodyAttacking()) {
					this.doPState76CurrentSkill(members);
					members.currentSkillIndex++;
					const maxSkillIndex = difficulty === 1 ? 6 : 5;
					if(members.currentSkillIndex > maxSkillIndex) {
						members.currentSkillIndex = 0;
					}
				}
			}
			const maxRatSummonTime = 300;
			if(members.ratSummonReadyTime < maxRatSummonTime) {
				members.ratSummonReadyTime++;
			} else {
				members.ratSummonReadyTime = 0;
				const rat = new Game_WallRat();
				rat.px = wallEvent.px - 220 + Utils.randomInt(-20, 20);
				rat.py = wallEvent.py - 700 + Utils.randomInt(-20, 20);
				rat.setBossEventId(this.eventId());
				$gameMap.createCharacter(rat);
			}
			if(!members.hasPlayHalfHpEffect && half) {
				members.hasPlayHalfHpEffect = true;
				this.requestAnimation(91, {physicsPosition:true});
				members.stoneSummonReadyTime = 1200;
			}
			//this.doPState76StoneGenerate(members, difficulty);
			break;
		}
		case 1: {
			members.closeTime++;
			if(members.closeTime == 8) {
				this.setCommonImage(";evil_eye_closed");
			}
			//this.doPState76StoneGenerate(members, difficulty);
			break;
		}
		case 2: {
			members.defenceBreakTime++;
			$gameMap.setSpecProgress(members.defenceBreakTime / maxBreakTime, 1);
			if(this.py > maxY) {
				this.py = maxY;
			}
			break;
		}
	}
};
Game_Event.prototype.doPState76CurrentSkill = function(members) {
	let skillName = "";
	switch(members.currentSkillIndex) {
		case 0: {
			skillName = "evil_wall_thick_bullet";
			break;
		}
		case 1: {
			skillName = "evil_wall_purple_bullet";
			break;
		}
		case 2: {
			skillName = "evil_wall_purple_bullet";
			break;
		}
		case 3: {
			skillName = "evil_wall_thick_bullet";
			break;
		}
		case 4: {
			skillName = "evil_wall_thick_bullet";
			break;
		}
		case 5: {
			skillName = "evil_wall_purple_bullet";
			break;
		}
		case 6: {
			skillName = "evil_wall_laser";
			members.laserEndCounter = 3;
			break;
		}
	}
	this.requestBodyAttack(skillName);
};
Game_Event.prototype.doPState76StoneGenerate = function(members, difficulty) {
	const half = this.battleObject().hp <= this.battleObject().mhp / 2;
	const maxStoneSummonTime = 1000;
	if(members.stoneSummonReadyTime < maxStoneSummonTime) {
		members.stoneSummonReadyTime++;
	} else {
		members.stoneSummonReadyTime = 0;
		members.stoneGenerate = difficulty === -1 ? 4 : (difficulty === 0 ? 5 : 6);
		members.stoneGenerate += (half ? 2 : 0);
		members.stoneGenerateCounter = 0;
	}
	if(members.stoneGenerate > 0 && members.stoneGenerateCounter >= (half ? 60 : 90)) {
		members.stoneGenerateCounter = 0;
		members.stoneGenerate--;
		const stone = new Game_BerriesStone();
		stone.px = $gamePlayer.px;
		stone.py = $gamePlayer.py;
		$gameMap.createCharacter(stone);
	} else if(members.stoneGenerate > 0) {
		members.stoneGenerateCounter++;
	}
};
Game_Event.prototype.doPStateChange76 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState76 = function(members) {
};

// 恶魔墙眼球背后的肉芽
Game_Event.prototype.initStatemMembers77 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockSkillInvincible();
	this._physicsFlag = 5;
	this._immueFixObject = true;
};
Game_Event.prototype.doPState77 = function(members) {
	this.suspendGravity();
	const eyeEvent = $gameMap.event(this.battleObject().factorA);
	this.px = eyeEvent.px;
	this.py = eyeEvent.py;
	this._vx = eyeEvent.vx;
	this._vy = eyeEvent.vy;
	if(eyeEvent.isDeath()) {
		this.battleObject().hp = 0;
	}
};
Game_Event.prototype.doPStateChange77 = function(members) {
};
Game_Event.prototype.detectState77 = function(members) {
};

// 恶魔墙前方的角
Game_Event.prototype.initStatemMembers78 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockSkillInvincible();
	this._physicsFlag = 5;
	this._immueFixObject = true;
};
Game_Event.prototype.doPState78 = function(members) {
	this.suspendGravity();
	const wallEvent = $gameMap.event(this.battleObject().factorA);
	this.px = wallEvent.px;
	this.py = wallEvent.py;
	this._vx = wallEvent.vx;
	this._vy = wallEvent.vy;
	if(wallEvent.isDeath()) {
		this.battleObject().hp = 0;
	}
};
Game_Event.prototype.doPStateChange78 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState78 = function(members) {
};

// 墙中层的基座，用于挡住老鼠营造层次感
Game_Event.prototype.initStatemMembers79 = function(members) {
	this.setImage(this.battleObject().standingImage);
	this.lockSkillInvincible();
	this._physicsFlag = 5;
	this.setTemporaryScreenZ(2);
	this._immueFixObject = true;
};
Game_Event.prototype.doPState79 = function(members) {
	this.suspendGravity();
	const wallEvent = $gameMap.event(this.battleObject().factorA);
	this.px = wallEvent.px;
	this.py = wallEvent.py;
	this._vx = wallEvent.vx;
	this._vy = wallEvent.vy;
	if(wallEvent.isDeath()) {
		this.battleObject().hp = 0;
	}
};
Game_Event.prototype.doPStateChange79 = function(members) {
	this.commonDoPStateChange(...arguments);
};
Game_Event.prototype.detectState79 = function(members) {
};

Game_Event.prototype.showAttackCd = function(name, normalCdReduce, hardCdReduce) {
	const difficulty = $gameSystem.difficulty();
	const reduce = difficulty === 1 ? hardCdReduce : (difficulty === 0 ? normalCdReduce : 0);
	const maxCd = AttackFrame.info(name).cd - reduce;
	const cd = this.getCd(name);
	this.setSpecProgress(1 - cd / maxCd);
};

















NYA.EFFECT = {};

Spriteset_Base.prototype.createAnimation = function(request) {
    const animation = $dataAnimations[request.animationId];
    const targets = request.targets;
    const mirror = request.mirror;
	const ext = request.ext;
	if(ext && ext.unique && targets.length === 1) {
		const id = animation.id;
		for(const sprite of this._animationSprites) {
			if(sprite._animation.id === id && sprite.targetObjects.includes(targets[0])) {
				sprite._ext = ext;
				return;
			}
		}
	}
    let delay = this.animationBaseDelay();
    const nextDelay = this.animationNextDelay();
    if (this.isAnimationForEach(animation)) {
        for (const target of targets) {
            this.createAnimationSprite([target], animation, mirror, delay, ext);
            delay += nextDelay;
        }
    } else {
        this.createAnimationSprite(targets, animation, mirror, delay, ext);
    }
};

// prettier-ignore
Spriteset_Base.prototype.createAnimationSprite = function(
    targets, animation, mirror, delay, ext
) {
    const sprite = new Sprite_Animation();
    const targetSprites = this.makeTargetSprites(targets);
    const baseDelay = this.animationBaseDelay();
    const previous = null;
    if (this.animationShouldMirror(targets[0])) {
        mirror = !mirror;
    }
    sprite.targetObjects = targets;
    sprite.setup(targetSprites, animation, mirror, delay, previous, ext);
	if(ext && ext.z) {
		sprite.z = ext.z;
	}
    this._effectsContainer.addChild(sprite);
    this._animationSprites.push(sprite);
};

NYA.EFFECT.Sprite_Animation_setup = Sprite_Animation.prototype.setup;
Sprite_Animation.prototype.setup = function(
    targets, animation, mirror, delay, previous, ext
) {
    NYA.EFFECT.Sprite_Animation_setup.apply(this, arguments);
	this._ext = ext || {};
	this._tempRect = new PIXI.Rectangle(0, 0, 1, 1);
};

// ext.z图层z值
// ext.staticPosition开启后特效变成近景，此时需要指定ext.x和ext.y
// ext.scale缩放比率
// ext.unique该特效将依据animationId和targets确定唯一，暂时只支持targets.length === 1的情况
// ext.physicsPosition指示该特效的位置计算应参照物理引擎上的坐标和大小，而不是贴图的坐标和大小，此时可以指定ext.align，可选值"top" "bottom"，表示上下对齐或下对齐，还可指定ext.x和ext.y，表示偏移量
// ext.rotation旋转弧度
Game_Temp.prototype.requestAdvanceAnimation = function(
    targets, animationId, ext, mirror = false
) {
    if ($dataAnimations[animationId]) {
        const request = {
            targets: targets,
            animationId: animationId,
            mirror: mirror,
			ext: ext
        };
        this._animationQueue.push(request);
        for (const target of targets) {
            if (target.startAnimation) {
                target.startAnimation();
            }
        }
    }
};

Game_Temp.prototype.requestRemoveAnimation = function(targets, animationId) {
	this._animationRemoveQueue.push({
		targets: targets,
        animationId: animationId
	});
};

NYA.EFFECT.Game_Screen_clearShake = Game_Screen.prototype.clearShake;
Game_Screen.prototype.clearShake = function() {
	NYA.EFFECT.Game_Screen_clearShake.apply(this, arguments);
	this._shakeAngle = 0;
};

Game_Screen.prototype.shakeAngle = function() {
	return this._shakeAngle;
};

Game_Screen.prototype.updateShake = function() {
    if (this._shakeDuration > 0 || this._shake !== 0) {
        const delta =
            (this._shakePower * this._shakeSpeed * this._shakeDirection) / 10;
        if (
            this._shakeDuration <= 1 &&
            this._shake * (this._shake + delta) < 0
        ) {
            this._shake = 0;
        } else {
            this._shake += delta;
        }
		if(this._shake === 0) {
			this._shakeAngle = Math.random() * 2 * Math.PI;
		}
        if (this._shake > this._shakePower * 2) {
            this._shakeDirection = -1;
        }
        if (this._shake < -this._shakePower * 2) {
            this._shakeDirection = 1;
        }
        this._shakeDuration--;
    }
};

NYA.EFFECT.Spriteset_Base_updatePosition = Spriteset_Base.prototype.updatePosition;
Spriteset_Base.prototype.updatePosition = function() {
	const screen = $gameScreen;
    const scale = screen.zoomScale();
    this.scale.x = scale;
    this.scale.y = scale;
    this.x = Math.round(-screen.zoomX() * (scale - 1));
    this.y = Math.round(-screen.zoomY() * (scale - 1));
    this.x += Math.round(screen.shake() * Math.cos(screen.shakeAngle()));
	this.y += Math.round(screen.shake() * Math.sin(screen.shakeAngle()));
};

NYA.EFFECT.Game_CharacterBase_initMembers = Game_CharacterBase.prototype.initMembers;
Game_CharacterBase.prototype.initMembers = function() {
	NYA.EFFECT.Game_CharacterBase_initMembers.apply(this, arguments);
	this.clearShake();
	this._transportRunning = false;
	this._transportEnding = false;
	this._transportFrame = 0;
	this._transportMapId = 0;
	this._transportX = 0;
	this._transportY = 0;
	this._spLackEffect = false;
	this._floatMessageStoryID = 0;
	this._floatMessageExecuteIndex = 0;
	this._fastMoveEffect = false;
	this._strokeEffect = false;
	this._rotation = 0;
	this._temporaryScreenZ = 0;
	this._scale = 1;
	this._lowerLightingMultiply = null;
	this._upperLightingMultiply = null;
	this._lowerLightingAdd = null;
	this._upperLightingAdd = null;
	this._blinkFrame = 0;
	this._blinkEffectType = 0;
};

Game_CharacterBase.prototype.clearShake = Game_Screen.prototype.clearShake;
Game_CharacterBase.prototype.updateShake = Game_Screen.prototype.updateShake;
Game_CharacterBase.prototype.shake = Game_Screen.prototype.shake;
Game_CharacterBase.prototype.shakeAngle = Game_Screen.prototype.shakeAngle;
Game_CharacterBase.prototype.startShake = Game_Screen.prototype.startShake;

NYA.EFFECT.Game_CharacterBase_screenX = Game_CharacterBase.prototype.screenX;
Game_CharacterBase.prototype.screenX = function() {
	return NYA.EFFECT.Game_CharacterBase_screenX.apply(this, arguments) + Math.round(this.shake() * Math.cos(this.shakeAngle()));
};

NYA.EFFECT.Game_CharacterBase_screenY = Game_CharacterBase.prototype.screenY;
Game_CharacterBase.prototype.screenY = function() {
	return NYA.EFFECT.Game_CharacterBase_screenY.apply(this, arguments) + Math.round(this.shake() * Math.sin(this.shakeAngle()));
};

NYA.EFFECT.Game_CharacterBase_update = Game_CharacterBase.prototype.update;
Game_CharacterBase.prototype.update = function() {
	NYA.EFFECT.Game_CharacterBase_update.apply(this, arguments);
	this.updateShake();
	this.updateBlinkEffect();
};

Game_CharacterBase.prototype.requestAnimation = function(animationId, info = {}, mirror = false) {
	$gameTemp.requestAdvanceAnimation([this], animationId, info, mirror);
};

Game_CharacterBase.prototype.requestDeathAnimation = function(scale) {
	this.requestAnimation(this.battleObject().deathAnimation, {scale:scale, physicsPosition:true});
};

Game_CharacterBase.prototype.requestSpLackEffect = function() {
	this._spLackEffect = true;
};

Game_CharacterBase.prototype.pollSpLackEffect = function() {
	const effect = this._spLackEffect
	this._spLackEffect = false;
	return effect;
};

Game_CharacterBase.prototype.enableFloatMessage = function() {
	return false;
};

Game_Event.prototype.enableFloatMessage = function() {
	return this.battleObject().enableFloatMessage;
};

Game_Player.prototype.enableFloatMessage = function() {
	return true;
};

Game_CharacterBase.prototype.requestFloatMessage = function(storyId) {
	this._floatMessageStoryID = storyId;
	this._floatMessageExecuteIndex = 0;
};

Game_CharacterBase.prototype.floatMessageInternal = function() {
	if(!this._floatMessageStoryID) {
		return null;
	}
	const story = $dataStory[this._floatMessageStoryID];
	for(let i = this._floatMessageExecuteIndex; i < story.length; i++) {
		if(story[i].name === "story") {
			return {idx:i, contents:story[i].contents};
		}
	}
	return null;
};

Game_CharacterBase.prototype.floatMessage = function() {
	const result = this.floatMessageInternal();
	if(result) {
		return result.contents;
	}
	return "";
};

Game_CharacterBase.prototype.clearFloatMessage = function() {
	this._floatMessageStoryID = 0;
	this._floatMessageExecuteIndex = 0;
};

Game_CharacterBase.prototype.nextFloatMessage = function() {
	this._floatMessageExecuteIndex++;
	const result = this.floatMessageInternal();
	if(result) {
		this._floatMessageExecuteIndex = result.idx;
		return result.contents;
	}
	this.clearFloatMessage();
	return "";
};

Game_CharacterBase.prototype.standardScale = function() {
	const base = $gameMap.tileWidth() + $gameMap.tileHeight();
	const one = this.hitOffsetL() + this.hitOffsetB() + this.hitOffsetR() + this.hitOffsetT();
	return one / base;
};

Game_CharacterBase.prototype.rotation = function() {
	return this._rotation;
};

Game_CharacterBase.prototype.setRotation = function(val) {
	this._rotation = val;
};

Sprite_Animation.prototype.extData = function() {
	return this._ext;
};

NYA.EFFECT.Sprite_Animation_updateEffectGeometry = Sprite_Animation.prototype.updateEffectGeometry;
Sprite_Animation.prototype.updateEffectGeometry = function() {
	NYA.EFFECT.Sprite_Animation_updateEffectGeometry.apply(this, arguments);
	const scale = this.extData().scale;
	const rotation = this.extData().rotation;
	if(this._handle) {
		if(scale) {
			const scale2 = this._animation.scale / 100 * scale;
			this._handle.setScale(scale2, scale2, scale2);
		}
		if(rotation) {
			this._handle.setRotation(0, 0, -rotation);
		}
	}
};

Sprite_Animation.prototype.targetSpritePosition = function(sprite) {
	const ext = this.extData();
	if(ext.physicsPosition) {
		const c = sprite._character;
		const point = new Point(c.physicsCenterX(), c.physicsCenterY());
		if (ext.align === "bottom" || this._animation.alignBottom) {
			point.y = (point.y + (c.hitOffsetT() + c.hitOffsetB()) / 2) | 0;
		} else if(ext.align === "top") {
			point.y = (point.y - (c.hitOffsetT() + c.hitOffsetB()) / 2) | 0;
		}
		point.x += (ext.x || 0);
		point.y += (ext.y || 0);
		point.x -= $gameMap.displayX() * $gameMap.tileWidth();
		point.y -= $gameMap.displayY() * $gameMap.tileHeight();
		return point;
	} else {
		const point = new Point(0, -sprite._contentSprite.height / 2);
		if (this._animation.alignBottom) {
			point.y = 0;
		}
		if(!sprite.parent) {
			return point;
		}
		sprite.updateTransform();
		return sprite.worldTransform.apply(point);
	}
};

NYA.EFFECT.Sprite_Animation_targetPosition = Sprite_Animation.prototype.targetPosition;
Sprite_Animation.prototype.targetPosition = function() {
	const ext = this.extData();
	if(ext.staticPosition) {
		const pos = new Point();
		pos.x = (-$gameMap.displayX() * $gameMap.tileWidth() + ext.x) * $gameMap.scale();
		pos.y = (-$gameMap.displayY() * $gameMap.tileHeight() + ext.y) * $gameMap.scale();
		return pos;
	} else {
		return NYA.EFFECT.Sprite_Animation_targetPosition.apply(this, arguments);
	}
};

NYA.EFFECT.Sprite_Animation_onBeforeRender = Sprite_Animation.prototype.onBeforeRender;
Sprite_Animation.prototype.onBeforeRender = function(renderer) {
	NYA.EFFECT.Sprite_Animation_onBeforeRender.apply(this, arguments);
	const resolution = renderer.resolution;
	const tempRect = this._tempRect;
	tempRect.width = renderer.width;
	tempRect.height = renderer.height;
	const destinationFrame = tempRect;
	const sourceFrame = destinationFrame;
	renderer.projection.update(destinationFrame, sourceFrame, resolution, false);
};

NYA.EFFECT.Scene_Map_terminate = Scene_Map.prototype.terminate;
Scene_Map.prototype.terminate = function() {
	NYA.EFFECT.Scene_Map_terminate.apply(this, arguments);
	this.preserveAnimation();
};

Scene_Map.prototype.preserveAnimation = function() {
	EffectManager.preverveAnimation = this._spriteset._effectsContainer.children.filter((sp) => {
		if(sp instanceof Sprite_Animation) {
			if(sp._handle) {
				sp._handle.setPaused(true);
				return true;
			}
			sp.destroy();
		}
		return false;
	});
	EffectManager.preverveAnimation.forEach((sp) => {
		this._spriteset._effectsContainer.removeChild(sp);
	});
	this._spriteset._animationSprites = [];
};

Spriteset_Base.prototype.resumeAnimation = function() {
	if(EffectManager.preverveAnimation) {
		EffectManager.preverveAnimation.forEach((sp) => {
			if(sp instanceof Sprite_Animation && sp._handle !== null) {
				if(sp.constructor === Sprite_Animation && sp.targetObjects) {
					sp.targetObjects = sp.targetObjects.map((ch) => {
						if(ch.constructor === Game_Event) {
							return $gameMap.event(ch.eventId());
						} else {
							return ch;
						}
					});
					sp._targets = this.makeTargetSprites(sp.targetObjects);
					sp._handle.setPaused(false);
					this._effectsContainer.addChild(sp);
					this._animationSprites.push(sp);
				} else if(sp.constructor === Sprite_AnimationEx) {
					sp._handle.setPaused(false);
					this._effectsContainer.addChild(sp);
					this._animationSprites.push(sp);
				} else {
					sp.destroy();
				}
			} 
		});
	}
	EffectManager.preverveAnimation = undefined;
};

EffectManager.destroyPreverveAnimation = function() {
	if(EffectManager.preverveAnimation) {
		if (Graphics.effekseer) {
			Graphics.effekseer.stopAll();
		}
		EffectManager.preverveAnimation.forEach((sp) => {
			sp.destroy();
		});
		EffectManager.preverveAnimation = undefined;
	}
};

NYA.EFFECT.Game_Map_setup = Game_Map.prototype.setup;
Game_Map.prototype.setup = function() {
	NYA.EFFECT.Game_Map_setup.apply(this, arguments);
	this._zxcOnce = false;
	EffectManager.destroyPreverveAnimation();
	this.setupAmbientLight();
	this._refreshDayNightTerrain = false;
};

NYA.EFFECT.Spriteset_Base_initialize = Spriteset_Base.prototype.initialize;
Spriteset_Base.prototype.initialize = function() {
	NYA.EFFECT.Spriteset_Base_initialize.apply(this, arguments);
	this.resumeAnimation();
};

SceneManager.onBeforeSceneStart = function() {
    if (this._previousScene) {
        this._previousScene.destroy();
        this._previousScene = null;
    }
};

Game_CharacterBase.prototype.startTransport = function(mapId, x, y, se = true) {
	this.lockInvincible();
	this.resumeFriction();
	this._transportRunning = true;
	this._transportFrame = 0;
	this._transportMapId = mapId;
	this._transportX = x;
	this._transportY = y;
	if(se) {
		AudioManager.playNormalSe("Magic1");
	}
};

Game_CharacterBase.prototype.transportEndFrame = function() {
	return 150;
};

Game_CharacterBase.prototype.transportWaitEndFrame = function() {
	return 30;
};

Game_CharacterBase.prototype.transportToneEndFrame = function() {
	return 90;
};

Game_CharacterBase.prototype.transportFlyEndFrame = function() {
	return 120;
};

Game_CharacterBase.prototype.endTransport = function() {
	this.completeTransport();
};

Game_Player.prototype.endTransport = function() {
	if(this._transportMapId) {
		this.reserveTransfer(this._transportMapId, this._transportX, this._transportY, 0, 0);
		this._transportEnding = true;
		this._transportFrame = this.transportEndFrame();
	}
};

Game_CharacterBase.prototype.completeTransport = function() {
	this._transportRunning = false;
	this._transportEnding = false;
	this.unlockInvincible();
};

Game_CharacterBase.prototype.updateTransport = function() {
	if(this._transportRunning) {
		if(this._transportEnding) {
			this._transportFrame--;
		} else {
			this._transportFrame++;
		}
	}
};

NYA.EFFECT.Game_CharacterBase_updateAnimation = Game_CharacterBase.prototype.updateAnimation;
Game_CharacterBase.prototype.updateAnimation = function() {
	NYA.EFFECT.Game_CharacterBase_updateAnimation.apply(this, arguments);
	this.updateTransport();
};

NYA.EFFECT.Sprite_Character_initMembers = Sprite_Character.prototype.initMembers;
Sprite_Character.prototype.initMembers = function() {
	NYA.EFFECT.Sprite_Character_initMembers.apply(this, arguments);
	this._internalOffsetX = 0;
	this._internalOffsetY = 0;
	this._fastMoveEffectHistoryPath = [];
	this._fastMoveSprite = new Sprite();
	this._fastMoveSprite.visible = false;
	this._fastMoveMode = false;
	this._lowerSprite.addChild(this._fastMoveSprite);
	this._fastMoveFadeInterval = 0;
	this._strokeFilter = null;
	this._strokeColorUpdateDirection = 0;
	
	this._shieldColorUpdateDirection = false;
	this._shieldColorUpdateFrame = 0;
	this.zy = 0;
	this.zk = 0;
	this.zx = 0;
	this.createShieldSprite();
};

NYA.EFFECT.Sprite_Character_setCharacter = Sprite_Character.prototype.setCharacter;
Sprite_Character.prototype.setCharacter = function(character) {
	NYA.EFFECT.Sprite_Character_setCharacter.apply(this, arguments);
	this.updateShieldEffect(true);
};

Sprite_Character.prototype.fastMoveEffectSpriteCount = function() {
	return 3;
};

Sprite_Character.prototype.fastMoveEffectSpriteInterval = function() {
	return 5;
};

NYA.EFFECT.Sprite_Character_updateOther = Sprite_Character.prototype.updateOther;
Sprite_Character.prototype.updateOther = function() {
	this.opacity = this._character.opacity();
	this.updateTransportEffect();
	this.updateFastMoveEffect();
	this.updateStrokeEffect();
	this.updateShieldEffect();
	this.updateScaleEffect();
};

Sprite_Character.prototype.updateScaleEffect = function() {
	this.scale.x = this._character.scaleX();
	this.scale.y = this._character.scaleY();
};

Sprite_Character.prototype.updateTransportEffect = function() {
	const ch = this._character;
	if(ch._transportRunning) {
		const frame = ch._transportFrame;
		if(ch._transportEnding) {
			if(frame < ch.transportFlyEndFrame()) {
				const max = ch.transportFlyEndFrame() - ch.transportToneEndFrame();
				const a = Math.min(1, Math.max(0, (frame - ch.transportToneEndFrame()) / max));
				this._internalOffsetY = Math.trunc(-a * Graphics.height);
			} else {
				this._internalOffsetY = -Graphics.height;
			}
			this.setBlendColor([255,255,255,255]);
			if(frame < ch.transportToneEndFrame()) {
				ch.completeTransport();
				this.setBlendColor([0,0,0,0]);
				this._internalOffsetY = 0;
			}
		} else {
			if(frame > ch.transportWaitEndFrame()) {
				const max = ch.transportToneEndFrame() - ch.transportWaitEndFrame();
				const a = Math.min(255, Math.max(0, (frame - ch.transportWaitEndFrame()) / max * 255));
				this.setBlendColor([255,255,255,a]);
			} else {
				this.setBlendColor([0,0,0,0]);
			}
			if(frame > ch.transportToneEndFrame()) {
				const max = ch.transportFlyEndFrame() - ch.transportToneEndFrame();
				const a = Math.min(1, Math.max(0, (frame - ch.transportToneEndFrame()) / max));
				this._internalOffsetY = Math.trunc(-a * Graphics.height);
			} else {
				this._internalOffsetY = 0;
			}
			if(frame >= ch.transportEndFrame()) {
				ch.endTransport();
			}
		}
	}
};

Sprite_Character.prototype.updateShieldEffect = function(init = false) {
	if(this._character.isShieldEffect()) {
		if(init) {
			this._defenceShieldSprite.visible = true;
			this._defenceShieldSprite.alpha = 1;
		} else if(this._defenceShieldSprite.alpha < 1) {
			this._defenceShieldSprite.visible = true;
			this._defenceShieldSprite.alpha += this.shieldFadeSpeed();
		}
		this._defenceShieldSprite.setBlendColor([0,0,0,0]);
		this.adjustShield();
		this._shieldColorUpdateFrame = 0;
	} else {
		if(init) {
			this._defenceShieldSprite.visible = false;
			this._defenceShieldSprite.alpha = 0;
		} else if(this._defenceShieldSprite.alpha > 0) {
			if(this.updateShieldColor()) {
				this._defenceShieldSprite.alpha -= this.shieldFadeSpeed();
				if(this._defenceShieldSprite.alpha <= 0) {
					this._defenceShieldSprite.visible = false;
				}
			}
			this.adjustShield();
		}
	}
};

Sprite_Character.prototype.adjustShield = function() {
	const physicsHeight = this._character.hitOffsetB() + this._character.hitOffsetT();
	const baseSize = 88;
	const baseScaleWidth = 192;
	const sign = Utils.boolSign(!this._character._mirrorLR);
	this._defenceShieldSprite.scale.x = sign;
	const actuallyHeight = this._defenceShieldSprite.bitmap.height;
	
	const fixX = this._character.patternWidth() / 2 - this._character.phAnchorX();
	const fixY = this._character.patternHeight() - this._character.phAnchorY();
	this._defenceShieldSprite.x = -4 + (sign === -1 ? fixX : -fixX);
	this._defenceShieldSprite.y = (actuallyHeight - physicsHeight) / 2 - 8 - fixY;
};

Sprite_Character.prototype.updateShieldColor = function() {
	if(this._shieldColorUpdateFrame > this.shieldColorEffectTime()) {
		return true;
	}
	const tick = this._shieldColorUpdateFrame % this.shieldColorCycle();
	if(tick === 0) {
		this._shieldColorUpdateDirection = !this._shieldColorUpdateDirection;
	}
	this._shieldColorUpdateFrame++;
	if(this._shieldColorUpdateDirection) {
		this._defenceShieldSprite.setBlendColor([0, 0, 0, this.maxShieldColorAlpha() * tick / this.shieldColorCycle()]);
	} else {
		this._defenceShieldSprite.setBlendColor([0, 0, 0, this.maxShieldColorAlpha() * (1 - tick / this.shieldColorCycle())]);
	}
	return false;
};

Sprite_Character.prototype.shieldColorCycle = function() {
	return 3;
};

Sprite_Character.prototype.shieldColorEffectTime = function() {
	return 18;
};

Sprite_Character.prototype.maxShieldColorAlpha = function() {
	return 128;
};

Sprite_Character.prototype.shieldFadeSpeed = function() {
	return 0.025;
};

Sprite_Character.prototype.createShieldSprite = function() {
	this._defenceShieldSprite = new Sprite(ImageManager.loadPicture('defence_shield'));
	this.addChild(this._defenceShieldSprite);
	this._defenceShieldSprite.visible = false;
	this._defenceShieldSprite.alpha = 0;
	this._defenceShieldSprite.anchor.x = 0.5;
	this._defenceShieldSprite.anchor.y = 1;
};

Sprite_Character.prototype.updateRotation = function() {
	this.rotation = this._character.rotation();
};

NYA.EFFECT.Sprite_Character_updatePosition = Sprite_Character.prototype.updatePosition;
Sprite_Character.prototype.updatePosition = function() {
	NYA.EFFECT.Sprite_Character_updatePosition.apply(this, arguments);
	this.updateRotation();
	if(this.rotation) {
		const base = 2 * (this._character.patternHeight() / 2) * Math.sin(this.rotation / 2);
		const rad = (Math.PI - this.rotation) / 2;
		const ox = -Math.round(Math.sin(rad) * base);
		const oy = -Math.round(Math.cos(rad) * base);
		this.x += (this._internalOffsetX + ox);
		this.y += (this._internalOffsetY + oy);
	} else {
		this.x += this._internalOffsetX;
		this.y += this._internalOffsetY;
	}
	this.zy = this._character.py;
	this.zx = this._character.px;
};

Game_CharacterBase.prototype.setFastMoveEffect = function(isOpen) {
	this._fastMoveEffect = isOpen;
};

Game_CharacterBase.prototype.isFastMoveEffect = function() {
	return this._fastMoveEffect;
};

Sprite_Character.prototype.updateFastMoveEffect = function() {
	if(this._character.isFastMoveEffect() || this._character._bodyAttacking === "down_dash" || this._character._bodyAttacking === "down_dash_through") {
		this._fastMoveFadeInterval += 0.5;
		this._fastMoveFadeInterval = this._fastMoveFadeInterval.clamp(0, this.fastMoveEffectSpriteInterval());
	} else if(this._fastMoveFadeInterval > 0) {
		this._fastMoveFadeInterval -= 0.4;
	}
	if(this._fastMoveFadeInterval > 0) {
		this._fastMoveSprite.visible = true;
		const len = this.fastMoveEffectSpriteCount();
		const interval = this._fastMoveFadeInterval;
		this.captureFastMoveEffect(len * this.fastMoveEffectSpriteInterval());
		for(let i = 1; i <= len; i++) {
			const targetFrame = Math.ceil(i * interval);
			if(this._fastMoveSprite.children.length < i) {
				const sprite = new Sprite();
				sprite.anchor.x = this._contentSprite.anchor.x;
				sprite.anchor.y = this._contentSprite.anchor.y;
				sprite.setBlendColor([244,244,244,95]);
				sprite.alpha = 0.5;
				this._fastMoveSprite.addChild(sprite);
			}
			const target = this._fastMoveSprite.children[i - 1];
			const info = this._fastMoveEffectHistoryPath[Math.min(this._fastMoveEffectHistoryPath.length - 1, targetFrame - 1)];
			const mirror = Utils.boolSign(!this._character._mirrorLR);
			target.bitmap = info.bitmap;
			const x = info.realX - ($gameMap.tileWidth() * $gameMap.displayX() + this.x);
			target.x = mirror === 1 ? x : -x;
			target.y = info.realY - ($gameMap.tileHeight() * $gameMap.displayY() + this.y);
			const frame = info.frame;
			target.setFrame(frame.x, frame.y, frame.width, frame.height);
			target.scale.x = mirror * info.scaleX * Graphics.scaleX;
			target.scale.y = Graphics.scaleY;
		}
	} else {
		this._fastMoveSprite.visible = false;
		if(this._fastMoveEffectHistoryPath.length !== 0) {
			this._fastMoveEffectHistoryPath = [];
		}
	}
};

Sprite_Character.prototype.captureFastMoveEffect = function(maxLen) {
	this._fastMoveEffectHistoryPath.reverse();
	this._fastMoveEffectHistoryPath.push({
		bitmap:this._contentSprite.bitmap
		,realX: this.x + $gameMap.tileWidth() * $gameMap.displayX()
		,realY: this.y + $gameMap.tileHeight() * $gameMap.displayY()
		,frame: Object.assign({}, this._contentSprite._frame)
		,scaleX: this.scale.x
	});
	this._fastMoveEffectHistoryPath.reverse();
	if(this._fastMoveEffectHistoryPath.length > maxLen) {
		this._fastMoveEffectHistoryPath.pop();
	}
};

AudioManager.playNormalBgm = function(name) {
	this.playBgm({name:name, volume:90, pan: 0, pitch: 100, pos: 0});
};

AudioManager.playNormalSe = function(name) {
	this.playSe({name:name, volume:90, pitch:100, pan:0});
};

AudioManager.cleanupSe = function() {
    this._seBuffers = this._seBuffers.filter(buffer => buffer.isPlaying());
};

AudioManager.playPlayerRoundSe = function(character, name, baseVol = 1) {
	const maxVol = 1;
	const minVol = 1080;
	const distance = Math.sqrt(Math.pow($gamePlayer.px - character.px, 2) + Math.pow($gamePlayer.py - character.py, 2));
	if(distance < maxVol) {
		AudioManager.playSe({name:name, volume:90*baseVol, pitch:100, pan:0});
	} else if(distance < minVol) {
		AudioManager.playSe({name:name, volume:90*baseVol*(minVol-distance)/(minVol-maxVol), pitch:100, pan:0});
	}
};

AudioManager.playPlayerRoundSeDefault = function(character, se) {
	const maxVol = 1;
	const minVol = 1580;
	const distance = Math.sqrt(Math.pow($gamePlayer.px - character.px, 2) + Math.pow($gamePlayer.py - character.py, 2));
	if(distance < maxVol) {
		AudioManager.playSe(se);
	} else if(distance < minVol) {
		AudioManager.playSe({name:se.name, volume:se.volume*(minVol-distance)/(minVol-maxVol), pitch:se.pitch, pan:se.pan});
	}
};

Game_CharacterBase.prototype.setStrokeEffect = function(enabled) {
	this._strokeEffect = enabled;
};

Game_CharacterBase.prototype.isStrokeEffect = function() {
	return this._strokeEffect;
};

Sprite_Character.prototype.updateStrokeEffect = function() {
	if(this._character.isStrokeEffect()) {
		if(this._strokeFilter === null) {
			this._strokeFilter = new PIXI.filters.OutlineFilter(2, 0xff0000);
			this._contentSprite.filters = this._contentSprite.filters || [];
			this._contentSprite.filters.push(this._strokeFilter);
			this._strokeColorUpdateDirection = 1;
		}
		this.updateStrokeFilter();
	} else {
		if(this._strokeFilter) {
			this._contentSprite.filters.remove(this._strokeFilter);
			this._strokeFilter = null;
		}
	}
};

Sprite_Character.prototype.updateStrokeFilter = function() {
	const color = this._strokeFilter.color;
	const counter = color & 0xff;
	const speed = 128;
	const colorNewBound = counter + speed * this._strokeColorUpdateDirection;
	const colorNew = colorNewBound.clamp(0, 255);
	if(this._strokeColorUpdateDirection > 0 && colorNew >= 255) {
		this._strokeColorUpdateDirection = -1;
	} else if(this._strokeColorUpdateDirection < 0 && colorNew <= 0) {
		this._strokeColorUpdateDirection = 1;
	}
	this._strokeFilter.color = 0xff0000 + (colorNew << 8) + colorNew;
};

NYA.EFFECT.Game_Temp_initialize = Game_Temp.prototype.initialize;
Game_Temp.prototype.initialize = function() {
    NYA.EFFECT.Game_Temp_initialize.apply(this, arguments);
	this._zxcArtwork = {};
	this._animation = new AnimationController();
	this._animationRemoveQueue = [];
	this._tempTransportInfo = {};
};

Game_Temp.prototype.requestZXCArtwork = function(artwork, mirror) {
	this._zxcArtwork.name = artwork;
	this._zxcArtwork.mirror = mirror;
	this._zxcArtwork.x = 0;
	this._zxcArtwork.y = 0;
	this._zxcArtwork.width = 0;
	this._zxcArtwork.height = 0;
	this._zxcArtwork.init = false;
};

Game_Temp.prototype.clearZXCArtwork = function() {
	this._zxcArtwork = {};
};

Game_Temp.prototype.zxcArtwork = function() {
	return this._zxcArtwork;
};

Game_Temp.prototype.animationController = function() {
	return this._animation;
};

Game_Temp.prototype.updateZXCArtwork = function() {
	this._animation.update();
};

Game_Temp.prototype.startZXCArtwork = function() {
	const controller = this._animation;
	const zxc = this._zxcArtwork;
	const y = Graphics.height * 0.6;
	const x = zxc.mirror ? Graphics.width * 0.75 : Graphics.width / 4;
	
	zxc.x = zxc.mirror ? Graphics.width + zxc.width / 2 : -zxc.width / 2;
	zxc.y = -zxc.height / 2;
	controller.add(zxc, {data:[{
		duration:50, property:"x", to:x, easingType:"easeOutQuart"
	}], complete:this.onZXCArtworkEasingIn.bind(this)});
	controller.add(zxc, {data:[{
		duration:50, property:"y", to:y, easingType:"easeOutQuart"
	}]});
};

Game_Temp.prototype.onZXCArtworkEasingIn = function() {
	const controller = this._animation;
	const zxc = this._zxcArtwork;
	const x = zxc.mirror ? -zxc.width : Graphics.width + zxc.width;
	controller.add(zxc, {data:[{
		duration:30, easingType:"easeInQuart", property:"x", to:x
	}], complete:this.clearZXCArtwork.bind(this)});
};

Game_Temp.prototype.setTransport = function(mapId, x, y, regionId) {
	this._tempTransportInfo.mapId = mapId;
	this._tempTransportInfo.x = x;
	this._tempTransportInfo.y = y;
	this._tempTransportInfo.regionId = regionId;
};

Game_Temp.prototype.performTransport = function() {
	const mapId = this._tempTransportInfo.mapId;
	const x = this._tempTransportInfo.x;
	const y = this._tempTransportInfo.y;
	$gamePlayer.startTransport(mapId, x, y);
	if(!$gameLily.isRemove()) {
		$gameLily.startTransport(mapId, x, y);
	}
};

NYA.EFFECT.Game_Map_initialize = Game_Map.prototype.initialize;
Game_Map.prototype.initialize = function() {
	NYA.EFFECT.Game_Map_initialize.apply(this, arguments);
	this._zxcOnce = false;
	this._lowerAmbientLight = 0xffffff;
	this._upperAmbientLight = 0xffffff;
	this._nightMode = false;
	this._refreshDayNightTerrain = false;
};

Game_Map.prototype.playerZXCOnce = function() {
	return this._zxcOnce;
};

Game_Map.prototype.setPlayerZXCOnce = function() {
	this._zxcOnce = true;
};

Sprite_Animation.prototype.processSoundTimings = function() {
	let se = [];
    for (const timing of this._animation.soundTimings) {
        if (timing.frame === this._frameIndex) {
			se.push(timing.se);
        }
    }
	if(se.length > 0) {
		AudioManager.playPlayerRoundSeDefault(this._targets[0]._character, se.randomElement());
	}
};

AudioManager.RL_PLAYER_FOOTSTEP = "footstep";
AudioManager.RL_ORANGE_CAT_EYES = "orange_cat_eyes";
AudioManager.RL_PARALYZE1 = "Paralyze1";
AudioManager.RL_DATA = {
	"1": {interval:20, volume:50, sounds:["fs_grass1","fs_grass2","fs_grass3","fs_grass4","fs_grass5","fs_grass6"], type:"footstep"}
	, "2": {interval:20, volume:50, sounds:["fs_stone1","fs_stone2","fs_stone3","fs_stone4","fs_stone5","fs_stone6"], type:"footstep"}
	, "3": {interval:20, volume:50, sounds:["fs_broad1","fs_broad2","fs_broad3","fs_broad4","fs_broad5","fs_broad6","fs_broad7"], type:"footstep"}
	, "4": {interval:20, volume:50, sounds:["fs_lower_grass1","fs_lower_grass2","fs_lower_grass3","fs_lower_grass4","fs_lower_grass5"], type:"footstep"}
	, "5": {interval:20, volume:50, sounds:["fs_school1","fs_school2","fs_school3","fs_school4","fs_school5","fs_school6","fs_school7"], type:"footstep"}
	, "6": {interval:20, volume:50, sounds:["fs_cavestone1","fs_cavestone2","fs_cavestone3","fs_cavestone4","fs_cavestone5"], type:"footstep"}
	, "7": {interval:70, volume:90, sounds:["orange_cat_eyes"], type:"orange_cat_eyes"}
	, "8": {interval:20, volume:90, sounds:["Paralyze1"], type:"Paralyze1"}
	, "9": {interval:20, volume:50, sounds:["fs_church1","fs_church2","fs_church3","fs_church4","fs_church5","fs_church6","fs_church7","fs_church8"], type:"footstep"}
};
AudioManager._randLoopBuffers = [];
AudioManager.playRandLoopSe = function(id) {
	const data = this.RL_DATA[id];
	for(const info of this._randLoopBuffers) {
		const infoType = this.RL_DATA[info.id].type;
		if(infoType === data.type) {
			info.id = id;
			return;
		}
	}
	this._randLoopBuffers.push({id:id, counter:data.interval});
};

AudioManager.stopRandLoopSe = function(type) {
	this._randLoopBuffers = this._randLoopBuffers.filter((info) => {
		const id = info.id;
		const data = this.RL_DATA[id];
		return data.type !== type;
	});
};

AudioManager.stopAllRandLoopSe = function() {
	this._randLoopBuffers = [];
};

AudioManager.updatePlayRandLoopSe = function() {
	for(const info of this._randLoopBuffers) {
		info.counter++;
		const id = info.id;
		const data = this.RL_DATA[id];
		const interval = data.interval;
		if(info.counter >= interval) {
			const seName = data.sounds.randomElement();
			AudioManager.playSe({name:seName, volume:data.volume, pitch:100, pan:0});
			info.counter = 0;
		}
	}
};

Game_CharacterBase.prototype.clearTemporaryScreenZ = function() {
	this._temporaryScreenZ = 0;
};

Game_CharacterBase.prototype.setTemporaryScreenZ = function(val) {
	this._temporaryScreenZ = val;
};

NYA.EFFECT.Game_CharacterBase_screenZ = Game_CharacterBase.prototype.screenZ;
Game_CharacterBase.prototype.screenZ = function() {
	if(this._temporaryScreenZ) {
		return this._temporaryScreenZ;
	}
	return NYA.EFFECT.Game_CharacterBase_screenZ.apply(this, arguments);
};

Game_CharacterBase.prototype.scale = function() {
	return this._scale;
};

Game_CharacterBase.prototype.scaleX = function() {
	let scale = 0;
	if(this._mirrorLR) {
		scale = -1;
	} else {
		scale = 1;
	}
	let transportScale = 1;
	if(this._transportRunning) {
		const frame = this._transportFrame;
		if(this._transportEnding) {
			if(frame < this.transportToneEndFrame()) {
				transportScale = 1;
			} else {
				transportScale = 0.15;
			}
		} else {
			if(frame > this.transportToneEndFrame()) {
				transportScale = 0.2;
			} else {
				transportScale = 1;
			}
		}
	}
	const blinkScale = 1 - (this._blinkFrame | 0) / this.blinkEffectSpeed();
	return scale * transportScale * blinkScale * this.scale();
};

Game_CharacterBase.prototype.scaleY = function() {
	let squashScale = 0;
	if(this.isSquash()) {
		squashScale = 0.5;
	} else {
		squashScale = 1;
	}
	const blinkScale = 1 + (this._blinkFrame | 0) / this.blinkEffectSpeed();
	return squashScale * blinkScale * this.scale();
};

Game_CharacterBase.prototype.setScale = function(val) {
	this._scale = val;
};

Game_Map.prototype.getLightShaderUniform = function(upper = 0, add = false) {
	const para = this.getEventLightShaderUniform(upper, add);
	if(add) {
		return {para:para};
	} else {
		const min = upper === 0 ? this.lowerAmbientLight() : this.upperAmbientLight();
		const minr = (min >> 16) / 255;
		const ming = (min >> 8 & 0xff) / 255;
		const minb = (min & 0xff) / 255;
		return {minr:minr, minb:minb, ming:ming, para:para};
	}
};

Game_Map.prototype.lightPerElement = function() {
	return 6;
};

Game_Map.prototype.maxLight = function() {
	return 8;
};

Game_Map.prototype.getEventLightShaderUniform = function(upper = 0, add = false, arr) {
	const lightPerElement = this.lightPerElement();
	const maxLight = this.maxLight();
	arr = arr || new Float64Array(maxLight * lightPerElement);
	const offsetx = -this.displayX() * this.tileWidth();
	const offsety = -this.displayY() * this.tileHeight();
	let pos = 0;
	const maxPos = arr.length;
	for(const event of this.allCharacters()) {
		if(pos >= maxPos) {
			break;
		}
		const lighting = event.lighting(upper, add);
		if(!lighting) { continue; }
		if(this.isDay() && lighting.night) { continue; }
		const cx = event.physicsCenterX() + offsetx;
		const cy = event.physicsCenterY() + offsety;
		const radius = lighting.radius;
		if(physicsASM.isRectOutBound(cx, cy, radius, radius, radius, radius, 0, 0, 0, 0, Graphics.width, Graphics.height)) {
			continue;
		}
		const r = lighting.r;
		const g = lighting.g;
		const b = lighting.b;
		const max = lighting.max;
		arr[pos] = cx;
		arr[pos+1] = cy;
		arr[pos+2] = r;
		arr[pos+3] = g;
		arr[pos+4] = b;
		arr[pos+5] = radius;
		pos += lightPerElement;
	}
	while(pos < arr.length) {
		arr[pos] = 0.0;
		pos++;
	}
	return arr;
};

Game_Map.prototype.updateLightShaderUniform = function(upper = 0, add = false, uniforms) {
	const min = upper === 0 ? this.lowerAmbientLight() : this.upperAmbientLight();
	if(add && min === 0xffffff) {
		return false;
	}
	if(!add && min === 0xffffff && uniforms.minr === 1 && uniforms.ming === 1 && uniforms.minb === 1) {
		return false;
	}
	if(!add) {
		uniforms.minr = (min >> 16) / 255;
		uniforms.ming = (min >> 8 & 0xff) / 255;
		uniforms.minb = (min & 0xff) / 255;
	}
	uniforms.para = this.getEventLightShaderUniform(upper, add, uniforms.para);
	return true;
};

Game_Map.prototype.lowerAmbientLight = function() {
	return this._lowerAmbientLight;
};

Game_Map.prototype.upperAmbientLight = function() {
	return this._upperAmbientLight;
};

Game_Map.prototype.setupAmbientLight = function() {
	this._lowerAmbientLight = 0xffffff;
	this._upperAmbientLight = 0xffffff;
	$gamePlayer.setLowerLightingAdd(null);
	$gamePlayer.setUpperLightingAdd(null);
	$gamePlayer.setLowerLightingMultiply(null);
	$gamePlayer.setUpperLightingMultiply(null);
	if($dataMap.richMeta.ambient_light) {
		$dataMap.richMeta.ambient_light.forEach((amb) => {
			if(amb.night && this.isDay() || amb.day && this.isNight()) {
				return;
			}
			if(amb.type === "lower") {
				if(amb.r || amb.g || amb.b) {
					this._lowerAmbientLight = Math.round(Utils.tryParseNumber(amb.r) * 255) << 16 | Math.round(Utils.tryParseNumber(amb.g) * 255) << 8 | Math.round(Utils.tryParseNumber(amb.b) * 255);
				} else {
					const c = Math.round(amb.value * 255);
					this._lowerAmbientLight = c << 16 | c << 8 | c;
				}
			} else if(amb.type === "upper") {
				if(amb.r || amb.g || amb.b) {
					this._upperAmbientLight = Math.round(Utils.tryParseNumber(amb.r) * 255) << 16 | Math.round(Utils.tryParseNumber(amb.g) * 255) << 8 | Math.round(Utils.tryParseNumber(amb.b) * 255);
				} else {
					const c = Math.round(amb.value * 255);
					this._upperAmbientLight = c << 16 | c << 8 | c;
				}
			}
		});
	}
	if($dataMap.richMeta.player_light) {
		$dataMap.richMeta.player_light.forEach((plt) => {
			if(plt.night && this.isDay() || plt.day && this.isNight()) {
				return;
			}
			const r = Utils.tryParseNumber(plt.r);
			const g = Utils.tryParseNumber(plt.g);
			const b = Utils.tryParseNumber(plt.b);
			const radius = Utils.tryParseInt(plt.radius);
			const night = Utils.tryParseInt(plt.night);
			if(plt.type === "lower" && (plt.add || !plt.multiply)) {
				$gamePlayer.setLowerLightingAdd({r:r,g:g,b:b,radius:radius,night:night});
			} else if(plt.type === "upper" && (plt.add || !plt.multiply)) {
				$gamePlayer.setUpperLightingAdd({r:r,g:g,b:b,radius:radius,night:night});
			} else if(plt.type === "lower" && (!plt.add || plt.multiply)) {
				$gamePlayer.setLowerLightingMultiply({r:r,g:g,b:b,radius:radius,night:night});
			} else if(plt.type === "upper" && (!plt.add || plt.multiply)) {
				$gamePlayer.setUpperLightingMultiply({r:r,g:g,b:b,radius:radius,night:night});
			}
		});
	}
	this.checkShouldUseFastLightMode();			// 如果只有一个环境光upper light且无其他光源，该环境光转换为$gameScreen.tone()
};

Game_Map.prototype.checkShouldUseFastLightMode = function() {
	const result = this.allCharacters().every((event) => {
		return !event.lightingAdd(0) && !event.lightingMultiply(0) && !event.lightingAdd(1) && !event.lightingMultiply(1);
	});
	if(result && this._upperAmbientLight !== 0xffffff) {
		const c = this._upperAmbientLight;
		$gameScreen._tone = [-(255 - (c >> 16)), -(255 - ((c >> 8) & 0xff)), -(255 - (c & 0xff)), 0];
		this._upperAmbientLight = 0xffffff;
	} else {
		$gameScreen._tone = [0, 0, 0, 0]
	}
};

Game_CharacterBase.prototype.lighting = function(upper = 0, add = false) {
	if(add) {
		return this.lightingAdd(upper);
	} else {
		return this.lightingMultiply(upper);
	}
};

Game_CharacterBase.prototype.lightingMultiply = function(upper = 0) {
	return upper === 0 ? this._lowerLightingMultiply : this._upperLightingMultiply;
};

Game_CharacterBase.prototype.setLowerLightingMultiply = function(lighting) {
	this._lowerLightingMultiply = lighting;
};

Game_CharacterBase.prototype.setUpperLightingMultiply = function(lighting) {
	this._upperLightingMultiply = lighting;
};

Game_CharacterBase.prototype.lightingAdd = function(upper = 0) {
	return upper === 0 ? this._lowerLightingAdd : this._upperLightingAdd;
};

Game_CharacterBase.prototype.setLowerLightingAdd = function(lighting) {
	this._lowerLightingAdd = lighting;
};

Game_CharacterBase.prototype.setUpperLightingAdd = function(lighting) {
	this._upperLightingAdd = lighting;
};

Game_CharacterBase.prototype.clearLight = function() {
	this.setLowerLightingMultiply(null);
	this.setUpperLightingMultiply(null);
	this.setUpperLightingAdd(null);
	this.setLowerLightingAdd(null);
};

Game_Map.prototype.lightShaderMultiply = function(uniforms) {
	const lightPerElement = this.lightPerElement();
	
	const vsrc = new String("attribute vec2 aVertexPosition;"
	+ "attribute vec2 aTextureCoord;"
	+ "uniform mat3 projectionMatrix;"
	+ "varying vec2 vTextureCoord;"
	+ "void main(void){"
	+ "gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);"
	+ "vTextureCoord = aTextureCoord;}");
	const len = uniforms.para.length;
    const fsrc = new String("varying vec2 vTextureCoord;"
	+ "uniform sampler2D uSampler;"
	+ "uniform float minr;"
	+ "uniform float ming;"
	+ "uniform float minb;"
	+ "uniform float para[%1];".format(len)
	+ "void main(void){"
	+ "vec4 a2 = vec4(0.0, 0.0, 0.0, 1.0); float distanceRate = 0.0; float rad;"
	+ "vec4 f = vec4(minr, ming, minb, 1.0); vec2 wh = vec2(" + Graphics.width + ", " + Graphics.height + "); vec2 p = wh * vTextureCoord;" 
	+ "for(int i = 0; i < %1; i += %2) {".format(len, lightPerElement)
	+ "if(para[i+5] == 0.0) {break;} vec2 center = vec2(para[i], para[i+1]); vec4 a = vec4(para[i+2],para[i+3],para[i+4],1.0); rad = max(1.0, para[i+5]); float distance = distance(p, center);"
	+ "distanceRate = max(0.0, 1.0 - distance / rad); a2 = max(a2, distanceRate * (a - f)); }"
	+ "gl_FragColor = f + a2;}");
    const shader = new PIXI.Filter(vsrc.toString(), fsrc.toString(), uniforms);
	return shader;
};

Game_Map.prototype.lightShaderAdd = function(uniforms) {
	const lightPerElement = this.lightPerElement();
	
	const vsrc = new String("attribute vec2 aVertexPosition;"
	+ "attribute vec2 aTextureCoord;"
	+ "uniform mat3 projectionMatrix;"
	+ "varying vec2 vTextureCoord;"
	+ "void main(void){"
	+ "gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);"
	+ "vTextureCoord = aTextureCoord;}");
	const len = uniforms.para.length;
    const fsrc = new String("varying vec2 vTextureCoord;"
	+ "uniform sampler2D uSampler;"
	+ "uniform float para[%1];".format(len)
	+ "void main(void){"
	+ "vec4 a2 = vec4(0.0);float distanceRate = 0.0; float rad;"
	+ "vec2 wh = vec2(" + Graphics.width + ", " + Graphics.height + "); vec2 p = wh * vTextureCoord;" 
	+ "for(int i = 0; i < %1; i += %2) {".format(len, lightPerElement)
	+ "if(para[i+5] == 0.0) {break;} vec2 center = vec2(para[i], para[i+1]); vec4 a = vec4(para[i+2],para[i+3],para[i+4],0.0); rad = max(1.0, para[i+5]); float distance = distance(p, center);"
	+ "distanceRate = max(0.0, 1.0 - distance / rad); a2 = max(a2, distanceRate * a);}"
	+ "gl_FragColor = a2;}");
    const shader = new PIXI.Filter(vsrc.toString(), fsrc.toString(), uniforms);
	return shader;
};

NYA.EFFECT.Tilemap_initialize = Tilemap.prototype.initialize;
Tilemap.prototype.initialize = function() {
	NYA.EFFECT.Tilemap_initialize.apply(this, arguments);
	this.createLightShader();
};

Tilemap.prototype.createLightShader = function() {
	this._lowerLightMultiplyShader = $gameMap.lightShaderMultiply($gameMap.getLightShaderUniform(0, false));
	this._upperLightMultiplyShader = $gameMap.lightShaderMultiply($gameMap.getLightShaderUniform(1, false));
	this._lowerLightMultiplyLayer = new LightingZLayer(this._lowerLightMultiplyShader);
	this._lowerLightMultiplyLayer.z = 3.99;
	this._upperLightMultiplyLayer = new LightingZLayer(this._upperLightMultiplyShader);
	this._upperLightMultiplyLayer.z = 99;
	this._lowerLightMultiplyShader.blendMode = PIXI.BLEND_MODES.MULTIPLY;
	this._upperLightMultiplyShader.blendMode = PIXI.BLEND_MODES.MULTIPLY;
	
	this._lowerLightAddShader = $gameMap.lightShaderAdd($gameMap.getLightShaderUniform(0, true));
	this._upperLightAddShader = $gameMap.lightShaderAdd($gameMap.getLightShaderUniform(1, true));
	this._lowerLightAddShader.blendMode = PIXI.BLEND_MODES.ADD;
	this._upperLightAddShader.blendMode = PIXI.BLEND_MODES.ADD;
	this._lowerLightAddLayer = new LightingZLayer(this._lowerLightAddShader);
	this._lowerLightAddLayer.z = 3.999;
	this._upperLightAddLayer = new LightingZLayer(this._upperLightAddShader);
	this._upperLightAddLayer.z = 99.9;
	
	this.addChild(this._lowerLightMultiplyLayer);
	this.addChild(this._upperLightMultiplyLayer);
	this.addChild(this._lowerLightAddLayer);
	this.addChild(this._upperLightAddLayer);
	this.updateLightShader();
};

NYA.EFFECT.Tilemap_update = Tilemap.prototype.update;
Tilemap.prototype.update = function() {
	NYA.EFFECT.Tilemap_update.apply(this, arguments);
	this.updateLightShader();
};

Tilemap.prototype.updateLightShader = function() {
	this._lowerLightMultiplyLayer.visible = $gameMap.updateLightShaderUniform(0, false, this._lowerLightMultiplyShader.uniforms);
	this._upperLightMultiplyLayer.visible = $gameMap.updateLightShaderUniform(1, false, this._upperLightMultiplyShader.uniforms);
	this._lowerLightAddLayer.visible = $gameMap.updateLightShaderUniform(0, true, this._lowerLightAddShader.uniforms);
	this._upperLightAddLayer.visible = $gameMap.updateLightShaderUniform(1, true, this._upperLightAddShader.uniforms);
};

function LightingZLayer() {
	this.initialize(...arguments);
}

LightingZLayer.prototype = Object.create(Sprite.prototype);
LightingZLayer.prototype.constructor = LightingZLayer;

LightingZLayer.prototype.initialize = function(lightShader) {
	Sprite.prototype.initialize.call(this);
	this.z = 0;
	this.filters = this.filters || [];
	this.filters.push(lightShader);
	this.bitmap = new Bitmap(Graphics.width, Graphics.height);
};

LightingZLayer.prototype.updateTransform = function() {
};

LightingZLayer.prototype.resizeForMapScale = function() {
};

Sprite_Animation.prototype.updateTransform = function() {
};

function Sprite_AnimationEx() {
	this.initialize(...arguments);
}

Sprite_AnimationEx.prototype = Object.create(Sprite_Animation.prototype);
Sprite_AnimationEx.prototype.constructor = Sprite_AnimationEx;

Sprite_AnimationEx.prototype.initialize = function() {
	Sprite_Animation.prototype.initialize.apply(this, arguments);
	this._externalTargetX = 0;
	this._externalTargetY = 0;
	this._viewportSize = 8192;
	this.targetObjects = [];
};

Sprite_AnimationEx.prototype.targetPosition = function() {
	const pos = new Point();
	pos.x = this._externalTargetX;
	pos.y = this._externalTargetY;
	return pos;
};

Object.defineProperty(Sprite_AnimationEx.prototype, "externalTargetX", {
	get: function() {
		return this._externalTargetX;
	}
	,set: function(value) {
		this._externalTargetX = value;
	}
	,configurable: true
});

Object.defineProperty(Sprite_AnimationEx.prototype, "externalTargetY", {
	get: function() {
		return this._externalTargetY;
	}
	,set: function(value) {
		this._externalTargetY = value;
	}
	,configurable: true
});

Sprite_AnimationEx.prototype._render = function(renderer) {
    if (this._handle && this._handle.exists) {
        this.onBeforeRender(renderer);
        this.setProjectionMatrix(renderer);
        this.setCameraMatrix(renderer);
        this.setViewport(renderer);
        Graphics.effekseer.beginDraw();
        Graphics.effekseer.drawHandle(this._handle);
        Graphics.effekseer.endDraw();
        this.resetViewport(renderer);
        this.onAfterRender(renderer);
    }
};

Game_Temp.prototype.retrieveRemoveAnimation = function() {
    return this._animationRemoveQueue.shift();
};

NYA.EFFECT.Spriteset_Base_processAnimationRequests = Spriteset_Base.prototype.processAnimationRequests;
Spriteset_Base.prototype.processAnimationRequests = function() {
	NYA.EFFECT.Spriteset_Base_processAnimationRequests.apply(this, arguments);
    for (;;) {
        const request = $gameTemp.retrieveRemoveAnimation();
        if (request) {
			for(const sprite of this._animationSprites) {
				if(sprite._animation.id === request.animationId && request.targets.some((target) => { return sprite.targetObjects.includes(target); })) {
					this.removeAnimation(sprite);
				}
			}
        } else {
            break;
        }
    }
};

Game_Map.prototype.isDay = function() {
	return !this._nightMode;
};

Game_Map.prototype.isNight = function() {
	return this._nightMode;
};

Game_Map.prototype.setNightEnabled = function(enabled) {
	this._nightMode = enabled;
	$gameSwitches.setValue(NYA.GAME.NIGHT_SWITCH_ID, enabled);
};

Game_Map.prototype.autoplay = function() {
    if ($dataMap.autoplayBgm && !$gamePlayer.isDeath()) {
        if ($gamePlayer.isInVehicle()) {
            $gameSystem.saveWalkingBgm2();
        } else if(!this.isNightSilent()) {
			AudioManager.playBgm($dataMap.bgm);
        } else {
			AudioManager.fadeOutBgm(1);
		}
    }
    if ($dataMap.autoplayBgs) {
        AudioManager.playBgs($dataMap.bgs);
    }
};

Game_Map.prototype.isNightSilent = function() {
	const regionId = DataManager.regionId();
	return this.isNight() && regionId && $dataRegion[regionId].nightSilent;
};

Sprite_Balloon.prototype.updatePosition = function() {
	const character = this._target._character;
    this.x = -$gameMap.displayX() * $gameMap.tileWidth() + character.physicsCenterX();
    this.y = -$gameMap.displayY() * $gameMap.tileHeight() + character.py - character.hitOffsetT() - 24;
};

// 闪现效果 1起点闪现开始，2终点闪现结束
Game_CharacterBase.prototype.makeBlinkEffect = function(type, effectId) {
	if(type === 1) {
		this._blinkFrame = 0;
	} else if(type === 2) {
		this._blinkFrame = this.blinkEffectSpeed();
	}
	this._blinkEffectType = type;
	if(effectId) {
		this.requestAnimation(effectId, {physicsPosition:true});
	}
};

Game_CharacterBase.prototype.updateBlinkEffect = function() {
	if(this._blinkEffectType !== 0) {
		if(this._blinkEffectType === 1 && this._blinkFrame < this.blinkEffectSpeed()) {
			this._blinkFrame++;
		} else if(this._blinkEffectType === 2 && this._blinkFrame > 0) {
			this._blinkFrame--;
		} else {
			this._blinkEffectType = 0;
		}
	}
};

Game_CharacterBase.prototype.blinkEffectSpeed = function() {
	return 12;
};

NYA.EFFECT.Sprite_Picture_initialize = Sprite_Picture.prototype.initialize;
Sprite_Picture.prototype.initialize = function() {
	NYA.EFFECT.Sprite_Picture_initialize.apply(this, arguments);
	this._curtainFilter = null;
};

NYA.EFFECT.Sprite_Picture_update = Sprite_Picture.prototype.update;
Sprite_Picture.prototype.update = function() {
	NYA.EFFECT.Sprite_Picture_update.apply(this, arguments);
	if(this.visible) {
		this.updateFadeEffect();
	}
};

Sprite_Picture.prototype.updateFadeEffect = function() {
	const picture = this.picture();
	const curtain = picture.curtainEffect();
	if(curtain && curtain.width > 0) {
		const progress = curtain.progress;
		const width = curtain.width;
		this.ensureCurtainFilter();
		this._curtainFilter.uniforms.progress = progress;
		this._curtainFilter.uniforms.width = width / 2;
	} else {
		this.ensureCurtainFilterRemove();
	}
};

Sprite_Picture.prototype.ensureCurtainFilter = function() {
	if(!this._curtainFilter) {
		const fsrc = "attribute vec2 aVertexPosition; attribute vec2 aTextureCoord; uniform mat3 projectionMatrix; varying vec2 vTextureCoord; void main(void){ gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0); vTextureCoord = aTextureCoord;}";
		const vsrc = "varying vec2 vTextureCoord; uniform sampler2D uSampler; uniform float width; uniform float progress; void main(void){"
			+ "gl_FragColor = texture2D(uSampler, vTextureCoord) * (min(max(-1.0, (progress - vTextureCoord.x) / width), 1.0) * 0.5 + 0.5);}";
		this._curtainFilter = new PIXI.Filter(fsrc, vsrc, {width:0, progress:0});
		this.filters = this.filters || [];
		this.filters.push(this._curtainFilter);
	}
};

Utils.createColorReplaceFilter = function() {
	const fsrc = "attribute vec2 aVertexPosition; attribute vec2 aTextureCoord; uniform mat3 projectionMatrix; varying vec2 vTextureCoord; void main(void){ gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0); vTextureCoord = aTextureCoord;}";
	const vsrc = "varying vec2 vTextureCoord; uniform sampler2D uSampler; uniform float sr; uniform float sg; uniform float sb; uniform float dr; uniform float dg; uniform float db; void main(void){ vec4 color = texture2D(uSampler, vTextureCoord); vec3 color2 = vec3(sr, sg, sb); if(distance(color.xyz, color2) < 0.003) { gl_FragColor.xyz = vec3(dr, dg, db); } else { gl_FragColor = color; };}";
	return new PIXI.Filter(fsrc, vsrc, {sr:0.0, sg:0.0, sb:0.0, dr:0.0, dg:0.0, db:0.0});
};

Sprite_Picture.prototype.ensureCurtainFilterRemove = function() {
	if(this._curtainFilter) {
		this.filters.remove(this._curtainFilter);
		this._curtainFilter = null;
	}
};

NYA.EFFECT.Game_Picture_initialize = Game_Picture.prototype.initialize;
Game_Picture.prototype.initialize = function() {
	NYA.EFFECT.Game_Picture_initialize.apply(this, arguments);
	this.initCurtainEffect();
};

Game_Picture.prototype.initCurtainEffect = function() {
	this._curtainEffect = {width:0, progress:0, speed:0};
};

NYA.EFFECT.Game_Picture_update = Game_Picture.prototype.update;
Game_Picture.prototype.update = function() {
	NYA.EFFECT.Game_Picture_update.apply(this, arguments);
	this.updateCurtainEffect();
};

Game_Picture.prototype.updateCurtainEffect = function() {
	if(this._curtainEffect.width > 0) {
		const endPoint = this._curtainEffect.width / 2 + 1;
		if(this._curtainEffect.progress < endPoint) {
			this._curtainEffect.progress += this._curtainEffect.speed;
		} else {
			this._curtainEffect.width = 0;
		}
	}
};

Game_Picture.prototype.setCurtainEffect = function(width, speed) {
	this._curtainEffect.progress = -width / 2;
	this._curtainEffect.width = width;
	this._curtainEffect.speed = speed;
};


Game_Picture.prototype.curtainEffect = function() {
	return this._curtainEffect;
};












NYA.TILEMAP = {};

function setTextures (tile, tileSet) {
  const textures = []
  if (tile.animations.length) {
    tile.animations.forEach((frame) => textures.push(tileSet.textures[frame.tileId]))
  } else {
    textures.push(tileSet.textures[tile.gid - tileSet.firstGid])
  }
  return textures
}

class Tile extends PIXI.AnimatedSprite {
  constructor (tile, tileSet, horizontalFlip, verticalFlip, diagonalFlip) {
    const textures = setTextures(tile, tileSet)
    super(textures)
	
    this.textures = textures
    this.tileSet = tileSet
    this.setTileProperties(tile)
    this.setFlips(horizontalFlip, verticalFlip, diagonalFlip)
  }

  setTileProperties (tile) {
    for (const property in tile) {
      if (Object.prototype.hasOwnProperty.call(tile, property)) {
        this[property] = tile[property]
      }
    }
  }

  setFlips (horizontalFlip, verticalFlip, diagonalFlip) {
    if (horizontalFlip) this.setHorizontalFlip()
    if (verticalFlip) this.setVerticalFlip()
    if (diagonalFlip) {
      if (horizontalFlip) this.setHorizontalDiagonalFlip()
      if (verticalFlip) this.setVerticalDiagonalFlip()
    }
  }

  setHorizontalFlip () {
    this.anchor.x = 1
    this.scale.x = -1
  }

  setVerticalFlip () {
    this.anchor.y = 1
    this.scale.y = -1
  }

  setHorizontalDiagonalFlip () {
    this.anchor.x = 0
    this.scale.x = 1
    this.anchor.y = 1
    this.scale.y = 1

    this.rotation = PIXI.DEG_TO_RAD * 90
  }

  setVerticalDiagonalFlip () {
    this.anchor.x = 1
    this.scale.x = 1
    this.anchor.y = 0
    this.scale.y = 1

    this.rotation = PIXI.DEG_TO_RAD * -90
  }
}

class TileLayer extends PIXI.Container {
  constructor (layer, tileSets) {
    super()
	this._compositeLayer = new PIXI.tilemap.CompositeTilemap()
	if(!layer.properties.animationAlign) {
		this._compositeLayer.tileAnim = [Utils.randomInt(0, 60), Utils.randomInt(0, 60)];
	}
	this.addChild(this._compositeLayer)
    this.setLayerProperties(layer)
	this.setTilesetTextures(tileSets)
    this.alpha = parseFloat(layer.opacity)
    this.setLayerTiles(layer, tileSets)
	this.zy = this.properties.zy || 0;
	this.zk = this.properties.zk || 0;
	this.zx = this.properties.zx || 0;
	this.alphaFilter = null;
	this.scale.x = Graphics.scaleX;
	this.scale.y = Graphics.scaleY;
	this.updateCollisionSwitch(true);
  }

  setLayerProperties (layer) {
    for (const property in layer) {
      if (Object.prototype.hasOwnProperty.call(layer, property)) {
        this[property] = layer[property]
      }
    }
  }
  
  update () {
	  if(!this._compositeLayer.tileAnim) {
		return
	  }
	  this._compositeLayer.tileAnim[0]++;
	  this._compositeLayer.tileAnim[1]++;
  }
  
  setTilesetTextures (tileSets) {
	  this._compositeLayer.tileset(tileSets.map((tileSet) => { return new PIXI.Texture(tileSet.baseTexture); }));
  }

  setLayerTiles (layer, tileSets) {
    for (let y = 0; y < layer.map.height; y++) {
      for (let x = 0; x < layer.map.width; x++) {
        const i = x + (y * layer.map.width)

        if (this.tileExists(layer, i)) {
          const tileData = { i, x, y }
          this.createTile(layer, tileSets, tileData)
        }
      }
    }
  }

  createTile (layer, tileSets, tileData) {
    const { i, x, y } = tileData
    const tileSet = findTileSet(layer.tiles[i].gid, tileSets)
	const tileSetIndex = tileSets.indexOf(tileSet);
	const tileTextures = setTextures(layer.tiles[i], tileSet);
	let sx = tileTextures[0]._frame.x;
	let sy = tileTextures[0]._frame.y;
	for(const texture of tileTextures) {
		if(sx > texture._frame.x) {
			sx = texture._frame.x;
		}
		if(sy > texture._frame.y) {
			sy = texture._frame.y;
		}
	}
	const displayX = x * layer.map.tileWidth + ((tileSet.tileOffset) ? tileSet.tileOffset.x : 0)
	const displayY = y * layer.map.tileHeight + ((tileSet.tileOffset) ? tileSet.tileOffset.y : 0)
	const animationLength = layer.tiles[i].animations.length;
	let rotation = 0;		// 2, 4, 6 逆时针旋转90 180 270，8垂直翻转，10旋转270+水平翻转，12水平翻转，14旋转90+水平翻转
	if(layer.diagonalFlips[i]) {
		if(layer.horizontalFlips[i] && layer.verticalFlips[i]) {
			rotation = 14;
		} else if(layer.horizontalFlips[i]) {
			rotation = 6;
		} else if(layer.verticalFlips[i]) {
			rotation = 2;
		} else {
			rotation = 10;
		}
	} else {
		if(layer.horizontalFlips[i] && layer.verticalFlips[i]) {
			rotation = 4;
		} else if(layer.horizontalFlips[i]) {
			rotation = 12;
		} else if(layer.verticalFlips[i]) {
			rotation = 8;
		}
	}
	this._compositeLayer.tile(tileSetIndex, displayX, displayY, {u:sx, v:sy, tileWidth:layer.map.tileWidth, tileHeight:layer.map.tileHeight, rotate:rotation}) 
	if(animationLength) {
		const duration = Math.round(parseInt(layer.tiles[i].animations[0].duration) * (60 / 1000));
		const intervalX = Math.abs(tileTextures[1]._frame.x - tileTextures[0]._frame.x);
		const intervalY = Math.abs(tileTextures[1]._frame.y - tileTextures[0]._frame.y);			// 目前暂无法支持从下往上，从右往左播放的帧动画
		if(intervalX > 0) {
			this._compositeLayer.tileAnimX(intervalX, animationLength).tileAnimDivisor(duration); 
		} else {
			this._compositeLayer.tileAnimY(intervalY, animationLength).tileAnimDivisor(duration); 
		}
	}
  }

  tileExists (layer, i) {
    return layer.tiles[i] && layer.tiles[i].gid && layer.tiles[i].gid !== 0
  }
  
  updateCollisionSwitch(noFade = false) {
	if(this.properties.collisionSwitchId) {
		const switchId = this.properties.collisionSwitchId;
		const nowVisible = $gameSwitches.value(switchId);
		if(this.visible !== nowVisible) {
			if(noFade) {
				this.visible = nowVisible;
				$gameMap.buildTerrain();
			} else if(this.alphaFilter.alpha > 0 && !nowVisible) {
				if(this.alphaFilter.alpha === 1) {
					$gameMap.buildTerrain();
				}
				this.alphaFilter.alpha -= 0.02;
			} else if(nowVisible) {
				this.alphaFilter.alpha = 1;
				this.visible = nowVisible;
				$gameMap.buildTerrain();
			} else {
				this.visible = nowVisible;
			}
		}
	}
  }

}

function findTileSet (gid, tileSets) {
  let tileSet
  for (let i = tileSets.length - 1; i >= 0; i--) {
    tileSet = tileSets[i]
    if (tileSet.firstGid <= gid) {
      break
    }
  }
  return tileSet
}

class TileSet {
  constructor (tileSet) {
    this.setTileSetProperties(tileSet)
    this.baseTexture = ImageManager.loadTileset(Utils.baseName(tileSet.image.source)).baseTexture
    this.setTileTextures()
  }

  setTileSetProperties (tileSet) {
    for (const property in tileSet) {
      if (Object.prototype.hasOwnProperty.call(tileSet, property)) {
        this[property] = tileSet[property]
      }
    }
  }

  setTileTextures () {
    this.textures = []
    for (let y = this.margin; y < this.image.height; y += this.tileHeight + this.spacing) {
      for (let x = this.margin; x < this.image.width; x += this.tileWidth + this.spacing) {
        const tileRectangle = new PIXI.Rectangle(x, y, this.tileWidth, this.tileHeight)
        this.textures.push(new PIXI.Texture(this.baseTexture, tileRectangle))
      }
    }
  }
}

class TiledMap {
  static middleware (resource, next) {
    if (resource.extension !== 'tmx') return next()

    const xmlString = resource.xhr.responseText
    const pathToFile = resource.url

    tmx.parse(xmlString, pathToFile, (error, map) => {
      if (error) throw error

      resource.data = map
      next()
    })
  }

  constructor (mapId) {
    this.renderable = [];
	const resourceId = DataManager.tmxFileName(mapId);
    const resource = PIXILoaderManager.resources()[resourceId]

    this.setDataProperties(resource.data)
    this.setDataTileSets(resource.data)
    this.setDataLayers(resource.data)
	this.setupAdvanceOptions();
  }

  setDataProperties (data) {
    for (const property in data) {
      if (Object.prototype.hasOwnProperty.call(data, property)) {
        this[property] = data[property]
      }
    }
  }

  setDataTileSets (data) {
    this.tileSets = []
    data.tileSets.forEach(
      (tileSetData) => this.tileSets.push(new TileSet(tileSetData))
    )
  }

  setDataLayers (data) {
    data.layers.forEach((layerData) => {
      if (layerData.type === 'tile') {
        this.setTileLayer(layerData)
        return
      }

      this.layers[layerData.name] = layerData
    })
  }

  setTileLayer (layerData) {
    const tileLayer = new TileLayer(layerData, this.tileSets)
	tileLayer.spriteId = Sprite._counter++;
    this.layers[layerData.name] = tileLayer
	if(tileLayer.properties.upper) {
		tileLayer.z = 4
	} else if(tileLayer.properties.normalUpper) {		// 与玩家相同的层级，用来解决透视问题
		tileLayer.z = 3;
	} else if(tileLayer.properties.z) {
		tileLayer.z = tileLayer.properties.z;
	} else {
		tileLayer.z = 0
	}
	if(tileLayer.properties.blendMode) {
		tileLayer.blendMode = tileLayer.properties.blendMode;
	}
	tileLayer.ensureColorMultiplyFilter();
	tileLayer.initColorMatrixFilter();
	if(tileLayer.properties.fake || tileLayer.properties.alphaAnimation || tileLayer.properties.collisionSwitchId || tileLayer.alpha < 1) {
		tileLayer.filters = tileLayer.filters || [];
		const alphaFilter = new PIXI.filters.AlphaFilter(tileLayer.alpha);
		tileLayer.alphaFilter = alphaFilter;
		tileLayer.filters.push(alphaFilter);
	}
	tileLayer.initDayNightVisible();
	tileLayer.initTmxFakeEffect();
	this.renderable.push(tileLayer);
  }
  
  setPos (x, y) {
	this.renderable.forEach((layer) => {
		layer.setPos(x, y);
	});
  }
  
  refreshDayNight() {
	this.renderable.forEach((layer) => {
		layer.initDayNightVisible();
		layer.initColorMatrixFilter();
	});
  }
  
  setupAdvanceOptions() {
	if(this.properties.animationId) {
		const x = $gameMap.width() * $gameMap.tileWidth() / 2;
		const y = $gameMap.height() * $gameMap.tileHeight() / 2;
		if(this.properties.animationZ) {
			$gameTemp.requestAdvanceAnimation([$gamePlayer], this.properties.animationId, {z:this.properties.animationZ,staticPosition:true,x:x, y:y});
		} else {
			$gameTemp.requestAdvanceAnimation([$gamePlayer], this.properties.animationId, {staticPosition:true,x:x, y:y});
		}
	}
	if(this.properties.animationId2) {
		const x = $gameMap.width() * $gameMap.tileWidth() / 2;
		const y = $gameMap.height() * $gameMap.tileHeight() / 2;
		if(this.properties.animationZ2) {
			$gameTemp.requestAdvanceAnimation([$gamePlayer], this.properties.animationId2, {z:this.properties.animationZ2,staticPosition:true,x:x,y:y});
		} else {
			$gameTemp.requestAdvanceAnimation([$gamePlayer], this.properties.animationId2, {staticPosition:true,x:x, y:y});
		}
	}
  }
}

class CollisionLayer {
	constructor(layer) {
		this.tilesMap = layer.tiles 
		this.constructCollisionsMap()
		this.width = layer.map.width 
		this.height = layer.map.height
		this.tileWidth = layer.map.tileWidth 
		this.tileHeight = layer.map.tileHeight
		this.diagonalFlips = layer.diagonalFlips
		this.horizontalFlips = layer.horizontalFlips
		this.verticalFlips = layer.verticalFlips
	}

	isWalkable(x, y) {
		const posx = Math.floor(x / this.tileWidth) 
		const posy = Math.floor(y / this.tileHeight)
		return this.collisionsMap[posx + posy * this.width]
	}

	constructCollisionsMap() {
		this.collisionsMap = new Array(this.tilesMap.length)
		for (let i = 0; i < this.tilesMap.length; ++i) {
			const tile = this.tilesMap[i]
			this.collisionsMap[i] = (tile === undefined)
		}
	}

	getCollidables(vground = false) {
		const collidables = []

		let row = 0;
		let column = 0
		for (let i = 0; i < this.tilesMap.length; ++i) {
			column = i % this.width 
			row = Math.floor(i / this.width)

			const tile = this.tilesMap[i]
			if (tile === undefined) continue
			if (vground && !tile.properties.vground) continue
			const baseX = column * this.tileWidth * Graphics.scaleX
			const baseY = row * this.tileHeight * Graphics.scaleY
			if (!tile.objectGroups || tile.objectGroups.length === 0) {
				const rect = {
					x: baseX,
					y: baseY,
					width: this.tileWidth * Graphics.scaleX,
					height: this.tileHeight * Graphics.scaleY
				}
				collidables.push({vertices:CollisionLayer.verticesFromRect(rect)})
			} else {
				let rotation = 0
				let flipX = 0
				let flipY = 0
				const centerX = baseX + this.tileWidth * Graphics.scaleX / 2
				const centerY = baseY + this.tileHeight * Graphics.scaleY / 2
				if(this.diagonalFlips[i]) {
					if(this.horizontalFlips[i] && this.verticalFlips[i]) {
						flipX = 1;
						rotation = Math.PI * 0.5;
					} else if(this.horizontalFlips[i]) {
						rotation = Math.PI * 1.5;
					} else if(this.verticalFlips[i]) {
						rotation = Math.PI * 0.5;
					} else {
						flipX = 1;
						rotation = Math.PI * 1.5;
					}
				} else {
					if(this.horizontalFlips[i] && this.verticalFlips[i]) {
						rotation = Math.PI;
					} else if(this.horizontalFlips[i]) {
						flipX = 1;
					} else if(this.verticalFlips[i]) {
						flipY = 1;
					}
				}
				tile.objectGroups.forEach((tmxobj) => {
					const vertices = CollisionLayer.tmxObjectToVertices(tmxobj, baseX, baseY, rotation, flipX, flipY, centerX, centerY)
					if(vertices) {
						collidables.push({vertices:vertices, footstep:tile.properties.footstep})
					}
				})
			}
			
		}
		return collidables
	}
	
	static tmxObjectToVertices(obj, ox = 0, oy = 0, rotation = 0, flipX = 0, flipY = 0, cx = 0, cy = 0) {
		if(!obj.ellipse) {
			if(obj.polygon) {
				return obj.polygon.map((p) => {
					return this.pointTransform({x:(parseFloat(p.x) + obj.x) * Graphics.scaleX + ox, y:(parseFloat(p.y) + obj.y) * Graphics.scaleY + oy}
						, rotation, flipX, flipY, cx, cy);
				});
			} else {
				return this.verticesFromRect({x:obj.x * Graphics.scaleX+ox
					,y:obj.y * Graphics.scaleY+oy
					,width:obj.width * Graphics.scaleX
					,height:obj.height * Graphics.scaleY
				}, rotation, flipX, flipY, cx, cy);
			}
		}
		return null;
	}
	
	static verticesFromRect(rect, rotation = 0, flipX = 0, flipY = 0, cx = 0, cy = 0) {
		return [
			this.pointTransform({x:rect.x, y:rect.y}, rotation, flipX, flipY, cx, cy)
			, this.pointTransform({x:(rect.x+rect.width), y:rect.y}, rotation, flipX, flipY, cx, cy)
			, this.pointTransform({x:(rect.x+rect.width), y:(rect.y+rect.height)}, rotation, flipX, flipY, cx, cy)
			, this.pointTransform({x:rect.x, y:(rect.y+rect.height)}, rotation, flipX, flipY, cx, cy)
		];
	}
	
	static pointTransform(pos, rotation = 0, flipX = 0, flipY = 0, cx = 0, cy = 0) {
		const x = pos.x - cx;
		const y = pos.y - cy;
		const sr = Math.sin(-rotation);
		const cr = Math.cos(-rotation);
		const x2 = x * cr - y * sr;
		const y2 = y * cr + x * sr;
		const x3 = flipX ? -x2 : x2;
		const y3 = flipY ? -y2 : y2;
		pos.x = Math.round(x3 + cx);
		pos.y = Math.round(y3 + cy);
		return pos;
	}
}

NYA.TILEMAP.Spriteset_Map_updateTilemap = Spriteset_Map.prototype.updateTilemap;
Spriteset_Map.prototype.updateTilemap = function() {
	NYA.TILEMAP.Spriteset_Map_updateTilemap.apply(this, arguments);
	Graphics.app.renderer.plugins.tilemap.tileAnim[0]++;
	Graphics.app.renderer.plugins.tilemap.tileAnim[1]++;
	this._tmxmap.setPos(-this._tilemap.origin.x, -this._tilemap.origin.y);
	this._tmxmap.renderable.forEach((layer) => {
		if(layer.properties.bezier) {
			layer.updateTmxBezierEffect();
		}
		if(layer.properties.rotation) {
			layer.updateTmxRotationEffect();
		}
		if(layer.properties.fake) {
			layer.updateTmxFakeEffect();		// 玩家一接触地形就消失
		}
		if(layer.properties.linearMoveAnimation) {
			layer.updateLinearMoveAnimation();
		}
		if(layer.properties.alphaAnimation) {
			layer.updateAlphaAnimation();
		}
		if(layer.properties.eyeLookRadius) {
			layer.updateEyeLook();
		}
		if(layer.properties.parallaxX || layer.properties.parallaxY) {
			layer.updateParallax();
		}
		if(layer.properties.collisionSwitchId) {
			layer.updateCollisionSwitch();
		}
	});
	if($gameMap.pollRefreshDayNight()) {
		this._tmxmap.refreshDayNight();
	}
};

TileLayer.prototype.initDayNightVisible = function() {
	if(this.properties.day && $gameMap.isNight() || this.properties.night && $gameMap.isDay()) {
		this.visible = false;
	} else {
		this.visible = true;
	}
};

TileLayer.prototype.initColorMatrixFilter = function() {
	const filter = this._colorMultiplyFilter;
	filter.enabled = false;
	if(!this.properties.nightHSLOrDarker || $gameMap.isNight()) {
		if(this.properties.darker) {
			filter.enabled = true;
			switch(this.properties.darker) {
				case 1: case 2: case 3: {
					//colorMatrix.hue(0)				// -180 ~ 180 -> -180 ~ 180
					//colorMatrix.saturate(-0.15, true) 	// -100 ~ 100 -> -1.0 ~ 1.0
					//colorMatrix.brightness(0.8, true)   // -100 ~ 100 -> 0.0 ~ 2.0
					filter.setBlendColor(172, 172, 172);
					break
				}
				case 4: {
					filter.setBlendColor(196, 196, 196);
					break
				}
				case 5: {
					filter.setBlendColor(196, 196, 196);
					break
				}
			}
		}
	}
};

TileLayer.prototype.ensureColorMultiplyFilter = function() {
	if(!this._colorMultiplyFilter) {
		this._colorMultiplyFilter = new ColorMultiplyFilter();
		this.filters = this.filters || [];
		this.filters.push(this._colorMultiplyFilter);
	}
};

TileLayer.prototype.setPos = function(x, y) {
	this.x = x + this.offsetx * Graphics.scaleX;
	this.y = y + this.offsety * Graphics.scaleY;
};

TileLayer.prototype.updateTmxBezierEffect = function() {
	const ltx = this.properties.ltx;
	const lty = this.properties.lty;
	const rdx = this.properties.rdx;
	const rdy = this.properties.rdy;
	this.playBezierCurveL2(ltx, lty, rdx, rdy);
};

TileLayer.prototype.playBezierCurveL2 = function(ltx, lty, rdx, rdy) {
	if(!this.bezierList)
	{
		const context = Utils.createBezierContext(this.offsetx, this.offsety, ltx, lty, rdx, rdy);
		this.bezierList = context.bezierList;
		this.bezierInterpolation = context.bezierInterpolation;
	}
	const d = this._bezierd ? this._bezierd : (this.properties.bezierd ? this.properties.bezierd : 0.004 + Math.random() * 0.004);
	this._bezierd = d;
	this.bezierInterpolation += d;
	const t = this.bezierInterpolation;
	const p = this.bezierList;
	const c1 = Math.pow(1 - t, 2);
	const c2 = 2 * t * (1 - t);
	const c3 = Math.pow(t, 2);
	this.offsetx = Math.floor(c1 * p[0][0] + c2 * p[1][0] + c3 * p[2][0]);
	this.offsety = Math.floor(c1 * p[0][1] + c2 * p[1][1] + c3 * p[2][1]);
	if(this.bezierInterpolation >= 1)
	{
		this._bezierd = 0;
		const dx = (p[2][0] - p[1][0]);
		const dy = (p[2][1] - p[1][1]);
		const k = dy / dx;
		let px2 = 0;
		let py2 = 0;
		const r1 = Math.random();
		if(Math.abs(k) > 1)
		{
			py2 = p[2][1] + (r1 * 0.4 + 0.6) * dy;
			px2 = p[2][0] + (py2 - p[2][1]) / k;
		}
		else
		{
			px2 = p[2][0] + (r1 * 0.4 + 0.6) * dx;
			py2 = p[2][1] + (px2 - p[2][0]) * k;
		}
		const r3 = Math.random();
		const r4 = Math.random();
		const px3 = Math.trunc(r3 * (rdx - ltx) + ltx);
		const py3 = Math.trunc(r4 * (rdy - lty) + lty);
		this.bezierList = [[this.offsetx, this.offsety],[px2, py2],[px3, py3]];
		this.bezierInterpolation = 0;
	}
};

TileLayer.prototype.updateTmxRotationEffect = function() {
	const v = this.properties.v;
	const cx = this.properties.cx;
	const cy = this.properties.cy;
	if(this.pivot.x === 0) {
		this.pivot.x = cx;
		this.offsetx += this.pivot.x;
	}
	if(this.pivot.y === 0) {
		this.pivot.y = cy;
		this.offsety += this.pivot.y;
	}
	this.rotation += v;
};

TileLayer.prototype.updateTmxFakeEffect = function() {
	const layerName = this.properties.fake;
	const minAlpha = this.properties.fakeMinAlpha || 0;
	if(this.alphaFilter.alpha > minAlpha && $gameMap.hitTest($gamePlayer, this.properties.fakeCache, false)) {
		this.alphaFilter.alpha -= 0.05;
		this.alphaFilter.alpha = this.alphaFilter.alpha.clamp(minAlpha, 1);
	} else if(this.alphaFilter.alpha < 1 && !$gameMap.hitTest($gamePlayer, this.properties.fakeCache, false)) {
		this.alphaFilter.alpha += 0.05;
		this.alphaFilter.alpha = this.alphaFilter.alpha.clamp(minAlpha, 1);
	}
};

TileLayer.prototype.updateLinearMoveAnimation = function() {
	const time = this.properties.t;
	const x = this.properties.x;
	const y = this.properties.y;
	const dx = x / time;
	const dy = y / time;
	if(!this._linearMoveData) {
		this._linearMoveData = {t:0, dir:1};
	}
	if(this._linearMoveData.dir) {
		this._linearMoveData.t++;
		this.x += dx * this._linearMoveData.t;
		this.y += dy * this._linearMoveData.t;
		
		if(this._linearMoveData.t >= time) {
			this._linearMoveData.dir = 0;
			this._linearMoveData.t = 0;
		}
	} else {
		this._linearMoveData.t++;
		this.x += dx * (time - this._linearMoveData.t);
		this.y += dy * (time - this._linearMoveData.t);
		if(this._linearMoveData.t >= time) {
			this._linearMoveData.dir = 1;
			this._linearMoveData.t = 0;
		}
	}
};

TileLayer.prototype.updateAlphaAnimation = function() {
	const time = this.properties.t;
	const d = 1 / time;
	if(!this._alphaMoveData) {
		this._alphaMoveData = {t:0, dir:this.properties.d};
	}
	if(this._alphaMoveData.dir) {
		this._alphaMoveData.t++;
		this.alphaFilter.alpha = this._alphaMoveData.t * d;
		
		if(this._alphaMoveData.t >= time) {
			this._alphaMoveData.dir = 0;
			this._alphaMoveData.t = 0;
		}
	} else {
		this._alphaMoveData.t++;
		this.alphaFilter.alpha = (time - this._alphaMoveData.t) * d;
		if(this._alphaMoveData.t >= time) {
			this._alphaMoveData.dir = 1;
			this._alphaMoveData.t = 0;
		}
	}
};

TileLayer.prototype.initTmxFakeEffect = function() {
	const layerName = this.properties.fake;
	if(layerName) {
		const collisionLayer = $gameMap.getLayerByName(layerName);
		const arr = collisionLayer.objects.map((tmxobj) => {
			const vertices = CollisionLayer.tmxObjectToVertices(tmxobj);
			return new Game_Terrain(this.offsetx, this.offsety, 0, vertices);
		});
		this.properties.fakeCache = new PhysicsGrid(arr);
		
		const minAlpha = this.properties.fakeMinAlpha || 0;
		if($gameMap.hitTest($gamePlayer, this.properties.fakeCache, false)) {
			this.alpha = minAlpha;
		}
	}
};

TileLayer.prototype.updateEyeLook = function() {
	const rad = this.properties.eyeLookRadius;
	const centerX = this.properties.eyeLookCenterGridX * $gameMap.tileWidth() + this.offsetx * Graphics.scaleX;
	const centerY = this.properties.eyeLookCenterGridY * $gameMap.tileHeight() + this.offsety * Graphics.scaleY;
	const dx = $gamePlayer.physicsCenterX() - centerX;
	const dy = $gamePlayer.physicsCenterY() - centerY;
	const distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
	this.x += Math.round((dx / distance) * rad);
	this.y += Math.round((dy / distance) * rad);
};

// 会覆盖上面所有修改坐标的特性
TileLayer.prototype.updateParallax = function() {
	this.setPos(-$gameMap.displayX() * $gameMap.tileWidth() * this.properties.parallaxX, -$gameMap.displayY() * $gameMap.tileHeight() * this.properties.parallaxY);
};

NYA.TILEMAP.Spriteset_Map_createTilemap = Spriteset_Map.prototype.createTilemap;
Spriteset_Map.prototype.createTilemap = function() {
	NYA.TILEMAP.Spriteset_Map_createTilemap.apply(this, arguments);
	const mapId = $gameMap.mapId();
	this._tmxmap = new TiledMap(mapId);
	this._tmxmap.renderable.forEach((layer) => { this._tilemap.addChild(layer); });
};

DataManager.tmxFileName = function(mapId) {
	return "data/Map%1.tmx".format(mapId.padZero(3));
};

Game_Map.prototype.getLayerByName = function(name) {
	const layers = this.getCurrentLayers();
	for(const layer of this.getCurrentLayers()) {
		if(layer.name === name) {
			return layer;
		}
	}
	return null;
};

Game_Map.prototype.getCurrentLayers = function() {
	const mapId = this.mapId();
	const resourceId = DataManager.tmxFileName(mapId);
	const resource = PIXILoaderManager.resources()[resourceId];
	return resource.data.layers;
};

Game_Map.prototype.tilemapTerrain = function() {
	this.getCurrentLayers().forEach((layer) => {
		if(!layer.visible) {
			return;
		}
		const offsetx = layer.offsetx * Graphics.scaleX;
		const offsety = layer.offsety * Graphics.scaleY;
		const vGroundType = layer.properties.vground ? 1 : 0;
		const elastic = layer.properties.elastic || 0;
		const elasticSe = layer.properties.elasticSe || 0;
		let triggerDamage = null;
		const damage = layer.properties.damage | 0;
		if(damage !== 0) {
			const alive = !!layer.properties.alive;
			const fx = layer.properties.fx | 0;
			const fy = layer.properties.fy | 0;
			const staggerTime = layer.properties.staggerTime | 0;
			const real = !!layer.properties.real;
			const mirror = !!layer.properties.mirror;
			const moveBack = !!layer.properties.moveBack;
			if(!layer.properties.noDamageIfEasy || $gameSystem.difficulty() !== -1) {
				triggerDamage = {damage:damage, staggerTime:staggerTime, fx:fx, fy:fy, alive:alive, mirror:mirror, real:real, moveBack:moveBack};
			}
		}
		if(layer.type === "object") {
			layer.objects.forEach((tmxobj) => {
				const vertices = CollisionLayer.tmxObjectToVertices(tmxobj);
				if(vertices) {
					if(tmxobj.properties.id) {
						const bound = this.verticesBound(vertices);
						const ox = Math.trunc((bound.minX + bound.maxX) / 2);
						const oy = Math.trunc((bound.minY + bound.maxY) / 2);
						for(const p of vertices) {
							p.x -= ox;
							p.y -= oy;
						}
						this._tmxExternalVertices[tmxobj.properties.id] = {ox:offsetx+ox, oy:offsety+oy, vertices:vertices};
					} else {
						const terrain = new Game_Terrain(offsetx, offsety, vGroundType, vertices);
						terrain.upElastic = elastic;
						terrain.elasticSe = elasticSe;
						terrain.triggerDamage = triggerDamage;
						if(tmxobj.properties.footstep || layer.properties.footstep) { terrain.footstepId = tmxobj.properties.footstep || layer.properties.footstep; }
						this._terrain.push(terrain);
						this.autoGenerateTopTerrain(terrain);
					}
				}
			});
		} else if(layer.properties.collision) {
			const switchId = layer.properties.collisionSwitchId | 0;
			if(switchId && !$gameSwitches.value(switchId)) {
				return;
			}
			const collision = new CollisionLayer(layer);
			const collidables = collision.getCollidables(layer.properties.vground);
			collidables.forEach((info) => {
				const vertices = info.vertices;
				const footstep = info.footstep;
				const terrain = new Game_Terrain(offsetx, offsety, vGroundType, vertices);
				if(footstep) { terrain.footstepId = footstep; }
				terrain.upElastic = elastic;
				terrain.elasticSe = elasticSe;
				terrain.triggerDamage = triggerDamage;
				this._terrain.push(terrain);
				this.autoGenerateTopTerrain(terrain);
			});
		}
	});
};

NYA.TILEMAP.readFile = tmx.readFile;
tmx.readFile = function(name, cb) {
	if(NYA.DEBUG) {
		NYA.TILEMAP.readFile.apply(this, arguments);
	}
	else {
		const res = PackageManager.getResource(name);
		let dec = new TextDecoder();
		cb("",dec.decode(res));
	}
};

Game_Map.prototype.parallaxName = function() {
	return "";
};

Game_Map.prototype.autoGenerateTopTerrain = function(terrain) {
	if(terrain.type !== 0) {
		return;
	}
	if(!terrain.vertices || Utils.isRectVertices(terrain.vertices)) {
		const top = terrain.py - terrain.hitOffsetT();
		if(top < 24) {
			const left = terrain.px - terrain.hitOffsetL();
			const right = terrain.px + terrain.hitOffsetR();
			const px = Math.round((right - left) / 2);
			const py = 0;
			const topTerrain = new Game_Terrain(px, py, 0, null);
			topTerrain.setHitRect({l:px-left,t:9999,r:right-px,b:0});
			topTerrain.triggerDamage = terrain.triggerDamage;
			this._terrain.push(topTerrain);
		}
	}
};

Utils.isRectVertices = function(vertices) {
	for(let i = 0; i < vertices.length - 1; i++) {
		if(vertices[i].x !== vertices[i+1].x && vertices[i].y !== vertices[i+1].y) {
			return false;
		}
	}
	return true;
};

function ColorMultiplyFilter() {
	PIXI.Filter.call(this, PIXI.defaultVertex, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 blendColor;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * blendColor;\n}\n", {blendColor: new Float32Array(4)});
	this.uniforms.blendColor.fill(1.0);
}

ColorMultiplyFilter.prototype = Object.create(PIXI.Filter.prototype);
ColorMultiplyFilter.prototype.constructor = ColorMultiplyFilter;

ColorMultiplyFilter.prototype.setBlendColor = function(r, g, b) {
	this.uniforms.blendColor[0] = r / 255;
	this.uniforms.blendColor[1] = g / 255;
	this.uniforms.blendColor[2] = b / 255;
};


NYA.EXTERNAL = {};

Graphics._makeErrorHtml = function(_name, message, error) {
    const nameDiv = document.createElement("div");
    const messageDiv = document.createElement("div");
    nameDiv.id = "errorName";
	nameDiv.style.fontSize = Math.round(250 * this._realScale) + "%";
    messageDiv.id = "errorMessage";
	messageDiv.style.marginTop = Math.round(100 * this._realScale) + "px";
	messageDiv.style.fontSize = Math.round(120 * this._realScale) + "%";
	const name = TextManager["STATIC_TEXT_GAME_CRASH_TITLE"] || "游戏居然出错了";
    nameDiv.innerHTML = Utils.escapeHtml(!_name ? "" : name);
    messageDiv.innerHTML = Utils.escapeHtml(!message ? "" : message);
	if(error && error.stack) {
		const stackDiv = document.createElement("div");
		stackDiv.id = "errorStack";
		stackDiv.innerHTML = Utils.escapeHtml(error.stack);
		stackDiv.style.marginTop = Math.round(24 * this._realScale) + "px";
		stackDiv.style.fontSize = Math.round(60 * this._realScale) + "%";
		return nameDiv.outerHTML + messageDiv.outerHTML + stackDiv.outerHTML;
	} else {
		return nameDiv.outerHTML + messageDiv.outerHTML;
	} 
};

Graphics._updateErrorPrinter = function() {
    const width = 960 * this._realScale;
    const height = 100 * this._realScale;
    this._errorPrinter.style.width = width + "px";
    this._errorPrinter.style.height = height + "px";
	const imageWidth = 480 * this._realScale;
	this._errorPrinterImage.style.width = this._errorPrinterImage.style.height = imageWidth + "px";
};

NYA.EXTERNAL.Graphics__createErrorPrinter = Graphics._createErrorPrinter;
Graphics._createErrorPrinter = function() {
	this._errorPrinterImage = document.createElement("img");
	this._errorPrinterImage.id = "errorImage";
    this._errorPrinterImage.src = "icon/error.png";
	this._errorPrinterImage.style.visibility = "hidden";
    document.body.appendChild(this._errorPrinterImage);
	NYA.EXTERNAL.Graphics__createErrorPrinter.apply(this, arguments);
};

NYA.EXTERNAL.Graphics_printError = Graphics.printError;
Graphics.printError = function() {
	NYA.EXTERNAL.Graphics_printError.apply(this, arguments);
	this._errorPrinterImage.style.visibility = "";
	this._errorPrinterImage.style.animation = "";
};

NYA.EXTERNAL.SceneManager_catchNormalError = SceneManager.catchNormalError;
SceneManager.catchNormalError = function(e) {
	NYA.EXTERNAL.SceneManager_catchNormalError.apply(this, arguments);
	this.makeErrorDump(e.stack);
};

SceneManager.makeErrorDump = function(stack) {
	if(!NYA.DEBUG) {
		if(Utils.isNwjs()) {
			const fs = require("fs");
			const filename = "error/error%1".format(Date.now());
			StorageManager.fsMkdir("error/");
			fs.writeFileSync(filename, stack);
		}
	}
};

NYA.EXTERNAL.SceneManager_onKeyDown = SceneManager.onKeyDown;
SceneManager.onKeyDown = function() {
	if(NYA.DEBUG) {
		NYA.EXTERNAL.SceneManager_onKeyDown.apply(this, arguments);
	}
	if (event.ctrlKey && event.altKey && SceneManager._scene.constructor === Scene_Map) {
        switch (event.keyCode) {
            case 119: // F8
                $gamePlayer.actor()._stones.clear();
                break;
        }
    }
};

NYA.STORAGE = {};

window.storageWorker = main.getWorker("js/nya_workers/nya_storage_worker.js");
NYA.STORAGE.DataManager_autoSaveGame = DataManager.autoSaveGame;
DataManager.autoSaveGame = function() {
	const worker = window.storageWorker;
	if(!worker) {
		NYA.STORAGE.DataManager_autoSaveGame.call(this);
	} else {
		SceneManager.snapForBackground();
		$gameSystem.onBeforeSave();
		const info = $gameMap.readyForSave();
		const contents = this.makeSaveContents();
		const saveName = this.makeSavename(0);
		const isSaveGlobal = !this._globalInfo[0];
		this._globalInfo[0] = this.makeSavefileInfo();
		this._globalInfo[0].latest = false;
		if(isSaveGlobal) {
			const globalInfo = this._globalInfo;
			worker.postMessage({method:"autoSaveGame", args:[saveName, JsonEx.stringify(globalInfo), JsonEx.stringify(contents)]});
		} else {
			worker.postMessage({method:"autoSaveGameWithOutGlobal", args:[saveName, JsonEx.stringify(contents)]});
		}
		$gameMap.completeSave(info);
	}
	this._autoSaveAnimationRequest = true;
};

NYA.STORAGE.ConfigManager_save = ConfigManager.save;
ConfigManager.save = function() {
	const worker = window.storageWorker;
	if(!worker) {
		NYA.STORAGE.ConfigManager_save.call(this);
	} else {
		const saveName = "config";
		worker.postMessage({method:"autoSaveGameWithOutGlobal", args:[saveName, JsonEx.stringify(this.makeData())]});
	}
};

StorageManager.fsReadFile = function(path) {
    const fs = require("fs");
    if (fs.existsSync(path)) {
		const buffer = fs.readFileSync(path);
        return main.y(buffer);
    } else {
        return null;
    }
};

StorageManager.fsWriteFile = function(path, data) {
    const fs = require("fs");
    fs.writeFileSync(path, main.y(data));
};

StorageManager.jsonToZip = function(json) {
    return new Promise((resolve, reject) => {
        try {
            const zip = pako.deflate(json);
            if (zip.length >= 50000) {
                console.warn("Save data is too big.");
            }
            resolve(zip);
        } catch (e) {
            reject(e);
        }
    });
};

StorageManager.zipToJson = function(zip) {
    return new Promise((resolve, reject) => {
        try {
            if (zip) {
                const json = pako.inflate(zip, { to: "string" });
                resolve(json);
            } else {
                resolve("null");
            }
        } catch (e) {
            reject(e);
        }
    });
};

StorageManager.saveObjectSync = function(saveName, object, info) {
	return new Promise((resolve, reject) => {
		const json = JsonEx.stringify(object);
		const zip = pako.deflate(json);
		$gameMap.completeSave(info);
		this.saveZip(saveName, zip);
		resolve();
	});
};

// worker回调
StorageManager.updateForageKeysDirect = function(keys) {
	this._forageKeys = keys;
};

StorageManager.postWorkerGameId = function() {
	const gameId = $dataSystem.advanced.gameId;
	if(storageWorker) {
		storageWorker.postMessage({method:"setGameId", args:[gameId]});
	}
};

(() => {
	if(storageWorker) {
		storageWorker.onmessage = function(e) {
			const m = e.data.method;
			const a = e.data.args;
			StorageManager[m](...a);
		}
		storageWorker.postMessage({method:"startWorking", args:[NYA.NWBIN]});
	}
})();
NYA.AI = {};

// 莉莉亚作为队友时的AI
window.$gameLily = null;
function Game_Lily() {
	this.initialize(...arguments);
}

Game_Lily.prototype = Object.create(Game_Player.prototype);
Game_Lily.prototype.constructor = Game_Lily;

Game_Lily.prototype.initialize = function() {
	Game_Player.prototype.initialize.call(this);
	this._statemMembers = {};
	this._aiState = 0;
	this._currentFollowTarget = -1;
	this._remove = true;
	const members = this._statemMembers;
	members.jumpSimulate = true;
	members.pathFinder = new Game_ProperPathFindContext();
	members.directionChangeCD = 0;
	members.specMoveCommand = null;
	this._currentFollowFindIdx = 0;
	this._currentFollowFindId = 0;
	this._currentFollowFinding = false;
	this.m = 0.4;
	this.initFloatMessageMembers();
};

Game_Lily.prototype.screenZ = function() {
	return 3;
};

Game_Lily.prototype.initFloatMessageMembers = function() {
	this._floatMessageCounterBase = 0;
	this._floatMessageUniqueRecord = {};
};

Game_Lily.prototype.actor = function() {
	return $gameActors.actor(4);
};

// 离玩家太远或者很近时选择攻击【离自己最近】的怪物
// 离玩家中等距离选择跟随玩家
Game_Lily.prototype.playerControl = function() {
	const state = this.pstate();
	const members = this._statemMembers;
	if(members.specMoveCommand) {
		if(this.updateSpecMove(members.specMoveCommand)) {
			members.specMoveCommand = null;
		} else {
			return;
		}
	}
	const aiState = this._aiState;
	if(aiState === 2) {
		this.processEvilWallBomb();
	}
	if(this.isOutControl()) {
		if(this._currentFollowFindId !== -1) { 
			this.followCharacter(this.targetIdToObject(this._currentFollowFindId), members);
		}
		return;
	}
	this.updateCreateFloatMessage();
	
	if(this.isBodyAttacking()) {
		return;
	}
	const actor = this.actor();
	this.updateDirectionChangeCD(members);
	switch(aiState) {
		case 1: {		// 从下面传送到上面的图，防顶玩家脑袋防自身坠落
			if(this.isGrounding()) {
				this._aiState = 0;
			} else {
				const dx = $gamePlayer.px - this.px;
				if(Math.abs(dx) > 12) {
					this.processFinderResult(dx > 0 ? 1 : 2);
				}
			}
			break;
		}
		case 2: {		// 恶魔墙BOSS的专用AI
			// 炸弹额外读条，不使用内置技能CD控制发射，平时锁定炸弹和扇子冲锋冷却
			// 对老鼠切换普通攻击模式，炸弹读条好后走到固定点朝右扔炸弹
			// 固定在最左边的小范围寻路
			// boss破防后直接莉莉亚朝外反向冲刺+扇子冲刺到BOSS身旁，攻击目标切换为BOSS
			this.processEvilWall();
			break;
		}
		default: {
			const attackCD1 = this.isAttackCD("lily_pan_attack_partner");
			const attackCD2 = this.isAttackCD("lily_pan_jump_attack_partner");
			if(!this.processTargetAttack(attackCD1, attackCD2)) {
				this.findBestAttackTarget(attackCD1, attackCD2);
			}
			break;
		}
	}
};

Game_Lily.prototype.targetIdToObject = function(id) {
	return id === 0 ? $gamePlayer : $gameMap.event(id);
};

Game_Lily.prototype.shouldFollowPlayer = function() {
	const distance = this.pixelDistanceToPlayer();
	return distance > 720;
};

Game_Lily.prototype.syncDirectionFromInput = function() {
};

// 未有攻击目标时，每帧只轮询一个敌人检测是否可达，由近到远
// 选定当前轮询敌人，开始寻路，设状态（切地图重置该状态），该状态开启时等待寻路完成
// 寻路完成后检测是否可达，不可达时递增当前轮询的索引，继续轮询寻路
// 目标可达，则目标设置为当前轮询目标
// 只攻击与主角互为敌方的目标，只攻击有血条的目标
// 已有攻击目标后，解除攻击目标的条件：目标死亡，目标当前不可达，每次寻路完成后的那一帧判定是否更改目标
Game_Lily.prototype.findBestAttackTarget = function(attackCD1, attackCD2) {
	const members = this._statemMembers;
	if(this._currentFollowTarget === -1) {		// 当前无目标
		if(members.pathFinder.isCompleted()) {		// 寻找目标的操作已完成
			if(!this._currentFollowFinding) {		// 当前不在寻找状态下，启动寻找目标的操作
				const targets = this.sortAllTarget();
				if(targets.length === 0 || this.shouldFollowPlayer() || (attackCD1 && attackCD2)) {
					this._currentFollowFindId = 0;
					this._currentFollowFinding = true;
				} else {
					if(this._currentFollowFindIdx >= targets.length) {
						this._currentFollowFindIdx = 0;
					}
					const target = targets[this._currentFollowFindIdx];
					this._currentFollowFindId = target.eventId();
					this._currentFollowFinding = true;
				}
				this.followCharacter(this.targetIdToObject(this._currentFollowFindId), members);
			} else {								// 当前在寻找状态下，检查目标是否可达，是：设置当前目标，否：递增寻找索引重置寻找状态
				if(members.pathFinder.bufferResult().success) {
					this._currentFollowTarget = this._currentFollowFindId;
					this._currentFollowFinding = false;
				} else {
					this._currentFollowFindIdx++;
					this._currentFollowFinding = false;
				}
			}
			
		} else {
			this.followCharacter(this.targetIdToObject(this._currentFollowFindId), members);
		}
	} else {
		const target = this.targetIdToObject(this._currentFollowTarget);
		this.processFinderResult(this.followCharacter(target, members));
		if(members.pathFinder.isCompleted()) {
			if(this.sortAllTarget().length === 0) {
				this._currentFollowTarget = 0;
			} else if(this._currentFollowTarget > 0 && !this.isValidTarget(target) || !members.pathFinder.bufferResult().success) {
				this._currentFollowTarget = -1;
			} else if(this._currentFollowTarget > 0 && attackCD1 && attackCD2) { 	//近战技能CD时把玩家作为目标
				this._currentFollowTarget = 0;
			} else if(this._currentFollowTarget === 0 && !this.shouldFollowPlayer() && (!attackCD1 || !attackCD2)) {
				this._currentFollowTarget = -1;
			}
		}
	}
};

Game_Lily.prototype.clearCurrentFollowFinding = function() {
	this._currentFollowFinding = false;
	this._currentFollowTarget = -1;
};

Game_Lily.prototype.updateDirectionChangeCD = function(members) {
	if(members.directionChangeCD) {
		members.directionChangeCD--;
	}
};

Game_Lily.prototype.processFinderResult = function(resultCode) {
	const members = this._statemMembers;
	if(resultCode === 1 && this.direction() === 4 || resultCode === 2 && this.direction() === 6) {
		if(members.directionChangeCD > 0) {
			Game_Player.prototype.processFinderResult.call(this, resultCode === 1 ? 2 : 1);
		} else {
			members.directionChangeCD = 10;
			Game_Player.prototype.processFinderResult.call(this, resultCode);
		}
	} else {
		Game_Player.prototype.processFinderResult.call(this, resultCode);
	}
};

Game_Lily.prototype.isValidTarget = function(character) {
	return character.battleObject() && !$gameMap.checkSameTeam(this, character) && !character.battleObject().unlimitHp && !character.battleObject().immueStaggerAttack && character.battleObject().specailHitFlag === 0 && !character.isDeath() && this.pixelDistanceToCharacter(character) <= 720 && !character.isInvincible();
};

Game_Lily.prototype.sortAllTarget = function() {
	return $gameMap.events().filter((character) => {
		return this.isValidTarget(character);
	}).sort((a, b) => {
		return this.pixelDistanceToCharacter(a) - this.pixelDistanceToCharacter(b);
	});
};

// 队友版本的莉莉亚会用折扇剑气，平底锅重击，平底锅跳劈，一飞冲天
// 在水底关解锁后，还会用折扇斩击，折扇下劈，折扇冲击
// 水底用蓝色炸弹，地面用红色炸弹
Game_Lily.prototype.processTargetAttack = function(attackCD1, attackCD2) {
	if(this._currentFollowTarget > 0) {
		const target = this.targetIdToObject(this._currentFollowTarget);
		if(target.isDeath()) {
			return false;
		}
		const distance = this.pixelDistanceToCharacter(target);
		const distanceY = Math.abs(this.py - target.py);
		const distanceX = Math.abs(this.px - target.px);
		const water = $gameMap.isInWater();
		const bombSkillName = water ? "lily_throw_sea_bomb_partner" : "lily_throw_bomb_partner";
		const attackCD4 = this.isAttackCD(bombSkillName);
		if(this.isGrounding()) {
			const attackCD3 = this.isAttackCD("lily_fan_partner");
			const attackCD5 = this.isAttackCD("lily_zxc_partner");
			if(distance < 120 && distanceY < 60 && !attackCD1) {
				this.faceToCharacter(target);
				this.requestBodyAttack("lily_pan_attack_partner");
			} else if(distance < 120 && !attackCD5) {
				this.requestBodyAttack("lily_zxc_partner");
			} else if(distance < 240 && distanceY < 140 && !attackCD2) {
				this.faceToCharacter(target);
				this.requestBodyAttack("lily_pan_jump_attack_partner");
			} else if(distance > 660 && !attackCD3) {
				this.faceToCharacter(target);
				this.requestBodyAttack("lily_fan_partner");
			} else if(!water && !attackCD4) {
				this.faceToCharacter(target);
				this.requestBodyAttack(bombSkillName)
			}
		} else {
			const attackCD6 = this.isAttackCD("lily_fan_normal_partner");
			const attackCD7 = this.isAttackCD("lily_fan_down_partner");
			const attackCD8 = this.isAttackCD("lily_fan_dash_partner");
			if(distanceX < 180 && distanceY < 40 && ! attackCD6) {
				this.faceToCharacter(target);
				this.requestBodyAttack("lily_fan_normal_partner");
			} else if(distanceX < 120 && distanceY < 140 && this.py < target.py && !attackCD7) {
				this.faceToCharacter(target);
				this.requestBodyAttack("lily_fan_down_partner");
			} else if(distanceY < 120 && distanceX > 500 && !attackCD8) {
				this.faceToCharacter(target);
				this.requestBodyAttack("lily_fan_dash_partner");
			} else if(water && !attackCD4) {
				this.faceToCharacter(target);
				this.requestBodyAttack(bombSkillName)
			}
		}
	}
	return this.isBodyAttacking();
};

Game_Lily.prototype.reloadToMap = function() {
	this.resetImage(this.battleObject().standingImage);
	this._isGrounding = false;
	this.clearPhysicsObject();
	if(!$gameMap.dynamicCharacters().includes(this)) {
		$gameMap.createCharacter(this);
	}
};

Game_Lily.prototype.revertToLastGroundingPos = function() {
	this.px = this.rx = $gamePlayer.px;
	this.py = this.ry = $gamePlayer.py;
	this.vx = this.vy = 0;
};

Game_CharacterBase.prototype.attachEventState = function(ev) {
	this.px = ev.px;
	this.py = ev.py;
	this.rx = ev.rx;
	this.ry = ev.ry;
	this.vx = ev.vx;
	this.vy = ev.vy;
	this._frameAnimationCounter = ev._frameAnimationCounter;
	this._framePos = ev._framePos;
	this._frameStartPos = ev._frameStartPos;
	this.setDirection(ev.direction());
};

Game_Lily.prototype.adjustPlayerTransfer = function() {
	const direction = $gamePlayer.direction();
	const dx = direction === 4 ? -1 : 1;
	this.px = this.rx = $gamePlayer.px + $gameMap.tileWidth() * dx;
	this.py = this.ry = $gamePlayer.py;
	this.vx = this.vy = 0;
	const grounding = $gamePlayer.py !== $gameMap.height() * $gameMap.tileHeight();
	// 先从水平方向搜索可占位的地方，如果遇到一个在往上搜索
	if(this.hitPreview(0, 0) || !this.hitPreview(0, 1)) {
		const dy = $gamePlayer.hitOffsetT() + $gamePlayer.hitOffsetB();
		this.px = this.rx = $gamePlayer.px;
		this.py = this.ry = $gamePlayer.py - dy - (grounding ? 0 : 72);
		while(this.hitPreview(0, 0)) {
			this.py = this.ry = this.ry - dy;
		}
	}
	
	this._zxcOnce = false;
	this._currentFollowTarget = -1;
	this._currentFollowFindIdx = 0;
	this._currentFollowFinding = false;
	this._currentFollowFindId = 0;
	this._statemMembers.pathFinder.clear();
};

Game_Lily.prototype.updateFootStepSe = function() {
};

Game_Lily.prototype.detectState = function() {
	Game_CharacterBase.prototype.detectState.apply(this, arguments);
};

Game_Lily.prototype.eventId = function() {
	return -2;
};

Game_Lily.prototype.forUpTransfer = function(vy) {
	this.vy = -vy;
	this._aiState = 1;
	const members = this._statemMembers;
	members.jumpSimulate = false;
};

Game_Lily.prototype.nonFollowUpTransfer = function(vy, ox, oy) {
	this.vy = -vy;
	const members = this._statemMembers;
	members.jumpSimulate = false;
	this._aiState = 1;
	this.px = this.rx = this.px + ox;
	this.py = this.ry = this.py + oy;
};

Game_Lily.prototype.setRemove = function(val) {
	const before = this.isRemove();
	Game_Player.prototype.setRemove.call(this, val);
	if(before && !val) {
		this.reloadToMap();
	}
};

Game_Lily.prototype.updateCreateFloatMessage = function() {
	const vid = 6;
	const t = $gameVariables.value(6);
	switch(t) {
		case 1: {
			if(this.commonFloatMessageProcess()) {
				const regionId = DataManager.regionId();
				const baseArr = [];
				switch(regionId) {
					case 1: {
						baseArr.push(152, 153, 154, 130, 131, 132);
						break;
					}
					case 2: {
						baseArr.push(139, 140, 141, 130, 131, 132);
						break;
					}
					case 3: {
						baseArr.push(145, 146, 147, 130, 131, 132);
						break;
					}
					case 4: {
						baseArr.push(133, 134, 135, 130, 131, 132);
						break;
					}
					default: break;
				}
				this.requestFloatMessage(baseArr.randomElement());
				this.resetNormalFloatMessageCounter();
			}
			break;
		}
		case 2: {
			if(this.commonFloatMessageProcess()) {
				const regionId = DataManager.regionId();
				const baseArr = [230, 231, 232, 233, 234];
				switch(regionId) {
					case 5: {
						this.requestFloatMessage(baseArr.randomElement());
						this.resetNormalFloatMessageCounter();
						break;
					}
					default: break;
				}
			}
			break;
		}
		case 3: {
			if(this.commonFloatMessageProcess()) {
				const regionId = DataManager.regionId();
				const baseArr = [276, 278, 279, 280];
				switch(regionId) {
					case 7: {
						this.requestFloatMessage(baseArr.randomElement());
						this.resetNormalFloatMessageCounter();
						break;
					}
					default: break;
				}
			}
		}
		default: break;
	}
};

Game_Lily.prototype.commonFloatMessageProcess = function() {
	const distance = this.pixelDistanceToPlayer();
	if(distance > this.floatMessageTriggerDistance() || this.floatMessage()) {
		return false;
	}
	const storyId = this.pollUniqueFloatMessage();
	if(storyId) {
		this.requestFloatMessage(storyId);
		return false;
	}
	const cd = 1200;
	if(this._floatMessageCounterBase < cd) {
		this._floatMessageCounterBase++;
		return false;
	}
	return true;
};

Game_Lily.prototype.pollUniqueFloatMessage = function() {
	const id = this._nextUniqueFloatMessage;
	if(id) {
		this._nextUniqueFloatMessage = 0;
		this._floatMessageUniqueRecord[id] = true;
		return id;
	}
	return 0;
};

Game_Lily.prototype.floatMessageTriggerDistance = function() {
	return 600;
};

Game_Lily.prototype.requestUniqueFloatMessage = function(id) {
	if(!this._floatMessageUniqueRecord[id] && this.pixelDistanceToPlayer() <= this.floatMessageTriggerDistance()) {
		this._nextUniqueFloatMessage = id;
	}
};

Game_Lily.prototype.resetNormalFloatMessageCounter = function() {
	this._floatMessageCounterBase = 0;
};

Game_Lily.prototype.triggerUniqueFloatMessage = function(storyId) {
	if(!this.isRemove()) {
		this.requestUniqueFloatMessage(storyId);
	}
};

Game_Lily.prototype.beHit = function(playSe, Damage, src) {
	Game_Player.prototype.beHit.apply(this, arguments);
	if(src && src.battleObject().templateId() === 41) {		// 山洞里猫牛怪的攻击
		this.requestUniqueFloatMessage(138);
	}
};

Game_Lily.prototype.requestSquashEffect = function() {
	Game_Player.prototype.requestSquashEffect.apply(this, arguments);
	this.requestUniqueFloatMessage(143);
};

Game_Lily.prototype.updateSpecMove = function(command) {
	const x = command.x;
	const y = command.y;
	const dir = command.direction;
	if(this.isXIn(x)) {
		this.setDirection(dir);
		return true;
	} else {
		const dir = this.px > x ? 4 : 6;
		this.commonDirectionMove(dir);
		if(this.isGrounding() && this.py - this.hitOffsetT() + this.hitOffsetB() > y) {
			this.vy = this.battleObject().jumpStrength;
		}
	}
	return false;
};

Game_Lily.prototype.commonDirectionMove = function(dir) {
	const moveStrength = this.battleObject().moveStrength;
	const maxMoveSpeed = this.battleObject().maxMoveSpeed;
	const x = dir === 4 ? -24 : 24;
	if(this.isGrounding() && this.hitPreview(x, 0)) {
		this._vy = this.battleObject().jumpStrength;
	} else {
		this.performMove(moveStrength, maxMoveSpeed, dir === 4, dir !== 4);
	}
};

Game_Lily.prototype.setSpecMoveCommand = function(x, y, d) {
	this._statemMembers.specMoveCommand = {x:x, y:y, direction:d};
};

Game_Lily.prototype.isSpecMoveCommandComplete = function() {
	return !this._statemMembers.specMoveCommand;
};

Game_Lily.prototype.endTransport = function() {
	if(this._transportMapId) {
		this._transportEnding = true;
		this._transportFrame = this.transportEndFrame();
	}
};

Game_Lily.prototype.checkSameTeam = function(obj) {
	return Game_CharacterBase.prototype.checkSameTeam.apply(this, arguments);
};

Game_Lily.prototype.beHit = function(playSe, damage, src) {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	const actor = this.actor();
	if(!this.isDeath()) {
		if(src !== $gamePlayer) {
			this.makeInvincible(actor.beHitInvincibleTime());
		}
	} else if(!actor.checkRaiseHpLockOrnaments(damage)) {
		this.lockSkillInvincible();
	} else {
		this.makeInvincible(actor.beHitInvincibleTime());
	}
	actor.checkRaiseDamageReflectionOrnaments(src, damage);
};

Game_Lily.prototype.processEvilWall = function() {
	const bossEvent = this.evilWallFightBoss();
	const bossState = bossEvent.statemMembers().state;
	const bossId = bossEvent.eventId();
	if(this.isBodyAttacking()) {
		return;
	}
	const members = this._statemMembers;
	switch(bossState) {
		case 0: case 1: {
			let targetId = -1;
			for(const character of $gameMap.dynamicCharacters()) {
				if(character.constructor === Game_WallRat && character.px < 200) {
					targetId = character.eventId();
				}
			}
			this._currentFollowTarget = targetId;
			break;
		}
		case 2: {
			this._currentFollowTarget = bossId;
			break;
		}
	}
	let tempTargetX = 100;
	if(this._currentFollowTarget === bossId) {
		tempTargetX = this.targetIdToObject(this._currentFollowTarget).px - 48;
		const distanceX = Math.abs(this.px - tempTargetX);
		if(distanceX > 580) {
			this.setDirection(4);
			this._attackcd.length = 0;
			this.requestBodyAttack("lily_reverse_dash");
		} else if(distanceX > 230) {
			this.setDirection(6);
			this.requestBodyAttack("lily_fan_dash_partner");
		} else if(distanceX < 100) {
			this.setDirection(6);
			if(this.requestBodyAttack("lily_pan_jump_attack_partner")) {
				return;
			}
			if(this.requestBodyAttack("lily_fan_down_partner")) {
				return;
			}
			if(this.requestBodyAttack("lily_fan_normal_partner")) {
				return;
			}
			if(this.requestBodyAttack("lily_fan_partner")) {
				return;
			}
			if(this.requestBodyAttack("lily_zxc_partner")) {
				return;
			}
			if(this.requestBodyAttack("lily_pan_attack_partner")) {
				return;
			}
		}
	} else if(this._currentFollowTarget !== -1) {
		tempTargetX = this.targetIdToObject(this._currentFollowTarget).px;
		if(this._statemMembers.bombReadyTime === 0) {
			this.setCD("lily_zxc_partner", 180);
		}
		const attackCD1 = this.isAttackCD("lily_pan_attack_partner");
		const attackCD2 = this.isAttackCD("lily_pan_jump_attack_partner");
		this.processTargetAttack(attackCD1, attackCD2, true);
	}
	if(!this.isXIn(tempTargetX)) {
		const isLeft = this.px > tempTargetX;
		this.updateMoveSimple(isLeft);
		if(this.isGrounding() && this.hitPreview(-20 * Utils.sign(isLeft), 0)) {
			this.vy = this.battleObject().jumpStrength;
		}
	}
};

Game_Lily.prototype.evilWallFightBombMaxTime = function() {
	return 600;
};

Game_Lily.prototype.evilWallFightBoss = function() {
	return $gameMap.event(22);
};

Game_Lily.prototype.startWallFight = function() {
	this._statemMembers.bombReadyTime = 0;
	this._aiState = 2;
};

Game_Lily.prototype.endWallFight = function() {
	this._aiState = 0;
};

// 炸弹在场时不读条，BOSS眩晕时不读条
Game_Lily.prototype.processEvilWallBomb = function() {
	const bossState = this.evilWallFightBoss().statemMembers().state;
	const isBombInMap = $gameMap.dynamicCharacters().some((c) => {
		return c.constructor === Game_LilyBombPartner;
	});
	this.lockBombCd();
	if(bossState === 2) {
		this._statemMembers.bombReadyTime = 0;
	} else {
		const maxTime = this.evilWallFightBombMaxTime();
		if(this._statemMembers.bombReadyTime < maxTime && !isBombInMap) {
			this._statemMembers.bombReadyTime++;
			$gameMap.setSpecProgress(this._statemMembers.bombReadyTime / maxTime);
		} else if(!isBombInMap && this.px < 200 && this.isGrounding()) {
			this.setDirection(6);
			this.unlockBombCd();
			if(this.requestBodyAttack("lily_throw_bomb_partner_wall")) {
				this._statemMembers.bombReadyTime = 0;
			}
		}
	}
};

Game_Lily.prototype.lockBombCd = function() {
	this.setCD("lily_throw_bomb_partner_wall", 2);
	this.setCD("lily_throw_bomb_partner", 100);
};

Game_Lily.prototype.unlockBombCd = function() {
	this.unlockCd("lily_throw_bomb_partner_wall");
};

Game_Lily.prototype.unlockCd = function(name) {
	this._attackcd = this._attackcd.filter((cd) => {
		return cd.name !== name;
	});
};

Game_Lily.prototype.shouldSetHotEvent = function() {
	return false;
};

NYA.AI.DataManager_createGameObjects = DataManager.createGameObjects;
DataManager.createGameObjects = function() {
	NYA.AI.DataManager_createGameObjects.apply(this, arguments);
	$gameLily = new Game_Lily();
};

Game_Map.prototype.setupStaticCharacters = function() {
	if(!$gameLily.isRemove()) {
		this.createCharacter($gameLily);
	}
};

NYA.AI.Game_Map_setupEvents = Game_Map.prototype.setupEvents;
Game_Map.prototype.setupEvents = function() {
	NYA.AI.Game_Map_setupEvents.apply(this, arguments);
	this.setupStaticCharacters();
};

NYA.AI.Game_Player_locate = Game_Player.prototype.locate;
Game_Player.prototype.locate = function() {
	NYA.AI.Game_Player_locate.apply(this, arguments);
	$gameLily.adjustPlayerTransfer();
};

Game_Lily.prototype.locate = function() {
	NYA.AI.Game_Player_locate.apply(this, arguments);
};

Game_System.prototype.setStaticCharacterUpForTransfer = function(vy) {
	$gameLily.forUpTransfer(vy);
};

// 莉莉亚的炸弹
function Game_LilyBomb() {
	this.initialize(...arguments);
}

Game_LilyBomb.prototype = Object.create(Game_CharacterBase.prototype);
Game_LilyBomb.prototype.constructor = Game_LilyBomb;

Game_LilyBomb.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.apply(this, arguments);
	this.m = 9999;
	this.setAirFriction(0.5);
	this.elastic = 1;
	this._g = -$gameMap.g() / 2;
	this._physicsFlag = 5;
	if($gameSystem.difficulty() === 1) {
		this._bombLevel = 10.0;			// 炸弹越打越小，这个数字是当前炸弹的放大倍率
	} else if($gameSystem.difficulty() === 0) {
		this._bombLevel = 5.0;
	} else {
		this._bombLevel = 2.0;
	}
	this._owner = null;
	this._boomBodyHit = null;
	this._removeCounter = 0;
	this._battleObject = null;
	this._physics = true;
};

Game_LilyBomb.prototype.initBomb = function(event) {
	this.px = this.rx = event.px + (event.direction() === 6 ? 40 : -40);
	this.py = this.ry = event.py - 120;
	this.initBattleObject();
	this.setImage(this.battleObject().standingImage);
	this.setVertices(this.currentBombVertices());
	this._owner = event;
	this.adjustInitPosition();
	this.vy = -12;
	this.vx = event.px - $gamePlayer.px > 0 ? -3 : 3;
};

Game_LilyBomb.prototype.battleObject = function() {
	return this._battleObject;
};

Game_LilyBomb.prototype.battleTeam = function() {
	return -1;
};

Game_LilyBomb.prototype.bombLevel = function() {
	return Math.max(1, this._bombLevel);
};

Game_LilyBomb.prototype.scaleX = function() {
	return Game_CharacterBase.prototype.scaleX.call(this) * this.bombLevel();
};

Game_LilyBomb.prototype.scaleY = function() {
	return Game_CharacterBase.prototype.scaleY.call(this) * this.bombLevel();
};

Game_LilyBomb.prototype.initVertices = function() {
	return [{"x":-12,"y":-44},{"x":20,"y":-30},{"x":20,"y":-20},{"x":2,"y":-2},{"x":-10,"y":-2},{"x":-22,"y":-14},{"x":-22,"y":-26}];
};

Game_LilyBomb.prototype.boomAttackVertices = function() {
	return [{"x":2,"y":-54},{"x":-102,"y":-112},{"x":-128,"y":-184},{"x":-114,"y":-246},{"x":-54,"y":-300},{"x":-4,"y":-308},{"x":96,"y":-256},{"x":120,"y":-184},{"x":88,"y":-100}];
};

Game_LilyBomb.prototype.currentBombVertices = function() {
	const vertices = this.initVertices();
	this.adjustVerticesScale(vertices);
	return vertices;
};

Game_LilyBomb.prototype.currentBoomAttackVertices = function() {
	const vertices = this.boomAttackVertices();
	this.adjustVerticesScale(vertices);
	return vertices;
};

Game_LilyBomb.prototype.currentBoomAttackPower = function() {
	return Math.round(this.bombLevel() * 8);
};

Game_LilyBomb.prototype.currentBoomStaggerTime = function() {
	return Math.round(this.bombLevel() * 8 + 15);
};

Game_LilyBomb.prototype.adjustVerticesScale = function(vertices) {
	vertices.forEach((p) => {
		p.x = Math.round(p.x * this.bombLevel());
		p.y = Math.round(p.y * this.bombLevel());
	});
};

Game_LilyBomb.prototype.initBattleObject = function() {
	const templateId = 37;
	this._battleObject = new Game_BattleObject(templateId);
};

Game_LilyBomb.prototype.adjustInitPosition = function() {
	const center = $gameMap.tileWidth() * $gameMap.width() / 2;
	const d = this.px - center > 0 ? -1 : 1;
	while(this.hitPreviewNoVGround()) {
		this.px = this.rx = this.rx + d;
	}
};

Game_LilyBomb.prototype.doPState = function() {
	Game_CharacterBase.prototype.doPState.call(this);
	this.adjustBombSpeed();
	this.determineBombDestroy();
	this.updateBoom();
};

Game_LilyBomb.prototype.adjustBombSpeed = function() {
	if(!this._hasBoom && !this.isStagger()) {
		if(this.vy < -12) {
			this.vy = -12;
		}
		if(Math.abs(this.vx) < 3) {
			this.vx = this.vx > 0 ? 3 : -3;
		}
	}
};

Game_LilyBomb.prototype.beHit = function() {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	if(!this._hasBoom) {
		this._bombLevel--;
		this.setVertices(this.currentBombVertices());
	}
};

Game_LilyBomb.prototype.determineBombDestroy = function() {
	if(this._hasBoom) {
		if(this._removeCounter) {
			this._removeCounter--
		} else {
			this.requestRemove();
		}
	}
};

Game_LilyBomb.prototype.updateFallDown = function() {
};

Game_LilyBomb.prototype.shouldUseImmuePhysicsObject = function() {
	return false;
};

Game_LilyBomb.prototype.updateBoom = function() {
	if(!this._hasBoom) {
		this._hasBoom = this.isBoom();
		if(this._hasBoom) {
			this.vy = 0;
			this._physicsFlag = 7;
			this.px = this.rx = this.px + this.vx;
			const baseOffsetX = 8;
			const baseOffsetY = 184;
			this.px = this.rx = this.px + baseOffsetX * this.bombLevel();
			this.py = this.ry = this.py + baseOffsetY * this.bombLevel();
			this.resetImage(this.battleObject().movingImage);
			AudioManager.playNormalSe("lily_bomb_boom");
			this._removeCounter = this.getAllFrameTime(ImageFrame.info(this.battleObject().movingImage)) - 1;
			const vertices = this.currentBoomAttackVertices();
			const hit = {
				vertices:vertices
				, onHit:{
					staggerTime:this.currentBoomStaggerTime()
					, shake:0
					, pauseTime:0
					, damage:this.currentBoomAttackPower()
					, fx:0
					, fy:0
					, sfx:0
					, sfy:0
					, refresh_air:false
			}};
			this._boomBodyHit = new Game_BodyHit(hit);
		}
	}
	if(this._hasBoom) {
		this.vx = this.vy = 0;
		this.updateBoomAttack();
	}
};

Game_LilyBomb.prototype.updateBoomAttack = function() {
	if(this._removeCounter > 8 && !this._owner.isDeath()) {
		this.bodyAttackHit(this._boomBodyHit);
	}
};

Game_LilyBomb.prototype.isBoom = function() {
	if(this._bombLevel === 0) {
		return true;
	}
	this.setImmueVground(true);
	this._physicsFlag = 7;
	const result = !!this.hitPreview(0, this.vy);
	this._physicsFlag = 5;
	return result;
};

function Game_LilyBombPartner() {
	this.initialize(...arguments);
}

Game_LilyBombPartner.prototype = Object.create(Game_LilyBomb.prototype);
Game_LilyBombPartner.prototype.constructor = Game_LilyBombPartner;

Game_LilyBombPartner.prototype.initialize = function() {
	Game_LilyBomb.prototype.initialize.apply(this, arguments);
	this._bombLevel = 6;
	this._battleTeam = -1;
};

Game_LilyBombPartner.prototype.initBomb = function(event) {
	Game_LilyBomb.prototype.initBomb.apply(this, arguments);
	this.vx = event.direction() === 4 ? -3 : 3;
};

Game_LilyBombPartner.prototype.initBombWall = function(event) {
	this.initBomb(event);
	this.px = this.rx = 240;
	this._battleTeam = 1;
};

Game_LilyBombPartner.prototype.battleTeam = function() {
	return this._hasBoom ? 0 : this._battleTeam;
};

Game_LilyBombPartner.prototype.isBoom = function() {
	if(this._bombLevel === 0) {
		return true;
	}
	if(this.vy < 0) {
		return false;
	}
	return !!this.hitPreview(0, this.vy + 1);
};

Game_LilyBombPartner.prototype.beHit = function() {
	Game_LilyBomb.prototype.beHit.apply(this, arguments);
	this.makeInvincible(1);
};

Game_LilyBombPartner.prototype.updateBoom = function() {
	if(!this._hasBoom) {
		this._hasBoom = this.isBoom();
		if(this._hasBoom) {
			this.lockSkillInvincible();
			this.px = this.rx = this.px + this.vx;
			const baseOffsetX = 8;
			const baseOffsetY = 184;
			this.px = this.rx = this.px + baseOffsetX * this.bombLevel();
			this.py = this.ry = this.py + baseOffsetY * this.bombLevel();
			this.resetImage(this.battleObject().movingImage);
			AudioManager.playNormalSe("lily_bomb_boom");
			this._removeCounter = this.getAllFrameTime(ImageFrame.info(this.battleObject().movingImage)) - 1;
			const vertices = this.currentBoomAttackVertices();
			const hit = {
				vertices:vertices
				, onHit:{
					staggerTime:this.currentBoomStaggerTime()
					, shake:0
					, pauseTime:0
					, damage:this.currentBoomAttackPower()
					, fx:0
					, fy:0
					, sfx:0
					, sfy:0
					, refresh_air:false
			}};
			this._boomBodyHit = new Game_BodyHit(hit);
		}
	}
	if(this._hasBoom) {
		this.vx = this.vy = 0;
		this.updateBoomAttack();
	}
};

// 莉莉亚的剑气
// 初始速度快，速度越打越慢
function Game_LilyProp() {
	this.initialize(...arguments);
}

Game_LilyProp.prototype = Object.create(Game_CharacterBase.prototype);
Game_LilyProp.prototype.constructor = Game_LilyProp;

Game_LilyProp.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.apply(this, arguments);
	this._physicsFlag = 3;
	this._speedLevel = 2;		// 速度等级，越打越小
	if($gameSystem.difficulty() === 1) {
		this._speedLevel = 3;
	}
	this._owner = null;
	this._propBodyHit = null;
	this._removeCounter = 600;
	this._fadeOutCounter = 45;
	this._battleObject = null;
	this._physics = true;
	this.setAirFriction(0);
};

Game_LilyProp.prototype.setupOwner = function(event) {
	this._owner = event;
	this.initBattleObject();
	this.setImage(this.battleObject().standingImage);
	this.setVertices(this.currentVertices());
	const ox = event.direction() === 4 ? -60 : 60;
	const oy = -120;
	this.rx = this.px = event.px + ox;
	this.ry = this.py = event.py + oy;
	this.setDirection(event.direction());
	
	const hit = {
		vertices:this.currentVertices()
		, onHit:{
			staggerTime:35
			, shake:0
			, pauseTime:0
			, damage:this.currentPropAttackPower()
			, fx:0
			, fy:0
			, sfx:0
			, sfy:0
			, refresh_air:false
		}};
	this._propBodyHit = new Game_BodyHit(hit);
};

Game_LilyProp.prototype.currentVertices = function() {
	return [{"x":-20,"y":-260},{"x":40,"y":-260},{"x":128,"y":-160},{"x":128,"y":-112},{"x":100,"y":-16},{"x":-24,"y":172},{"x":-124,"y":260},{"x":-84,"y":-160},{"x":-56,"y":-228}];
};

Game_LilyProp.prototype.battleObject = function() {
	return this._battleObject;
};

Game_LilyProp.prototype.initBattleObject = function() {
	const templateId = 38;
	this._battleObject = new Game_BattleObject(templateId);
};

Game_LilyProp.prototype.battleTeam = function() {
	return this._speedLevel === 0 ? $gamePlayer.battleTeam() : this._owner.battleTeam();
};

Game_LilyProp.prototype.currentPropAttackPower = function() {
	return 15;
};

Game_LilyProp.prototype.doPState = function() {
	Game_CharacterBase.prototype.doPState.call(this);
	this.adjustPropSpeed();
	this.determinePropDestroy();
	this.updatePropAttack();
	this.updateFastMoveEffectStart();
};

Game_LilyProp.prototype.updateFastMoveEffectStart = function() {
	if(this._removeCounter < 598) {
		this.setFastMoveEffect(true);
	}
};

Game_LilyProp.prototype.adjustPropSpeed = function() {
	if(!this.noControlTime() && !this.isStagger() || this._speedLevel === 0) {
		const sign = Utils.boolSign(this.direction() === 6);
		let speedBase = 12;
		if(this._speedLevel === 3) {
			speedBase = 12;
		} else if(this._speedLevel === 2) {
			speedBase = 8;
		} else if(this._speedLevel === 1) {
			speedBase = 4;
		}
		if($gameSystem.difficulty() === -1) {
			speedBase -= 2;
		}
		this.vx = sign * speedBase;
	}
	this.vy = 0;
	this.suspendGravity();
};

Game_LilyProp.prototype.determinePropDestroy = function() {
	if(this._removeCounter) {
		this._removeCounter--;
	}
	if(this._removeCounter <= 0) {
		if(this._fadeOutCounter > 0) {
			this._fadeOutCounter--;
			this.setOpacity(Math.trunc(this._fadeOutCounter / 45 * 255));
			return;
		}
		this.requestRemove();
	}
};

Game_LilyProp.prototype.beHit = function() {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	this._speedLevel--;
	if(this._speedLevel === 0) {
		this.lockInvincible();
		this.setDirection(this.direction() === 4 ? 6 : 4);
	}
};


Game_LilyProp.prototype.updatePropAttack = function() {
	this.bodyAttackHit(this._propBodyHit);
};

function Game_LilyPropPartner() {
	this.initialize(...arguments);
}

Game_LilyPropPartner.prototype = Object.create(Game_LilyProp.prototype);
Game_LilyPropPartner.prototype.constructor = Game_LilyPropPartner;

Game_LilyPropPartner.prototype.initialize = function() {
	Game_LilyProp.prototype.initialize.apply(this, arguments);
	this._speedLevel = 3;
	this.lockInvincible();
};

// 莉莉亚的平底锅-作为独立单位时
function Game_LilyPan() {
	this.initialize(...arguments);
}

Game_LilyPan.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_LilyPan.prototype.constructor = Game_LilyPan;

Game_LilyPan.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.apply(this, arguments);
	this.m = 1;
	this.setFriction(3);
	this.setAirFriction(3);
	this._owner = null;
	this._physicsFlag = 5;
};

Game_LilyPan.prototype.battleObjectId = function() {
	return 85;
};

Game_LilyPan.prototype.setupOwner = function(character) {
	this._owner = character;
	this.resetPosToOwner();
	this._owner.battleObject().addBuff("hp_resume", 9999999, 4 / 60, true);
	this._owner.battleObject().addBuff("def_up", 9999999, 0.5, true);
};

Game_LilyPan.prototype.resetPosToOwner = function() {
	this.px = this._owner.px;
	this.py = this._owner.py - this._owner.hitOffsetT();
};

Game_LilyPan.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	this.suspendGravity();
	if(this.isStagger()) {
		return;
	}
	if(!this.isBodyAttacking()) {
		if(!this.noControlTime()) {
			this.controlMove();
		}
		this.controlAttack();
	} else {
		this.vx = this.vy = 0;
	}
	const info = AttackFrame.info("lily_pan_summon");
	if(this._owner.isDeath()) {
		this.battleObject().hp = 0;
	} else {
		this._owner.setCD("lily_pan_summon", info.cd);
		this._owner.requestAnimation(22, {unique:true, physicsPosition:true});
	}
};

Game_LilyPan.prototype.controlMove = function() {
	const thresholds = 72;
	const target = 0;
	const v = 2;
	this.vx = this.vy = 0;
	if(Math.abs(this.px - $gamePlayer.px) > thresholds) {
		this.vx = v * Utils.sign($gamePlayer.px - this.px);
	}
	if(Math.abs(this.py - $gamePlayer.py) > thresholds) {
		this.vy = v * Utils.sign($gamePlayer.py - this.py);
	}
};

Game_LilyPan.prototype.controlAttack = function() {
	const distanceY = this.py - $gamePlayer.py;
	const distanceX = Math.abs(this.px - $gamePlayer.px);
	if(distanceY > -96 && distanceY < 48 && distanceX < 128 && !this.isAttackCD("lily_pan_normal") && !$gamePlayer.isInvincible()) {
		this.faceToPlayer();
		if(this.requestBodyAttack("lily_pan_normal")) {
			this.reduceAttackCD(180);
		}
	}
};

Game_LilyPan.prototype.beHit = function() {
	Game_CharacterDynamicCreate.prototype.beHit.apply(this, arguments);
	this.ownerEnterWeak();
};

Game_LilyPan.prototype.ownerEnterWeak = function() {
	if(this.isDeath() && !this._owner.isDeath() && this._owner._bodyAttacking !== "lily_weak") {
		this._owner.battleObject().delBuff("hp_resume");
		this._owner.battleObject().delBuff("def_up");
		this._owner.clearStagger();
		this._owner.setPstate(0);
		this._owner.requestBodyAttack("lily_weak");
		this._owner.battleObject().addBuff("anti_stagger", this._owner._attackingCounter, 1, true);
	}
};

function Game_LilySeaBomb() {
	this.initialize(...arguments);
}

Game_LilySeaBomb.prototype = Object.create(Game_LilyBomb.prototype);
Game_LilySeaBomb.prototype.constructor = Game_LilySeaBomb;

Game_LilySeaBomb.prototype.initialize = function() {
	Game_LilyBomb.prototype.initialize.call(this);
	const difficulty = $gameSystem.difficulty();
	this._bombLevel = difficulty === 1 ? 5 : (difficulty === -1 ? 3 : 4);
	this._startCounter = 0;
	this._dirX = 0;
	this._dirY = 0;
	this._checkBombVertices = null;
	this.setFriction(0);
	this.setAirFriction(0);
	this.suspendFriction();
	this.lockInvincible();
};

Game_LilySeaBomb.prototype.initBattleObject = function() {
	const templateId = 86;
	this._battleObject = new Game_BattleObject(templateId);
};

Game_LilySeaBomb.prototype.doPState = function() {
	Game_LilyBomb.prototype.doPState.apply(this, arguments);
	if(!this.isStarted()) {
		this._startCounter++;
		if(this.isStarted()) {
			this.unlockInvincible();
			$gameTemp.requestRemoveAnimation([this], 43);
		} else {
			this.requestAnimation(43, {physicsPosition:true, unique:true, scale:this._bombLevel / 2.5});
		}
	}
	if(this._owner.isDeath() && !this._hasBoom) {
		this.requestRemove();
	}
};

Game_LilySeaBomb.prototype.isStarted = function() {
	return this._startCounter >= 120;
};

Game_LilySeaBomb.prototype.adjustBombSpeed = function() {
	this.suspendGravity();
	if(!this.isStarted()) {
		this.vx = this.vy = 0;
	}
	else if(!this._hasBoom && !this.isStagger() && !this.noControlTime()) {
		if(this._impact && this._impact.terrain) {
			if(this._impactDirection === 0) {
				this._dirX = -this._dirX;
			} else if(this._impactDirection === 1) {
				this._dirY = -this._dirY;
			}
		}
		const difficulty = $gameSystem.difficulty();
		const d = this.baseSpeed();
		this.vx = d * this._dirX;
		this.vy = d * this._dirY;
	}
};

Game_LilySeaBomb.prototype.isBoom = function() {
	if(!this.isStarted()) {
		return false;
	}
	const flag = this._physicsFlag;
	this._physicsFlag = 0;
	const result = this.hitTest($gamePlayer);
	this._physicsFlag = flag;
	return result && !$gamePlayer.isVisibleInvincible();
};

Game_LilySeaBomb.prototype.adjustInitPosition = function() {
	const event = this._owner;
	this.px = this.rx = event.px;
	this.py = this.ry = event.py - event.hitOffsetT() - this.hitOffsetB() - 1;
};

Game_LilySeaBomb.prototype.initBomb = function(event) {
	Game_LilyBomb.prototype.initBomb.call(this, event);
	this._dirX = Utils.sign($gamePlayer.px - event.px);
	this._dirY = -1;
	this.adjustBombSpeed();
};

Game_LilySeaBomb.prototype.baseSpeed = function() {
	const difficulty = $gameSystem.difficulty();
	return difficulty === 1 ? 10 : (difficulty === -1 ? 6 : 8);
};

Game_LilySeaBomb.prototype.beHit = function() {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	if(this.isStagger()) {
		return;
	}
	const d = this.baseSpeed();
	const dx = this._dirX * d;
	const dy = this._dirY * d;
	if(this._dirY * (this.vy - dy) < 0) {
		this._dirY = -this._dirY;
	} else if(this._dirX * (this.vx - dx) < 0) {
		this._dirX = -this._dirX;
	}
};

Game_LilySeaBomb.prototype.updateBoom = function() {
	if(!this._hasBoom) {
		this._hasBoom = this.isBoom();
		if(this._hasBoom) {
			const baseOffsetX = 0;
			const baseOffsetY = 184;
			this.px = this.rx = this.px + baseOffsetX * this.bombLevel();
			this.py = this.ry = this.py + baseOffsetY * this.bombLevel();
			this.resetImage(this.battleObject().movingImage);
			AudioManager.playNormalSe("lily_bomb_boom");
			this._removeCounter = this.getAllFrameTime(ImageFrame.info(this.battleObject().movingImage)) - 1;
			const vertices = this.currentBoomAttackVertices();
			const hit = {
				vertices:vertices
				, onHit:{
					staggerTime:this.currentBoomStaggerTime()
					, shake:0
					, pauseTime:0
					, damage:this.currentBoomAttackPower()
					, fx:0
					, fy:0
					, sfx:0
					, sfy:0
					, refresh_air:false
			}};
			this._boomBodyHit = new Game_BodyHit(hit);
		}
	}
	if(this._hasBoom) {
		this.vx = this.vy = 0;
		this.updateBoomAttack();
	}
};

function Game_LilyBubble() {
	this.initialize(...arguments);
}

Game_LilyBubble.prototype = Object.create(Game_CharacterBase.prototype);
Game_LilyBubble.prototype.constructor = Game_LilyBubble;

Game_LilyBubble.prototype.initialize = function() {
	Game_CharacterBase.prototype.initialize.call(this);
	this._battleObject = null;
	this._physics = true;
	this._statemMembers = {};
	this._statemMembers.destroyTime = 150;
	this._statemMembers.hasBuffEventIds = [];
	this._isStarting = true;
	this.lockInvincible();
	this.setScale(0);
};

Game_LilyBubble.prototype.initPosition = function(x, y) {
	this.px = this.rx = x;
	this.py = this.ry = this._statemMembers.py = y;
	this.initBattleObject();
};

Game_LilyBubble.prototype.battleObject = function() {
	return this._battleObject;
};

Game_LilyBubble.prototype.initBattleObject = function() {
	this._battleObject = new Game_BattleObject(88);
	this._physicsFlag = this._battleObject.physicsFlag || 0;
	this._lighting = this._battleObject.lighting;
	this.setVertices([{"x":14,"y":-71},{"x":40,"y":-60},{"x":60,"y":-40},{"x":71,"y":-14},{"x":71,"y":14},{"x":60,"y":40},{"x":40,"y":60}
	,{"x":14,"y":71},{"x":-14,"y":71},{"x":-40,"y":60},{"x":-60,"y":40},{"x":-71,"y":14},{"x":-71,"y":-14},{"x":-60,"y":-40},{"x":-40,"y":-60},{"x":-14,"y":-71}]);
};

Game_LilyBubble.prototype.doPStateChange = function() {
	Game_CharacterBase.prototype.doPStateChange.apply(this, arguments);
	this.baseDoPStateChange(...arguments);
};

Game_LilyBubble.prototype.doPState = function() {
	Game_CharacterBase.prototype.doPState.apply(this, arguments);
	const members = this._statemMembers;
	if(!this.isDeath()) {
		if(members.destroyTime < 150) {
			this.setPstate(1);
		} else {
			this.setPstate(0);
		}
	} else {
		this.requestRemove();
	}
};

Game_LilyBubble.prototype.requestRemove = function() {
	Game_CharacterBase.prototype.requestRemove.call(this);
};

Game_LilyBubble.prototype.detectState = function() {
	Game_CharacterBase.prototype.detectState.apply(this, arguments);
	this.suspendGravity();
	this.vx = this.vy = 0;
	const members = this._statemMembers;
	if(this._isStarting) {
		const scale = this.scale() + 0.02;
		if(scale >= 1) {
			this.setScale(1);
			this._isStarting = false;
			this.unlockInvincible();
			this.py = this.ry = members.py;
		} else {
			this.setScale(scale);
			this.py = this.ry = members.py - Math.round(this.patternHeight() / 2 * (1-scale));
		}
		return;
	}
	const flag = this._physicsFlag;
	this._physicsFlag = 0;
	const hit = this.hitPreview(0, 0);
	this._physicsFlag = flag;
	if(hit) {
		let availHit = false;
		for(const obj of hit) {
			if(obj.battleObject() && !obj.battleObject().unlimitHp) {
				availHit = true;
				obj.requestStagger(2);
				obj.px = this.px;
				const cycle = 20;
				const timeCycle = members.destroyTime % cycle;
				const sign = Utils.sign(timeCycle - cycle / 2);
				this.py = members.py + sign * (timeCycle - cycle / 2);
				obj.py = this.py + (obj.hitOffsetB() + obj.hitOffsetT()) / 2;
				if(!members.hasBuffEventIds.includes(obj.eventId())) {
					members.hasBuffEventIds.push(obj.eventId());
					obj.battleObject().addBuff("unvisible_invincible", 150, 1, true);
				}
			}
		}
		if(availHit) {
			if(members.destroyTime === 150) {
				AudioManager.playPlayerRoundSe(this, "bubble_in");
			}
			members.destroyTime--;
		}
	} else if(members.destroyTime < 150) {
		members.destroyTime--;
	}
	if(members.destroyTime <= 0) {
		this.battleObject().hp = 0;
	}
};

Game_LilyBubble.prototype.beHit = function(playSe, damage, src) {
	Game_CharacterBase.prototype.beHit.apply(this, arguments);
	if(src.constructor === Game_LilyProp) {
		this._battleObject._hp = 1;
		this.clearStagger();
	}
};

// 与boss版本的区别：到一定时间自动爆炸，不再受难度控制，适用最高难度的属性
function Game_LilySeaBombPartner() {
	this.initialize(...arguments);
}

Game_LilySeaBombPartner.prototype = Object.create(Game_LilySeaBomb.prototype);
Game_LilySeaBombPartner.prototype.constructor = Game_LilySeaBombPartner;

Game_LilySeaBombPartner.prototype.initialize = function() {
	Game_LilySeaBomb.prototype.initialize.apply(this, arguments);
	this._boomLeftTime = 1200;
	this._bombLevel = 5;
};

Game_LilySeaBombPartner.prototype.doPState = function() {
	Game_LilySeaBomb.prototype.doPState.apply(this, arguments);
	if(this._boomLeftTime > 0) {
		this._boomLeftTime--;
	}
};

Game_LilySeaBombPartner.prototype.baseSpeed = function() {
	return 10;
};

Game_LilySeaBombPartner.prototype.isBoom = function() {
	if(!this.isStarted()) {
		return false;
	}
	if(this._boomLeftTime === 0) {
		return true;
	}
	const flag = this._physicsFlag;
	this._physicsFlag = 0;
	const result = this.hitPreview(0, 0);
	this._physicsFlag = flag;
	return !!result;
};

Game_LilySeaBombPartner.prototype.battleTeam = function() {
	return this._hasBoom ? 0 : -1;
};

// 贴着地面运动的铁饼
// (朝向为4的情况)运行方向逆时针旋转90度的方向移动1像素，如果有碰撞判定，则继续往运行方向移动
// 否则往碰撞判定的方向运动
// 如果运行方向遇到阻挡，把运行方向修改为当前运行方向的顺时针90度，朝向为6则顺时针和逆时针要反过来
function Game_IronPie() {
	this.initialize(...arguments);
}

Game_IronPie.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_IronPie.prototype.constructor = Game_IronPie;

Game_IronPie.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.call(this);
	this._runningDirection = 0;			// 0-0点方向，1-3点方向，2-6点方向，3-9点方向
	this._physicsFlag = 8;
	this.setVertices([{"x":6,"y":-32},{"x":18,"y":-27},{"x":27,"y":-18},{"x":32,"y":-6},{"x":32,"y":6},{"x":27,"y":18},{"x":18,"y":27},{"x":6,"y":32},{"x":-6,"y":32},{"x":-18,"y":27},{"x":-27,"y":18},{"x":-32,"y":6},{"x":-32,"y":-6},{"x":-27,"y":-18},{"x":-18,"y":-27},{"x":-6,"y":-32}]);
	this.maxExistTime = 1200;
};

Game_IronPie.prototype.battleObjectId = function() {
	return 90;
};

Game_IronPie.prototype.setRunningDirection = function(dir) {
	this._runningDirection = dir;
};

Game_IronPie.prototype.changeRunningDirection = function() {
	if(this.direction() === 4) {
		switch(this._runningDirection) {
			case 0: return 1;
			case 1: return 2;
			case 2: return 3;
			case 3: return 0;
			default: return 0;
		}
	} else {
		switch(this._runningDirection) {
			case 0: return 3;
			case 1: return 0;
			case 2: return 1;
			case 3: return 2;
			default: return 0;
		}
	}
};

Game_IronPie.prototype.changeReverseRunningDirection = function() {
	if(this.direction() !== 4) {
		switch(this._runningDirection) {
			case 0: return 1;
			case 1: return 2;
			case 2: return 3;
			case 3: return 0;
			default: return 0;
		}
	} else {
		switch(this._runningDirection) {
			case 0: return 3;
			case 1: return 0;
			case 2: return 1;
			case 3: return 2;
			default: return 0;
		}
	}
};

Game_IronPie.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.call(this, arguments);
	this.suspendGravity();
	this.suspendFriction();
	if(!this.isAttackOutControl() && !this.noControlTime()) {
		this.updateRunningDirection();
		this.requestBodyAttack("iron_pie_attack");
	}
	this.updateOutOfBoundDestroy();
	this.setRotation(this.rotation() + 0.5 * Utils.sign(this.direction() === 6));
	if(this.maxExistTime) {
		this.maxExistTime--;
	} else {
		this.requestRemove();
	}
};

Game_IronPie.prototype.updateOutOfBoundDestroy = function() {
	if(this.py - this.hitOffsetT() >= $gameMap.height() * $gameMap.tileHeight() || this.py + this.hitOffsetB() < 0) {
		this.requestRemove();
	}
};

Game_IronPie.prototype.updateSpecialGrounding = function() {
};
// 当前运行方向的XY轴方向量
Game_IronPie.prototype.frontDirX = function() {
	switch(this._runningDirection) {
		case 1: return 1;
		case 3: return -1;
		default: return 0;
	}
};

Game_IronPie.prototype.frontDirY = function() {
	switch(this._runningDirection) {
		case 2: return 1;
		case 0: return -1;
		default: return 0;
	}
};
// 顺时针旋转当前运行方向
Game_IronPie.prototype.frontRotationDirX = function() {
	switch(this._runningDirection) {
		case 0: return 1;
		case 2: return -1;
		default: return 0;
	}
};

Game_IronPie.prototype.frontRotationDirY = function() {
	switch(this._runningDirection) {
		case 1: return 1;
		case 3: return -1;
		default: return 0;
	}
};
// 逆时针旋转当前运行方向
Game_IronPie.prototype.frontReverseRotationDirX = function() {
	return -this.frontRotationDirX();
};

Game_IronPie.prototype.frontReverseRotationDirY = function() {
	return -this.frontRotationDirY();
};

Game_IronPie.prototype.updateRunningDirection = function() {
	const speed = this.battleObject().maxMoveSpeed;
	const dx = this.frontDirX() * speed;
	const dy = this.frontDirY() * speed;
	const groundingTestX = (this.direction() === 6 ? this.frontRotationDirX() : this.frontReverseRotationDirX()) * speed;
	const groundingTestY = (this.direction() === 6 ? this.frontRotationDirY() : this.frontReverseRotationDirY()) * speed;
	
	const groundHitObjs = this.hitPreview(groundingTestX, groundingTestY);
	if(groundHitObjs) {
		const frontHitObjs = this.hitPreview(dx, dy);
		if(!frontHitObjs) {
			this.vx = dx;
			this.vy = dy;
		} else {
			this.setRunningDirection(this.changeRunningDirection());
		}
	} else {
		this.vx = groundingTestX;
		this.vy = groundingTestY;
		const backHitObjs = this.hitPreview(-dx, -dy);
		if(backHitObjs) {
			this.setRunningDirection(this.changeReverseRunningDirection());
		}
	}
};

Game_IronPie.prototype.performTerrainDamage = function() {
};

function Game_IronPieThrow() {
	this.initialize(...arguments);
}

Game_IronPieThrow.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_IronPieThrow.prototype.constructor = Game_IronPieThrow;

Game_IronPieThrow.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.call(this);
	this._readyToRemove = false;			// 暂停一帧之后再移除
	this._physicsFlag = 8;
	this.maxExistTime = 1200;
	this.setVertices([{"x":6,"y":-32},{"x":18,"y":-27},{"x":27,"y":-18},{"x":32,"y":-6},{"x":32,"y":6},{"x":27,"y":18},{"x":18,"y":27},{"x":6,"y":32},{"x":-6,"y":32},{"x":-18,"y":27},{"x":-27,"y":18},{"x":-32,"y":6},{"x":-32,"y":-6},{"x":-27,"y":-18},{"x":-18,"y":-27},{"x":-6,"y":-32}]);
};

Game_IronPieThrow.prototype.battleObjectId = function() {
	return 90;
};

Game_IronPieThrow.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.call(this, arguments);
	this.suspendFriction();
	if(this._readyToRemove) {
		this.requestRemove();
		return;
	}
	if(!this.isAttackOutControl() && !this.noControlTime()) {
		this.updatePosition();
		this.requestBodyAttack("iron_pie_attack");
		if(this.isGrounding()) {
			this._readyToRemove = true;
			const left = new Game_IronPie();
			const right = new Game_IronPie();
			left.setRunningDirection(3);
			left.setDirection(4);
			right.setRunningDirection(1);
			right.setDirection(6);
			left.px = right.px = this.px;
			left.py = right.py = this.py;
			$gameMap.createCharacter(left);
			$gameMap.createCharacter(right);
		}
	}
	if(this.maxExistTime) {
		this.maxExistTime--;
	} else {
		this.requestRemove();
	}
};

Game_IronPieThrow.prototype.updatePosition = function() {
	this.updateMoveSimple(this.direction() === 4); 
};

Game_IronPieThrow.prototype.shouldUseImmuePhysicsObject = function() {
	return true;
};

Game_IronPieThrow.prototype.performTerrainDamage = function() {
};

function Game_SmallBomb() {
	this.initialize(...arguments);
}

Game_SmallBomb.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_SmallBomb.prototype.constructor = Game_SmallBomb;

Game_SmallBomb.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.call(this);
	this._physicsFlag = 5;
	this._hasBoom = false;
	this._bodyHit = null;
	this._boomRemoveCounter = 20;
	this.setVertices([{"x":-4,"y":-16},{"x":4,"y":-16},{"x":8,"y":-6},{"x":-8,"y":20},{"x":-18,"y":20},{"x":-22,"y":16}]);
	this._elasticBeforeBoom = 4;
};

Game_SmallBomb.prototype.battleObjectId = function() {
	return 95;
};

Game_SmallBomb.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	if(this._hasBoom) {
		this.vx = this.vy = 0;
		this.updateBoom();
	}
};

Game_SmallBomb.prototype.beHit = function() {
	Game_CharacterDynamicCreate.prototype.beHit.apply(this, arguments);
	this.requestBomb();
};

Game_SmallBomb.prototype.requestBomb = function() {
	this.battleObject().standingImage = this.battleObject().movingImage = this.battleObject().staggerImage = "";
	this.requestAnimation(46, {physicsPosition:true, z:7});
	this._hasBoom = true;
	const hit = {
		vertices:[{"x":19,"y":-94},{"x":53,"y":-80},{"x":80,"y":-53},{"x":94,"y":-19},{"x":94,"y":19},{"x":80,"y":53},{"x":53,"y":80},{"x":19,"y":94},{"x":-19,"y":94},{"x":-53,"y":80},{"x":-80,"y":53},{"x":-94,"y":19},{"x":-94,"y":-19},{"x":-80,"y":-53},{"x":-53,"y":-80},{"x":-19,"y":-94}]
		, onHit:{
			staggerTime:35
			, shake:0
			, pauseTime:0
			, damage:14
			, fx:0
			, fy:0
			, sfx:0
			, sfy:0
			, refresh_air:false
	}};
	AudioManager.playPlayerRoundSe(this, "lily_bomb_boom");
	this._boomBodyHit = new Game_BodyHit(hit);
	this.lockSkillInvincible();
};

Game_SmallBomb.prototype.doSpecialElastic = function() {
	Game_CharacterDynamicCreate.prototype.doSpecialElastic.apply(this, arguments);
	this._elasticBeforeBoom--;
	if(this._elasticBeforeBoom === 1) {
		this.battleObject().standingImage = this.battleObject().movingImage = this.battleObject().staggerImage = ";small_bomb_caution";
		this.resetImage(this.battleObject().standingImage);
	} else if(this._elasticBeforeBoom === 0) {
		this.requestBomb();
	}
};

Game_SmallBomb.prototype.updateBoom = function() {
	if(this._boomRemoveCounter) {
		this._boomRemoveCounter--;
		if(this._boomRemoveCounter < 17) {
			this.updateBoomAttack();
		}
	} else {
		this.requestRemove();
	}
};

Game_SmallBomb.prototype.updateBoomAttack = function() {
	this.bodyAttackHit(this._boomBodyHit);
};


function Game_BerriesStone() {
	this.initialize(...arguments);
}

Game_BerriesStone.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_BerriesStone.prototype.constructor = Game_BerriesStone;

Game_BerriesStone.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.call(this);
	this._physicsFlag = 3;
	this._startCounter = 0;
	const hit = {
		vertices:[{"x":25,"y":0},{"x":25,"y":-80},{"x":-25,"y":-80},{"x":-25,"y":0}]
		, onHit:{
			staggerTime:35
			, shake:0
			, pauseTime:0
			, damage:12
			, fx:0
			, fy:0
			, sfx:0
			, sfy:0
			, refresh_air:false
	}};
	this._stoneBodyHit = new Game_BodyHit(hit);
	this.lockInvincible();
};

Game_BerriesStone.prototype.battleObjectId = function() {
	return 110;
};

Game_BerriesStone.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	if(this._startCounter > this.startTime() && !this.isDeath()) {
		this.bodyAttackHit(this._stoneBodyHit);
		this._vy += this.accerateY();
		this._vy = Math.min(this.maxY(), this._vy);
		this.vx = 0;
	} else if(this._startCounter === this.startTime() && !this.isDeath()) {
		this.unlockInvincible();
		this.battleObject().standingImage = this.battleObject().movingImage = this.battleObject().staggerImage = ";berries_stone1";
		this.resetImage(this.battleObject().standingImage);
		this.py = this.ry = 48;
	} else {
		this.vx = this.vy = 0;
	}
	if(this._startCounter === 600) {
		this.requestRemove();
	}
	this._startCounter++;
};

Game_BerriesStone.prototype.startTime = function() {
	if($gameSystem.difficulty() === -1) {
		return 75;
	} else if($gameSystem.difficulty() === 0) {
		return 60;
	} else {
		return 45;
	}
};

Game_BerriesStone.prototype.accerateY = function() {
	if($gameSystem.difficulty() === -1) {
		return 0.15;
	} else if($gameSystem.difficulty() === 0) {
		return 0.18;
	} else {
		return 0.2;
	}
};

Game_BerriesStone.prototype.maxY = function() {
	if($gameSystem.difficulty() === -1) {
		return 8;
	} else if($gameSystem.difficulty() === 0) {
		return 10;
	} else {
		return 12;
	}
};

Game_BerriesStone.prototype.screenZ = function() {
	return 5;
};

function Game_BallLighting() {
	this.initialize(...arguments);
}

Game_BallLighting.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_BallLighting.prototype.constructor = Game_BallLighting;

Game_BallLighting.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.call(this);
	this._physicsFlag = 5;
	this._runningSignX = 0;
	this._runningSignY = 1;
	this._isMagnet = false;
	this._magnetTime = 0;
	this._shouldPlaySe = false;
};

Game_BallLighting.prototype.shouldPlaySe = function() {
	return this._shouldPlaySe;
};

Game_BallLighting.prototype.battleObjectId = function() {
	return 111;
};

Game_BallLighting.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	this.suspendGravity();
	if(!this._isMagnet) {
		this.vx = this._runningSignX * this.battleObject().maxMoveSpeed;
		this.vy = this._runningSignY * this.battleObject().maxMoveSpeed;
		if(this.impactObject() && this.impactObject().terrain) {
			this._isMagnet = true;
			this.battleObject().standingImage = this.battleObject().movingImage = this.battleObject().staggerImage = ";berries_em_field";
			this.resetImage(this.battleObject().standingImage);
			this.setScale(2);
			this.rx = this.px = this.px;
			this.ry = this.py = this.py + 80;
			this.setVertices([{"x":36,"y":-135},{"x":99,"y":-99},{"x":135,"y":-36},{"x":135,"y":36},{"x":99,"y":99},{"x":36,"y":135}
			,{"x":-36,"y":135},{"x":-99,"y":99},{"x":-135,"y":36},{"x":-135,"y":-36},{"x":-99,"y":-99},{"x":-36,"y":-135}]);
			this.lockInvincible();
			AudioManager.playPlayerRoundSe(this, "Thunder11");
		}
		if(this.py < -120) {
			this.requestRemove();
		}
	} else {
		this.vx = this.vy = 0;
		this._magnetTime++;
		this.updateMagnetStagger();
		if(this._magnetTime < 180) {
		} else if(this._magnetTime === 180) {
			this.requestRemove();
		}
	}
};

Game_BallLighting.prototype.beHit = function() {
	Game_CharacterDynamicCreate.prototype.beHit.apply(this, arguments);
	if(this._runningSignX !== 0) {
		if(this.vx !== 0 && Utils.sign(this.vx) !== this._runningSignX) {
			this._runningSignX = Utils.sign(this.vx);
		} else if(this.vy !== 0) {
			this._runningSignY = Utils.sign(this.vy);
			this._runningSignX = 0;
		}
	} else if(this._runningSignY !== 0) {
		if(this.vy !== 0 && Utils.sign(this.vy) !== this._runningSignY) {
			this._runningSignY = Utils.sign(this.vy);
		} else if(this.vx !== 0) {
			this._runningSignX = Utils.sign(this.vx);
			this._runningSignY = 0;
		}
	}
};

Game_BallLighting.prototype.updateMagnetStagger = function() {
	this._physicsFlag = 4;
	const hit = this.hitPreview(0, -80);
	let shouldPlaySe = false;
	if(hit) {
		for(const obj of hit) {
			if(obj.battleObject() && obj.battleTeam() !== -2) {
				obj.vx = obj.vy = 0;
				obj.battleObject().delBuff("anti_stagger");
				obj.requestStagger(2);
				obj.startShake(1, 25, 2);
				shouldPlaySe = true;
			}
		}
	}
	this._shouldPlaySe = shouldPlaySe;
	this._physicsFlag = 5;
};


Game_BallLighting.prototype.doSpecialElastic = function() {
};

function Game_BerriesSmallBomb() {
	this.initialize(...arguments);
}

Game_BerriesSmallBomb.prototype = Object.create(Game_SmallBomb.prototype);
Game_BerriesSmallBomb.prototype.constructor = Game_BerriesSmallBomb;

Game_BerriesSmallBomb.prototype.initialize = function() {
	Game_SmallBomb.prototype.initialize.call(this);
	this._startCounter = 0;
	this.lockInvincible();
	this._elasticBeforeBoom = 1;
	this.setCommonImage(";berries_lockon");
	this.setTemporaryScreenZ(5);
};

Game_BerriesSmallBomb.prototype.doPState = function() {
	Game_SmallBomb.prototype.doPState.apply(this, arguments);
	if(this._startCounter === this.startTime() && !this.isDeath()) {
		this.unlockInvincible();
		this.clearTemporaryScreenZ();
		this.setCommonImage(";small_bomb_caution");
		this.py = this.ry = 48;
	} else if(this._startCounter < this.startTime()) {
		this.vx = this.vy = 0;
	}
	this._startCounter++;
};

Game_BerriesSmallBomb.prototype.startTime = function() {
	if($gameSystem.difficulty() === -1) {
		return 75;
	} else if($gameSystem.difficulty() === 0) {
		return 60;
	} else {
		return 45;
	}
};

// 和玩家在同一条Y线上会分裂成一上一下两个Game_WallDivisionBulletFragment
function Game_WallDivisionBullet() {
	this.initialize(...arguments);
}

Game_WallDivisionBullet.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_WallDivisionBullet.prototype.constructor = Game_WallDivisionBullet;

Game_WallDivisionBullet.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.apply(this, arguments);
	this.lockInvincible();
	this.setTemporaryScreenZ(5);
	this._physicsFlag = 7;
};

Game_WallDivisionBullet.prototype.shouldUseImmuePhysicsObject = function() {
	return true;
};

Game_WallDivisionBullet.prototype.battleObjectId = function() {
	return 124;
};

Game_WallDivisionBullet.prototype.dirX = function() {
	return -1;
};

Game_WallDivisionBullet.prototype.dirY = function() {
	return 0;
};

Game_WallDivisionBullet.prototype.immueFixObject = function() {
	return true;
};

Game_WallDivisionBullet.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	this.suspendGravity();
	if(this.isRemove()) {
		return;
	}
	this.updateMove();
	this.updateRemove();
	this.updateAttack();
	this.updateDivision();
};

Game_WallDivisionBullet.prototype.updateMove = function() {
	const ms = this.battleObject().maxMoveSpeed;
	this.vx = this.dirX() * ms;
	this.vy = this.dirY() * ms;
};

Game_WallDivisionBullet.prototype.attackName = function() {
	return "evil_wall_division";
};

Game_WallDivisionBullet.prototype.updateRemove = function() {
	if((this.impactObject() && this.impactObject().constructor === Game_Terrain) || this.px < -this.hitOffsetL() || this.px > this.hitOffsetR() + $gameMap.pixelWidth() || this.py < -this.hitOffsetT() || this.py > $gameMap.pixelHeight() + this.hitOffsetB()) {
		this.requestRemove();
	}
};

Game_WallDivisionBullet.prototype.updateDivision = function() {
	const threshold = 12;
	if(Math.abs(this.px - $gamePlayer.px) <= threshold) {
		this.makeDivision();
		this.requestRemove();
	}
};

Game_WallDivisionBullet.prototype.makeDivision = function() {
	const up = new Game_WallDivisionBulletFragment();
	up.setDirY(-1);
	up.px = up.rx = this.px;
	up.py = up.ry = this.py;
	$gameMap.createCharacter(up);
	const down = new Game_WallDivisionBulletFragment();
	down.px = down.rx = this.px;
	down.py = down.ry = this.py;
	down.setDirY(1);
	$gameMap.createCharacter(down);
	AudioManager.playPlayerRoundSe(this, "wall_bullet_division");
};

Game_WallDivisionBullet.prototype.updateAttack = function() {
	this.requestBodyAttack(this.attackName());
};

function Game_WallDivisionBulletFragment() {
	this.initialize(...arguments);
}

Game_WallDivisionBulletFragment.prototype = Object.create(Game_WallDivisionBullet.prototype);
Game_WallDivisionBulletFragment.prototype.constructor = Game_WallDivisionBulletFragment;

Game_WallDivisionBulletFragment.prototype.initialize = function() {
	Game_WallDivisionBullet.prototype.initialize.apply(this, arguments);
	this._dirY = 0;
};

Game_WallDivisionBulletFragment.prototype.battleObjectId = function() {
	return 125;
};

Game_WallDivisionBulletFragment.prototype.dirX = function() {
	return 0;
};

Game_WallDivisionBulletFragment.prototype.dirY = function() {
	return this._dirY;
};

Game_WallDivisionBulletFragment.prototype.setDirY = function(y) {
	this._dirY = y;
};

Game_WallDivisionBulletFragment.prototype.attackName = function() {
	return "evil_wall_division_fragment";
};

Game_WallDivisionBulletFragment.prototype.updateDivision = function() {
};

function Game_WallRat() {
	this.initialize(...arguments);
}

Game_WallRat.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_WallRat.prototype.constructor = Game_WallRat;

Game_WallRat.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.apply(this, arguments);
	this._statemMembers = {};
	const members = this._statemMembers;
	Game_Event.prototype.initStatemMembers70.call(this, members);
	this.battleObject().factorA = 1;
	this.setCommonImage(";gray_rat_running");
	this.battleObject().jumpUpImage = this.battleObject().jumpDownImage = ";gray_rat_running";
	this._isRunning = true;
	this._physicsFlag = 5;
	this.lockSkillInvincible();
	this._runningSpeedX = -Utils.randomInt(4, 6) / 2;
	this._runningSpeedY = 3;
	this._bossEventId = 0;
};

Game_WallRat.prototype.battleObjectId = function() {
	return 118;
};

Game_WallRat.prototype.setBossEventId = function(id) {
	this._bossEventId = id;
};

Game_WallRat.prototype.detectState = function() {
	Game_CharacterDynamicCreate.prototype.detectState.apply(this, arguments);
	if(!this._isRunning) {
		const members = this._statemMembers;
		Game_Event.prototype.detectState70.call(this, members);
	}
};

Game_WallRat.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	if($gameMap.event(this._bossEventId).statemMembers().state === 2) {
		this.battleObject().hp = 0;
	}
	if(!this._isRunning) {
		const members = this._statemMembers;
		Game_Event.prototype.doPState70.call(this, members);
	} else {
		this.vx = this._runningSpeedX;
		this.vy = this._runningSpeedY;
		this.suspendGravity();
		if(this.isGrounding()) {
			this._isRunning = false;
			Object.assign(this.battleObject(), {
				standingImage:";gray_rat"
				, movingImage:";gray_rat_move"
				, staggerImage:";gray_rat_stagger"
				, jumpUpImage:";gray_rat"
				, jumpDownImage:";gray_rat"}
			);
			this.setImage(this.battleObject().standingImage);
			this.resumeGravity();
			this.unlockSkillInvincible();
			this._physicsFlag = 0;
		}
	}
};

Game_WallRat.prototype.doPStateChange = function(oldState, newState) {
	Game_CharacterBase.prototype.doPStateChange.apply(this, arguments);
	const members = this._statemMembers;
	Game_Event.prototype.doPStateChange18.call(this, members, oldState, newState);
};

Game_WallRat.prototype.updateJumpCD = function() {
	Game_Event.prototype.updateJumpCD.apply(this, arguments);
};

Game_WallRat.prototype.executeJump3 = function() {
};

Game_WallRat.prototype.screenZ = function() {
	return this._isRunning ? 1 : 5;
};

Game_WallRat.prototype.immueFixObject = function() {
	return true;
};

Game_WallRat.prototype.shouldUseImmuePhysicsObject = function() {
	return true;
};

function Game_WallPurpleFlower() {
	this.initialize(...arguments);
}

Game_WallPurpleFlower.prototype = Object.create(Game_CharacterDynamicCreate.prototype);
Game_WallPurpleFlower.prototype.constructor = Game_WallPurpleFlower;

Game_WallPurpleFlower.prototype.initialize = function() {
	Game_CharacterDynamicCreate.prototype.initialize.apply(this, arguments);
	this._statemMembers = {};
	const members = this._statemMembers;
	members.state = 0;
	members.restartTime = 0;
	members.readyRespawn = false;
	this._physicsFlag = 5;
	this._bossEventId = 0;
	this.setImage(this.battleObject().standingImage);
};

Game_WallPurpleFlower.prototype.battleObjectId = function() {
	return 126;
};

Game_WallPurpleFlower.prototype.setBossEventId = function(id) {
	this._bossEventId = id;
};

Game_WallPurpleFlower.prototype.doPState = function() {
	Game_CharacterDynamicCreate.prototype.doPState.apply(this, arguments);
	this.vx = this.vy = 0;
	const members = this._statemMembers;
	const bossEvent = $gameMap.event(this._bossEventId);
	if(members.state === 0) {
		this.requestBodyAttack("evil_wall_flower");
/* 		if(Graphics.frameCount % 12 === 0) {
			this.requestAnimation(93, {physicsPosition:true});
		} */
		if(this.isLatestHitObject(Game_WallDivisionBulletFragment)) {
			members.restartTime = 0;
			members.state = 1;
			this.lockInvincible();
			this.requestAnimation(88, {physicsPosition:true});
		}
	} else if($gameSystem.difficulty() === 1) {
		const maxTime = 1450;
		if(members.restartTime < maxTime) {
			members.restartTime++;
			this.setSpecProgress(members.restartTime / maxTime);
		} else {
			this.clearSpecProgress();
			this.unlockInvincible();
			members.state = 0;
		}
	} else if(bossEvent.statemMembers().state === 2) {
		members.readyRespawn = true;
	} else if(bossEvent.statemMembers().state !== 2 && members.readyRespawn) {
		members.state = 0;
		this.unlockInvincible();
		members.readyRespawn = false;
	}
};

Game_WallPurpleFlower.prototype.detectState = function() {
	Game_CharacterDynamicCreate.prototype.detectState.apply(this, arguments);
	this.setPstate(this._statemMembers.state);
};

Game_WallPurpleFlower.prototype.onAttackHit = function(onHit, character, effectPos) {
	if(character.constructor === Game_LilyBombPartner) {
		Game_CharacterDynamicCreate.prototype.onAttackHit.apply(this, arguments);
	}
};

NYA.PATCH = {};

function PatchManager() {
	throw new Error("This is a static class");
}

PatchManager.updatePatch = function(version) {
	this["patch" + version]();
};

PatchManager.patch0 = function() {
	$gameLily = new Game_Lily();
};

PatchManager.patch1 = function() {
	$gameMap._lowerAmbientLight = 1;
	$gameMap._upperAmbientLight = 1;
};

PatchManager.patch2 = function() {
	$gameLily.battleObject().spResume = 0.4;
};

PatchManager.patch3 = function() {
	$gameLily._statemMembers.pathFinder.createNodeObjectPool();
};

PatchManager.patch4 = function() {
	$gameMap.resetScale();
};

PatchManager.patch5 = function() {
	const allCharacter = $gameMap.events().concat([$gamePlayer, $gameLily], $gameMap.dynamicCharacters());
	for(const character of allCharacter) {
		character.clearPhysicsObject();
	}
};

PatchManager.patch6 = function() {
	$gameLily.initFloatMessageMembers();
};

PatchManager.patch7 = function() {
	$gameMap._lowerAmbientLight = 0xffffff;
	$gameMap._upperAmbientLight = 0xffffff;
};

PatchManager.patch8 = function() {
	if($gameMap.mapId() === 39) {
		$gamePlayer.requestMapReload();
		$gamePlayer.reserveTransfer($gameMap.mapId(), $gamePlayer.x, $gamePlayer.y);
	}
};

PatchManager.patch9 = function() {
	$gameSystem._achieveUnlockRegion = $gameSystem._regionTransportUnlock.clone();
};

PatchManager.patch10 = function() {
	//$gameSystem.clearNoRecoverEvents();
};

PatchManager.patch11 = function() {
	$gamePlayer.battleObject().wallDownImage = ";toru_walldown";
	$gamePlayer._jumpGroundAnimationInterval = 0;
	$gamePlayer.actor()._weapons._currentWeapon = 0;
	$gameMap.rebuildDynamicCharacterPosMap();
	if($gameMap.mapId() === 39) {
		const temp = $dataMap;
		$dataMap = DataManager.getCachedData(39);
		$gameMap.setupTilemapLayers();
		$dataMap = temp;
	}
};

PatchManager.patch12 = function() {
	$gamePlayer.setFriction(6);
	$gamePlayer.setAirFriction(6);
};

PatchManager.patch13 = function() {
	$gameLily.battleObject().alwaysShowDamageDigit = true;
	if($gamePlayer.actor()._ornaments.isUnlock(15)) {
		$gamePlayer.actor()._ornaments._equip.remove(15);
		$gamePlayer.actor()._ornaments._unlock.remove(15);
		$gamePlayer.actor().unlockOrnaments(11);
	}
};

PatchManager.patch14 = function() {
	$gamePlayer.actor()._ornaments._bell = 0;
};

PatchManager.patch15 = function() {
	$gameMap.allCharacters().forEach((obj) => {
		obj._bodyAttackExtensions = new Game_BodyAttackExtensions();
	});
	$gameLily._bodyAttackExtensions = new Game_BodyAttackExtensions();
};

PatchManager.patch16 = function() {
	$gameVariables._coinStoneData = {};
};

PatchManager.patch17 = function() {
	$gamePlayer.battleObject().onHitSe = ["player_hit_01", "player_hit_02", "player_hit_03"];
};

PatchManager.patch18 = function() {
	$gameLily.battleObject().onHitSe = ["player_hit_01", "player_hit_02", "player_hit_03"];
};

PatchManager.patch19 = function() {
	if($gameSwitches.value(67)) {
		if($gamePlayer.actor().hasTask(17)) {
			$gamePlayer.actor().completeTask(17);
			if($gameSystem.isThumbnailActive(48212)) {
				$gameLily.requestRemove();
				$gameSwitches.setValue(77, true);
			}
		}
	}
	$gameLily.m = 0.4;
};

PatchManager.patch20 = function() {
	$gamePlayer.battleObject().getDownImage = ";toru_get_down";
	$gamePlayer.battleObject().getDownMoveImage = ";toru_get_down_move";
};

PatchManager.patch21 = function() {
	$gamePlayer.battleObject().getDownImage = ";toru_get_down";
	if($gameSwitches.value(77)) {
		if($gamePlayer.actor().hasTask(17)) {
			$gamePlayer.actor().completeTask(17);
		}
	}
};

PatchManager.patch22 = function() {
	$gamePlayer._mg = $gameLily._mg = 0;
	$gameMap.allCharacters().forEach((character) => {
		character._mg = 0;
	});
};

PatchManager.patch23 = function() {
	$gameMap._sightMoveX = new Game_SightMove();
	$gameMap._sightMoveY = new Game_SightMove();
};

PatchManager.patch24 = function() {
	$gamePlayer.setTempGravity(0);
	$gamePlayer.setTempMGravity(0);
	$gameLily.setTempGravity(0);
	$gameLily.setTempMGravity(0);
	$gameMap.allCharacters().forEach((character) => {
		character.setTempGravity(0);
		character.setTempMGravity(0);
	});
};

PatchManager.patch25 = function() {
	$gameLily.cancelTemporaryPhysicsFlag1();
	if($gameSwitches.value(86)) {
		$gameSwitches.setValue(78, false);
	}
};

PatchManager.patch26 = function() {
	$gamePlayer._latestHitObjectsConstructor = [];
	$gameLily._latestHitObjectsConstructor = [];
	$gameMap.allCharacters().forEach((character) => {
		character._latestHitObjectsConstructor = [];
	});
};

PatchManager.patch27 = function() {
	$gameLily.battleObject().hasSpecProgress = true;
};

PatchManager.patch28 = function() {
	$gameMap.allCharacters().forEach((character) => {
		if(character.battleObject()) {
			character.battleObject().hint = [];
			character.battleObject().initField("hint");
		}
	});
	$gamePlayer.battleObject().hint = [];
    $gameLily.battleObject().hint = [];
	$gamePlayer.battleObject().attackSlashAnimations = [1];
};






